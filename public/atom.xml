<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hola</title>
  
  
  <link href="http://github.com/sebastian/about/atom.xml" rel="self"/>
  
  <link href="http://github.com/sebastian/about/"/>
  <updated>2020-08-09T05:50:41.788Z</updated>
  <id>http://github.com/sebastian/about/</id>
  
  <author>
    <name>Sebastian Getts</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>contest201</title>
    <link href="http://github.com/sebastian/about/2020/08/09/contest201/"/>
    <id>http://github.com/sebastian/about/2020/08/09/contest201/</id>
    <published>2020-08-09T04:22:53.000Z</published>
    <updated>2020-08-09T05:50:41.788Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode周赛201.</p><a id="more"></a><h1 id="1544-Make-The-String-Great"><a href="#1544-Make-The-String-Great" class="headerlink" title="1544 Make The String Great"></a>1544 Make The String Great</h1><p>Given a string <code>s</code> of lower and upper case English letters.</p><p>A good string is a string which doesn’t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li></ul><p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p><p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p><p><strong>Notice</strong> that an empty string is also good.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leEeetcode&quot;</span><br><span class="line">Output: &quot;leetcode&quot;</span><br><span class="line">Explanation: In the first step, either you choose i &#x3D; 1 or i &#x3D; 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abBAcC&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: We have many possible scenarios, and all lead to the same answer. For example:</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;s&quot;</span><br><span class="line">Output: &quot;s&quot;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>首先要注意审题，明确界限的判断。尤其是<code>vice-versa</code>，反之亦然的意思，就是<strong>相邻两个字母忽略大小写时相同，且一个大写一个小写</strong>，需要将这两个字母剔除。</li><li>通过<code>example 2</code>可以看出算法应有<em>循环</em>的动作，剔除后还应该重新审视。</li></ul><h3 id="mine"><a href="#mine" class="headerlink" title="mine"></a>mine</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty() &amp;&amp; (</span><br><span class="line">                (Character.isUpperCase(c) &amp;&amp; Character.isLowerCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class="string">&#x27;a&#x27;</span>) == (c - <span class="string">&#x27;A&#x27;</span>)))</span><br><span class="line">                        ||</span><br><span class="line">                        (Character.isLowerCase(c) &amp;&amp; Character.isUpperCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class="string">&#x27;A&#x27;</span>) == (c - <span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">        )) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Character&gt; iterator = stack.iterator();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        sb.append(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是iterator，不用reverse()</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="better"><a href="#better" class="headerlink" title="better"></a>better</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ch = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (ch) &#123;</span><br><span class="line">    ch = <span class="keyword">false</span>;</span><br><span class="line">    String t = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) + <span class="number">32</span> == s.charAt(i + <span class="number">1</span>) || s.charAt(i + <span class="number">1</span>) + <span class="number">32</span> == s.charAt(i)) &#123;</span><br><span class="line">            t = s.substring(<span class="number">0</span>, i) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">            ch = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><h1 id="1545-Find-Kth-Bit-in-Nth-Binary-String"><a href="#1545-Find-Kth-Bit-in-Nth-Binary-String" class="headerlink" title="1545 Find Kth Bit in Nth Binary String"></a>1545 Find Kth Bit in Nth Binary String</h1><p>Given two positive integers <code>n</code> and <code>k</code>, the binary string <code>Sn</code> is formed as follows:</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code> for <code>i &gt; 1</code></li></ul><p>Where <code>+</code> denotes the concatenation operation, <code>reverse(x)</code> returns the reversed string x, and <code>invert(x)</code> inverts all the bits in x (0 changes to 1 and 1 changes to 0).</p><p>For example, the first 4 strings in the above sequence are:</p><ul><li>S1 = “0”</li><li>S2 = “0<strong>1</strong>1”</li><li>S3 = “011<strong>1</strong>001”</li><li>S4 = “0111001<strong>1</strong>0110001”</li></ul><p>Return <em>the</em> <code>kth</code> <em>bit</em> <em>in</em> <code>Sn</code>. It is guaranteed that <code>k</code> is valid for the given <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 1</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: S3 is &quot;0111001&quot;. The first bit is &quot;0&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 11</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: S4 is &quot;011100110110001&quot;. The 11th bit is &quot;1&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1, k &#x3D; 1</span><br><span class="line">Output: &quot;0&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2, k &#x3D; 3</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>题目中已经给了计算式，根据式子来计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> integer = Integer.parseInt(sb.toString());</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(integer));</span><br><span class="line">        <span class="comment">// 0-1 inverse</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringBuilder.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                stringBuilder.replace(i, i + <span class="number">1</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.replace(i, i + <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.reverse();</span><br><span class="line">        sb.append(<span class="string">&quot;1&quot;</span>).append(stringBuilder);</span><br><span class="line">        n--;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = sb.toString().toCharArray();</span><br><span class="line">    <span class="keyword">return</span> chars[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解题过程是错的，我觉得最好的方式应该是用递归，但是不太会，用来迭代，在n=4时的结果就错了。</p><h3 id="better-1"><a href="#better-1" class="headerlink" title="better"></a>better</h3><p>做<code>0-1</code>转换时，当时想用位运算，怎奈不熟练、没想起来<code>异或</code>。</p><ul><li>异或 ^ ：相同为0，0异或任何数为任何数。在二进制的情况下，与<code>1</code>异或等同于<code>0-1</code>翻转。</li></ul><h4 id="method-1"><a href="#method-1" class="headerlink" title="method 1"></a>method 1</h4><p>一目了然，迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        --n;</span><br><span class="line">        s = s+<span class="string">&quot;1&quot;</span>+sinv(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从0开始，k-1</span></span><br><span class="line">    <span class="keyword">return</span> s.charAt(k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sinv</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder a = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 从后遍历，reverse()</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="comment">// 0-1翻转</span></span><br><span class="line">        c^=<span class="number">1</span>;</span><br><span class="line">        a.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="method-2"><a href="#method-2" class="headerlink" title="method 2"></a>method 2</h4><p>别具一格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    s[1]</span>=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    t[<span class="number">1</span>]=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=s[i-<span class="number">1</span>];</span><br><span class="line">        s[i]+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        s[i]+=t[i-<span class="number">1</span>];</span><br><span class="line">        t[i]=s[i-<span class="number">1</span>];</span><br><span class="line">        t[i]+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t[i]+=t[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[n][k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="method-3"><a href="#method-3" class="headerlink" title="method 3"></a>method 3</h4><p>清清楚楚，深度优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> base = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == base + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= base) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n - <span class="number">1</span>, len - k + <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode周赛201.&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>mybatis</title>
    <link href="http://github.com/sebastian/about/2020/08/05/mybatis/"/>
    <id>http://github.com/sebastian/about/2020/08/05/mybatis/</id>
    <published>2020-08-05T14:21:19.000Z</published>
    <updated>2020-08-05T16:02:18.465Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。</p><a id="more"></a><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: start</span><br><span class="line">config&#x3D;&gt;operation: mybatis-config.xml</span><br><span class="line">build&#x3D;&gt;operation: SqlSessionFactoryBuilder</span><br><span class="line">factory&#x3D;&gt;operation: SqlSessionFactory</span><br><span class="line">session&#x3D;&gt;parallel: SqlSession</span><br><span class="line">mapper&#x3D;&gt;operation: Sql Mapper</span><br><span class="line">end&#x3D;&gt;end: end</span><br><span class="line"></span><br><span class="line">start-&gt;config-&gt;build-&gt;factory-&gt;session</span><br><span class="line">session(path1,)-&gt;end</span><br><span class="line">session(path2,right)-&gt;mapper-&gt;end</span><br></pre></td></tr></table></figure><p>对于<code>SqlSessionFactoryBuilder</code>来说，作用是创建<code>SqlSessionFactory</code>，一旦创建完工厂就没用了，所以是作为<strong>局部变量</strong>；而对于<code>SqlSessionFactory</code>，可以把它看作<em>连接池</em>，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建<code>SqlSession</code> 。创建<code>SqlSession</code>后用来链接数据库，每个session被看作是请求数据库，他是<strong>线程不安全</strong>的，每个线程都应有自己的session，不共享，所以最佳作用域是<strong>方法域</strong>，即每次与数据库交互都创建一个<code>SqlSession</code>，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。</p><h2 id="属性名与数据库表字段名"><a href="#属性名与数据库表字段名" class="headerlink" title="属性名与数据库表字段名"></a>属性名与数据库表字段名</h2><p>当pojo中的实例变量与数据库字段中不一致时，可以使用<code>resultMap</code>来解决，即<strong>结果集映射</strong>。</p><p>也常用<code>resultType</code>，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来<code>resultMap</code>时可以去掉<code>resultType</code>属性。</p><h2 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h2><p>mybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>mybatis支持分页，有<code>limit</code>和<code>rowBounts</code>两个方法。区别是前者在sql中实现，后者面向对象。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">USER</span> <span class="keyword">limit</span> <span class="comment">#&#123;index&#125;,#&#123;size&#125;</span></span><br></pre></td></tr></table></figure><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>默认定义了两级缓存：一级缓存、二级缓存</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>默认开启，在session的<code>close</code>之前都有效，如果是查询相同的数据，直接在缓存中拿。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>需要手动开启和配置，基于<code>namespace</code>级别，有<code>Cache</code>接口来自定义实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="mybatis" scheme="http://github.com/sebastian/about/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>contest200</title>
    <link href="http://github.com/sebastian/about/2020/08/02/contest200/"/>
    <id>http://github.com/sebastian/about/2020/08/02/contest200/</id>
    <published>2020-08-02T04:56:29.000Z</published>
    <updated>2020-08-02T06:03:42.348Z</updated>
    
    <content type="html"><![CDATA[<p>Record Leetcode contest 200.</p><a id="more"></a><h1 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h1><p>passed.</p><h1 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h1><p>Find the winner of an Array Game.</p><p>Given an integer array <code>arr</code> of <strong>distinct</strong> integers and an integer <code>k</code>.</p><p>A game will be played between the first two elements of the array (i.e. <code>arr[0]</code> and <code>arr[1]</code>). In each round of the game, we compare <code>arr[0]</code> with <code>arr[1]</code>, the larger integer wins and remains at position <code>0</code> and the smaller integer moves to the end of the array. The game ends when an integer wins <code>k</code> consecutive rounds.</p><p>Return <em>the integer which will win the game</em>.</p><p>It is <strong>guaranteed</strong> that there will be a winner of the game.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [2,1,3,5,4,6,7], k = 2</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Let&#x27;s see the rounds of the game:</span><br><span class="line">Round |       arr       | winner | win<span class="emphasis">_count</span></span><br><span class="line"><span class="emphasis">  1   | [2,1,3,5,4,6,7] | 2      | 1</span></span><br><span class="line"><span class="emphasis">  2   | [2,3,5,4,6,7,1] | 3      | 1</span></span><br><span class="line"><span class="emphasis">  3   | [3,5,4,6,7,1,2] | 5      | 1</span></span><br><span class="line"><span class="emphasis">  4   | [5,4,6,7,1,2,3] | 5      | 2</span></span><br><span class="line"><span class="emphasis">So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,1], k = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 will win the first 10 rounds consecutively.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,9,8,2,3,7,6,4,5], k = 7</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><p>看到这题，首先我认为这题清晰明了，用__迭代__去完成全部流程，用<strong>k</strong>去做结束的标志，是一道从头到尾很明确的题。但是:joy:</p><p>贴上我稚嫩的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> zero = k-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> solution = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> currMax = Math.max(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> currMin = Math.min(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">        helper(currMax, currMin, arr);</span><br><span class="line">        <span class="keyword">if</span>(res == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// initial, no compare</span></span><br><span class="line">            res = currMax;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(currMax == res)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                solution = currMax;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = zero;</span><br><span class="line">                res = currMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> min, <span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[arr.length-<span class="number">1</span>] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没通过，因为<code>Time Limited</code>，跑得太慢了！</p><h2 id="Niubility-Solution"><a href="#Niubility-Solution" class="headerlink" title="Niubility Solution"></a>Niubility Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">// 数组长度与k之间取最小的。</span></span><br><span class="line">    k = Math.min(k, n);</span><br><span class="line">    <span class="keyword">int</span> A = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 标志位，记录相同次数</span></span><br><span class="line">    <span class="keyword">int</span> rep = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从第二个开始iterate，无终结条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;;i++)&#123;</span><br><span class="line">        <span class="comment">// “i%n“ 取余数，逻辑变换数组。由于for循环无终结条件，所以i会无限增加超过n。</span></span><br><span class="line">        <span class="keyword">int</span> B = arr[i%n];</span><br><span class="line">        <span class="keyword">if</span>(A &gt;= B)&#123;</span><br><span class="line">            rep++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A = B;</span><br><span class="line">            rep = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终结条件在这里，rep等于k时结束。</span></span><br><span class="line">        <span class="keyword">if</span>(rep == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过对比可以发现，我耗时的原因在于：</strong> </p><ol><li>我是真的挪了数组！物理上的挪动，实际上，逻辑移动数组即可！我的程序算例4要6秒，这个只需要0秒。</li><li><code>Math.min(k, n)</code>，如果题目给的k为<code>10000000</code>,数组长度为<code>8</code>,那么最后也是按<code>8</code> 来算，那么多循环无意义，一遍遍历即可获取最大（这样也行？）</li></ol><p>况且，逻辑i上也没有去变换位置，题目的本质还是挨个遍历！</p><p>i.e. arr = [2,1,3,5,4,6,7], k = 2</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Record Leetcode contest 200.&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>lock</title>
    <link href="http://github.com/sebastian/about/2020/07/20/lock/"/>
    <id>http://github.com/sebastian/about/2020/07/20/lock/</id>
    <published>2020-07-20T13:46:41.000Z</published>
    <updated>2020-07-20T15:43:56.514Z</updated>
    
    <content type="html"><![CDATA[<p>进程，线程，流程。</p><a id="more"></a><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p><img src="https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png" alt="image.png"></p><h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁|悲观锁"></a>乐观锁|悲观锁</h1><p>所谓乐观锁、悲观锁可以类比地看作<strong>JVM里的方法区</strong>，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？</p><ul><li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，<code>synchronized</code>关键字和<code>Lock的实现类</code>都是悲观锁。</li><li>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过<strong>无锁编程</strong>实现的乐观锁，最常用的就是<code>CAS算法</code>，Java原子类中的递增操作就是通过<strong>CAS自旋实现</strong>的。</li></ul><p>根据他们的概念，可以发现<strong>悲观锁适合写操作多的场景</strong>，<strong>乐观锁适合读操作多的场景</strong>，这样利于性能的优化提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMehthod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观锁</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">// 执行自增1</span></span><br></pre></td></tr></table></figure><h1 id="Compare-And-Swap"><a href="#Compare-And-Swap" class="headerlink" title="Compare And Swap"></a>Compare And Swap</h1><p>CAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的<strong>原子类</strong>就是通过这种算法实现了乐观锁。算法涉及到三个操作数：</p><ul><li>需要读写的内存值V （已存在的值）</li><li>进行比较的值A</li><li>要写入的新值B</li></ul><p>当<code>V=A</code>时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="comment">// 获取并操作内存的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// 存储value在AtomicInteger中的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储AtomicInteger的int值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>一目了然了吧，最终的<code>compareAndSwapInt</code>是<code>native</code>，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：</p><ul><li>看到<code>do-while</code>了吧，循环时间长会造成较大的CPU开销。</li></ul><p><strong>note:</strong> ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A”</p><h1 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁|适应性自旋锁"></a>自旋锁|适应性自旋锁</h1><p>涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference <a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">here</a></p><h1 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁|非公平锁"></a>公平锁|非公平锁</h1><p>简而言之，公平锁是好好排队的，非公平锁是插队来的。</p><p>在类<code>ReentrantLock</code>中，有一个内部类<code>Sync</code>，他是继承<code>AbstractQueuedSnchronizer</code>的，对锁的添加、释放等操作大部分都是在<code>Sync</code>实现的，他又有<code>FairSync</code>和<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁。</p><h1 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁|共享锁"></a>独享锁|共享锁</h1><p>别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的<code>synchronized</code>和并发包中的<code>Lock</code>。</p><p>共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁和共享锁也是通过AQS来实现的。具体参考类<code>ReentrantReadWriteLock</code>。类中有<code>ReadLock</code>和<code>WriteLock</code>两把锁，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程，线程，流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="lock" scheme="http://github.com/sebastian/about/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="http://github.com/sebastian/about/2020/07/20/volatile/"/>
    <id>http://github.com/sebastian/about/2020/07/20/volatile/</id>
    <published>2020-07-20T13:23:51.000Z</published>
    <updated>2020-07-20T13:26:07.636Z</updated>
    
    <content type="html"><![CDATA[<p>这个关键字用于将Java变量标记为<code>being stored in main memory</code>，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。</p><a id="more"></a><h1 id="Visibility-problems"><a href="#Visibility-problems" class="headerlink" title="Visibility problems"></a>Visibility problems</h1><p>主要是多线程中的问题。线程在操作<code>非volatile</code>的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。</p><p>那么问题来了，对于<code>非volatile</code>的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。</p><p>如果counter不声明为<code>volatile</code>，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，<strong>一个线程的更新对其他线程是不可见的</strong>。</p><h1 id="Visibility-Guarantee"><a href="#Visibility-Guarantee" class="headerlink" title="Visibility Guarantee"></a>Visibility Guarantee</h1><p>关键字<code>volatile</code>的设定就是解决上面提到的可见性问题。通过声明counter变量为<code>volatile</code>的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字<code>volatile</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareObject</span></span>&#123;</span><br><span class="line">    <span class="comment">// 由于声明为volatile，因此更改变量对于其他线程的是可见的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为<code>volatile</code>是不够的。</p><h2 id="Full-Visibility-Guarantee"><a href="#Full-Visibility-Guarantee" class="headerlink" title="Full Visibility Guarantee"></a>Full Visibility Guarantee</h2><p>实际上，关键字<code>volatile</code>的可见保证性超越了<code>volatile</code>变量本身。有点绕吧，可见保证性如下：</p><ul><li><p>如果线程A更改了<code>volatile</code>变量，并且线程B随后读取了它，则在写入<code>volatile</code>变量之前线程A可见的所有变量在线程B读取<code>volatile</code>变量后也将可见。</p></li><li><p>如果线程A读取了一个<code>volatile</code>变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。</p></li></ul><p>看个代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改了三个变量，只有days是volatile的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = year;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalDays</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="keyword">this</span>.days;</span><br><span class="line">        total += months * <span class="number">30</span>;</span><br><span class="line">        total += years * <span class="number">365</span>;</span><br><span class="line">        <span class="keyword">return</span> total;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着重观察<em>totalDays()<em>，他一开始会将<code>days</code>的值赋给变量<code>total</code> ,由于<code>days</code>的类型是<code>volatile</code>，所以，读取<code>days</code>的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了<code>volatile</code>他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为<code>volatile</code>，读取时必须</em></em>最后**读取带有<code>volatile</code>属性的值）。</p><h1 id="Instruction-Reordering"><a href="#Instruction-Reordering" class="headerlink" title="Instruction Reordering"></a>Instruction Reordering</h1><p>指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">1</span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">b++</span><br></pre></td></tr></table></figure><p>然而，当变量属于<code>volatile</code>时，指令排序就需要小心了，看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果JVM重排指令，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里将days赋值动作放到了第一位</span></span><br><span class="line">    <span class="keyword">this</span>.days = days;</span><br><span class="line">    <span class="keyword">this</span>.years = years;</span><br><span class="line">    <span class="keyword">this</span>.months = months;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。</p><h2 id="Volatile-Happens-Before-Guarantee"><a href="#Volatile-Happens-Before-Guarantee" class="headerlink" title="Volatile Happens-Before Guarantee"></a>Volatile Happens-Before Guarantee</h2><p><code>volatile</code>关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。</p><ul><li>如果读/写其他变量出现在写<code>volatile变量</code>之前，那么就不能重排为出现在它之后。当然返回过是允许的。</li><li>如果读/写其他变量出现在读<code>volatile变量</code>之后，那么就不能重排为出现在它之前。</li></ul><h1 id="Volatile-is-Not-Always-Enough"><a href="#Volatile-is-Not-Always-Enough" class="headerlink" title="Volatile is Not Always Enough"></a>Volatile is Not Always Enough</h1><p>很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证<code>原子性</code>的操作了，如<strong>syncronized</strong>或者比并发包下的<code>lock</code>了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个关键字用于将Java变量标记为&lt;code&gt;being stored in main memory&lt;/code&gt;，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="lock" scheme="http://github.com/sebastian/about/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>mq</title>
    <link href="http://github.com/sebastian/about/2020/07/20/mq/"/>
    <id>http://github.com/sebastian/about/2020/07/20/mq/</id>
    <published>2020-07-20T13:04:40.000Z</published>
    <updated>2020-08-16T05:24:15.951Z</updated>
    
    <content type="html"><![CDATA[<p>mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。</p><a id="more"></a><h1 id="MQ的引入"><a href="#MQ的引入" class="headerlink" title="MQ的引入"></a>MQ的引入</h1><p>模拟几个场景：</p><ol><li><p><code>学生模块</code>和<code>老师模块</code>。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。</p><p>解决方式：引入<code>班长模块</code>，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。</p></li><li><p><code>系统A</code>需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。</p><p>上线后又新增了一个需求，<code>D</code>也要接收<code>A</code>的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对<code>A</code>进行改造，开发、联调效率低，耦合严重，增加<code>A</code>的负担。</p></li></ol><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li><p>解决耦合  当新的模块接进来时，可以做到代码改动最小</p></li><li><p>异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力</p></li><li><p>削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨</p></li></ul><h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><table><thead><tr><th>比较项目</th><th>Topic模式队列</th><th>Queue模式队列</th></tr></thead><tbody><tr><td>工作模式</td><td>”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。</td><td>”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。</td></tr><tr><td>有无状态</td><td>无状态</td><td>Queue数据默认会在mq服务器上以文件形式保存</td></tr><tr><td>传递完整性</td><td>如果没有订阅者，消息会被丢弃。不完整。</td><td>消息不会丢弃</td></tr><tr><td>处理效率</td><td>由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异</td><td>由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的</td></tr></tbody></table><h1 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h1><p>Java消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。</p><p>实现JMS接口和规范的消息中间件，即我们的MQ服务器。</p><h2 id="MESSAGE"><a href="#MESSAGE" class="headerlink" title="MESSAGE"></a>MESSAGE</h2><p>JMS message的组成：消息头 + 消息体 + 消息属性</p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>记录常用的</p><ul><li><p>JMSDestination 消息发送的目的地，Queue或Topic</p></li><li><p>JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。</p></li><li><p>JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除</p></li><li><p>JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通</p></li><li><p>JMSMessgeID 唯一ID，判断是否重复消费，幂等性</p></li></ul><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>封装具体消息数据，5种格式。（使用频率高）</p><ul><li><p>TextMessage 普通字符串消息 （使用频率高）</p></li><li><p>MapMessage map类型消息，key为String类型，值为Java基本数据类型</p></li><li><p>BytesMessage 二进制数组消息</p></li><li><p>StreamMessage 流</p></li><li><p>ObjectMessage 可序列化的Java对象</p></li></ul><p>发送和接受的消息类型必须一致。</p><h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><p>如果需要除消息头字段以外的值，那么可以使用消息属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextMessage tm = session.createTextMessage(<span class="string">&quot;wa wa&quot;</span>);</span><br><span class="line">tm.setStringProperty(<span class="string">&quot;c01&quot;</span>,<span class="string">&quot;vip&quot;</span>); <span class="comment">// 增加属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextMessage tms = (TextMessage) messge;</span><br><span class="line">System.out.println(tms.getStringProperty(<span class="string">&quot;c01&quot;</span>)); <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><p>MQ挂了，消息的持久话和丢失的情况如何？一般有<strong>三个特征</strong>来保障：持久化、事务、签收，其中<strong>事务偏生产者，签收偏消费者</strong>。此外对于对于宕机，还有<strong>多节点集群</strong>。</p><h2 id="持久化-PERSISTENT"><a href="#持久化-PERSISTENT" class="headerlink" title="持久化 PERSISTENT"></a>持久化 PERSISTENT</h2><p>参考redis的持久化（有rdb和aof），消息也有类似的辅助。</p><h3 id="QUEUE"><a href="#QUEUE" class="headerlink" title="QUEUE"></a>QUEUE</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><ol><li><p>非持久 服务器宕机，消息不存在</p><blockquote><p>messaegeProducer.setDeliveryMode(DeliveryMode.<em>NON_PRESISTENT</em>);</p></blockquote></li><li><p>持久化 服务器宕机后消息依然存在</p><blockquote><p>messageProducer.setDelieveryMode(DeliveryMode.<em>PRESISTENT</em>);</p></blockquote></li></ol><h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h4><p>非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。</p><p>持久化时，上述操作后，数据依然存在。</p><p>在队列中，如果<strong>不显示标注持久</strong>，<strong>默认持久化</strong>，因为可靠性是优先考虑的因素。</p><p>持久、事物、签收</p><h3 id="TOPIC"><a href="#TOPIC" class="headerlink" title="TOPIC"></a>TOPIC</h3><p>对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：</p><ol><li><p>先运行一次消费者，等于向MQ注册</p></li><li><p>然后再运行生产者发送信息</p></li><li><p>消费者一定会收到订阅消息。不在线的话下次连接时会接收。</p></li></ol><h2 id="事务-TRANSACTION"><a href="#事务-TRANSACTION" class="headerlink" title="事务 TRANSACTION"></a>事务 TRANSACTION</h2><p>数据库的事务、ACID、隔离级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第一个参数即 事务是否开启</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul><li><p>false 关闭事务，只要执行<code>send</code>就进入到队列中</p></li><li><p>true 开启事物，先执行<code>send</code>再执行<code>commit</code>，消息才被真正提交到队列中。</p></li></ul><p>对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// ok session.commit;</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    session.rollback();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != session)&#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>创建session时将事务改为<code>true</code>，同样需要<code>commit</code>，否则事务会被重复消费。</p><h2 id="签收-ACKNOWLEDGE"><a href="#签收-ACKNOWLEDGE" class="headerlink" title="签收 ACKNOWLEDGE"></a>签收 ACKNOWLEDGE</h2><p>分为事务和非事务两种情况</p><h4 id="非事务"><a href="#非事务" class="headerlink" title="非事务"></a>非事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第个参数即 签收类型</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><ul><li><p>自动签收（默认）   <strong>AUTO_ACKNOWLEDGE</strong>  （使用频率高）</p></li><li><p>手动签收 <strong>CLIENT_ACKNOWLEDGE</strong> （使用频率高）</p></li><li><p>允许重复消息 <strong>DUPS_OK_ACKNOWLEDGE</strong></p></li></ul><p>手动签收时需要手动标记，否则会造成重复消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextMessage tm = (TextMessage)messageConsumer.receive(<span class="number">4000L</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != tm)&#123;</span><br><span class="line">    tm.acknowledge();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第个参数即 签收类型</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><p>有事务就需要<code>commit</code>。</p><h2 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h2><p>基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。类比平时的即时通讯工具。</p><ul><li><p>如果在<strong>Session</strong>关闭时有部分消息已被收到但还没有签收（<strong>acknowledge</strong>)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）</p></li><li><p>队列可以长久地保存消息直到消费者收到消息。<strong>消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态</strong>，充分体现了异步传输模式的优势。</p></li></ul><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>JMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作<strong>topic</strong>，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。</p><h3 id="非持久"><a href="#非持久" class="headerlink" title="非持久"></a>非持久</h3><p>对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。</p><h1 id="BROKER"><a href="#BROKER" class="headerlink" title="BROKER"></a>BROKER</h1><p>集群、配置时会用到。</p><p>相当于一个ActiveMQ服务器<strong>实例</strong>，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。</p><p>之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.</p><h2 id="消息发送模式"><a href="#消息发送模式" class="headerlink" title="消息发送模式"></a>消息发送模式</h2><p>ActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。</p><p><code>ActiveMQ默认使用异步发送的模式</code>，<strong>同步发送有两种情况</strong>：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。</p><p>异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，<code>允许在失败的情况下有少量的数据丢失</code>。</p><h1 id="ACTIVEMQ的传输协议"><a href="#ACTIVEMQ的传输协议" class="headerlink" title="ACTIVEMQ的传输协议"></a>ACTIVEMQ的传输协议</h1><p>Q: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？</p><p>调优：使用NIO传输协议</p><p>支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）</p><table><thead><tr><th>协议</th><th>描述</th></tr></thead><tbody><tr><td>TCP</td><td>默认的协议，性能相对可以</td></tr><tr><td>NIO</td><td>基于TCP协议之上的，进行了扩展和优化</td></tr><tr><td>HTP(s)</td><td>基于HTTP(s)</td></tr></tbody></table><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>要换为NIO，需要修改<code>activemq.xml</code>配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;nio&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;nio://192.168.111.136&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在消费者、生产者修改代码，指定传输协议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> stati <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;nio://192.168.111.136&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ActiveMQConnectionFactory af = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h3><p>Q: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持<code>openwire（TCP）</code>，如何让这个端口支持NIO，又支持多个协议呢？</p><p>默认是<code>BIO+TCP</code>，目前是<code>NIO+TCP</code>，那么如何做到<code>NIO+TCP/Mqtt/stomp</code>。</p><p>A: 开启多协议支持，用<code>auto</code>关键字，<a href="https://activemq.apache.org/auto">reference</a>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;auto://localhost:5761&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>note:</strong> 在activeMQ后台配置面板的<code>Network</code>可以查看开启的网络协议。</p><h1 id="ACTIVEMQ的存储和可持久化"><a href="#ACTIVEMQ的存储和可持久化" class="headerlink" title="ACTIVEMQ的存储和可持久化"></a>ACTIVEMQ的存储和可持久化</h1><p>对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会<code>采用持久化机制</code>（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p><p>主要介绍两个DB：<code>KahaDB</code>, <code>LevelDB</code>, <code>JDBC</code></p><p>Q: AMQ持久化机制</p><h2 id="KahaDB"><a href="#KahaDB" class="headerlink" title="KahaDB"></a>KahaDB</h2><p>基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。</p><p>在配置文件中，有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdpter</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>reference <a href="https://activemq.apache.org/kahadb">here</a></p><p>可用于任何场合，提高了性能和恢复能力。消息存储使用一个<strong>事务日志</strong>和一个<strong>索引文件</strong>（存储所有地址）。</p><p>Kahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）</p><h4 id="db-lt-Number-gt-log"><a href="#db-lt-Number-gt-log" class="headerlink" title="db&lt;Number&gt;.log"></a>db&lt;Number&gt;.log</h4><p>存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。</p><h4 id="db-data"><a href="#db-data" class="headerlink" title="db.data"></a>db.data</h4><p>包含了持久化的<code>BTree索引</code>，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向<code>db-\&lt;Number&gt;.log</code>里面存储的消息。</p><h4 id="db-free"><a href="#db-free" class="headerlink" title="db.free"></a>db.free</h4><p>当前<code>db.data</code>文件里哪些页面是空闲的，文件具体内容是所有空闲页的<strong>ID</strong>. 类比linux的bash命令<code>free</code>。</p><h4 id="db-redo"><a href="#db-redo" class="headerlink" title="db.redo"></a>db.redo</h4><p>用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。</p><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。</p><h2 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h2><h2 id="JDBC-Message-store-with-ActiveMQ-Journal"><a href="#JDBC-Message-store-with-ActiveMQ-Journal" class="headerlink" title="JDBC Message store with ActiveMQ Journal"></a>JDBC Message store with ActiveMQ Journal</h2><p>主要。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li><p>引入消息队列后该如何保证其高可用性</p></li><li><p>异步投递Async Sends</p></li><li><p>延迟投递和定时投递</p></li><li><p>分发策略</p></li><li><p>ActiveMQ消费重试机制</p></li><li><p>死信队列</p></li><li><p>如何保证消息不被重复消费呢？谈谈幂等性问题</p></li></ol><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>zookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。</p><h2 id="异步投递"><a href="#异步投递" class="headerlink" title="异步投递"></a>异步投递</h2><p>如何确认发送成功？ </p><p>在消息发送完后接收回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ActiveMQConnectionFacotry acf = <span class="keyword">new</span> ActiveMQConnectionFactory(URL);</span><br><span class="line"><span class="comment">// 设置为异步发送消息</span></span><br><span class="line">acf.setUseAsyncSend(<span class="keyword">true</span>);</span><br><span class="line">ActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class="line">...</span><br><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line"><span class="comment">// 未message设置属性</span></span><br><span class="line">message.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用带有回调的send方法来发送</span></span><br><span class="line">amp.send(message, <span class="keyword">new</span> AsyncCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSucces</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(message.getJMSmessageID+<span class="string">&quot; succeed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException exception)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 拿到属性来确认发送失败的消息</span></span><br><span class="line">        System.out.println(message.getJMSmessageID+<span class="string">&quot; fail&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="延迟投递和定时投递"><a href="#延迟投递和定时投递" class="headerlink" title="延迟投递和定时投递"></a>延迟投递和定时投递</h2><p>参考<a href="http://activemq.apache.org/delay-and-schedule-message-delivery.html">官网说明</a></p><table><thead><tr><th>Property name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>AMQ_SCHEDULED_DELAY</td><td>long</td><td>延迟投递的时间</td></tr><tr><td>AMQ_SCHEDULED_PERIOD</td><td>long</td><td>重复投递的时间间隔</td></tr><tr><td>AMQ_SCHEDULED_REPEAT</td><td>int</td><td>重复投递次数</td></tr><tr><td>AMQ_SCHEDULED_CRON</td><td>String</td><td>Cron表达式</td></tr></tbody></table><p>在<code>activemq.xml</code>中配置<em>schedulerSupport</em>属性为<em>true</em>且Java代码中封装的辅助消息类型为<em>ScheduledMessage</em>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = <span class="number">3</span> * <span class="number">1000</span>; <span class="comment">//延迟投递的时间，每3秒</span></span><br><span class="line"><span class="keyword">long</span> period = <span class="number">4</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> repeat = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);</span><br><span class="line">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);</span><br><span class="line"></span><br><span class="line">messageProducer.send(mesage);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="ActiveMQ消费重试机制"><a href="#ActiveMQ消费重试机制" class="headerlink" title="ActiveMQ消费重试机制"></a>ActiveMQ消费重试机制</h2><ul><li><p>哪些情况会引起消息重发？</p></li><li><p>消息重发时间间隔和重发次数</p></li><li><p>有毒消息Posion ACK</p></li></ul><p>reference <a href="activemq.apache.org/redelivery-policy">here</a></p><p>重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。</p><h2 id="如何保证消息不被重复消费（幂等性）"><a href="#如何保证消息不被重复消费（幂等性）" class="headerlink" title="如何保证消息不被重复消费（幂等性）"></a>如何保证消息不被重复消费（幂等性）</h2><p><strong>note</strong>: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。</p><ul><li><p>如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突</p></li><li><p>使用第三方服务来做消费记录。以redis为例，给消息分配一个<strong>全局id</strong>，只要消费过该消息，将&lt;id, message&gt;以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。&lt;/p&gt;</summary>
    
    
    
    <category term="MiddleWare" scheme="http://github.com/sebastian/about/categories/MiddleWare/"/>
    
    
    <category term="activemq" scheme="http://github.com/sebastian/about/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>subsets</title>
    <link href="http://github.com/sebastian/about/2020/06/27/subsets/"/>
    <id>http://github.com/sebastian/about/2020/06/27/subsets/</id>
    <published>2020-06-27T15:09:34.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>Return all possible subsets(the power set).</p><a id="more"></a><h1 id="5460-Number-of-Good-Pairs"><a href="#5460-Number-of-Good-Pairs" class="headerlink" title="5460. Number of Good Pairs"></a>5460. Number of Good Pairs</h1><p>Given an array of integers <code>nums</code>.</p><p>A pair (i, j) is called <em>good</em> if <code>nums[i] == nums[j]</code> and <code>i &lt; j</code>.</p><p>Return the numbers of <em>good</em> pairs.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1,1,3]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Each pair in the array are good.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><ul><li>蛮力法获取到所有重复的数字，如何解出符合要求的解？</li><li>用什么数据结构保存数组和对应的下标以保证遍历一次数组而不是两次？</li><li>利用递归求解应该是个不错的选择。</li></ul><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>想多了。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里i、j的命名与题目相反，思路结果是ok的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h1><p>Given a set of distinct integers, <em>nums</em>, return all possible</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> value: nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; a:result)&#123;</span><br><span class="line">            temp.add(<span class="keyword">new</span> ArrayList&lt;&gt;(a));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; a:temp)&#123;</span><br><span class="line">            a.add(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; single = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        single.add(value);</span><br><span class="line">        temp.add(single);</span><br><span class="line"></span><br><span class="line">        result.addAll(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的工作都在一个for循环中完成了，return前的一次add是加入空表，因为空也是原数组的一个子集。来看看for循环中做了什么，把result中的线性表赋给临时表、往临时表中的每个元素添加目前正在遍历的元素、往临时表中作为独立元素添加目前正在遍历的元素，最后是将临时表赋给result。</p><h1 id="90-Subset-II"><a href="#90-Subset-II" class="headerlink" title="90. Subset II"></a>90. Subset II</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Return all possible subsets(the power set).&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>goodleTest</title>
    <link href="http://github.com/sebastian/about/2020/06/22/goodleTest/"/>
    <id>http://github.com/sebastian/about/2020/06/22/goodleTest/</id>
    <published>2020-06-22T06:38:50.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>googletest，顾名思义，google公司研发的测试框架，适用于C++，协助完成包括单元测试在内的各种类型测试。</p><a id="more"></a><p>谷歌测试团队的理念：</p><ol><li>测试应该是独立且可重复的。</li><li>测试应该是被组织良好的，并且能反映出测试代码的架构。</li><li>测试应该是可拔插、可重用的。</li><li>当测试失败，应该有足够多的问题信息。</li><li>测试框架应该帮助开发人员专注于测试内容，琐碎的事情由框架完成。</li><li>测试的速度应该足够快。</li></ol><p>googletest基于<code>xUnit架构</code>，用过JUnit或者PyUnit的再使用它应该不会陌生。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>注意区分Test, Test Case, Test Suite</p><table><thead><tr><th>Meaning</th><th>googletest Term</th><th>ISTQB Term</th></tr></thead><tbody><tr><td>涉及特定输入输出的测试代码</td><td>TEST()</td><td>Test Case</td></tr></tbody></table><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>tests 使用<strong>断言</strong>来验证测试代码</li><li>test suit 可以裂解为“测试套装”，包含一个或多个tests，多个tests来反映测试代码的结构，一个test suit中多个tests应该是有共享的对象。</li><li>test program 包含多个“测试套装”。</li></ul><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>有<code>ASSERT_*</code>和<code>EXPECT_*</code>。前者会在遇到异常时抛弃当前的方法，后者在遇到非致命的故障时不会抛弃。通常，后者用的比较多，因为输出的异常信息会更多。</p><p>还可以自定义异常消息，使用<strong>stream</strong>特性，可以借助<code>&lt;&lt;</code>来实现，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSERT_EQ(x.<span class="built_in">size</span>(), y.<span class="built_in">size</span>()) &lt;&lt; <span class="string">&quot;Vectors x and y are of unequal length&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;x.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">    EXPECT_EQ(x[i], y[i]) &lt;&lt; <span class="string">&quot;Vectors x and y differ at index &quot;</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在断言后加上可能出现的异常，好比java中的<code>try-catch</code>块中，不打印异常信息而输出自定义的信息。</p><h2 id="true-false断言"><a href="#true-false断言" class="headerlink" title="true/false断言"></a>true/false断言</h2><table><thead><tr><th>fatal assertion</th><th>nonfatal assertion</th><th>verifies</th></tr></thead><tbody><tr><td>ASSERT_TRUE(condition);</td><td>EXPECT_TRUE(condition);</td><td>condition is true</td></tr><tr><td>ASSERT_FALSE(condition);</td><td>EXPECT_FALSE(condition);</td><td>condition is false</td></tr></tbody></table><p>出现异常时，<code>ASSERT_*</code>会在出现异常的部分返回，不继续进行（类比java中的throw，抛出异常），而<code>EXPECT_*</code>会继续执行后续的代码（类比java中的try-catch块捕捉异常）。但是无论哪种，断言失败都意味着测试失败。</p><h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><p>需要熟悉简写，如EQ、NE、LT……</p><table><thead><tr><th>Fatal assertion</th><th>Nonfatal assertion</th><th>Verifies</th></tr></thead><tbody><tr><td>ASSERT_EQ(val1, val2);</td><td>EXPECT_EQ(val1, val2);</td><td>val1 == val2</td></tr><tr><td>ASSERT_NE(val1, val2);</td><td>EXPECT_EQ(val1, val2);</td><td>val1 !=  val2</td></tr><tr><td>ASSERT_LT(val1, val2);</td><td>EXPECT_LT(val1, val2);</td><td>val1 &lt; val2</td></tr><tr><td>ASSERT_LE(val1, val2);</td><td>EXPECT_LE(val1, val2);</td><td>val1 &lt;= val2</td></tr><tr><td>ASSERT_GT(val1, val2);</td><td>EXPECT_GT(val1, val2);</td><td>val1 &gt; val2</td></tr><tr><td>ASSERT_GE(val1, val2);</td><td>EXPECT_GE(val1, val2);</td><td>val1 &gt;= val2</td></tr></tbody></table><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>注意区分C-strings和string对象的区别。比较两个string对象使用<code>EXPECT_EQ</code>，<code>EXPECT_NE</code>这些方式，参见上方。</p><table><thead><tr><th>Fatal assertion</th><th>Nonfatal assertion</th><th>Verifies</th></tr></thead><tbody><tr><td>ASSERT_STREQ(str1, str2);</td><td>EXPECT_STREQ(str1, str2);</td><td>same content</td></tr><tr><td>ASSERT_STRNE(str1, str2);</td><td>EXPECT_STRNE(str1, str2);</td><td>different contents</td></tr><tr><td>ASSERT_STRCASEEQ(str1, str2);</td><td>EXPECT_STRCASEEQ(str1, str2);</td><td>same content, ignoring case(lower/capital)</td></tr><tr><td>ASSERT_STRCASENE(str1, str2);</td><td>EXPECT_STRCASENE(str1, str2);</td><td>different content, ignoring case</td></tr></tbody></table><h1 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST(TestSuiteName, TestName)&#123;</span><br><span class="line">    ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意两个入参都要满足c++的命名规范，且不能有下划线。</p><p>例如，有一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// Return the factorial of n</span></span><br></pre></td></tr></table></figure><p>那么它的测试函数可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tests factorial of 0.</span></span><br><span class="line">TEST(FactorialTest, HandlesZeroInput) &#123;</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line">TEST(FactorialTest, HandlesPositiveInput) &#123;</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">2</span>), <span class="number">2</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">3</span>), <span class="number">6</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">8</span>), <span class="number">40320</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>googletest通过test suits把测试分组，上买能的函数中，虽然有两个（<code>HandlesZeroInput</code>, <code>handlesPositiveInput</code>），但是都属于<code>FacotrialTest</code>，跟Java的命名规范有区别。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;googletest，顾名思义，google公司研发的测试框架，适用于C++，协助完成包括单元测试在内的各种类型测试。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://github.com/sebastian/about/categories/C/"/>
    
    
    <category term="test" scheme="http://github.com/sebastian/about/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>decorating</title>
    <link href="http://github.com/sebastian/about/2020/06/12/decorating/"/>
    <id>http://github.com/sebastian/about/2020/06/12/decorating/</id>
    <published>2020-06-12T10:30:28.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。</p><a id="more"></a><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是<code>Beverage</code>抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso… 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。</p><p>如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？</p><blockquote><p>类应该堆扩展开放，对修改关闭。</p></blockquote><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。</p><ol><li>DarkRoast对象</li><li>用摩卡装饰</li><li>用奶泡装饰</li><li>调用cost方法，依赖delegate添加价钱</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png" alt="Screenshot from 2020-06-12 20-50-33.png"></p><p>其中<code>Condiment</code>是调料类，重写了<code>Beverage</code>的<code>getDescription</code>方法。以Whip为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> .<span class="number">30</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的_cost_方法入获取description的方法如出一辙，这样的好处在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage1 = <span class="keyword">new</span> DarRoast();</span><br><span class="line">beverage1 = <span class="keyword">new</span> Mocha(beverage1);</span><br><span class="line">beverage1 = <span class="keyword">new</span> Mocha(beverage1);</span><br><span class="line">beverage1 = <span class="keyword">new</span> Whip(beverage1);</span><br><span class="line">System.out.println(beverage1.getDescription() + <span class="string">&quot; $&quot;</span> + beverage1.cost());</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75</span><br></pre></td></tr></table></figure><p>制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为<strong>委托</strong>.</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><p>大量的<code>Decorator Pattern</code>在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">para1&#x3D;&gt;parallel: FileInputStream</span><br><span class="line">para2&#x3D;&gt;parallel: BufferedInputStream</span><br><span class="line">para3&#x3D;&gt;parallel: LineNumberInputStream</span><br><span class="line">op1&#x3D;&gt;operation: Beferage</span><br><span class="line">op2&#x3D;&gt;operation: Espresso</span><br><span class="line">op3&#x3D;&gt;operation: Mocha</span><br><span class="line">para1(path1, bottom)-&gt;para2</span><br><span class="line">para2(path1,bottom)-&gt;para3</span><br><span class="line">para1(path2, right)-&gt;op1</span><br><span class="line">para2(path2, right)-&gt;op2</span><br><span class="line">para3(path2, right)-&gt;op3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="design_patterns" scheme="http://github.com/sebastian/about/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>observer</title>
    <link href="http://github.com/sebastian/about/2020/06/12/observer/"/>
    <id>http://github.com/sebastian/about/2020/06/12/observer/</id>
    <published>2020-06-12T09:12:38.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？</p><a id="more"></a><p>一个好的设计模式能拯救一堆代码。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">WeatherData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getTemperature()&#123;&#125;;</span><br><span class="line">    getHumidity()&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一旦气象更新，此方法会被调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    measuremetnsChanged()&#123;</span><br><span class="line">        <span class="comment">// our codes go here</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接在<code>measuremetnsChanged</code>这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measuremetnsChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class="line">    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>先看看我们平时是怎么浏览微信订阅号消息：</p><p>首先整个流程应该有两个参与者</p><ul><li>订阅号运营者</li><li>订阅者</li></ul><p>订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。</p><p>那么观察者模式也类似：</p><blockquote><p>订阅号运营者+订阅者=观察者模式</p></blockquote><p>不一样的是名称，订阅号运营者改为“subject”（主题），订阅者改为”observer”（观察者）。</p><p>由于一个主题可以被多个观察者订阅，所以，它实现了对象之间<strong>一对多</strong>；同时，这种对象设计也让主题和观察者之间<strong>松耦合</strong>.</p><p>对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png" alt="Screenshot from 2020-06-12 18-03-04.png"></p><p>我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">    weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。</p><p>完整代码参考：<a href="https://github.com/Sebastian-Getts/designPatternsPractice">项目传送门</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="design_patterns" scheme="http://github.com/sebastian/about/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>FS</title>
    <link href="http://github.com/sebastian/about/2020/06/09/FS/"/>
    <id>http://github.com/sebastian/about/2020/06/09/FS/</id>
    <published>2020-06-09T15:41:57.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>FastDFS, TFS, GFS, HDFS, OSS …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FastDFS, TFS, GFS, HDFS, OSS …&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="fs" scheme="http://github.com/sebastian/about/tags/fs/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://github.com/sebastian/about/2020/06/09/redis/"/>
    <id>http://github.com/sebastian/about/2020/06/09/redis/</id>
    <published>2020-06-09T13:54:01.000Z</published>
    <updated>2020-08-06T12:11:06.098Z</updated>
    
    <content type="html"><![CDATA[<p>常用redis，深入了解redis的性能和瓶颈。<a href="https://github.com/antirez/redis">reference</a></p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>redis: <strong>内存</strong>中的数据结构存储系统，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>，nosql的一种。</p><h2 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h2><p>关系型数据库不够用，出来了nosql。。。</p><ol><li>一开始单体应用，小用户量能承受。但是当体量变大时：<ul><li>数据量大</li><li>数据的索引大</li><li>访问量大</li></ul></li><li>读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层<strong>memcache</strong>缓存</li><li>集群（水平拆分）：上面的读写分离copy多份。</li></ol><p>mysql早些年使用的是MyISAM引擎，特性是<strong>表锁</strong>（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了<strong>行锁</strong>。</p><p>不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。</li><li>大数据量也高性能（写8万次/秒，读11万次/秒）</li><li>多样型，不需要事先设计数据库</li><li>没有固定的查询语言；最终一致性</li><li>键值对存储，列存储，文档存储，图形存储库（社交）</li><li>高性能、高可用、高可扩</li><li>CAP、BASE，异地多活</li><li>多样、实时、并发（Volume, Variety, Veiocity）</li></ol><p>与关系型一起使用。</p><p>商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）</p><p>商品的基本信息（价格、商家、名称）：MySQL</p><p>图片：FastDFS, GFS, HDFS, OSS…</p><p>商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）</p><p>==没有什么不是加以层解决不了的==： 统一服务层。</p><h3 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h3><p>MongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。</p><h3 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对"></a>KV键值对</h3><p>Redis，Tair</p><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h3><p>HBase（大数据）</p><p>分布式文件系统</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>类似知识图谱，不是存储图形。主要用于存储社交网络。</p><p>Neo4j，InfoGrid。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Remote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。</p><ul><li>内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）</li><li>计时器、计数器（浏览量）</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>安装后自带的测试工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h localhost -p 6379 -100 -n 100000</span><br></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>默认16个数据库且使用的是第0个。 </p><h3 id="GEOSPATIAL"><a href="#GEOSPATIAL" class="headerlink" title="GEOSPATIAL"></a>GEOSPATIAL</h3><p>地理位置，不仅仅是GET、SET！根据经纬度获取距离。</p><h2 id="springboot集成"><a href="#springboot集成" class="headerlink" title="springboot集成"></a>springboot集成</h2><p>版本&lt;2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。</p><p>版本&gt;2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p><h2 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h2><p>为什么会有这个rdb？</p><p>redis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: start</span><br><span class="line">end&#x3D;&gt;end: end</span><br><span class="line">condition&#x3D;&gt;condition: 触发rdb</span><br><span class="line">rdbfile&#x3D;&gt;inputoutput: dump.rdb</span><br><span class="line">operation&#x3D;&gt;operation: go on dealing with</span><br><span class="line"></span><br><span class="line">start-&gt;condition</span><br><span class="line">condition(yes)-&gt;rdbfile-&gt;end</span><br><span class="line">condition(no)-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><ol><li>save的规则</li><li>执行flushall</li><li>退出redis</li></ol><p>产生备份，会自动生成一个dump.rdb</p><h4 id="用rdb恢复"><a href="#用rdb恢复" class="headerlink" title="用rdb恢复"></a>用rdb恢复</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get dir</span><br></pre></td></tr></table></figure><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>适合大数据</li><li>对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>需要一定的时间间隔进程操作</li><li>fork进程的时候会占用一定的内容空间</li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Append Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。</p><ul><li>大数据的情况下效率会比较低。</li><li>默认是不开启的。</li></ul><p>开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。</p><p>修复aof文件 <code>redis-check-aof --fix</code></p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ol><li>每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据</li><li>从不同步效率最高</li></ol><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>相对于数据文件，aof远大于rdb，修复的速度比rdb慢</li><li>默认是rdb，效率自然高于aof。</li></ol><p><strong>与rdb混合使用</strong></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。</p><p>作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石</p><p>reids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。</p><p>默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication # 查看当前库的信息</span><br></pre></td></tr></table></figure><p>一般情况下只用配置从机即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF ip:port # ip:port为主机</span><br></pre></td></tr></table></figure><p>上面的是命令配置，只是暂时的。<strong>实际生产应该修改配置文件</strong>，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。</p><h4 id="如果主机宕机了呢？"><a href="#如果主机宕机了呢？" class="headerlink" title="如果主机宕机了呢？"></a>如果主机宕机了呢？</h4><p>默认情况下，主机挂了以后，用<code>info replication</code>查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。</p><p>更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。</p><ul><li>全量复制 master将整个数据传送到slaver</li><li>增量复制</li></ul><p>只要重新链接master，一次全量复制将被自动执行</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>Sentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p><p>哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>集群</li><li>主从切换</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>不方便在线扩容，一旦到达上线。</li><li>配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。</li></ol><h2 id="redis异常处理"><a href="#redis异常处理" class="headerlink" title="redis异常处理"></a>redis异常处理</h2><h3 id="缓存穿透（一直查询不到）"><a href="#缓存穿透（一直查询不到）" class="headerlink" title="缓存穿透（一直查询不到）"></a>缓存穿透（一直查询不到）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: request</span><br><span class="line">end&#x3D;&gt;end: response</span><br><span class="line">condition&#x3D;&gt;condition: redis缓存中是否存在</span><br><span class="line">op1&#x3D;&gt;operation: select in mysql</span><br><span class="line">start-&gt;condition</span><br><span class="line">condition(yes)-&gt;end</span><br><span class="line">condition(no)-&gt;op1-&gt;end</span><br></pre></td></tr></table></figure><p>如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><p>活力集中在一个点（一个热评的点，如微博）。</p><h4 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h4><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h4><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。</p><h4 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h4><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><p>正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用redis，深入了解redis的性能和瓶颈。&lt;a href=&quot;https://github.com/antirez/redis&quot;&gt;reference&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="DB" scheme="http://github.com/sebastian/about/categories/DB/"/>
    
    
    <category term="redis" scheme="http://github.com/sebastian/about/tags/redis/"/>
    
    <category term="nosql" scheme="http://github.com/sebastian/about/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>heap</title>
    <link href="http://github.com/sebastian/about/2020/06/06/heap/"/>
    <id>http://github.com/sebastian/about/2020/06/06/heap/</id>
    <published>2020-06-06T14:54:27.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>这里的堆是数据结构中的堆，不是JVM中的堆。</p><p>关键词：堆，二叉树，优先级队列，排序，topN</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。    </p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul><li>路径长度是指路径上的边数</li><li>结点深度是指从根结点到该结点的路径的长度</li><li>每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置</li></ul><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><ul><li>完全二叉树</li><li>每个结点大于或等于它的任意一个孩子</li></ul><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>可以将二叉堆用数组来存储。</p><p>例如如下一个二叉堆：</p><p><img src="https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png" alt="Screenshot from 2020-06-06 15-24-34.png"></p><p>在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}</p><p>可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题</p><h2 id="TOP-N"><a href="#TOP-N" class="headerlink" title="TOP N"></a>TOP N</h2><p>给一组数据，求其中最大/小的几个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最小的n个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topN(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// default big heap, lambda make it small heap</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n, ((o1, o2) -&gt; Integer.compare(o2, o1)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : array) &#123;</span><br><span class="line">        <span class="comment">// put the integer in when it smaller than the top of integer</span></span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; n || e &lt; heap.peek()) &#123;</span><br><span class="line">            heap.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; n) &#123;</span><br><span class="line">            <span class="comment">// delete the top of heap integer</span></span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">        res[j++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。</p><p>稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认大顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e: array)&#123;</span><br><span class="line">    <span class="comment">// 大于堆顶的放入优先级队列</span></span><br><span class="line">    <span class="keyword">if</span>(heap.isEmpty() || heap.size() &lt; n || e &gt; heap.peak())&#123;</span><br><span class="line">        heap.offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过要求的个数，清除堆顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(heap.size() &gt; n)&#123;</span><br><span class="line">        heap.pool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里的堆是数据结构中的堆，不是JVM中的堆。&lt;/p&gt;
&lt;p&gt;关键词：堆，二叉树，优先级队列，排序，topN&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="datastructure" scheme="http://github.com/sebastian/about/tags/datastructure/"/>
    
  </entry>
  
  <entry>
    <title>regex</title>
    <link href="http://github.com/sebastian/about/2020/06/01/regex/"/>
    <id>http://github.com/sebastian/about/2020/06/01/regex/</id>
    <published>2020-06-01T15:38:31.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>Java正则表达式介绍及应用。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>regular expression =&gt; regex。用来描述<strong>匹配</strong>一个字符串集合的<strong>模式</strong>，可以用它来匹配、替换和分割字符串。</p><p>Java里String的方法matches(xxxx)，其中就可以装载正则表达式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java正则表达式介绍及应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="regex" scheme="http://github.com/sebastian/about/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>bitwise</title>
    <link href="http://github.com/sebastian/about/2020/06/01/bitwise/"/>
    <id>http://github.com/sebastian/about/2020/06/01/bitwise/</id>
    <published>2020-06-01T13:11:25.000Z</published>
    <updated>2020-08-08T15:57:25.149Z</updated>
    
    <content type="html"><![CDATA[<p>Introduction of Java bitwise and operation.</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><table><thead><tr><th>操作符</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>1 &amp; 1 = 1 (only)</td></tr><tr><td>|</td><td>或</td><td>0 | 0 = 0 (only)</td></tr><tr><td>^</td><td>异或</td><td>1 ^ 0 = 1</td></tr><tr><td>~</td><td>非</td><td>~ 1 = 0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>右边空出来的补0</td></tr><tr><td>&gt;&gt;</td><td>带符号位右移</td><td>最高位补符号位</td></tr><tr><td>&gt;&gt;&gt;</td><td>无符号位右移</td><td>左边空出来的补0</td></tr></tbody></table><p>位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，&lt;&lt;=以及&gt;&gt;&gt;=。</p><p>位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 11111111111111111111111111111111111(32个1)</span></span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">System.out.printlnl(a&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1111111111111111111111111111111111(32个1)</span></span><br><span class="line">System.out.println(Integer.toBinaryString(a&gt;&gt;<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(a&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 0111111111111111111111111111111111(31个1)</span></span><br><span class="line">System.out.prinlnt(Integer.toBinaryString(a&gt;&gt;&gt;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="a-gt-gt-1"><a href="#a-gt-gt-1" class="headerlink" title="a&gt;&gt;1"></a>a&gt;&gt;1</h4><p>原码：10000000000000000000000000000001</p><p>反码：1111111111111111111111111111111111110</p><p>补码：1111111111111111111111111111111111111</p><p>补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）</p><p>取反：10000000000000000000000000000000</p><p>原码：10000000000000000000000000000001 即 -1.</p><h4 id="a-gt-gt-gt-1"><a href="#a-gt-gt-gt-1" class="headerlink" title="a&gt;&gt;&gt;1"></a>a&gt;&gt;&gt;1</h4><p>同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。</p><p>补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）</p><p>正数原码即补码。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的<code>^</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;&lt;</code>等位运算符。</p><h2 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &amp; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">8</span> &amp; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">7</span> &amp; <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>1的原码：0001</p><p>8的原码：1000</p><p>7的原码：0111</p><p>奇数的最低位永远是1,偶数的为0.</p><h2 id="求非重复数字"><a href="#求非重复数字" class="headerlink" title="求非重复数字"></a>求非重复数字</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ^ 2 ^ 1 = 1</span><br><span class="line">4 ^ 2 ^ 1 ^ 1 ^ 2 = 4</span><br></pre></td></tr></table></figure><p>两个<strong>相同的数字</strong>做<code>^</code>运算时，值为<code>0</code>，再结合<strong>交换律</strong>，可以用来找出一组数字中“落单”的数字。</p><h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><p>……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Introduction of Java bitwise and operation.&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="bitwise" scheme="http://github.com/sebastian/about/tags/bitwise/"/>
    
  </entry>
  
  <entry>
    <title>elasticSearch</title>
    <link href="http://github.com/sebastian/about/2020/05/30/elasticSearch/"/>
    <id>http://github.com/sebastian/about/2020/05/30/elasticSearch/</id>
    <published>2020-05-30T12:42:30.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>reflect</title>
    <link href="http://github.com/sebastian/about/2020/05/27/annotation/"/>
    <id>http://github.com/sebastian/about/2020/05/27/annotation/</id>
    <published>2020-05-26T16:31:17.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>Introduction of Java annotation</p><a id="more"></a><h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><p>在程序执行期间可以通过Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>Normal: class -&gt; new -&gt; object</p><p>Reflect: object -&gt; getClass() -&gt; class</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>在运行时代码可以根据某些条件改变自身结构。</p><p>i.e. Object-C, C#, JavaScrit, PHP, Pthon and etc.</p><h3 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h3><p>i.e. Java, C, C++</p><ul><li>Java也有一定的动态性，利用反射机制获得相关特性。</li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Java反射的源头，通过对象反射求出类的名字。</p><p>在Object类中定义了一个方法，自然而然会被所有子类继承：</p><blockquote><p>public final Class getClass()</p></blockquote><h2 id="META-ANNOTATION"><a href="#META-ANNOTATION" class="headerlink" title="META_ANNOTATION"></a>META_ANNOTATION</h2><ul><li><strong>@Target</strong> 用于描述注解的使用范围</li><li><strong>@Retention</strong> 表示需要在什么级别保存该注解信息，描述注解的生命周期（Source&lt;CLASS&lt;<strong>RUNTIME</strong>)，一般默认RUNTIME。</li><li>@Document 说明注解将被包含在JAVADOC中</li><li>@Inherited 说明子类可以继承父类的该注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementTYpe.TYPE,ELementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation()&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Introduction of Java annotation&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="annatation, reflect" scheme="http://github.com/sebastian/about/tags/annatation-reflect/"/>
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://github.com/sebastian/about/2020/05/24/jvm/"/>
    <id>http://github.com/sebastian/about/2020/05/24/jvm/</id>
    <published>2020-05-24T09:39:25.000Z</published>
    <updated>2020-08-06T11:35:52.358Z</updated>
    
    <content type="html"><![CDATA[<p>associate with juc</p><a id="more"></a><h1 id="系统图"><a href="#系统图" class="headerlink" title="系统图"></a>系统图</h1><p><img src="https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png" alt="Screenshot from 2020-06-04 20-11-48.png"></p><ul><li>灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收</li><li>亮色代表存在垃圾回收</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。</p><blockquote><p>Car.class -&gt; Class Loader -&gt; Car Class -&gt; car1/car2/car3</p></blockquote><p>Car Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。</p><p><img src="https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png" alt="Screenshot from 2020-06-04 20-33-54.png"></p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h3 id="启动类加载器（Bootstrap）"><a href="#启动类加载器（Bootstrap）" class="headerlink" title="启动类加载器（Bootstrap）"></a>启动类加载器（Bootstrap）</h3><p>由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。</p><h3 id="扩展类加载器（Extension）"><a href="#扩展类加载器（Extension）" class="headerlink" title="扩展类加载器（Extension）"></a>扩展类加载器（Extension）</h3><p>Java编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。</p><h3 id="应用程序类加载器（AppClassLoader）"><a href="#应用程序类加载器（AppClassLoader）" class="headerlink" title="应用程序类加载器（AppClassLoader）"></a>应用程序类加载器（AppClassLoader）</h3><p>我们编写程序时定义的类所用的加载器</p><h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><p>定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。</p><h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><p>比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。</p><p><strong>Bootstrap</strong> –&gt; <strong>Extension</strong> –&gt; <strong>Application</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。</p></blockquote><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p><strong>note</strong>: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。</p><h2 id="本地方法接口（Native-Interface）"><a href="#本地方法接口（Native-Interface）" class="headerlink" title="本地方法接口（Native Interface）"></a>本地方法接口（Native Interface）</h2><p>融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。</p><p>异构领域间通信发达，Socket通信或webService。</p><h3 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h3><p>只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。</p><h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><p>实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。</p><p>是当前线程所执行的字节码的行号指示器。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul><li>不存在垃圾回收问题</li><li>==线程私有==（想想加锁，不就在方法上/中加的么）</li></ul><p>也叫栈内存，<strong>主管Java程序的运行</strong>，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>在java中的方法装载在虚拟机的栈中叫栈帧。</p><ul><li><p>Local Variables: 输入参数、输出参数以及方法内的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参为 x, y， 输出为result，方法内变量为result，均在栈中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Operand Stack: 记录出栈、入栈的操作</p></li><li><p>Frame Data: 包括类文件、方法等等</p></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。</p><p>栈管运行，堆管存储。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>class文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是<code>永久代(PermGen space)</code>和<code>元空间(Metaspace)</code>。</p><ul><li>所有==线程共享==</li><li>存在垃圾回收</li></ul><p>存储每个类的<strong>结构信息</strong>（模板）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> price = <span class="number">1233435</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">park</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;stop ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。</p><p>元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是<strong>本机物理内存</strong>。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p><p>实例变量存在堆内存中，与方法区无关。i.e.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        demo.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。</p><h1 id="方法区、栈、堆"><a href="#方法区、栈、堆" class="headerlink" title="方法区、栈、堆"></a>方法区、栈、堆</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person person2 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。</p><p>要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。</p><p>hotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈–&gt;堆–&gt;方法区</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>（Java7之前）    一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p><p>(Java8)    永久区换成了元空间。</p><p>物理上为新生区+养老区。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>逻辑上分为三部分：新生+养老+永久</p><p>新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)</p><p>养老区：Tenure Generation Space</p><p>永久存储区：Permanent Space</p><ul><li>Eden: 0space: 1space  = 8 : 1 : 1</li><li>Young : Old = 1 : 2</li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。</p><h2 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h2><p>Survivor 0 space: from区</p><p>Surrivor 1 space: to区</p><p>他们的位置不固定，每次GC之后位置会交换，空的为to区。</p><ol><li>Eden, SurvivorFrom copy to SurviviorTo</li><li>clean up Eden, SurvivorFrom</li><li>Swap SurvivorTo and SurvivorFrom</li></ol><h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。</p><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Returns the maximum amount of memory that the Java virtual machine will attempt to use.</span></span><br><span class="line">    <span class="keyword">long</span> l = Runtime.getRuntime().maxMemory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the total amount of memory in the Java virtual machine.</span></span><br><span class="line">    <span class="keyword">long</span> l1 = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1/4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;(-xmx) MAX_MEMORY: &quot;</span> + l + <span class="string">&quot;bytes, &quot;</span> + (l / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1/64</span></span><br><span class="line">    System.out.println(<span class="string">&quot;(-xms) TOTAL_MEMORY: &quot;</span> + l1 + <span class="string">&quot;bytes, &quot;</span> + (l1 / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>note:</strong> 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。</p><blockquote><p>-XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）</p></blockquote><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><ul><li>minor GC</li><li>major/full GC</li></ul><p>major GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>分代收集，根据各个代来使用</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。</p><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>Minor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。</p><p>因为存活率都很低，复制也没啥。</p><h3 id="标记清除法（Mark-Sweep）"><a href="#标记清除法（Mark-Sweep）" class="headerlink" title="标记清除法（Mark-Sweep）"></a>标记清除法（Mark-Sweep）</h3><p>Major GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。</p><h3 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark-Compact）"></a>标记压缩（Mark-Compact）</h3><p>Mark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。</p><p>也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>Java的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（<strong>包括实例字段、静态字段以及构成数组对象的元素</strong>）的访问方式。</p><p>在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，<code>工作内存</code>是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作</p><p>内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p><h2 id="violatile"><a href="#violatile" class="headerlink" title="violatile"></a>violatile</h2><p>java虚拟机提供的轻量级的同步机制，乞丐版syncronized。</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A:"></a>Q&amp;A:</h1><h2 id="请谈谈你对JVM的理解？java8虚拟机有哪些更新？"><a href="#请谈谈你对JVM的理解？java8虚拟机有哪些更新？" class="headerlink" title="请谈谈你对JVM的理解？java8虚拟机有哪些更新？"></a>请谈谈你对JVM的理解？java8虚拟机有哪些更新？</h2><h2 id="什么是OOM？是么是StackOverFlowError？有哪些方法分析？"><a href="#什么是OOM？是么是StackOverFlowError？有哪些方法分析？" class="headerlink" title="什么是OOM？是么是StackOverFlowError？有哪些方法分析？"></a>什么是OOM？是么是StackOverFlowError？有哪些方法分析？</h2><h2 id="JVM的常用参数调优你知道哪些？"><a href="#JVM的常用参数调优你知道哪些？" class="headerlink" title="JVM的常用参数调优你知道哪些？"></a>JVM的常用参数调优你知道哪些？</h2><h2 id="谈谈JVM中，对类加载器你的认识？"><a href="#谈谈JVM中，对类加载器你的认识？" class="headerlink" title="谈谈JVM中，对类加载器你的认识？"></a>谈谈JVM中，对类加载器你的认识？</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;associate with juc&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://github.com/sebastian/about/categories/JVM/"/>
    
    
    <category term="jvm" scheme="http://github.com/sebastian/about/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>static_final</title>
    <link href="http://github.com/sebastian/about/2020/04/12/static-final/"/>
    <id>http://github.com/sebastian/about/2020/04/12/static-final/</id>
    <published>2020-04-12T08:19:56.000Z</published>
    <updated>2020-08-15T11:22:06.137Z</updated>
    
    <content type="html"><![CDATA[<p>Java的关键字static, final，以及部分jvm的内容。</p><a id="more"></a><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>先说说final的位置，它可以标注在__类__上、__方法__上以及__变量__上，且变量部分实例和局部。</p><p>简单来说，final的作用就是令其唯一。</p><table><thead><tr><th>final</th><th>influence</th></tr></thead><tbody><tr><td>类</td><td>不能被继承</td></tr><tr><td>方法</td><td>不能被重写</td></tr><tr><td>变量</td><td>不能再被更改</td></tr></tbody></table><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>同上，他的位置也是多样的。可以标注在__方法__上和__变量__上。</p><p>静态，不受实例的影响：例如 Math.max(a, b)，输出的结果只跟调用方传入的a、b的值有关，与Math的实例无关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBook</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//会报告异常，静态方法中不能使用实例变量，对他来说是未知的。</span></span><br><span class="line">        System.out.println(price);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pricce;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">sellingPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bookPrice = <span class="number">2</span>/<span class="number">3</span> * price;</span><br><span class="line">        <span class="keyword">return</span> bookPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例所示，由于静态方法是直接用类名来引用的，所以<strong>实例变量</strong>对于它来说是未知的。那么，实例变量是谁可知、又如何可知的呢？</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量按照不同的分类可以用不同的分法。</p><p>按照位置分类，可以有局部变量和实例变量；按照类型又可以有原始变量和引用变量。</p><p>局部变量：声明在方法内部的变量，如例子中方法sellingPrice()内的变量<code>bookPrice</code>。</p><p>实例变量：声明在类内、方法之外的变量，如例子中的<code>price</code>。关于实例变量，在上例中每创建一个MyBook的对象，都会伴随对象产生一个变量price，且互不影响。</p><p>原始变量：即primitive变量，使用java的基本数据类型声明的变量，如<code>int a = 0</code>。</p><p>引用变量：在创建对象的过程中，将对象赋予的变量。如<code>MyBook firstBook = new MyBook();</code>中，<code>new MyBook()</code>的作用是利用构造函数创建对象，<code>MyBook firstBook</code>声明引用变量，最后是赋值对象给引用。</p><h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><p>如果在实例变量上添加了static修饰符，那么这个变量会被所有的实例共享。</p><h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><p>声明之后的变量存到哪里去了？栈和堆。</p><ul><li>局部变量会跟随方法一起保存在栈中，除此之外还有方法的调用状态，他们一起被称为<strong>堆栈块</strong>。</li><li>实例变量会跟随类的对象一起保存在堆中。</li></ul><p>所以，在静态方法中，对于实例变量是不可知的，或者说不知道该调用哪一个实例变量。</p><p>非primitive的变量只是保存对象的引用。对象都存在堆中，而引用的变量本身会放在栈上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java的关键字static, final，以及部分jvm的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="static" scheme="http://github.com/sebastian/about/tags/static/"/>
    
    <category term="final" scheme="http://github.com/sebastian/about/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>springAOP</title>
    <link href="http://github.com/sebastian/about/2020/03/28/springAOP/"/>
    <id>http://github.com/sebastian/about/2020/03/28/springAOP/</id>
    <published>2020-03-28T06:43:58.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>AOP, 切面。聊聊几个通知。</p><a id="more"></a><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>如果是吃个蛋糕，会怎么吃？有的人会一层一层吃，当然最上面是奶油或者水果，最下方是面包，但是大部分人都不会这么吃，会用刀将蛋糕切开，将糅合了多层的可口蛋糕一起送入口中，而非第一种吃法那样有先后顺序。Spring框架中的AOP的用途就好比那把刀，将容器中的bean有个安排。</p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p>AOP中的刀不像是切蛋糕那样最终把蛋糕送入口中，它的实际工序会更多。比如送入口中可能是最后一步，在这之前也许会统一撒点肉松、统一加热之类的。虽然有点奇怪。</p><p>Spring的命名是让人通俗易懂的，也可以理解为你的英语水平够用。诸如*@Before*, <em>@After</em>…之类的一眼扫过去就能知道它的作用。目前用到的有5个：l@Before, @After, @AfterReturning, @AfterThrowing和@Around。他们都不是直接标注就可以使用，而是<strong>需要指要作用的方法</strong>。</p><p>由于作用的目标方法大多相同，因此还可以提取公共的路径。</p><p>与之相关的要先介绍<code>JointPoint</code>，根据词意不难理解：切点。切面中的切点可以说是很细节的了，能用他来获取切面相关的信息，可以理解为“帮手”。</p><h2 id="PointCut"><a href="#PointCut" class="headerlink" title="@PointCut"></a>@PointCut</h2><p>公用切入点。括号后加入作用路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public int org.example.aop.MathCalculate.*(..)) &quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MathCalculate为类名，<code>MathCalculate.*</code>表示作用于类下的所有方法。<code>(..)</code>表示任意参数。</p><h2 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h2><p>这个是前置通知。表示在方法执行前执行标识了这个注解的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;，logStart()..方法名：&quot;</span> + <span class="string">&quot;....参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="After"><a href="#After" class="headerlink" title="@After"></a>@After</h2><p>后置通知。方法结束后会被调用，<strong>无论方法成功还是失败</strong>，类似于<code>finally</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;，@After.方法名：&quot;</span> + <span class="string">&quot;. 一定会返回的。.参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a>@AfterReturning</h2><p>返回通知。在方法正常结束时用。因为是正常结束，一般都需要知道返回的结果，所以入参相比之前的就多了一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;object&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint, Object object)</span> </span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;，@AfterReturning..正常返回。.运行结果：&quot;</span> + object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="@AfterThrowing"></a>@AfterThrowing</h2><p>异常通知。抛出异常的时候用。抛出的异常也是对象，需要告诉Spring，所以这也算一个入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot; 方法名：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;.....异常信息：&quot;</span> + exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h2><p>环绕通知。听这个名字有没有觉得很仙气，很厉害的样子。的确厉害，一个顶四个。。</p><p>他的“帮手”也不再是JointPoint了，而是升级版的：<code>ProceedingJoinPoint</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(value = &quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">logAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;，Around ..方法名：&quot;</span> + <span class="string">&quot;....参数：&quot;</span> + Arrays.asList(proceedingJoinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line">        System.out.println(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;，Around..正常返回。.运行结果：&quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法名：&quot;</span> + proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;....Around  .异常信息：&quot;</span> + throwable);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;，Around.方法名：&quot;</span> + <span class="string">&quot;. 一定会返回的。.参数：&quot;</span> + Arrays.asList(proceedingJoinPoint.getArgs()));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果认为标注注解就能生效就  <em>too young to navie</em> 了。</p><ul><li>将业务逻辑代码以及切面类（例如日志打印服务）都加入到容器中，并且告诉Spring哪个是切面类（在类上加**@Aspect**）</li><li>在切面类上的要用的通知方法上加入相应注解（如@Before）。</li><li>在配置类上开启注解的aop模式（ <strong>@EnableAspectJAutoProxy</strong>）。</li></ul><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;AOP, 切面。聊聊几个通知。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://github.com/sebastian/about/categories/Spring/"/>
    
    
    <category term="aop" scheme="http://github.com/sebastian/about/tags/aop/"/>
    
  </entry>
  
</feed>
