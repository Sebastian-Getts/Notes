<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hola</title>
  
  
  <link href="http://github.com/sebastian/about/atom.xml" rel="self"/>
  
  <link href="http://github.com/sebastian/about/"/>
  <updated>2020-08-23T06:50:59.923Z</updated>
  <id>http://github.com/sebastian/about/</id>
  
  <author>
    <name>Sebastian Getts</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>contest203</title>
    <link href="http://github.com/sebastian/about/2020/08/23/contest203/"/>
    <id>http://github.com/sebastian/about/2020/08/23/contest203/</id>
    <published>2020-08-23T04:22:22.000Z</published>
    <updated>2020-08-23T06:50:59.923Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode周赛203</p><a id="more"></a><h1 id="1560-Most-Visited-Sector-in-a-Circular-Track"><a href="#1560-Most-Visited-Sector-in-a-Circular-Track" class="headerlink" title="1560. Most Visited Sector in a Circular Track"></a>1560. Most Visited Sector in a Circular Track</h1><p>Given an integer <code>n</code> and an integer array <code>rounds</code>. We have a circular track which consists of <code>n</code> sectors labeled from <code>1</code> to <code>n</code>. A marathon will be held on this track, the marathon consists of <code>m</code> rounds. The <code>ith</code> round starts at sector <code>rounds[i - 1]</code> and ends at sector <code>rounds[i]</code>. For example, round 1 starts at sector <code>rounds[0]</code> and ends at sector <code>rounds[1]</code></p><p>Return <em>an array of the most visited sectors</em> sorted in <strong>ascending</strong> order.</p><p>Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/14/tmp.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4, rounds &#x3D; [1,3,1,2]</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:</span><br><span class="line">1 --&gt; 2 --&gt; 3 (end of round 1) --&gt; 4 --&gt; 1 (end of round 2) --&gt; 2 (end of round 3 and the marathon)</span><br><span class="line">We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2, rounds &#x3D; [2,1,2,1,2,1,2,1,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 7, rounds &#x3D; [1,3,5,7]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>这道题虽然看起来长，但是难度是<code>easy</code>的，所以一定不会复杂，仔细看来只是求重复次数最多的sectors，我觉得难点是在头一个数比后一个数大的情况下（相当与跑步比赛中的套圈），如何去从头开始循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] rounds)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取数组第一个和最后一个数字</span></span><br><span class="line">    <span class="keyword">int</span> f = rounds[<span class="number">0</span>], t = rounds[rounds.length-<span class="number">1</span>];</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = f;;)&#123;</span><br><span class="line">        ret.add(i);</span><br><span class="line">        <span class="keyword">if</span>(i == t)<span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i == n+<span class="number">1</span>)i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmm上面这个有些取巧，不明白的先看看下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A[<span class="number">0</span>]; i &lt;= A[A.length - <span class="number">1</span>]; ++i)</span><br><span class="line">        res.add(i);</span><br><span class="line">    <span class="keyword">if</span> (res.size() &gt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 下面计算的是start&gt;end的情况，[1, end] + [start, n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[A.length - <span class="number">1</span>]; ++i)</span><br><span class="line">        res.add(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A[<span class="number">0</span>]; i &lt;= n; ++i)</span><br><span class="line">        res.add(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我们只需要关注首节点和末节点就行了，因为要求的是重复次数最多的sector，那么，必然会涉及到首尾，完全不必考虑中间节点。</p><ul><li>如果start&lt;=end，返回[start, end]</li><li>如果start&gt;end，返回[start, n]+[1, end]</li></ul><p>另外一个版本，更好理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] rounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = rounds.length, fr = rounds[<span class="number">0</span>], to = rounds[len - <span class="number">1</span>];</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (to &gt;= fr) &#123;     <span class="comment">// no circle, such as [1,3,1,2]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fr; i &lt;= to; i++) res.add(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">// cross a circle, such as [2,3,2,1]</span></span><br><span class="line">        <span class="comment">// 这里遍历每个sector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果到最后一个sector的下一个，就从数组中第一个开始，相当于从“后端”开始了，省去了中间部分。</span></span><br><span class="line">            <span class="keyword">if</span> (i == to + <span class="number">1</span>) i = fr;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及<code>环</code>的问题，要找到问题本质。这里说的首尾，一是指给定n个sector中的首尾，二是指给定round中的首尾。</p><h1 id="1561-Maximum-Number-of-Coins-You-Can-Get"><a href="#1561-Maximum-Number-of-Coins-You-Can-Get" class="headerlink" title="1561. Maximum Number of Coins You Can Get"></a>1561. Maximum Number of Coins You Can Get</h1><p>There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:</p><ul><li>In each step, you will choose <strong>any</strong> 3 piles of coins (not necessarily consecutive).</li><li>Of your choice, Alice will pick the pile with the maximum number of coins.</li><li>You will pick the next pile with maximum number of coins.</li><li>Your friend Bob will pick the last pile.</li><li>Repeat until there are no more piles of coins.</li></ul><p>Given an array of integers <code>piles</code> where <code>piles[i]</code> is the number of coins in the <code>ith</code> pile.</p><p>Return the maximum number of coins which you can have.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: piles &#x3D; [2,4,1,2,7,8]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.</span><br><span class="line">Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.</span><br><span class="line">The maximum number of coins which you can have are: 7 + 2 &#x3D; 9.</span><br><span class="line">On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 &#x3D; 6 coins which is not optimal.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles &#x3D; [2,4,5]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles &#x3D; [9,8,7,6,5,1,2,3,4]</span><br><span class="line">Output: 18</span><br></pre></td></tr></table></figure><h2 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h2><p>我觉得这道题本质是个排序的题，但是要按一定的规则排序，最初设想的是每三个数排序，取中间那个。</p><p>然而好的算法都是讲究技巧的，不是靠蛮力。完全可以放心地对数组进行排序，可以理解为逆向思维，例如example1中的数组排好序后：*[1,2,2,4,7,8]*，无论我们怎么分，最优解必然是Bob拿到前两个数，剩下的四个是我们与Alice分，由于是我拿第二大的，所以先分我，在分给Alice，依照这样的一个思路，问题就解决了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">        res += A[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode周赛203&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://github.com/sebastian/about/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>hashmap</title>
    <link href="http://github.com/sebastian/about/2020/08/20/hashmap/"/>
    <id>http://github.com/sebastian/about/2020/08/20/hashmap/</id>
    <published>2020-08-20T15:04:30.000Z</published>
    <updated>2020-08-31T15:54:55.950Z</updated>
    
    <content type="html"><![CDATA[<p>Java Hashmap. 探究他的实现原理和数据结构。基于jdk8. 虽然被讲烂了，但是再烂也得自己整明白了记下来，不然总归不是自己的。</p><p>经典数据结构。</p><a id="more"></a><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Gloria&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;wage&quot;</span>, <span class="number">539.8</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>通过一个简单的<code>put</code>操作，来看看究竟发生了什么。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;(map); <span class="comment">// map为上方那个</span></span><br></pre></td></tr></table></figure><p>来看看初始化容量时的装载因子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>HashMap的容量是我们存入的数值乘以<code>0.75</code>,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>那么，这个map的<strong>实际容量</strong>就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的<code>0.75</code>,自定义<strong>初始容量</strong>。</p><h2 id="put初识"><a href="#put初识" class="headerlink" title="put初识"></a>put初识</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;key</span><br></pre></td></tr></table></figure><p>put有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个<strong>位运算</strong>:</p><ul><li>^ 异或(两个相同的数做异或运算结果为0)</li><li>&gt;&gt;&gt; 无符号右移，左边空出来的补0</li></ul><p>首先是给h赋值为key的hashCode，key的hashcode是通过Object的<code>native方法</code>，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。</p><p>关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量<code>table</code>，他的类型是<code>Noe&lt;K,V&gt; []</code>，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。</p><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 用来定位数组索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">// 链接下一个Node</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get, set equals ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>脱脱的链表有么有！！！ <code>Node&lt;K, V&gt; next</code>！！！</li><li>上面提到的<code>table</code>就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。</li><li>实现了<code>Map.Entry&lt;K, V&gt;</code>接口，所以，他的本质（或者说表现）就是一个k-v键值对。</li><li>与算法题通常定义的简易链表不同，除了<code>next</code>外这里存储了三个值：<code>hash</code>, <code>key</code>, <code>value</code></li></ul><h1 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h1><p>首先想想：什么是哈希表。</p><p>哈希表=数组+链表。通过<code>Node&lt;K, V&gt;</code>以及<code>Node&lt;K, V&gt; []</code>我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是<code>数组+链表</code>。</p><p>哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于<strong>桶</strong>（即之前提到的<code>table</code>数组）和<strong>哈希算法</strong>，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">  * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">  * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">  * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">  * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><code>threshold</code>临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node&lt;K,V&gt;[] table的length是16, loadFactor是0.75,，那么</p><blockquote><p>threshold = loadFactor * length</p></blockquote><p>也就是说，table数组中所能容纳的Node个数由<code>threshold</code>指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.</p><p>size就是表示目前存储的Node的数量。</p><p>在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种<strong>非常规</strong>设计，为什么呢？一个冷知识：</p><ul><li>2的n次方的数为<code>合数</code>，实际上<code>质数</code>导致哈希冲突的概率要小于合数。</li></ul><p>参考HashTable的初始化，<code>initialCapacity</code>就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了<strong>红黑树</strong>，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。</p><h1 id="确定索引"><a href="#确定索引" class="headerlink" title="确定索引"></a>确定索引</h1><p>我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：</p><blockquote><p>取值（key的hashCode），高位运算，取模运算</p></blockquote><p>我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以<code>(n-1)&amp;hash</code>等价于对length取模，比使用<code>%</code>具有更高的效率。</p><h1 id="put详解"><a href="#put详解" class="headerlink" title="put详解"></a>put详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断table的是否为空，是则执行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算插入数组的索引，如果为null，新建节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断key是否存在，如ugo存在直接覆盖掉value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断是否是红黑树，如果是的话就在树中操作，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历table</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 链表的插入操作</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 长度大于8时转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？</p><blockquote><p>note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 太大就不管了，let it go</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，左移一位（X2）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算resize的上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，把每个桶都移动到新的中去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java Hashmap. 探究他的实现原理和数据结构。基于jdk8. 虽然被讲烂了，但是再烂也得自己整明白了记下来，不然总归不是自己的。&lt;/p&gt;
&lt;p&gt;经典数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="hashmap, data structure" scheme="http://github.com/sebastian/about/tags/hashmap-data-structure/"/>
    
  </entry>
  
  <entry>
    <title>contest202</title>
    <link href="http://github.com/sebastian/about/2020/08/16/contest202/"/>
    <id>http://github.com/sebastian/about/2020/08/16/contest202/</id>
    <published>2020-08-16T06:36:31.000Z</published>
    <updated>2020-08-16T07:14:32.244Z</updated>
    
    <content type="html"><![CDATA[<p>Leetocode周赛202</p><a id="more"></a><h1 id="1550-Three-Consecutive-Odds"><a href="#1550-Three-Consecutive-Odds" class="headerlink" title="1550. Three Consecutive Odds"></a>1550. Three Consecutive Odds</h1><p>Given an integer array <code>arr</code>, return <code>true</code> if there are three consecutive odd numbers in the array. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [2,6,4,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are no three consecutive odds.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [1,2,34,3,4,5,7,23,12]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: [5,7,23] are three consecutive odds.</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>题目难度不高，因此重点关注代码技巧上。“连续三个基数”则返回true，否则false，一般情况下都会想到遍历数组的同时维护一个变量，变量达到三时返回。直到我看到了神级代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+<span class="number">2</span> &lt; a.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span> + a[i+<span class="number">1</span>] % <span class="number">2</span> + a[i+<span class="number">2</span>] % <span class="number">2</span> == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rank榜单的前几名整齐化一地这样写。我们来看看这样写的原理：</p><p>同样是for循环，它的 判断条件是<code>i+2&lt;a.length</code>，为何要<code>+2</code>,原因在for循环中，它每次在第i处下标都会同时获取到i的后两位，把和三个数与2相除取余，如果是奇数余数为1,那么这三个数相加即为3,好处是不用额外维护一个变量，代码也简单易懂。</p><p><strong>note:</strong> 循环时同时做三个数的运算；取余判断奇偶</p><h1 id="1551-Minimum-Operations-to-Make-Array-Equal"><a href="#1551-Minimum-Operations-to-Make-Array-Equal" class="headerlink" title="1551. Minimum Operations to Make Array Equal"></a>1551. Minimum Operations to Make Array Equal</h1><p>You have an array <code>arr</code> of length <code>n</code> where <code>arr[i] = (2 * i) + 1</code> for all valid values of <code>i</code> (i.e. <code>0 &lt;= i &lt; n</code>).</p><p>In one operation, you can select two indices <code>x</code> and <code>y</code> where <code>0 &lt;= x, y &lt; n</code> and subtract <code>1</code> from <code>arr[x]</code> and add <code>1</code> to <code>arr[y]</code> (i.e. perform <code>arr[x] -=1 </code>and <code>arr[y] += 1</code>). The goal is to make all the elements of the array <strong>equal</strong>. It is <strong>guaranteed</strong> that all the elements of the array can be made equal using some operations.</p><p>Given an integer <code>n</code>, the length of the array. Return <em>the minimum number of operations</em> needed to make all the elements of arr equal.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: arr &#x3D; [1, 3, 5]</span><br><span class="line">First operation choose x &#x3D; 2 and y &#x3D; 0, this leads arr to be [2, 3, 4]</span><br><span class="line">In the second operation choose x &#x3D; 2 and y &#x3D; 0 again, thus arr &#x3D; [3, 3, 3].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><h2 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h2><p>这道题看着挺复杂，行数多，其实像是在<code>找规律</code>（我就是没找出来，n=6时output=9？），是一道数学题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Take care of overflow if n is too large.</span></span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (n*(n+<span class="number">1</span>));</span><br><span class="line">    &#125;        </span><br><span class="line">    n/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> n*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解法是将其分两种情况–奇数与偶数。考得不是算法， 是脑子吧。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetocode周赛202&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>contest201</title>
    <link href="http://github.com/sebastian/about/2020/08/09/contest201/"/>
    <id>http://github.com/sebastian/about/2020/08/09/contest201/</id>
    <published>2020-08-09T04:22:53.000Z</published>
    <updated>2020-08-09T05:50:41.788Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode周赛201.</p><a id="more"></a><h1 id="1544-Make-The-String-Great"><a href="#1544-Make-The-String-Great" class="headerlink" title="1544 Make The String Great"></a>1544 Make The String Great</h1><p>Given a string <code>s</code> of lower and upper case English letters.</p><p>A good string is a string which doesn’t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li></ul><p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p><p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p><p><strong>Notice</strong> that an empty string is also good.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leEeetcode&quot;</span><br><span class="line">Output: &quot;leetcode&quot;</span><br><span class="line">Explanation: In the first step, either you choose i &#x3D; 1 or i &#x3D; 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abBAcC&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: We have many possible scenarios, and all lead to the same answer. For example:</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;s&quot;</span><br><span class="line">Output: &quot;s&quot;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>首先要注意审题，明确界限的判断。尤其是<code>vice-versa</code>，反之亦然的意思，就是<strong>相邻两个字母忽略大小写时相同，且一个大写一个小写</strong>，需要将这两个字母剔除。</li><li>通过<code>example 2</code>可以看出算法应有<em>循环</em>的动作，剔除后还应该重新审视。</li></ul><h3 id="mine"><a href="#mine" class="headerlink" title="mine"></a>mine</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty() &amp;&amp; (</span><br><span class="line">                (Character.isUpperCase(c) &amp;&amp; Character.isLowerCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class="string">&#x27;a&#x27;</span>) == (c - <span class="string">&#x27;A&#x27;</span>)))</span><br><span class="line">                        ||</span><br><span class="line">                        (Character.isLowerCase(c) &amp;&amp; Character.isUpperCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class="string">&#x27;A&#x27;</span>) == (c - <span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">        )) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Character&gt; iterator = stack.iterator();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        sb.append(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是iterator，不用reverse()</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="better"><a href="#better" class="headerlink" title="better"></a>better</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ch = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (ch) &#123;</span><br><span class="line">    ch = <span class="keyword">false</span>;</span><br><span class="line">    String t = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) + <span class="number">32</span> == s.charAt(i + <span class="number">1</span>) || s.charAt(i + <span class="number">1</span>) + <span class="number">32</span> == s.charAt(i)) &#123;</span><br><span class="line">            t = s.substring(<span class="number">0</span>, i) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">            ch = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><h1 id="1545-Find-Kth-Bit-in-Nth-Binary-String"><a href="#1545-Find-Kth-Bit-in-Nth-Binary-String" class="headerlink" title="1545 Find Kth Bit in Nth Binary String"></a>1545 Find Kth Bit in Nth Binary String</h1><p>Given two positive integers <code>n</code> and <code>k</code>, the binary string <code>Sn</code> is formed as follows:</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code> for <code>i &gt; 1</code></li></ul><p>Where <code>+</code> denotes the concatenation operation, <code>reverse(x)</code> returns the reversed string x, and <code>invert(x)</code> inverts all the bits in x (0 changes to 1 and 1 changes to 0).</p><p>For example, the first 4 strings in the above sequence are:</p><ul><li>S1 = “0”</li><li>S2 = “0<strong>1</strong>1”</li><li>S3 = “011<strong>1</strong>001”</li><li>S4 = “0111001<strong>1</strong>0110001”</li></ul><p>Return <em>the</em> <code>kth</code> <em>bit</em> <em>in</em> <code>Sn</code>. It is guaranteed that <code>k</code> is valid for the given <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 1</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: S3 is &quot;0111001&quot;. The first bit is &quot;0&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 11</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: S4 is &quot;011100110110001&quot;. The 11th bit is &quot;1&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1, k &#x3D; 1</span><br><span class="line">Output: &quot;0&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2, k &#x3D; 3</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>题目中已经给了计算式，根据式子来计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> integer = Integer.parseInt(sb.toString());</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(integer));</span><br><span class="line">        <span class="comment">// 0-1 inverse</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringBuilder.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                stringBuilder.replace(i, i + <span class="number">1</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.replace(i, i + <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.reverse();</span><br><span class="line">        sb.append(<span class="string">&quot;1&quot;</span>).append(stringBuilder);</span><br><span class="line">        n--;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = sb.toString().toCharArray();</span><br><span class="line">    <span class="keyword">return</span> chars[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解题过程是错的，我觉得最好的方式应该是用递归，但是不太会，用来迭代，在n=4时的结果就错了。</p><h3 id="better-1"><a href="#better-1" class="headerlink" title="better"></a>better</h3><p>做<code>0-1</code>转换时，当时想用位运算，怎奈不熟练、没想起来<code>异或</code>。</p><ul><li>异或 ^ ：相同为0，0异或任何数为任何数。在二进制的情况下，与<code>1</code>异或等同于<code>0-1</code>翻转。</li></ul><h4 id="method-1"><a href="#method-1" class="headerlink" title="method 1"></a>method 1</h4><p>一目了然，迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        --n;</span><br><span class="line">        s = s+<span class="string">&quot;1&quot;</span>+sinv(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从0开始，k-1</span></span><br><span class="line">    <span class="keyword">return</span> s.charAt(k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sinv</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder a = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 从后遍历，reverse()</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="comment">// 0-1翻转</span></span><br><span class="line">        c^=<span class="number">1</span>;</span><br><span class="line">        a.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="method-2"><a href="#method-2" class="headerlink" title="method 2"></a>method 2</h4><p>别具一格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    s[1]</span>=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    t[<span class="number">1</span>]=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=s[i-<span class="number">1</span>];</span><br><span class="line">        s[i]+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        s[i]+=t[i-<span class="number">1</span>];</span><br><span class="line">        t[i]=s[i-<span class="number">1</span>];</span><br><span class="line">        t[i]+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t[i]+=t[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[n][k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="method-3"><a href="#method-3" class="headerlink" title="method 3"></a>method 3</h4><p>清清楚楚，深度优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> base = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == base + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= base) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n - <span class="number">1</span>, len - k + <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode周赛201.&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>mybatis</title>
    <link href="http://github.com/sebastian/about/2020/08/05/mybatis/"/>
    <id>http://github.com/sebastian/about/2020/08/05/mybatis/</id>
    <published>2020-08-05T14:21:19.000Z</published>
    <updated>2020-08-05T16:02:18.465Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。</p><a id="more"></a><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: start</span><br><span class="line">config&#x3D;&gt;operation: mybatis-config.xml</span><br><span class="line">build&#x3D;&gt;operation: SqlSessionFactoryBuilder</span><br><span class="line">factory&#x3D;&gt;operation: SqlSessionFactory</span><br><span class="line">session&#x3D;&gt;parallel: SqlSession</span><br><span class="line">mapper&#x3D;&gt;operation: Sql Mapper</span><br><span class="line">end&#x3D;&gt;end: end</span><br><span class="line"></span><br><span class="line">start-&gt;config-&gt;build-&gt;factory-&gt;session</span><br><span class="line">session(path1,)-&gt;end</span><br><span class="line">session(path2,right)-&gt;mapper-&gt;end</span><br></pre></td></tr></table></figure><p>对于<code>SqlSessionFactoryBuilder</code>来说，作用是创建<code>SqlSessionFactory</code>，一旦创建完工厂就没用了，所以是作为<strong>局部变量</strong>；而对于<code>SqlSessionFactory</code>，可以把它看作<em>连接池</em>，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建<code>SqlSession</code> 。创建<code>SqlSession</code>后用来链接数据库，每个session被看作是请求数据库，他是<strong>线程不安全</strong>的，每个线程都应有自己的session，不共享，所以最佳作用域是<strong>方法域</strong>，即每次与数据库交互都创建一个<code>SqlSession</code>，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。</p><h2 id="属性名与数据库表字段名"><a href="#属性名与数据库表字段名" class="headerlink" title="属性名与数据库表字段名"></a>属性名与数据库表字段名</h2><p>当pojo中的实例变量与数据库字段中不一致时，可以使用<code>resultMap</code>来解决，即<strong>结果集映射</strong>。</p><p>也常用<code>resultType</code>，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来<code>resultMap</code>时可以去掉<code>resultType</code>属性。</p><h2 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h2><p>mybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>mybatis支持分页，有<code>limit</code>和<code>rowBounts</code>两个方法。区别是前者在sql中实现，后者面向对象。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">USER</span> <span class="keyword">limit</span> <span class="comment">#&#123;index&#125;,#&#123;size&#125;</span></span><br></pre></td></tr></table></figure><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>默认定义了两级缓存：一级缓存、二级缓存</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>默认开启，在session的<code>close</code>之前都有效，如果是查询相同的数据，直接在缓存中拿。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>需要手动开启和配置，基于<code>namespace</code>级别，有<code>Cache</code>接口来自定义实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="mybatis" scheme="http://github.com/sebastian/about/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>contest200</title>
    <link href="http://github.com/sebastian/about/2020/08/02/contest200/"/>
    <id>http://github.com/sebastian/about/2020/08/02/contest200/</id>
    <published>2020-08-02T04:56:29.000Z</published>
    <updated>2020-08-02T06:03:42.348Z</updated>
    
    <content type="html"><![CDATA[<p>Record Leetcode contest 200.</p><a id="more"></a><h1 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h1><p>passed.</p><h1 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h1><p>Find the winner of an Array Game.</p><p>Given an integer array <code>arr</code> of <strong>distinct</strong> integers and an integer <code>k</code>.</p><p>A game will be played between the first two elements of the array (i.e. <code>arr[0]</code> and <code>arr[1]</code>). In each round of the game, we compare <code>arr[0]</code> with <code>arr[1]</code>, the larger integer wins and remains at position <code>0</code> and the smaller integer moves to the end of the array. The game ends when an integer wins <code>k</code> consecutive rounds.</p><p>Return <em>the integer which will win the game</em>.</p><p>It is <strong>guaranteed</strong> that there will be a winner of the game.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [2,1,3,5,4,6,7], k = 2</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Let&#x27;s see the rounds of the game:</span><br><span class="line">Round |       arr       | winner | win<span class="emphasis">_count</span></span><br><span class="line"><span class="emphasis">  1   | [2,1,3,5,4,6,7] | 2      | 1</span></span><br><span class="line"><span class="emphasis">  2   | [2,3,5,4,6,7,1] | 3      | 1</span></span><br><span class="line"><span class="emphasis">  3   | [3,5,4,6,7,1,2] | 5      | 1</span></span><br><span class="line"><span class="emphasis">  4   | [5,4,6,7,1,2,3] | 5      | 2</span></span><br><span class="line"><span class="emphasis">So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,1], k = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 will win the first 10 rounds consecutively.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,9,8,2,3,7,6,4,5], k = 7</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><p>看到这题，首先我认为这题清晰明了，用__迭代__去完成全部流程，用<strong>k</strong>去做结束的标志，是一道从头到尾很明确的题。但是:joy:</p><p>贴上我稚嫩的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> zero = k-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> solution = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> currMax = Math.max(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> currMin = Math.min(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">        helper(currMax, currMin, arr);</span><br><span class="line">        <span class="keyword">if</span>(res == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// initial, no compare</span></span><br><span class="line">            res = currMax;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(currMax == res)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                solution = currMax;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = zero;</span><br><span class="line">                res = currMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> min, <span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[arr.length-<span class="number">1</span>] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没通过，因为<code>Time Limited</code>，跑得太慢了！</p><h2 id="Niubility-Solution"><a href="#Niubility-Solution" class="headerlink" title="Niubility Solution"></a>Niubility Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">// 数组长度与k之间取最小的。</span></span><br><span class="line">    k = Math.min(k, n);</span><br><span class="line">    <span class="keyword">int</span> A = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 标志位，记录相同次数</span></span><br><span class="line">    <span class="keyword">int</span> rep = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从第二个开始iterate，无终结条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;;i++)&#123;</span><br><span class="line">        <span class="comment">// “i%n“ 取余数，逻辑变换数组。由于for循环无终结条件，所以i会无限增加超过n。</span></span><br><span class="line">        <span class="keyword">int</span> B = arr[i%n];</span><br><span class="line">        <span class="keyword">if</span>(A &gt;= B)&#123;</span><br><span class="line">            rep++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A = B;</span><br><span class="line">            rep = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终结条件在这里，rep等于k时结束。</span></span><br><span class="line">        <span class="keyword">if</span>(rep == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过对比可以发现，我耗时的原因在于：</strong> </p><ol><li>我是真的挪了数组！物理上的挪动，实际上，逻辑移动数组即可！我的程序算例4要6秒，这个只需要0秒。</li><li><code>Math.min(k, n)</code>，如果题目给的k为<code>10000000</code>,数组长度为<code>8</code>,那么最后也是按<code>8</code> 来算，那么多循环无意义，一遍遍历即可获取最大（这样也行？）</li></ol><p>况且，逻辑i上也没有去变换位置，题目的本质还是挨个遍历！</p><p>i.e. arr = [2,1,3,5,4,6,7], k = 2</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Record Leetcode contest 200.&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>lock</title>
    <link href="http://github.com/sebastian/about/2020/07/20/lock/"/>
    <id>http://github.com/sebastian/about/2020/07/20/lock/</id>
    <published>2020-07-20T13:46:41.000Z</published>
    <updated>2020-08-23T02:23:51.331Z</updated>
    
    <content type="html"><![CDATA[<p>锁跟多线程紧密相关，有复杂与简单之分。</p><a id="more"></a><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p><img src="https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png" alt="image.png"></p><h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁|悲观锁"></a>乐观锁|悲观锁</h1><p>所谓乐观锁、悲观锁可以类比地看作<strong>JVM里的方法区</strong>，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？</p><ul><li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，<code>synchronized</code>关键字和<code>Lock的实现类</code>都是悲观锁。</li><li>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过<strong>无锁编程</strong>实现的乐观锁，最常用的就是<code>CAS算法</code>，Java原子类中的递增操作就是通过<strong>CAS自旋实现</strong>的。</li></ul><p>根据他们的概念，可以发现<strong>悲观锁适合写操作多的场景</strong>，<strong>乐观锁适合读操作多的场景</strong>，这样利于性能的优化提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMehthod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观锁</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">// 执行自增1</span></span><br></pre></td></tr></table></figure><h1 id="Compare-And-Swap"><a href="#Compare-And-Swap" class="headerlink" title="Compare And Swap"></a>Compare And Swap</h1><p>CAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的<strong>原子类</strong>就是通过这种算法实现了乐观锁。算法涉及到三个操作数：</p><ul><li>需要读写的内存值V （已存在的值）</li><li>进行比较的值A</li><li>要写入的新值B</li></ul><p>当<code>V=A</code>时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="comment">// 获取并操作内存的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// 存储value在AtomicInteger中的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储AtomicInteger的int值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>一目了然了吧，最终的<code>compareAndSwapInt</code>是<code>native</code>，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：</p><ul><li>看到<code>do-while</code>了吧，循环时间长会造成较大的CPU开销。</li></ul><p><strong>note:</strong> ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A”</p><h1 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁|适应性自旋锁"></a>自旋锁|适应性自旋锁</h1><p>涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference <a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">here</a></p><h1 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁|非公平锁"></a>公平锁|非公平锁</h1><p>简而言之，公平锁是好好排队的，非公平锁是插队来的。</p><p>在类<code>ReentrantLock</code>中，有一个内部类<code>Sync</code>，他是继承<code>AbstractQueuedSnchronizer</code>的，对锁的添加、释放等操作大部分都是在<code>Sync</code>实现的，他又有<code>FairSync</code>和<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁。</p><h1 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁|共享锁"></a>独享锁|共享锁</h1><p>别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的<code>synchronized</code>和并发包中的<code>Lock</code>。</p><p>共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁和共享锁也是通过AQS来实现的。具体参考类<code>ReentrantReadWriteLock</code>。类中有<code>ReadLock</code>和<code>WriteLock</code>两把锁，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;锁跟多线程紧密相关，有复杂与简单之分。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="lock" scheme="http://github.com/sebastian/about/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="http://github.com/sebastian/about/2020/07/20/volatile/"/>
    <id>http://github.com/sebastian/about/2020/07/20/volatile/</id>
    <published>2020-07-20T13:23:51.000Z</published>
    <updated>2020-08-31T15:56:14.114Z</updated>
    
    <content type="html"><![CDATA[<p>这个关键字用于将Java变量标记为<code>being stored in main memory</code>，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。</p><a id="more"></a><h1 id="Visibility-problems"><a href="#Visibility-problems" class="headerlink" title="Visibility problems"></a>Visibility problems</h1><p>主要是多线程中的问题。线程在操作<code>非volatile</code>的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。</p><p>那么问题来了，对于<code>非volatile</code>的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。</p><p>如果counter不声明为<code>volatile</code>，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，<strong>一个线程的更新对其他线程是不可见的</strong>。</p><h1 id="Visibility-Guarantee"><a href="#Visibility-Guarantee" class="headerlink" title="Visibility Guarantee"></a>Visibility Guarantee</h1><p>关键字<code>volatile</code>的设定就是解决上面提到的可见性问题。通过声明counter变量为<code>volatile</code>的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字<code>volatile</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareObject</span></span>&#123;</span><br><span class="line">    <span class="comment">// 由于声明为volatile，因此更改变量对于其他线程的是可见的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为<code>volatile</code>是不够的。</p><h2 id="Full-Visibility-Guarantee"><a href="#Full-Visibility-Guarantee" class="headerlink" title="Full Visibility Guarantee"></a>Full Visibility Guarantee</h2><p>实际上，关键字<code>volatile</code>的可见保证性超越了<code>volatile</code>变量本身。有点绕吧，可见保证性如下：</p><ul><li><p>如果线程A更改了<code>volatile</code>变量，并且线程B随后读取了它，则在写入<code>volatile</code>变量之前线程A可见的所有变量在线程B读取<code>volatile</code>变量后也将可见。</p></li><li><p>如果线程A读取了一个<code>volatile</code>变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。</p></li></ul><p>看个代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改了三个变量，只有days是volatile的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = year;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalDays</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="keyword">this</span>.days;</span><br><span class="line">        total += months * <span class="number">30</span>;</span><br><span class="line">        total += years * <span class="number">365</span>;</span><br><span class="line">        <span class="keyword">return</span> total;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着重观察<em>totalDays()<em>，他一开始会将<code>days</code>的值赋给变量<code>total</code> ,由于<code>days</code>的类型是<code>volatile</code>，所以，读取<code>days</code>的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了<code>volatile</code>他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为<code>volatile</code>，读取时必须</em></em>最后**读取带有<code>volatile</code>属性的值）。</p><h1 id="Instruction-Reordering"><a href="#Instruction-Reordering" class="headerlink" title="Instruction Reordering"></a>Instruction Reordering</h1><p>指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">1</span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">b++</span><br></pre></td></tr></table></figure><p>然而，当变量属于<code>volatile</code>时，指令排序就需要小心了，看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果JVM重排指令，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里将days赋值动作放到了第一位</span></span><br><span class="line">    <span class="keyword">this</span>.days = days;</span><br><span class="line">    <span class="keyword">this</span>.years = years;</span><br><span class="line">    <span class="keyword">this</span>.months = months;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。</p><h2 id="Volatile-Happens-Before-Guarantee"><a href="#Volatile-Happens-Before-Guarantee" class="headerlink" title="Volatile Happens-Before Guarantee"></a>Volatile Happens-Before Guarantee</h2><p><code>volatile</code>关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。</p><ul><li>如果读/写其他变量出现在写<code>volatile变量</code>之前，那么就不能重排为出现在它之后。当然返回过是允许的。</li><li>如果读/写其他变量出现在读<code>volatile变量</code>之后，那么就不能重排为出现在它之前。</li></ul><h1 id="Volatile-is-Not-Always-Enough"><a href="#Volatile-is-Not-Always-Enough" class="headerlink" title="Volatile is Not Always Enough"></a>Volatile is Not Always Enough</h1><p>很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证<code>原子性</code>的操作了，如<strong>syncronized</strong>或者比并发包下的<code>lock</code>了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个关键字用于将Java变量标记为&lt;code&gt;being stored in main memory&lt;/code&gt;，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="lock" scheme="http://github.com/sebastian/about/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>mq</title>
    <link href="http://github.com/sebastian/about/2020/07/20/mq/"/>
    <id>http://github.com/sebastian/about/2020/07/20/mq/</id>
    <published>2020-07-20T13:04:40.000Z</published>
    <updated>2020-08-16T05:24:15.951Z</updated>
    
    <content type="html"><![CDATA[<p>mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。</p><a id="more"></a><h1 id="MQ的引入"><a href="#MQ的引入" class="headerlink" title="MQ的引入"></a>MQ的引入</h1><p>模拟几个场景：</p><ol><li><p><code>学生模块</code>和<code>老师模块</code>。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。</p><p>解决方式：引入<code>班长模块</code>，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。</p></li><li><p><code>系统A</code>需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。</p><p>上线后又新增了一个需求，<code>D</code>也要接收<code>A</code>的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对<code>A</code>进行改造，开发、联调效率低，耦合严重，增加<code>A</code>的负担。</p></li></ol><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li><p>解决耦合  当新的模块接进来时，可以做到代码改动最小</p></li><li><p>异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力</p></li><li><p>削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨</p></li></ul><h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><table><thead><tr><th>比较项目</th><th>Topic模式队列</th><th>Queue模式队列</th></tr></thead><tbody><tr><td>工作模式</td><td>”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。</td><td>”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。</td></tr><tr><td>有无状态</td><td>无状态</td><td>Queue数据默认会在mq服务器上以文件形式保存</td></tr><tr><td>传递完整性</td><td>如果没有订阅者，消息会被丢弃。不完整。</td><td>消息不会丢弃</td></tr><tr><td>处理效率</td><td>由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异</td><td>由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的</td></tr></tbody></table><h1 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h1><p>Java消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。</p><p>实现JMS接口和规范的消息中间件，即我们的MQ服务器。</p><h2 id="MESSAGE"><a href="#MESSAGE" class="headerlink" title="MESSAGE"></a>MESSAGE</h2><p>JMS message的组成：消息头 + 消息体 + 消息属性</p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>记录常用的</p><ul><li><p>JMSDestination 消息发送的目的地，Queue或Topic</p></li><li><p>JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。</p></li><li><p>JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除</p></li><li><p>JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通</p></li><li><p>JMSMessgeID 唯一ID，判断是否重复消费，幂等性</p></li></ul><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>封装具体消息数据，5种格式。（使用频率高）</p><ul><li><p>TextMessage 普通字符串消息 （使用频率高）</p></li><li><p>MapMessage map类型消息，key为String类型，值为Java基本数据类型</p></li><li><p>BytesMessage 二进制数组消息</p></li><li><p>StreamMessage 流</p></li><li><p>ObjectMessage 可序列化的Java对象</p></li></ul><p>发送和接受的消息类型必须一致。</p><h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><p>如果需要除消息头字段以外的值，那么可以使用消息属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextMessage tm = session.createTextMessage(<span class="string">&quot;wa wa&quot;</span>);</span><br><span class="line">tm.setStringProperty(<span class="string">&quot;c01&quot;</span>,<span class="string">&quot;vip&quot;</span>); <span class="comment">// 增加属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextMessage tms = (TextMessage) messge;</span><br><span class="line">System.out.println(tms.getStringProperty(<span class="string">&quot;c01&quot;</span>)); <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><p>MQ挂了，消息的持久话和丢失的情况如何？一般有<strong>三个特征</strong>来保障：持久化、事务、签收，其中<strong>事务偏生产者，签收偏消费者</strong>。此外对于对于宕机，还有<strong>多节点集群</strong>。</p><h2 id="持久化-PERSISTENT"><a href="#持久化-PERSISTENT" class="headerlink" title="持久化 PERSISTENT"></a>持久化 PERSISTENT</h2><p>参考redis的持久化（有rdb和aof），消息也有类似的辅助。</p><h3 id="QUEUE"><a href="#QUEUE" class="headerlink" title="QUEUE"></a>QUEUE</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><ol><li><p>非持久 服务器宕机，消息不存在</p><blockquote><p>messaegeProducer.setDeliveryMode(DeliveryMode.<em>NON_PRESISTENT</em>);</p></blockquote></li><li><p>持久化 服务器宕机后消息依然存在</p><blockquote><p>messageProducer.setDelieveryMode(DeliveryMode.<em>PRESISTENT</em>);</p></blockquote></li></ol><h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h4><p>非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。</p><p>持久化时，上述操作后，数据依然存在。</p><p>在队列中，如果<strong>不显示标注持久</strong>，<strong>默认持久化</strong>，因为可靠性是优先考虑的因素。</p><p>持久、事物、签收</p><h3 id="TOPIC"><a href="#TOPIC" class="headerlink" title="TOPIC"></a>TOPIC</h3><p>对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：</p><ol><li><p>先运行一次消费者，等于向MQ注册</p></li><li><p>然后再运行生产者发送信息</p></li><li><p>消费者一定会收到订阅消息。不在线的话下次连接时会接收。</p></li></ol><h2 id="事务-TRANSACTION"><a href="#事务-TRANSACTION" class="headerlink" title="事务 TRANSACTION"></a>事务 TRANSACTION</h2><p>数据库的事务、ACID、隔离级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第一个参数即 事务是否开启</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul><li><p>false 关闭事务，只要执行<code>send</code>就进入到队列中</p></li><li><p>true 开启事物，先执行<code>send</code>再执行<code>commit</code>，消息才被真正提交到队列中。</p></li></ul><p>对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// ok session.commit;</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    session.rollback();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != session)&#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>创建session时将事务改为<code>true</code>，同样需要<code>commit</code>，否则事务会被重复消费。</p><h2 id="签收-ACKNOWLEDGE"><a href="#签收-ACKNOWLEDGE" class="headerlink" title="签收 ACKNOWLEDGE"></a>签收 ACKNOWLEDGE</h2><p>分为事务和非事务两种情况</p><h4 id="非事务"><a href="#非事务" class="headerlink" title="非事务"></a>非事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第个参数即 签收类型</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><ul><li><p>自动签收（默认）   <strong>AUTO_ACKNOWLEDGE</strong>  （使用频率高）</p></li><li><p>手动签收 <strong>CLIENT_ACKNOWLEDGE</strong> （使用频率高）</p></li><li><p>允许重复消息 <strong>DUPS_OK_ACKNOWLEDGE</strong></p></li></ul><p>手动签收时需要手动标记，否则会造成重复消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextMessage tm = (TextMessage)messageConsumer.receive(<span class="number">4000L</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != tm)&#123;</span><br><span class="line">    tm.acknowledge();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第个参数即 签收类型</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><p>有事务就需要<code>commit</code>。</p><h2 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h2><p>基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。类比平时的即时通讯工具。</p><ul><li><p>如果在<strong>Session</strong>关闭时有部分消息已被收到但还没有签收（<strong>acknowledge</strong>)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）</p></li><li><p>队列可以长久地保存消息直到消费者收到消息。<strong>消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态</strong>，充分体现了异步传输模式的优势。</p></li></ul><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>JMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作<strong>topic</strong>，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。</p><h3 id="非持久"><a href="#非持久" class="headerlink" title="非持久"></a>非持久</h3><p>对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。</p><h1 id="BROKER"><a href="#BROKER" class="headerlink" title="BROKER"></a>BROKER</h1><p>集群、配置时会用到。</p><p>相当于一个ActiveMQ服务器<strong>实例</strong>，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。</p><p>之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.</p><h2 id="消息发送模式"><a href="#消息发送模式" class="headerlink" title="消息发送模式"></a>消息发送模式</h2><p>ActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。</p><p><code>ActiveMQ默认使用异步发送的模式</code>，<strong>同步发送有两种情况</strong>：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。</p><p>异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，<code>允许在失败的情况下有少量的数据丢失</code>。</p><h1 id="ACTIVEMQ的传输协议"><a href="#ACTIVEMQ的传输协议" class="headerlink" title="ACTIVEMQ的传输协议"></a>ACTIVEMQ的传输协议</h1><p>Q: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？</p><p>调优：使用NIO传输协议</p><p>支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）</p><table><thead><tr><th>协议</th><th>描述</th></tr></thead><tbody><tr><td>TCP</td><td>默认的协议，性能相对可以</td></tr><tr><td>NIO</td><td>基于TCP协议之上的，进行了扩展和优化</td></tr><tr><td>HTP(s)</td><td>基于HTTP(s)</td></tr></tbody></table><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>要换为NIO，需要修改<code>activemq.xml</code>配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;nio&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;nio://192.168.111.136&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在消费者、生产者修改代码，指定传输协议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> stati <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;nio://192.168.111.136&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ActiveMQConnectionFactory af = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h3><p>Q: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持<code>openwire（TCP）</code>，如何让这个端口支持NIO，又支持多个协议呢？</p><p>默认是<code>BIO+TCP</code>，目前是<code>NIO+TCP</code>，那么如何做到<code>NIO+TCP/Mqtt/stomp</code>。</p><p>A: 开启多协议支持，用<code>auto</code>关键字，<a href="https://activemq.apache.org/auto">reference</a>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;auto://localhost:5761&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>note:</strong> 在activeMQ后台配置面板的<code>Network</code>可以查看开启的网络协议。</p><h1 id="ACTIVEMQ的存储和可持久化"><a href="#ACTIVEMQ的存储和可持久化" class="headerlink" title="ACTIVEMQ的存储和可持久化"></a>ACTIVEMQ的存储和可持久化</h1><p>对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会<code>采用持久化机制</code>（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p><p>主要介绍两个DB：<code>KahaDB</code>, <code>LevelDB</code>, <code>JDBC</code></p><p>Q: AMQ持久化机制</p><h2 id="KahaDB"><a href="#KahaDB" class="headerlink" title="KahaDB"></a>KahaDB</h2><p>基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。</p><p>在配置文件中，有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdpter</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>reference <a href="https://activemq.apache.org/kahadb">here</a></p><p>可用于任何场合，提高了性能和恢复能力。消息存储使用一个<strong>事务日志</strong>和一个<strong>索引文件</strong>（存储所有地址）。</p><p>Kahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）</p><h4 id="db-lt-Number-gt-log"><a href="#db-lt-Number-gt-log" class="headerlink" title="db&lt;Number&gt;.log"></a>db&lt;Number&gt;.log</h4><p>存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。</p><h4 id="db-data"><a href="#db-data" class="headerlink" title="db.data"></a>db.data</h4><p>包含了持久化的<code>BTree索引</code>，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向<code>db-\&lt;Number&gt;.log</code>里面存储的消息。</p><h4 id="db-free"><a href="#db-free" class="headerlink" title="db.free"></a>db.free</h4><p>当前<code>db.data</code>文件里哪些页面是空闲的，文件具体内容是所有空闲页的<strong>ID</strong>. 类比linux的bash命令<code>free</code>。</p><h4 id="db-redo"><a href="#db-redo" class="headerlink" title="db.redo"></a>db.redo</h4><p>用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。</p><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。</p><h2 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h2><h2 id="JDBC-Message-store-with-ActiveMQ-Journal"><a href="#JDBC-Message-store-with-ActiveMQ-Journal" class="headerlink" title="JDBC Message store with ActiveMQ Journal"></a>JDBC Message store with ActiveMQ Journal</h2><p>主要。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li><p>引入消息队列后该如何保证其高可用性</p></li><li><p>异步投递Async Sends</p></li><li><p>延迟投递和定时投递</p></li><li><p>分发策略</p></li><li><p>ActiveMQ消费重试机制</p></li><li><p>死信队列</p></li><li><p>如何保证消息不被重复消费呢？谈谈幂等性问题</p></li></ol><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>zookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。</p><h2 id="异步投递"><a href="#异步投递" class="headerlink" title="异步投递"></a>异步投递</h2><p>如何确认发送成功？ </p><p>在消息发送完后接收回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ActiveMQConnectionFacotry acf = <span class="keyword">new</span> ActiveMQConnectionFactory(URL);</span><br><span class="line"><span class="comment">// 设置为异步发送消息</span></span><br><span class="line">acf.setUseAsyncSend(<span class="keyword">true</span>);</span><br><span class="line">ActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class="line">...</span><br><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line"><span class="comment">// 未message设置属性</span></span><br><span class="line">message.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用带有回调的send方法来发送</span></span><br><span class="line">amp.send(message, <span class="keyword">new</span> AsyncCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSucces</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(message.getJMSmessageID+<span class="string">&quot; succeed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException exception)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 拿到属性来确认发送失败的消息</span></span><br><span class="line">        System.out.println(message.getJMSmessageID+<span class="string">&quot; fail&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="延迟投递和定时投递"><a href="#延迟投递和定时投递" class="headerlink" title="延迟投递和定时投递"></a>延迟投递和定时投递</h2><p>参考<a href="http://activemq.apache.org/delay-and-schedule-message-delivery.html">官网说明</a></p><table><thead><tr><th>Property name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>AMQ_SCHEDULED_DELAY</td><td>long</td><td>延迟投递的时间</td></tr><tr><td>AMQ_SCHEDULED_PERIOD</td><td>long</td><td>重复投递的时间间隔</td></tr><tr><td>AMQ_SCHEDULED_REPEAT</td><td>int</td><td>重复投递次数</td></tr><tr><td>AMQ_SCHEDULED_CRON</td><td>String</td><td>Cron表达式</td></tr></tbody></table><p>在<code>activemq.xml</code>中配置<em>schedulerSupport</em>属性为<em>true</em>且Java代码中封装的辅助消息类型为<em>ScheduledMessage</em>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = <span class="number">3</span> * <span class="number">1000</span>; <span class="comment">//延迟投递的时间，每3秒</span></span><br><span class="line"><span class="keyword">long</span> period = <span class="number">4</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> repeat = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);</span><br><span class="line">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);</span><br><span class="line"></span><br><span class="line">messageProducer.send(mesage);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="ActiveMQ消费重试机制"><a href="#ActiveMQ消费重试机制" class="headerlink" title="ActiveMQ消费重试机制"></a>ActiveMQ消费重试机制</h2><ul><li><p>哪些情况会引起消息重发？</p></li><li><p>消息重发时间间隔和重发次数</p></li><li><p>有毒消息Posion ACK</p></li></ul><p>reference <a href="activemq.apache.org/redelivery-policy">here</a></p><p>重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。</p><h2 id="如何保证消息不被重复消费（幂等性）"><a href="#如何保证消息不被重复消费（幂等性）" class="headerlink" title="如何保证消息不被重复消费（幂等性）"></a>如何保证消息不被重复消费（幂等性）</h2><p><strong>note</strong>: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。</p><ul><li><p>如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突</p></li><li><p>使用第三方服务来做消费记录。以redis为例，给消息分配一个<strong>全局id</strong>，只要消费过该消息，将&lt;id, message&gt;以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。&lt;/p&gt;</summary>
    
    
    
    <category term="MiddleWare" scheme="http://github.com/sebastian/about/categories/MiddleWare/"/>
    
    
    <category term="activemq" scheme="http://github.com/sebastian/about/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>decorating</title>
    <link href="http://github.com/sebastian/about/2020/06/12/decorating/"/>
    <id>http://github.com/sebastian/about/2020/06/12/decorating/</id>
    <published>2020-06-12T10:30:28.000Z</published>
    <updated>2020-08-31T15:55:19.226Z</updated>
    
    <content type="html"><![CDATA[<p>继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。</p><a id="more"></a><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是<code>Beverage</code>抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso… 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。</p><p>如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？</p><blockquote><p>类应该堆扩展开放，对修改关闭。</p></blockquote><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。</p><ol><li>DarkRoast对象</li><li>用摩卡装饰</li><li>用奶泡装饰</li><li>调用cost方法，依赖delegate添加价钱</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png" alt="Screenshot from 2020-06-12 20-50-33.png"></p><p>其中<code>Condiment</code>是调料类，重写了<code>Beverage</code>的<code>getDescription</code>方法。以Whip为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> .<span class="number">30</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的_cost_方法入获取description的方法如出一辙，这样的好处在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage1 = <span class="keyword">new</span> DarRoast();</span><br><span class="line">beverage1 = <span class="keyword">new</span> Mocha(beverage1);</span><br><span class="line">beverage1 = <span class="keyword">new</span> Mocha(beverage1);</span><br><span class="line">beverage1 = <span class="keyword">new</span> Whip(beverage1);</span><br><span class="line">System.out.println(beverage1.getDescription() + <span class="string">&quot; $&quot;</span> + beverage1.cost());</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75</span><br></pre></td></tr></table></figure><p>制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为<strong>委托</strong>.</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><p>大量的<code>Decorator Pattern</code>在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">para1&#x3D;&gt;parallel: FileInputStream</span><br><span class="line">para2&#x3D;&gt;parallel: BufferedInputStream</span><br><span class="line">para3&#x3D;&gt;parallel: LineNumberInputStream</span><br><span class="line">op1&#x3D;&gt;operation: Beferage</span><br><span class="line">op2&#x3D;&gt;operation: Espresso</span><br><span class="line">op3&#x3D;&gt;operation: Mocha</span><br><span class="line">para1(path1, bottom)-&gt;para2</span><br><span class="line">para2(path1,bottom)-&gt;para3</span><br><span class="line">para1(path2, right)-&gt;op1</span><br><span class="line">para2(path2, right)-&gt;op2</span><br><span class="line">para3(path2, right)-&gt;op3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。&lt;/p&gt;</summary>
    
    
    
    <category term="DesignPatterns" scheme="http://github.com/sebastian/about/categories/DesignPatterns/"/>
    
    
    <category term="design_patterns" scheme="http://github.com/sebastian/about/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>observer</title>
    <link href="http://github.com/sebastian/about/2020/06/12/observer/"/>
    <id>http://github.com/sebastian/about/2020/06/12/observer/</id>
    <published>2020-06-12T09:12:38.000Z</published>
    <updated>2020-08-31T15:55:34.030Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？</p><a id="more"></a><p>一个好的设计模式能拯救一堆代码。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">WeatherData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getTemperature()&#123;&#125;;</span><br><span class="line">    getHumidity()&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一旦气象更新，此方法会被调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    measuremetnsChanged()&#123;</span><br><span class="line">        <span class="comment">// our codes go here</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接在<code>measuremetnsChanged</code>这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measuremetnsChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class="line">    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>先看看我们平时是怎么浏览微信订阅号消息：</p><p>首先整个流程应该有两个参与者</p><ul><li>订阅号运营者</li><li>订阅者</li></ul><p>订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。</p><p>那么观察者模式也类似：</p><blockquote><p>订阅号运营者+订阅者=观察者模式</p></blockquote><p>不一样的是名称，订阅号运营者改为“subject”（主题），订阅者改为”observer”（观察者）。</p><p>由于一个主题可以被多个观察者订阅，所以，它实现了对象之间<strong>一对多</strong>；同时，这种对象设计也让主题和观察者之间<strong>松耦合</strong>.</p><p>对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png" alt="Screenshot from 2020-06-12 18-03-04.png"></p><p>我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">    weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。</p><p>完整代码参考：<a href="https://github.com/Sebastian-Getts/designPatternsPractice">项目传送门</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？&lt;/p&gt;</summary>
    
    
    
    <category term="DesignPatterns" scheme="http://github.com/sebastian/about/categories/DesignPatterns/"/>
    
    
    <category term="design_patterns" scheme="http://github.com/sebastian/about/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://github.com/sebastian/about/2020/06/09/redis/"/>
    <id>http://github.com/sebastian/about/2020/06/09/redis/</id>
    <published>2020-06-09T13:54:01.000Z</published>
    <updated>2020-08-06T12:11:06.098Z</updated>
    
    <content type="html"><![CDATA[<p>常用redis，深入了解redis的性能和瓶颈。<a href="https://github.com/antirez/redis">reference</a></p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>redis: <strong>内存</strong>中的数据结构存储系统，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>，nosql的一种。</p><h2 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h2><p>关系型数据库不够用，出来了nosql。。。</p><ol><li>一开始单体应用，小用户量能承受。但是当体量变大时：<ul><li>数据量大</li><li>数据的索引大</li><li>访问量大</li></ul></li><li>读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层<strong>memcache</strong>缓存</li><li>集群（水平拆分）：上面的读写分离copy多份。</li></ol><p>mysql早些年使用的是MyISAM引擎，特性是<strong>表锁</strong>（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了<strong>行锁</strong>。</p><p>不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。</li><li>大数据量也高性能（写8万次/秒，读11万次/秒）</li><li>多样型，不需要事先设计数据库</li><li>没有固定的查询语言；最终一致性</li><li>键值对存储，列存储，文档存储，图形存储库（社交）</li><li>高性能、高可用、高可扩</li><li>CAP、BASE，异地多活</li><li>多样、实时、并发（Volume, Variety, Veiocity）</li></ol><p>与关系型一起使用。</p><p>商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）</p><p>商品的基本信息（价格、商家、名称）：MySQL</p><p>图片：FastDFS, GFS, HDFS, OSS…</p><p>商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）</p><p>==没有什么不是加以层解决不了的==： 统一服务层。</p><h3 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h3><p>MongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。</p><h3 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对"></a>KV键值对</h3><p>Redis，Tair</p><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h3><p>HBase（大数据）</p><p>分布式文件系统</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>类似知识图谱，不是存储图形。主要用于存储社交网络。</p><p>Neo4j，InfoGrid。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Remote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。</p><ul><li>内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）</li><li>计时器、计数器（浏览量）</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>安装后自带的测试工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h localhost -p 6379 -100 -n 100000</span><br></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>默认16个数据库且使用的是第0个。 </p><h3 id="GEOSPATIAL"><a href="#GEOSPATIAL" class="headerlink" title="GEOSPATIAL"></a>GEOSPATIAL</h3><p>地理位置，不仅仅是GET、SET！根据经纬度获取距离。</p><h2 id="springboot集成"><a href="#springboot集成" class="headerlink" title="springboot集成"></a>springboot集成</h2><p>版本&lt;2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。</p><p>版本&gt;2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p><h2 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h2><p>为什么会有这个rdb？</p><p>redis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: start</span><br><span class="line">end&#x3D;&gt;end: end</span><br><span class="line">condition&#x3D;&gt;condition: 触发rdb</span><br><span class="line">rdbfile&#x3D;&gt;inputoutput: dump.rdb</span><br><span class="line">operation&#x3D;&gt;operation: go on dealing with</span><br><span class="line"></span><br><span class="line">start-&gt;condition</span><br><span class="line">condition(yes)-&gt;rdbfile-&gt;end</span><br><span class="line">condition(no)-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><ol><li>save的规则</li><li>执行flushall</li><li>退出redis</li></ol><p>产生备份，会自动生成一个dump.rdb</p><h4 id="用rdb恢复"><a href="#用rdb恢复" class="headerlink" title="用rdb恢复"></a>用rdb恢复</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get dir</span><br></pre></td></tr></table></figure><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>适合大数据</li><li>对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>需要一定的时间间隔进程操作</li><li>fork进程的时候会占用一定的内容空间</li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Append Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。</p><ul><li>大数据的情况下效率会比较低。</li><li>默认是不开启的。</li></ul><p>开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。</p><p>修复aof文件 <code>redis-check-aof --fix</code></p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ol><li>每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据</li><li>从不同步效率最高</li></ol><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>相对于数据文件，aof远大于rdb，修复的速度比rdb慢</li><li>默认是rdb，效率自然高于aof。</li></ol><p><strong>与rdb混合使用</strong></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。</p><p>作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石</p><p>reids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。</p><p>默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication # 查看当前库的信息</span><br></pre></td></tr></table></figure><p>一般情况下只用配置从机即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF ip:port # ip:port为主机</span><br></pre></td></tr></table></figure><p>上面的是命令配置，只是暂时的。<strong>实际生产应该修改配置文件</strong>，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。</p><h4 id="如果主机宕机了呢？"><a href="#如果主机宕机了呢？" class="headerlink" title="如果主机宕机了呢？"></a>如果主机宕机了呢？</h4><p>默认情况下，主机挂了以后，用<code>info replication</code>查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。</p><p>更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。</p><ul><li>全量复制 master将整个数据传送到slaver</li><li>增量复制</li></ul><p>只要重新链接master，一次全量复制将被自动执行</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>Sentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p><p>哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>集群</li><li>主从切换</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>不方便在线扩容，一旦到达上线。</li><li>配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。</li></ol><h2 id="redis异常处理"><a href="#redis异常处理" class="headerlink" title="redis异常处理"></a>redis异常处理</h2><h3 id="缓存穿透（一直查询不到）"><a href="#缓存穿透（一直查询不到）" class="headerlink" title="缓存穿透（一直查询不到）"></a>缓存穿透（一直查询不到）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: request</span><br><span class="line">end&#x3D;&gt;end: response</span><br><span class="line">condition&#x3D;&gt;condition: redis缓存中是否存在</span><br><span class="line">op1&#x3D;&gt;operation: select in mysql</span><br><span class="line">start-&gt;condition</span><br><span class="line">condition(yes)-&gt;end</span><br><span class="line">condition(no)-&gt;op1-&gt;end</span><br></pre></td></tr></table></figure><p>如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><p>活力集中在一个点（一个热评的点，如微博）。</p><h4 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h4><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h4><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。</p><h4 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h4><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><p>正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用redis，深入了解redis的性能和瓶颈。&lt;a href=&quot;https://github.com/antirez/redis&quot;&gt;reference&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="DB" scheme="http://github.com/sebastian/about/categories/DB/"/>
    
    
    <category term="redis" scheme="http://github.com/sebastian/about/tags/redis/"/>
    
    <category term="nosql" scheme="http://github.com/sebastian/about/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>heap</title>
    <link href="http://github.com/sebastian/about/2020/06/06/heap/"/>
    <id>http://github.com/sebastian/about/2020/06/06/heap/</id>
    <published>2020-06-06T14:54:27.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>这里的堆是数据结构中的堆，不是JVM中的堆。</p><p>关键词：堆，二叉树，优先级队列，排序，topN</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。    </p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul><li>路径长度是指路径上的边数</li><li>结点深度是指从根结点到该结点的路径的长度</li><li>每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置</li></ul><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><ul><li>完全二叉树</li><li>每个结点大于或等于它的任意一个孩子</li></ul><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>可以将二叉堆用数组来存储。</p><p>例如如下一个二叉堆：</p><p><img src="https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png" alt="Screenshot from 2020-06-06 15-24-34.png"></p><p>在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}</p><p>可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题</p><h2 id="TOP-N"><a href="#TOP-N" class="headerlink" title="TOP N"></a>TOP N</h2><p>给一组数据，求其中最大/小的几个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最小的n个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topN(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// default big heap, lambda make it small heap</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n, ((o1, o2) -&gt; Integer.compare(o2, o1)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : array) &#123;</span><br><span class="line">        <span class="comment">// put the integer in when it smaller than the top of integer</span></span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; n || e &lt; heap.peek()) &#123;</span><br><span class="line">            heap.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; n) &#123;</span><br><span class="line">            <span class="comment">// delete the top of heap integer</span></span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">        res[j++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。</p><p>稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认大顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e: array)&#123;</span><br><span class="line">    <span class="comment">// 大于堆顶的放入优先级队列</span></span><br><span class="line">    <span class="keyword">if</span>(heap.isEmpty() || heap.size() &lt; n || e &gt; heap.peak())&#123;</span><br><span class="line">        heap.offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过要求的个数，清除堆顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(heap.size() &gt; n)&#123;</span><br><span class="line">        heap.pool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里的堆是数据结构中的堆，不是JVM中的堆。&lt;/p&gt;
&lt;p&gt;关键词：堆，二叉树，优先级队列，排序，topN&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="datastructure" scheme="http://github.com/sebastian/about/tags/datastructure/"/>
    
  </entry>
  
  <entry>
    <title>bitwise</title>
    <link href="http://github.com/sebastian/about/2020/06/01/bitwise/"/>
    <id>http://github.com/sebastian/about/2020/06/01/bitwise/</id>
    <published>2020-06-01T13:11:25.000Z</published>
    <updated>2020-08-08T15:57:25.149Z</updated>
    
    <content type="html"><![CDATA[<p>Introduction of Java bitwise and operation.</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><table><thead><tr><th>操作符</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>1 &amp; 1 = 1 (only)</td></tr><tr><td>|</td><td>或</td><td>0 | 0 = 0 (only)</td></tr><tr><td>^</td><td>异或</td><td>1 ^ 0 = 1</td></tr><tr><td>~</td><td>非</td><td>~ 1 = 0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>右边空出来的补0</td></tr><tr><td>&gt;&gt;</td><td>带符号位右移</td><td>最高位补符号位</td></tr><tr><td>&gt;&gt;&gt;</td><td>无符号位右移</td><td>左边空出来的补0</td></tr></tbody></table><p>位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，&lt;&lt;=以及&gt;&gt;&gt;=。</p><p>位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 11111111111111111111111111111111111(32个1)</span></span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">System.out.printlnl(a&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1111111111111111111111111111111111(32个1)</span></span><br><span class="line">System.out.println(Integer.toBinaryString(a&gt;&gt;<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(a&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 0111111111111111111111111111111111(31个1)</span></span><br><span class="line">System.out.prinlnt(Integer.toBinaryString(a&gt;&gt;&gt;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="a-gt-gt-1"><a href="#a-gt-gt-1" class="headerlink" title="a&gt;&gt;1"></a>a&gt;&gt;1</h4><p>原码：10000000000000000000000000000001</p><p>反码：1111111111111111111111111111111111110</p><p>补码：1111111111111111111111111111111111111</p><p>补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）</p><p>取反：10000000000000000000000000000000</p><p>原码：10000000000000000000000000000001 即 -1.</p><h4 id="a-gt-gt-gt-1"><a href="#a-gt-gt-gt-1" class="headerlink" title="a&gt;&gt;&gt;1"></a>a&gt;&gt;&gt;1</h4><p>同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。</p><p>补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）</p><p>正数原码即补码。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的<code>^</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;&lt;</code>等位运算符。</p><h2 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &amp; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">8</span> &amp; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">7</span> &amp; <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>1的原码：0001</p><p>8的原码：1000</p><p>7的原码：0111</p><p>奇数的最低位永远是1,偶数的为0.</p><h2 id="求非重复数字"><a href="#求非重复数字" class="headerlink" title="求非重复数字"></a>求非重复数字</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ^ 2 ^ 1 = 1</span><br><span class="line">4 ^ 2 ^ 1 ^ 1 ^ 2 = 4</span><br></pre></td></tr></table></figure><p>两个<strong>相同的数字</strong>做<code>^</code>运算时，值为<code>0</code>，再结合<strong>交换律</strong>，可以用来找出一组数字中“落单”的数字。</p><h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><p>……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Introduction of Java bitwise and operation.&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="bitwise" scheme="http://github.com/sebastian/about/tags/bitwise/"/>
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://github.com/sebastian/about/2020/05/24/jvm/"/>
    <id>http://github.com/sebastian/about/2020/05/24/jvm/</id>
    <published>2020-05-24T09:39:25.000Z</published>
    <updated>2020-08-06T11:35:52.358Z</updated>
    
    <content type="html"><![CDATA[<p>associate with juc</p><a id="more"></a><h1 id="系统图"><a href="#系统图" class="headerlink" title="系统图"></a>系统图</h1><p><img src="https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png" alt="Screenshot from 2020-06-04 20-11-48.png"></p><ul><li>灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收</li><li>亮色代表存在垃圾回收</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。</p><blockquote><p>Car.class -&gt; Class Loader -&gt; Car Class -&gt; car1/car2/car3</p></blockquote><p>Car Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。</p><p><img src="https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png" alt="Screenshot from 2020-06-04 20-33-54.png"></p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h3 id="启动类加载器（Bootstrap）"><a href="#启动类加载器（Bootstrap）" class="headerlink" title="启动类加载器（Bootstrap）"></a>启动类加载器（Bootstrap）</h3><p>由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。</p><h3 id="扩展类加载器（Extension）"><a href="#扩展类加载器（Extension）" class="headerlink" title="扩展类加载器（Extension）"></a>扩展类加载器（Extension）</h3><p>Java编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。</p><h3 id="应用程序类加载器（AppClassLoader）"><a href="#应用程序类加载器（AppClassLoader）" class="headerlink" title="应用程序类加载器（AppClassLoader）"></a>应用程序类加载器（AppClassLoader）</h3><p>我们编写程序时定义的类所用的加载器</p><h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><p>定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。</p><h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><p>比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。</p><p><strong>Bootstrap</strong> –&gt; <strong>Extension</strong> –&gt; <strong>Application</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。</p></blockquote><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p><strong>note</strong>: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。</p><h2 id="本地方法接口（Native-Interface）"><a href="#本地方法接口（Native-Interface）" class="headerlink" title="本地方法接口（Native Interface）"></a>本地方法接口（Native Interface）</h2><p>融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。</p><p>异构领域间通信发达，Socket通信或webService。</p><h3 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h3><p>只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。</p><h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><p>实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。</p><p>是当前线程所执行的字节码的行号指示器。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul><li>不存在垃圾回收问题</li><li>==线程私有==（想想加锁，不就在方法上/中加的么）</li></ul><p>也叫栈内存，<strong>主管Java程序的运行</strong>，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>在java中的方法装载在虚拟机的栈中叫栈帧。</p><ul><li><p>Local Variables: 输入参数、输出参数以及方法内的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参为 x, y， 输出为result，方法内变量为result，均在栈中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result = x + y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Operand Stack: 记录出栈、入栈的操作</p></li><li><p>Frame Data: 包括类文件、方法等等</p></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。</p><p>栈管运行，堆管存储。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>class文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是<code>永久代(PermGen space)</code>和<code>元空间(Metaspace)</code>。</p><ul><li>所有==线程共享==</li><li>存在垃圾回收</li></ul><p>存储每个类的<strong>结构信息</strong>（模板）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> price = <span class="number">1233435</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">park</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;stop ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。</p><p>元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是<strong>本机物理内存</strong>。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p><p>实例变量存在堆内存中，与方法区无关。i.e.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        demo.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。</p><h1 id="方法区、栈、堆"><a href="#方法区、栈、堆" class="headerlink" title="方法区、栈、堆"></a>方法区、栈、堆</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person person2 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。</p><p>要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。</p><p>hotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈–&gt;堆–&gt;方法区</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>（Java7之前）    一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p><p>(Java8)    永久区换成了元空间。</p><p>物理上为新生区+养老区。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>逻辑上分为三部分：新生+养老+永久</p><p>新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)</p><p>养老区：Tenure Generation Space</p><p>永久存储区：Permanent Space</p><ul><li>Eden: 0space: 1space  = 8 : 1 : 1</li><li>Young : Old = 1 : 2</li></ul><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。</p><h2 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h2><p>Survivor 0 space: from区</p><p>Surrivor 1 space: to区</p><p>他们的位置不固定，每次GC之后位置会交换，空的为to区。</p><ol><li>Eden, SurvivorFrom copy to SurviviorTo</li><li>clean up Eden, SurvivorFrom</li><li>Swap SurvivorTo and SurvivorFrom</li></ol><h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。</p><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Returns the maximum amount of memory that the Java virtual machine will attempt to use.</span></span><br><span class="line">    <span class="keyword">long</span> l = Runtime.getRuntime().maxMemory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the total amount of memory in the Java virtual machine.</span></span><br><span class="line">    <span class="keyword">long</span> l1 = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1/4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;(-xmx) MAX_MEMORY: &quot;</span> + l + <span class="string">&quot;bytes, &quot;</span> + (l / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1/64</span></span><br><span class="line">    System.out.println(<span class="string">&quot;(-xms) TOTAL_MEMORY: &quot;</span> + l1 + <span class="string">&quot;bytes, &quot;</span> + (l1 / (<span class="keyword">double</span>) <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>note:</strong> 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。</p><blockquote><p>-XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）</p></blockquote><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><ul><li>minor GC</li><li>major/full GC</li></ul><p>major GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>分代收集，根据各个代来使用</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。</p><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>Minor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。</p><p>因为存活率都很低，复制也没啥。</p><h3 id="标记清除法（Mark-Sweep）"><a href="#标记清除法（Mark-Sweep）" class="headerlink" title="标记清除法（Mark-Sweep）"></a>标记清除法（Mark-Sweep）</h3><p>Major GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。</p><h3 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark-Compact）"></a>标记压缩（Mark-Compact）</h3><p>Mark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。</p><p>也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>Java的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（<strong>包括实例字段、静态字段以及构成数组对象的元素</strong>）的访问方式。</p><p>在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，<code>工作内存</code>是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作</p><p>内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p><h2 id="violatile"><a href="#violatile" class="headerlink" title="violatile"></a>violatile</h2><p>java虚拟机提供的轻量级的同步机制，乞丐版syncronized。</p><ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A:"></a>Q&amp;A:</h1><h2 id="请谈谈你对JVM的理解？java8虚拟机有哪些更新？"><a href="#请谈谈你对JVM的理解？java8虚拟机有哪些更新？" class="headerlink" title="请谈谈你对JVM的理解？java8虚拟机有哪些更新？"></a>请谈谈你对JVM的理解？java8虚拟机有哪些更新？</h2><h2 id="什么是OOM？是么是StackOverFlowError？有哪些方法分析？"><a href="#什么是OOM？是么是StackOverFlowError？有哪些方法分析？" class="headerlink" title="什么是OOM？是么是StackOverFlowError？有哪些方法分析？"></a>什么是OOM？是么是StackOverFlowError？有哪些方法分析？</h2><h2 id="JVM的常用参数调优你知道哪些？"><a href="#JVM的常用参数调优你知道哪些？" class="headerlink" title="JVM的常用参数调优你知道哪些？"></a>JVM的常用参数调优你知道哪些？</h2><h2 id="谈谈JVM中，对类加载器你的认识？"><a href="#谈谈JVM中，对类加载器你的认识？" class="headerlink" title="谈谈JVM中，对类加载器你的认识？"></a>谈谈JVM中，对类加载器你的认识？</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;associate with juc&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="http://github.com/sebastian/about/categories/JVM/"/>
    
    
    <category term="jvm" scheme="http://github.com/sebastian/about/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>springAOP</title>
    <link href="http://github.com/sebastian/about/2020/03/28/springAOP/"/>
    <id>http://github.com/sebastian/about/2020/03/28/springAOP/</id>
    <published>2020-03-28T06:43:58.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>AOP, 切面。聊聊几个通知。</p><a id="more"></a><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>如果是吃个蛋糕，会怎么吃？有的人会一层一层吃，当然最上面是奶油或者水果，最下方是面包，但是大部分人都不会这么吃，会用刀将蛋糕切开，将糅合了多层的可口蛋糕一起送入口中，而非第一种吃法那样有先后顺序。Spring框架中的AOP的用途就好比那把刀，将容器中的bean有个安排。</p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p>AOP中的刀不像是切蛋糕那样最终把蛋糕送入口中，它的实际工序会更多。比如送入口中可能是最后一步，在这之前也许会统一撒点肉松、统一加热之类的。虽然有点奇怪。</p><p>Spring的命名是让人通俗易懂的，也可以理解为你的英语水平够用。诸如*@Before*, <em>@After</em>…之类的一眼扫过去就能知道它的作用。目前用到的有5个：l@Before, @After, @AfterReturning, @AfterThrowing和@Around。他们都不是直接标注就可以使用，而是<strong>需要指要作用的方法</strong>。</p><p>由于作用的目标方法大多相同，因此还可以提取公共的路径。</p><p>与之相关的要先介绍<code>JointPoint</code>，根据词意不难理解：切点。切面中的切点可以说是很细节的了，能用他来获取切面相关的信息，可以理解为“帮手”。</p><h2 id="PointCut"><a href="#PointCut" class="headerlink" title="@PointCut"></a>@PointCut</h2><p>公用切入点。括号后加入作用路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public int org.example.aop.MathCalculate.*(..)) &quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MathCalculate为类名，<code>MathCalculate.*</code>表示作用于类下的所有方法。<code>(..)</code>表示任意参数。</p><h2 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h2><p>这个是前置通知。表示在方法执行前执行标识了这个注解的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;，logStart()..方法名：&quot;</span> + <span class="string">&quot;....参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="After"><a href="#After" class="headerlink" title="@After"></a>@After</h2><p>后置通知。方法结束后会被调用，<strong>无论方法成功还是失败</strong>，类似于<code>finally</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;，@After.方法名：&quot;</span> + <span class="string">&quot;. 一定会返回的。.参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a>@AfterReturning</h2><p>返回通知。在方法正常结束时用。因为是正常结束，一般都需要知道返回的结果，所以入参相比之前的就多了一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;object&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint, Object object)</span> </span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot;，@AfterReturning..正常返回。.运行结果：&quot;</span> + object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="@AfterThrowing"></a>@AfterThrowing</h2><p>异常通知。抛出异常的时候用。抛出的异常也是对象，需要告诉Spring，所以这也算一个入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot; 方法名：&quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot;.....异常信息：&quot;</span> + exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h2><p>环绕通知。听这个名字有没有觉得很仙气，很厉害的样子。的确厉害，一个顶四个。。</p><p>他的“帮手”也不再是JointPoint了，而是升级版的：<code>ProceedingJoinPoint</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(value = &quot;pointCut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">logAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;，Around ..方法名：&quot;</span> + <span class="string">&quot;....参数：&quot;</span> + Arrays.asList(proceedingJoinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line">        System.out.println(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;，Around..正常返回。.运行结果：&quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法名：&quot;</span> + proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;....Around  .异常信息：&quot;</span> + throwable);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;，Around.方法名：&quot;</span> + <span class="string">&quot;. 一定会返回的。.参数：&quot;</span> + Arrays.asList(proceedingJoinPoint.getArgs()));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果认为标注注解就能生效就  <em>too young to navie</em> 了。</p><ul><li>将业务逻辑代码以及切面类（例如日志打印服务）都加入到容器中，并且告诉Spring哪个是切面类（在类上加**@Aspect**）</li><li>在切面类上的要用的通知方法上加入相应注解（如@Before）。</li><li>在配置类上开启注解的aop模式（ <strong>@EnableAspectJAutoProxy</strong>）。</li></ul><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;AOP, 切面。聊聊几个通知。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://github.com/sebastian/about/categories/Spring/"/>
    
    
    <category term="aop" scheme="http://github.com/sebastian/about/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>https</title>
    <link href="http://github.com/sebastian/about/2020/03/14/https/"/>
    <id>http://github.com/sebastian/about/2020/03/14/https/</id>
    <published>2020-03-14T02:43:29.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Hypertext Transfer Protocol Secure</strong>, an extension of the Hypertext Transfer Protocol. </p><p>How to encrypt communication? Through referred to as <strong>HTTP over TLS</strong>, or <strong>HTTP over SSL</strong></p><ul><li>Transport Layer Security</li><li>Secure Sockets Layer</li></ul><a id="more"></a><h1 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h1><h2 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h2><p>HTTPS的URL地址开头是<code>https://</code>，默认使用的的端口是<code>443</code>，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。</p><hr><p>HTTP的URL地址开头是<code>http://</code>，默认使用的端口是<code>80</code>，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。</p><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h2><p>SSL/TSL没有禁止网络搜索器（website crawler）搜索它的索引，所以在这种情况下，请求和响应的报文的大小是会被知晓的（内容仍然加密无法破解）。</p><h1 id="URI、URL与URN"><a href="#URI、URL与URN" class="headerlink" title="URI、URL与URN"></a>URI、URL与URN</h1><p>url是uri的子集。</p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>统一资源标识符。<em>A string of characters that unambiguously identifies a particular resource</em>.  它规定了一些特定的语法规则，并且在规则下还可以自有扩展，例如<code>http://</code>。</p><h2 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h2><p>统一资源名称。<em>A Uniform Resource Name(URN) is a URI that identifies a resource by name in a particular namespace.</em> 它能标识一个唯一的名称，但不清楚它的位置。</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>统一资源定位符。<em>A Uniform Resource Locator(URL) is a URI that specifies the means of acting upon or obtaining the representation of a resource.</em> 就是我们常见的http请求地址。</p><p><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">reference</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Hypertext Transfer Protocol Secure&lt;/strong&gt;, an extension of the Hypertext Transfer Protocol. &lt;/p&gt;
&lt;p&gt;How to encrypt communication? Through referred to as &lt;strong&gt;HTTP over TLS&lt;/strong&gt;, or &lt;strong&gt;HTTP over SSL&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transport Layer Security&lt;/li&gt;
&lt;li&gt;Secure Sockets Layer&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Network" scheme="http://github.com/sebastian/about/categories/Network/"/>
    
    
    <category term="http" scheme="http://github.com/sebastian/about/tags/http/"/>
    
    <category term="https" scheme="http://github.com/sebastian/about/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>uml</title>
    <link href="http://github.com/sebastian/about/2020/01/12/uml/"/>
    <id>http://github.com/sebastian/about/2020/01/12/uml/</id>
    <published>2020-01-12T15:14:16.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>The <strong>Unified Modeling Language(UML)</strong> is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>主要说说UML中的关系(Class Relationships)</p><p><a href="https://www.visual-paradigm.com/cn/guide/">reference1</a>, <a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">reference2</a></p><h2 id="Class-Relationships"><a href="#Class-Relationships" class="headerlink" title="Class Relationships"></a>Class Relationships</h2><p>A class may be involved in one or more relationships with other classes.</p><h2 id="Inheritance-or-Generalization"><a href="#Inheritance-or-Generalization" class="headerlink" title="Inheritance(or Generalization)"></a>Inheritance(or Generalization)</h2><ul><li>Represents an “is-a” relationship</li><li>An abstract class name is shown <em>in italics</em></li><li>SubClass1 and SubClass2 are specializations of Super Class</li><li><strong>A solid line with a hollow arrowhead that point <u>from the child to the parent class</u></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class &lt;|-- SubClass1</span><br><span class="line">Class &lt;|-- SubClass2 </span><br></pre></td></tr></table></figure><hr><h2 id="Simple-Association"><a href="#Simple-Association" class="headerlink" title="Simple Association"></a>Simple Association</h2><ul><li>A structural link between two peer classes</li><li>There is an association between Class1 and Class2</li><li><strong>A solid line connecting two classes</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class1 .. Class2</span><br></pre></td></tr></table></figure><hr><h2 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h2><p>A special type of association. It represents a “part of” relationship.</p><ul><li>Class2 is part of Class1.</li><li>Many instances(denoted by the *) of Class2 can be associated with Class1</li><li>Objects of Class1 and Class2 have separate lifetimes</li><li><strong>A solid line with an unfilled diamond at the association end connected to the class of composite</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class1 o-- Class2</span><br></pre></td></tr></table></figure><hr><h2 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h2><p>A special type of aggregation <strong>where parts are destroyed when the whole is destroyed.</strong></p><ul><li>Objects of Class2 live and die with Class1</li><li>Class2 cannot stand by itself</li><li><strong>A solid line with a filled diamond at the association connected to the class of composite</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class1 *-- Class2</span><br></pre></td></tr></table></figure><hr><h2 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h2><ul><li>Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)</li><li>Class1 depends on Class2</li><li>A dashed line with an open arrow</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class1 ..&gt; Class2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;The &lt;strong&gt;Unified Modeling Language(UML)&lt;/strong&gt; is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.&lt;/p&gt;</summary>
    
    
    
    <category term="Utils" scheme="http://github.com/sebastian/about/categories/Utils/"/>
    
    
    <category term="utils" scheme="http://github.com/sebastian/about/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>kafka</title>
    <link href="http://github.com/sebastian/about/2019/12/03/kafka/"/>
    <id>http://github.com/sebastian/about/2019/12/03/kafka/</id>
    <published>2019-12-03T14:34:16.000Z</published>
    <updated>2020-07-20T13:30:20.863Z</updated>
    
    <content type="html"><![CDATA[<p>卡夫卡，消息中间件，注意同类型的异同。</p><!-- mroe --><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p><code>分布式</code>的基于<code>发布、订阅</code>的<code>消息队列</code>（Message Queue)，主要应用于大数据实时处理领域。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>一个场景，用户注册某网站时填写个人信息，需要短信验证码，这时页面响应，有两种模式：</p><ol><li>同步：用户填写信息，提交（信息入库），触发短信发送接口，发送短信，页面反馈给用户</li><li>异步：用户填写信息，提交（信息入库），页面反馈给用户，同时触发接口，发送短信</li></ol><p>消息队列的主要特点：解耦、削峰</p><h3 id="消息队列的两种模式"><a href="#消息队列的两种模式" class="headerlink" title="消息队列的两种模式"></a>消息队列的两种模式</h3><ol><li><p>点对点模式: 消费者主动拉取数据，消息收到后信息清除。消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息，消息被消费后Queue中不再有存储。。。。。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。<br> 消息不能复用，比如A生产消息，B消费消息，此时如果C也想消费A的消息，那么只能让A再开一个队列让C接受。<code>只是消息队列，不是消息的存储系统</code>（一对一）</p></li><li><p>发布订阅模式：消费者消费数据后不会清除消息。相当于消息生产者将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。发布到topic的消息会被所有订阅者消费。（一对多）</p><ol><li>队列主动推送</li><li>消费者主动拉取</li></ol><ul><li><p>不想要的消息？？</p></li><li><p>推送速度如何确定？</p><p>而卡夫卡属于消费者拉取。所以卡夫卡内有个<code>长轮询</code>来不断地问topic内有没有消息。</p></li></ul></li></ol><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>生产者、消费者、kafka集群。(集群就是消息暂停的地方)</p><ol><li>集群中，分布式，多台服务器。服务器中的broker就是卡夫卡的进程。broker中还有组件：主题。主题将消息分类。partition提高卡夫卡的负载能力和并发度。有leader和follower，后者做数据冗余，提升安全性，且前后者不会出现在同一台服务器。生产者只会寻找leader。主题：分区+主副本。</li><li>消费者，有消费者组，将多个消费者用一个组名。<code>一个分区只能被一个消费者组内的某一个消费者消费</code>。消费者组可以提高消费能力。并发度最好的时候就是消费者个数与分支数相等。</li><li>zookeeper，集群要正常工作就要依赖zookeeper，要想多台装有卡夫卡的机器组成集群，只要他们所用的zookeeper是同一套集群就ok了。除了帮卡夫卡存贮信息外还存储消费到何处的位置信息。（0.9版本之前存才zk，之后存在kafka（存在磁盘，默认7天）。目的都一样：记住消费到的位置）</li></ol><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;卡夫卡，消息中间件，注意同类型的异同。&lt;/p&gt;
&lt;!-- mroe --&gt;

&lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;&lt;code&gt;分布式&lt;/code&gt;的基于&lt;code&gt;发布、订阅&lt;/</summary>
      
    
    
    
    <category term="MiddleWare" scheme="http://github.com/sebastian/about/categories/MiddleWare/"/>
    
    
    <category term="kafka" scheme="http://github.com/sebastian/about/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://github.com/sebastian/about/2019/11/02/nginx/"/>
    <id>http://github.com/sebastian/about/2019/11/02/nginx/</id>
    <published>2019-11-02T14:53:32.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIGNX"><a href="#NIGNX" class="headerlink" title="NIGNX"></a>NIGNX</h1><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和<strong>反向代理</strong>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p><p>特点：</p><ul><li>反向代理</li><li>负载均衡</li><li>动静分离</li><li>高可用</li></ul><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）</p><p>正向访问需要在浏览器配置代理服务器。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。</p><p>静态资源：html, css, js</p><p>动态资源：jsp, servlet</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>前提条件：进入nginx目录</p><p>/usr/localnginx/sbin</p><ul><li>查看nginx版本号</li><li>启动</li><li>关闭</li><li>重新加载nginx</li></ul><p><a href="https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng">referenct</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol><li><p>配置EPEL源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum -y update</span><br></pre></td></tr></table></figure></li><li><p>安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum instll -y nginx</span><br></pre></td></tr></table></figure><p>安装成功后：</p><p><code>默认网站目录</code>：<em>/usr/share/nginx/html</em></p><p><code>默认的配置文件为</code>：<em>/etc/nginx/nginx.conf</em></p><p><code>自定义配置文件目录为</code>：<em>/etc/nginx/conf.d/</em></p></li><li><p>开启端口80和443</p><p>如果关闭了防火墙，直接略过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>命令</p><ul><li><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure></li><li><p>停止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop nginx</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></li><li><p>查看状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure></li><li><p>启用开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><p>测试的时候，直接<code>nginx</code>命令即可，方便调试，调试时使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>禁止开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disbale nginx</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>https</p><ol><li><p>关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。</p></li><li><p>拷贝证书至nginx</p><p>domain为个人域名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/nginx/ssl</span><br><span class="line">   </span><br><span class="line">acme.sh --install-cert -d domain \</span><br><span class="line">   --key-file       /etc/nginx/ssl/domain.key  \</span><br><span class="line">   --fullchain-file /etc/nginx/ssl/domain.cer \</span><br><span class="line">   --reloadcmd     <span class="string">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>配置nginx</p><p>删除**/etc/nginx/nginx.conf**中的server部分代码</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在**/etc/nginx/conf.d<strong>创建自定义配置文件夹</strong>default.conf**</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">443 ssl;</span></span><br><span class="line">    <span class="attr">server_name</span>  <span class="string">domain www.domain;</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">         <span class="attr">root</span> <span class="string">/usr/share/nginx/html;</span></span><br><span class="line">         <span class="attr">index</span>  <span class="string">index.html index.htm;</span></span><br><span class="line">     <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">ssl_certificate</span> <span class="string">/etc/nginx/ssl/domain.crt;</span></span><br><span class="line">    <span class="attr">ssl_certificate_key</span> <span class="string">/etc/nginx/ssl/domain.key;</span></span><br><span class="line">    <span class="attr">ssl_session_timeout</span>  <span class="string">5m;</span></span><br><span class="line">    <span class="attr">ssl_protocols</span> <span class="string">TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class="line">    <span class="attr">ssl_ciphers</span> <span class="string">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;</span></span><br><span class="line">    <span class="attr">ssl_prefer_server_ciphers</span>  <span class="string">on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">error_page</span> <span class="string">497  https://$host$uri?$args;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NIGNX&quot;&gt;&lt;a href=&quot;#NIGNX&quot; class=&quot;headerlink&quot; title=&quot;NIGNX&quot;&gt;&lt;/a&gt;NIGNX&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Nginx&lt;/em&gt; (engine x) 是一个高性能的HTTP和&lt;strong&gt;反向代理&lt;/strong</summary>
      
    
    
    
    <category term="Network" scheme="http://github.com/sebastian/about/categories/Network/"/>
    
    
    <category term="network" scheme="http://github.com/sebastian/about/tags/network/"/>
    
  </entry>
  
</feed>
