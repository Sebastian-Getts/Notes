<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hola</title>
  
  
  <link href="http://github.com/sebastian/about/atom.xml" rel="self"/>
  
  <link href="http://github.com/sebastian/about/"/>
  <updated>2020-08-23T06:50:59.923Z</updated>
  <id>http://github.com/sebastian/about/</id>
  
  <author>
    <name>Sebastian Getts</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>contest203</title>
    <link href="http://github.com/sebastian/about/2020/08/23/contest203/"/>
    <id>http://github.com/sebastian/about/2020/08/23/contest203/</id>
    <published>2020-08-23T04:22:22.000Z</published>
    <updated>2020-08-23T06:50:59.923Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode周赛203</p><a id="more"></a><h1 id="1560-Most-Visited-Sector-in-a-Circular-Track"><a href="#1560-Most-Visited-Sector-in-a-Circular-Track" class="headerlink" title="1560. Most Visited Sector in a Circular Track"></a>1560. Most Visited Sector in a Circular Track</h1><p>Given an integer <code>n</code> and an integer array <code>rounds</code>. We have a circular track which consists of <code>n</code> sectors labeled from <code>1</code> to <code>n</code>. A marathon will be held on this track, the marathon consists of <code>m</code> rounds. The <code>ith</code> round starts at sector <code>rounds[i - 1]</code> and ends at sector <code>rounds[i]</code>. For example, round 1 starts at sector <code>rounds[0]</code> and ends at sector <code>rounds[1]</code></p><p>Return <em>an array of the most visited sectors</em> sorted in <strong>ascending</strong> order.</p><p>Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/14/tmp.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4, rounds &#x3D; [1,3,1,2]</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:</span><br><span class="line">1 --&gt; 2 --&gt; 3 (end of round 1) --&gt; 4 --&gt; 1 (end of round 2) --&gt; 2 (end of round 3 and the marathon)</span><br><span class="line">We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2, rounds &#x3D; [2,1,2,1,2,1,2,1,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 7, rounds &#x3D; [1,3,5,7]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>这道题虽然看起来长，但是难度是<code>easy</code>的，所以一定不会复杂，仔细看来只是求重复次数最多的sectors，我觉得难点是在头一个数比后一个数大的情况下（相当与跑步比赛中的套圈），如何去从头开始循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] rounds)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取数组第一个和最后一个数字</span></span><br><span class="line">    <span class="keyword">int</span> f = rounds[<span class="number">0</span>], t = rounds[rounds.length-<span class="number">1</span>];</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = f;;)&#123;</span><br><span class="line">        ret.add(i);</span><br><span class="line">        <span class="keyword">if</span>(i == t)<span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i == n+<span class="number">1</span>)i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmm上面这个有些取巧，不明白的先看看下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A[<span class="number">0</span>]; i &lt;= A[A.length - <span class="number">1</span>]; ++i)</span><br><span class="line">        res.add(i);</span><br><span class="line">    <span class="keyword">if</span> (res.size() &gt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 下面计算的是start&gt;end的情况，[1, end] + [start, n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[A.length - <span class="number">1</span>]; ++i)</span><br><span class="line">        res.add(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A[<span class="number">0</span>]; i &lt;= n; ++i)</span><br><span class="line">        res.add(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我们只需要关注首节点和末节点就行了，因为要求的是重复次数最多的sector，那么，必然会涉及到首尾，完全不必考虑中间节点。</p><ul><li>如果start&lt;=end，返回[start, end]</li><li>如果start&gt;end，返回[start, n]+[1, end]</li></ul><p>另外一个版本，更好理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mostVisited</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] rounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = rounds.length, fr = rounds[<span class="number">0</span>], to = rounds[len - <span class="number">1</span>];</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (to &gt;= fr) &#123;     <span class="comment">// no circle, such as [1,3,1,2]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fr; i &lt;= to; i++) res.add(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">// cross a circle, such as [2,3,2,1]</span></span><br><span class="line">        <span class="comment">// 这里遍历每个sector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果到最后一个sector的下一个，就从数组中第一个开始，相当于从“后端”开始了，省去了中间部分。</span></span><br><span class="line">            <span class="keyword">if</span> (i == to + <span class="number">1</span>) i = fr;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及<code>环</code>的问题，要找到问题本质。这里说的首尾，一是指给定n个sector中的首尾，二是指给定round中的首尾。</p><h1 id="1561-Maximum-Number-of-Coins-You-Can-Get"><a href="#1561-Maximum-Number-of-Coins-You-Can-Get" class="headerlink" title="1561. Maximum Number of Coins You Can Get"></a>1561. Maximum Number of Coins You Can Get</h1><p>There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:</p><ul><li>In each step, you will choose <strong>any</strong> 3 piles of coins (not necessarily consecutive).</li><li>Of your choice, Alice will pick the pile with the maximum number of coins.</li><li>You will pick the next pile with maximum number of coins.</li><li>Your friend Bob will pick the last pile.</li><li>Repeat until there are no more piles of coins.</li></ul><p>Given an array of integers <code>piles</code> where <code>piles[i]</code> is the number of coins in the <code>ith</code> pile.</p><p>Return the maximum number of coins which you can have.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: piles &#x3D; [2,4,1,2,7,8]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.</span><br><span class="line">Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.</span><br><span class="line">The maximum number of coins which you can have are: 7 + 2 &#x3D; 9.</span><br><span class="line">On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 &#x3D; 6 coins which is not optimal.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles &#x3D; [2,4,5]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles &#x3D; [9,8,7,6,5,1,2,3,4]</span><br><span class="line">Output: 18</span><br></pre></td></tr></table></figure><h2 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h2><p>我觉得这道题本质是个排序的题，但是要按一定的规则排序，最初设想的是每三个数排序，取中间那个。</p><p>然而好的算法都是讲究技巧的，不是靠蛮力。完全可以放心地对数组进行排序，可以理解为逆向思维，例如example1中的数组排好序后：*[1,2,2,4,7,8]*，无论我们怎么分，最优解必然是Bob拿到前两个数，剩下的四个是我们与Alice分，由于是我拿第二大的，所以先分我，在分给Alice，依照这样的一个思路，问题就解决了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">        res += A[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode周赛203&lt;/p&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://github.com/sebastian/about/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>hashmap</title>
    <link href="http://github.com/sebastian/about/2020/08/20/hashmap/"/>
    <id>http://github.com/sebastian/about/2020/08/20/hashmap/</id>
    <published>2020-08-20T15:04:30.000Z</published>
    <updated>2020-08-22T09:20:05.379Z</updated>
    
    <content type="html"><![CDATA[<p>Java Hashmap. 探究他的实现原理和数据结构。基于jdk8. 虽然被讲烂了，但是再烂也得自己整明白了记下来，不然总归不是自己的。</p><a id="more"></a><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Gloria&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;wage&quot;</span>, <span class="number">539.8</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>通过一个简单的<code>put</code>操作，来看看究竟发生了什么。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;(map); <span class="comment">// map为上方那个</span></span><br></pre></td></tr></table></figure><p>来看看初始化容量时的装载因子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>HashMap的容量是我们存入的数值乘以<code>0.75</code>,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>那么，这个map的<strong>实际容量</strong>就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的<code>0.75</code>,自定义<strong>初始容量</strong>。</p><h2 id="put初识"><a href="#put初识" class="headerlink" title="put初识"></a>put初识</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;key</span><br></pre></td></tr></table></figure><p>put有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个<strong>位运算</strong>:</p><ul><li>^ 异或(两个相同的数做异或运算结果为0)</li><li>&gt;&gt;&gt; 无符号右移，左边空出来的补0</li></ul><p>首先是给h赋值为key的hashCode，key的hashcode是通过Object的<code>native方法</code>，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。</p><p>关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量<code>table</code>，他的类型是<code>Noe&lt;K,V&gt; []</code>，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。</p><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 用来定位数组索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">// 链接下一个Node</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get, set equals ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>脱脱的链表有么有！！！ <code>Node&lt;K, V&gt; next</code>！！！</li><li>上面提到的<code>table</code>就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。</li><li>实现了<code>Map.Entry&lt;K, V&gt;</code>接口，所以，他的本质（或者说表现）就是一个k-v键值对。</li><li>与算法题通常定义的简易链表不同，除了<code>next</code>外这里存储了三个值：<code>hash</code>, <code>key</code>, <code>value</code></li></ul><h1 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h1><p>首先想想：什么是哈希表。</p><p>哈希表=数组+链表。通过<code>Node&lt;K, V&gt;</code>以及<code>Node&lt;K, V&gt; []</code>我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是<code>数组+链表</code>。</p><p>哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于<strong>桶</strong>（即之前提到的<code>table</code>数组）和<strong>哈希算法</strong>，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">  * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">  * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">  * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">  * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><code>threshold</code>临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node&lt;K,V&gt;[] table的length是16, loadFactor是0.75,，那么</p><blockquote><p>threshold = loadFactor * length</p></blockquote><p>也就是说，table数组中所能容纳的Node个数由<code>threshold</code>指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.</p><p>size就是表示目前存储的Node的数量。</p><p>在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种<strong>非常规</strong>设计，为什么呢？一个冷知识：</p><ul><li>2的n次方的数为<code>合数</code>，实际上<code>质数</code>导致哈希冲突的概率要小于合数。</li></ul><p>参考HashTable的初始化，<code>initialCapacity</code>就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了<strong>红黑树</strong>，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。</p><h1 id="确定索引"><a href="#确定索引" class="headerlink" title="确定索引"></a>确定索引</h1><p>我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：</p><blockquote><p>取值（key的hashCode），高位运算，取模运算</p></blockquote><p>我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以<code>(n-1)&amp;hash</code>等价于对length取模，比使用<code>%</code>具有更高的效率。</p><h1 id="put详解"><a href="#put详解" class="headerlink" title="put详解"></a>put详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断table的是否为空，是则执行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算插入数组的索引，如果为null，新建节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断key是否存在，如ugo存在直接覆盖掉value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断是否是红黑树，如果是的话就在树中操作，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历table</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 链表的插入操作</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 长度大于8时转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？</p><blockquote><p>note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 太大就不管了，let it go</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，左移一位（X2）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算resize的上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，把每个桶都移动到新的中去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java Hashmap. 探究他的实现原理和数据结构。基于jdk8. 虽然被讲烂了，但是再烂也得自己整明白了记下来，不然总归不是自己的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hashmap, data structure" scheme="http://github.com/sebastian/about/tags/hashmap-data-structure/"/>
    
  </entry>
  
  <entry>
    <title>contest202</title>
    <link href="http://github.com/sebastian/about/2020/08/16/contest202/"/>
    <id>http://github.com/sebastian/about/2020/08/16/contest202/</id>
    <published>2020-08-16T06:36:31.000Z</published>
    <updated>2020-08-16T07:14:32.244Z</updated>
    
    <content type="html"><![CDATA[<p>Leetocode周赛202</p><a id="more"></a><h1 id="1550-Three-Consecutive-Odds"><a href="#1550-Three-Consecutive-Odds" class="headerlink" title="1550. Three Consecutive Odds"></a>1550. Three Consecutive Odds</h1><p>Given an integer array <code>arr</code>, return <code>true</code> if there are three consecutive odd numbers in the array. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [2,6,4,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are no three consecutive odds.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [1,2,34,3,4,5,7,23,12]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: [5,7,23] are three consecutive odds.</span><br></pre></td></tr></table></figure><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>题目难度不高，因此重点关注代码技巧上。“连续三个基数”则返回true，否则false，一般情况下都会想到遍历数组的同时维护一个变量，变量达到三时返回。直到我看到了神级代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i+<span class="number">2</span> &lt; a.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">2</span> + a[i+<span class="number">1</span>] % <span class="number">2</span> + a[i+<span class="number">2</span>] % <span class="number">2</span> == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rank榜单的前几名整齐化一地这样写。我们来看看这样写的原理：</p><p>同样是for循环，它的 判断条件是<code>i+2&lt;a.length</code>，为何要<code>+2</code>,原因在for循环中，它每次在第i处下标都会同时获取到i的后两位，把和三个数与2相除取余，如果是奇数余数为1,那么这三个数相加即为3,好处是不用额外维护一个变量，代码也简单易懂。</p><p><strong>note:</strong> 循环时同时做三个数的运算；取余判断奇偶</p><h1 id="1551-Minimum-Operations-to-Make-Array-Equal"><a href="#1551-Minimum-Operations-to-Make-Array-Equal" class="headerlink" title="1551. Minimum Operations to Make Array Equal"></a>1551. Minimum Operations to Make Array Equal</h1><p>You have an array <code>arr</code> of length <code>n</code> where <code>arr[i] = (2 * i) + 1</code> for all valid values of <code>i</code> (i.e. <code>0 &lt;= i &lt; n</code>).</p><p>In one operation, you can select two indices <code>x</code> and <code>y</code> where <code>0 &lt;= x, y &lt; n</code> and subtract <code>1</code> from <code>arr[x]</code> and add <code>1</code> to <code>arr[y]</code> (i.e. perform <code>arr[x] -=1 </code>and <code>arr[y] += 1</code>). The goal is to make all the elements of the array <strong>equal</strong>. It is <strong>guaranteed</strong> that all the elements of the array can be made equal using some operations.</p><p>Given an integer <code>n</code>, the length of the array. Return <em>the minimum number of operations</em> needed to make all the elements of arr equal.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: arr &#x3D; [1, 3, 5]</span><br><span class="line">First operation choose x &#x3D; 2 and y &#x3D; 0, this leads arr to be [2, 3, 4]</span><br><span class="line">In the second operation choose x &#x3D; 2 and y &#x3D; 0 again, thus arr &#x3D; [3, 3, 3].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><h2 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h2><p>这道题看着挺复杂，行数多，其实像是在<code>找规律</code>（我就是没找出来，n=6时output=9？），是一道数学题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Take care of overflow if n is too large.</span></span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (n*(n+<span class="number">1</span>));</span><br><span class="line">    &#125;        </span><br><span class="line">    n/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> n*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解法是将其分两种情况–奇数与偶数。考得不是算法， 是脑子吧。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetocode周赛202&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>contest201</title>
    <link href="http://github.com/sebastian/about/2020/08/09/contest201/"/>
    <id>http://github.com/sebastian/about/2020/08/09/contest201/</id>
    <published>2020-08-09T04:22:53.000Z</published>
    <updated>2020-08-09T05:50:41.788Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode周赛201.</p><a id="more"></a><h1 id="1544-Make-The-String-Great"><a href="#1544-Make-The-String-Great" class="headerlink" title="1544 Make The String Great"></a>1544 Make The String Great</h1><p>Given a string <code>s</code> of lower and upper case English letters.</p><p>A good string is a string which doesn’t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li></ul><p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p><p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p><p><strong>Notice</strong> that an empty string is also good.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leEeetcode&quot;</span><br><span class="line">Output: &quot;leetcode&quot;</span><br><span class="line">Explanation: In the first step, either you choose i &#x3D; 1 or i &#x3D; 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abBAcC&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: We have many possible scenarios, and all lead to the same answer. For example:</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;s&quot;</span><br><span class="line">Output: &quot;s&quot;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>首先要注意审题，明确界限的判断。尤其是<code>vice-versa</code>，反之亦然的意思，就是<strong>相邻两个字母忽略大小写时相同，且一个大写一个小写</strong>，需要将这两个字母剔除。</li><li>通过<code>example 2</code>可以看出算法应有<em>循环</em>的动作，剔除后还应该重新审视。</li></ul><h3 id="mine"><a href="#mine" class="headerlink" title="mine"></a>mine</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!stack.empty() &amp;&amp; (</span><br><span class="line">                (Character.isUpperCase(c) &amp;&amp; Character.isLowerCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class="string">&#x27;a&#x27;</span>) == (c - <span class="string">&#x27;A&#x27;</span>)))</span><br><span class="line">                        ||</span><br><span class="line">                        (Character.isLowerCase(c) &amp;&amp; Character.isUpperCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class="string">&#x27;A&#x27;</span>) == (c - <span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">        )) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Character&gt; iterator = stack.iterator();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        sb.append(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为是iterator，不用reverse()</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="better"><a href="#better" class="headerlink" title="better"></a>better</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ch = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (ch) &#123;</span><br><span class="line">    ch = <span class="keyword">false</span>;</span><br><span class="line">    String t = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) + <span class="number">32</span> == s.charAt(i + <span class="number">1</span>) || s.charAt(i + <span class="number">1</span>) + <span class="number">32</span> == s.charAt(i)) &#123;</span><br><span class="line">            t = s.substring(<span class="number">0</span>, i) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">            ch = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><h1 id="1545-Find-Kth-Bit-in-Nth-Binary-String"><a href="#1545-Find-Kth-Bit-in-Nth-Binary-String" class="headerlink" title="1545 Find Kth Bit in Nth Binary String"></a>1545 Find Kth Bit in Nth Binary String</h1><p>Given two positive integers <code>n</code> and <code>k</code>, the binary string <code>Sn</code> is formed as follows:</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code> for <code>i &gt; 1</code></li></ul><p>Where <code>+</code> denotes the concatenation operation, <code>reverse(x)</code> returns the reversed string x, and <code>invert(x)</code> inverts all the bits in x (0 changes to 1 and 1 changes to 0).</p><p>For example, the first 4 strings in the above sequence are:</p><ul><li>S1 = “0”</li><li>S2 = “0<strong>1</strong>1”</li><li>S3 = “011<strong>1</strong>001”</li><li>S4 = “0111001<strong>1</strong>0110001”</li></ul><p>Return <em>the</em> <code>kth</code> <em>bit</em> <em>in</em> <code>Sn</code>. It is guaranteed that <code>k</code> is valid for the given <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 1</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: S3 is &quot;0111001&quot;. The first bit is &quot;0&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4, k &#x3D; 11</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: S4 is &quot;011100110110001&quot;. The 11th bit is &quot;1&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1, k &#x3D; 1</span><br><span class="line">Output: &quot;0&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2, k &#x3D; 3</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>题目中已经给了计算式，根据式子来计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> integer = Integer.parseInt(sb.toString());</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(integer));</span><br><span class="line">        <span class="comment">// 0-1 inverse</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringBuilder.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                stringBuilder.replace(i, i + <span class="number">1</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.replace(i, i + <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.reverse();</span><br><span class="line">        sb.append(<span class="string">&quot;1&quot;</span>).append(stringBuilder);</span><br><span class="line">        n--;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chars = sb.toString().toCharArray();</span><br><span class="line">    <span class="keyword">return</span> chars[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解题过程是错的，我觉得最好的方式应该是用递归，但是不太会，用来迭代，在n=4时的结果就错了。</p><h3 id="better-1"><a href="#better-1" class="headerlink" title="better"></a>better</h3><p>做<code>0-1</code>转换时，当时想用位运算，怎奈不熟练、没想起来<code>异或</code>。</p><ul><li>异或 ^ ：相同为0，0异或任何数为任何数。在二进制的情况下，与<code>1</code>异或等同于<code>0-1</code>翻转。</li></ul><h4 id="method-1"><a href="#method-1" class="headerlink" title="method 1"></a>method 1</h4><p>一目了然，迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        --n;</span><br><span class="line">        s = s+<span class="string">&quot;1&quot;</span>+sinv(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从0开始，k-1</span></span><br><span class="line">    <span class="keyword">return</span> s.charAt(k-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sinv</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder a = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 从后遍历，reverse()</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="comment">// 0-1翻转</span></span><br><span class="line">        c^=<span class="number">1</span>;</span><br><span class="line">        a.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="method-2"><a href="#method-2" class="headerlink" title="method 2"></a>method 2</h4><p>别具一格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    s[1]</span>=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    t[<span class="number">1</span>]=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s[i]=s[i-<span class="number">1</span>];</span><br><span class="line">        s[i]+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        s[i]+=t[i-<span class="number">1</span>];</span><br><span class="line">        t[i]=s[i-<span class="number">1</span>];</span><br><span class="line">        t[i]+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t[i]+=t[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[n][k-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="method-3"><a href="#method-3" class="headerlink" title="method 3"></a>method 3</h4><p>清清楚楚，深度优先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> base = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == base + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= base) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(n - <span class="number">1</span>, len - k + <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(n, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode周赛201.&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>mybatis</title>
    <link href="http://github.com/sebastian/about/2020/08/05/mybatis/"/>
    <id>http://github.com/sebastian/about/2020/08/05/mybatis/</id>
    <published>2020-08-05T14:21:19.000Z</published>
    <updated>2020-08-05T16:02:18.465Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。</p><a id="more"></a><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: start</span><br><span class="line">config&#x3D;&gt;operation: mybatis-config.xml</span><br><span class="line">build&#x3D;&gt;operation: SqlSessionFactoryBuilder</span><br><span class="line">factory&#x3D;&gt;operation: SqlSessionFactory</span><br><span class="line">session&#x3D;&gt;parallel: SqlSession</span><br><span class="line">mapper&#x3D;&gt;operation: Sql Mapper</span><br><span class="line">end&#x3D;&gt;end: end</span><br><span class="line"></span><br><span class="line">start-&gt;config-&gt;build-&gt;factory-&gt;session</span><br><span class="line">session(path1,)-&gt;end</span><br><span class="line">session(path2,right)-&gt;mapper-&gt;end</span><br></pre></td></tr></table></figure><p>对于<code>SqlSessionFactoryBuilder</code>来说，作用是创建<code>SqlSessionFactory</code>，一旦创建完工厂就没用了，所以是作为<strong>局部变量</strong>；而对于<code>SqlSessionFactory</code>，可以把它看作<em>连接池</em>，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建<code>SqlSession</code> 。创建<code>SqlSession</code>后用来链接数据库，每个session被看作是请求数据库，他是<strong>线程不安全</strong>的，每个线程都应有自己的session，不共享，所以最佳作用域是<strong>方法域</strong>，即每次与数据库交互都创建一个<code>SqlSession</code>，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。</p><h2 id="属性名与数据库表字段名"><a href="#属性名与数据库表字段名" class="headerlink" title="属性名与数据库表字段名"></a>属性名与数据库表字段名</h2><p>当pojo中的实例变量与数据库字段中不一致时，可以使用<code>resultMap</code>来解决，即<strong>结果集映射</strong>。</p><p>也常用<code>resultType</code>，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来<code>resultMap</code>时可以去掉<code>resultType</code>属性。</p><h2 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h2><p>mybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>mybatis支持分页，有<code>limit</code>和<code>rowBounts</code>两个方法。区别是前者在sql中实现，后者面向对象。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">USER</span> <span class="keyword">limit</span> <span class="comment">#&#123;index&#125;,#&#123;size&#125;</span></span><br></pre></td></tr></table></figure><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>默认定义了两级缓存：一级缓存、二级缓存</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>默认开启，在session的<code>close</code>之前都有效，如果是查询相同的数据，直接在缓存中拿。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>需要手动开启和配置，基于<code>namespace</code>级别，有<code>Cache</code>接口来自定义实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="mybatis" scheme="http://github.com/sebastian/about/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>contest200</title>
    <link href="http://github.com/sebastian/about/2020/08/02/contest200/"/>
    <id>http://github.com/sebastian/about/2020/08/02/contest200/</id>
    <published>2020-08-02T04:56:29.000Z</published>
    <updated>2020-08-02T06:03:42.348Z</updated>
    
    <content type="html"><![CDATA[<p>Record Leetcode contest 200.</p><a id="more"></a><h1 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h1><p>passed.</p><h1 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h1><p>Find the winner of an Array Game.</p><p>Given an integer array <code>arr</code> of <strong>distinct</strong> integers and an integer <code>k</code>.</p><p>A game will be played between the first two elements of the array (i.e. <code>arr[0]</code> and <code>arr[1]</code>). In each round of the game, we compare <code>arr[0]</code> with <code>arr[1]</code>, the larger integer wins and remains at position <code>0</code> and the smaller integer moves to the end of the array. The game ends when an integer wins <code>k</code> consecutive rounds.</p><p>Return <em>the integer which will win the game</em>.</p><p>It is <strong>guaranteed</strong> that there will be a winner of the game.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [2,1,3,5,4,6,7], k = 2</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Let&#x27;s see the rounds of the game:</span><br><span class="line">Round |       arr       | winner | win<span class="emphasis">_count</span></span><br><span class="line"><span class="emphasis">  1   | [2,1,3,5,4,6,7] | 2      | 1</span></span><br><span class="line"><span class="emphasis">  2   | [2,3,5,4,6,7,1] | 3      | 1</span></span><br><span class="line"><span class="emphasis">  3   | [3,5,4,6,7,1,2] | 5      | 1</span></span><br><span class="line"><span class="emphasis">  4   | [5,4,6,7,1,2,3] | 5      | 2</span></span><br><span class="line"><span class="emphasis">So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,1], k = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 will win the first 10 rounds consecutively.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,9,8,2,3,7,6,4,5], k = 7</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><p>看到这题，首先我认为这题清晰明了，用__迭代__去完成全部流程，用<strong>k</strong>去做结束的标志，是一道从头到尾很明确的题。但是:joy:</p><p>贴上我稚嫩的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> zero = k-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> solution = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> currMax = Math.max(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> currMin = Math.min(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">        helper(currMax, currMin, arr);</span><br><span class="line">        <span class="keyword">if</span>(res == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// initial, no compare</span></span><br><span class="line">            res = currMax;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(currMax == res)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                solution = currMax;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = zero;</span><br><span class="line">                res = currMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> min, <span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[arr.length-<span class="number">1</span>] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没通过，因为<code>Time Limited</code>，跑得太慢了！</p><h2 id="Niubility-Solution"><a href="#Niubility-Solution" class="headerlink" title="Niubility Solution"></a>Niubility Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">// 数组长度与k之间取最小的。</span></span><br><span class="line">    k = Math.min(k, n);</span><br><span class="line">    <span class="keyword">int</span> A = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 标志位，记录相同次数</span></span><br><span class="line">    <span class="keyword">int</span> rep = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从第二个开始iterate，无终结条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;;i++)&#123;</span><br><span class="line">        <span class="comment">// “i%n“ 取余数，逻辑变换数组。由于for循环无终结条件，所以i会无限增加超过n。</span></span><br><span class="line">        <span class="keyword">int</span> B = arr[i%n];</span><br><span class="line">        <span class="keyword">if</span>(A &gt;= B)&#123;</span><br><span class="line">            rep++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A = B;</span><br><span class="line">            rep = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终结条件在这里，rep等于k时结束。</span></span><br><span class="line">        <span class="keyword">if</span>(rep == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过对比可以发现，我耗时的原因在于：</strong> </p><ol><li>我是真的挪了数组！物理上的挪动，实际上，逻辑移动数组即可！我的程序算例4要6秒，这个只需要0秒。</li><li><code>Math.min(k, n)</code>，如果题目给的k为<code>10000000</code>,数组长度为<code>8</code>,那么最后也是按<code>8</code> 来算，那么多循环无意义，一遍遍历即可获取最大（这样也行？）</li></ol><p>况且，逻辑i上也没有去变换位置，题目的本质还是挨个遍历！</p><p>i.e. arr = [2,1,3,5,4,6,7], k = 2</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Record Leetcode contest 200.&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
    <category term="algorithm" scheme="http://github.com/sebastian/about/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>lock</title>
    <link href="http://github.com/sebastian/about/2020/07/20/lock/"/>
    <id>http://github.com/sebastian/about/2020/07/20/lock/</id>
    <published>2020-07-20T13:46:41.000Z</published>
    <updated>2020-08-23T02:23:51.331Z</updated>
    
    <content type="html"><![CDATA[<p>锁跟多线程紧密相关，有复杂与简单之分。</p><a id="more"></a><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p><img src="https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png" alt="image.png"></p><h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁|悲观锁"></a>乐观锁|悲观锁</h1><p>所谓乐观锁、悲观锁可以类比地看作<strong>JVM里的方法区</strong>，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？</p><ul><li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，<code>synchronized</code>关键字和<code>Lock的实现类</code>都是悲观锁。</li><li>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过<strong>无锁编程</strong>实现的乐观锁，最常用的就是<code>CAS算法</code>，Java原子类中的递增操作就是通过<strong>CAS自旋实现</strong>的。</li></ul><p>根据他们的概念，可以发现<strong>悲观锁适合写操作多的场景</strong>，<strong>乐观锁适合读操作多的场景</strong>，这样利于性能的优化提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMehthod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乐观锁</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">// 执行自增1</span></span><br></pre></td></tr></table></figure><h1 id="Compare-And-Swap"><a href="#Compare-And-Swap" class="headerlink" title="Compare And Swap"></a>Compare And Swap</h1><p>CAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的<strong>原子类</strong>就是通过这种算法实现了乐观锁。算法涉及到三个操作数：</p><ul><li>需要读写的内存值V （已存在的值）</li><li>进行比较的值A</li><li>要写入的新值B</li></ul><p>当<code>V=A</code>时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="comment">// 获取并操作内存的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">// 存储value在AtomicInteger中的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储AtomicInteger的int值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>一目了然了吧，最终的<code>compareAndSwapInt</code>是<code>native</code>，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：</p><ul><li>看到<code>do-while</code>了吧，循环时间长会造成较大的CPU开销。</li></ul><p><strong>note:</strong> ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A”</p><h1 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁|适应性自旋锁"></a>自旋锁|适应性自旋锁</h1><p>涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference <a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">here</a></p><h1 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁|非公平锁"></a>公平锁|非公平锁</h1><p>简而言之，公平锁是好好排队的，非公平锁是插队来的。</p><p>在类<code>ReentrantLock</code>中，有一个内部类<code>Sync</code>，他是继承<code>AbstractQueuedSnchronizer</code>的，对锁的添加、释放等操作大部分都是在<code>Sync</code>实现的，他又有<code>FairSync</code>和<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁。</p><h1 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁|共享锁"></a>独享锁|共享锁</h1><p>别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的<code>synchronized</code>和并发包中的<code>Lock</code>。</p><p>共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁和共享锁也是通过AQS来实现的。具体参考类<code>ReentrantReadWriteLock</code>。类中有<code>ReadLock</code>和<code>WriteLock</code>两把锁，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;锁跟多线程紧密相关，有复杂与简单之分。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="lock" scheme="http://github.com/sebastian/about/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="http://github.com/sebastian/about/2020/07/20/volatile/"/>
    <id>http://github.com/sebastian/about/2020/07/20/volatile/</id>
    <published>2020-07-20T13:23:51.000Z</published>
    <updated>2020-07-20T13:26:07.636Z</updated>
    
    <content type="html"><![CDATA[<p>这个关键字用于将Java变量标记为<code>being stored in main memory</code>，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。</p><a id="more"></a><h1 id="Visibility-problems"><a href="#Visibility-problems" class="headerlink" title="Visibility problems"></a>Visibility problems</h1><p>主要是多线程中的问题。线程在操作<code>非volatile</code>的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。</p><p>那么问题来了，对于<code>非volatile</code>的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。</p><p>如果counter不声明为<code>volatile</code>，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，<strong>一个线程的更新对其他线程是不可见的</strong>。</p><h1 id="Visibility-Guarantee"><a href="#Visibility-Guarantee" class="headerlink" title="Visibility Guarantee"></a>Visibility Guarantee</h1><p>关键字<code>volatile</code>的设定就是解决上面提到的可见性问题。通过声明counter变量为<code>volatile</code>的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字<code>volatile</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareObject</span></span>&#123;</span><br><span class="line">    <span class="comment">// 由于声明为volatile，因此更改变量对于其他线程的是可见的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为<code>volatile</code>是不够的。</p><h2 id="Full-Visibility-Guarantee"><a href="#Full-Visibility-Guarantee" class="headerlink" title="Full Visibility Guarantee"></a>Full Visibility Guarantee</h2><p>实际上，关键字<code>volatile</code>的可见保证性超越了<code>volatile</code>变量本身。有点绕吧，可见保证性如下：</p><ul><li><p>如果线程A更改了<code>volatile</code>变量，并且线程B随后读取了它，则在写入<code>volatile</code>变量之前线程A可见的所有变量在线程B读取<code>volatile</code>变量后也将可见。</p></li><li><p>如果线程A读取了一个<code>volatile</code>变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。</p></li></ul><p>看个代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改了三个变量，只有days是volatile的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = year;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalDays</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="keyword">this</span>.days;</span><br><span class="line">        total += months * <span class="number">30</span>;</span><br><span class="line">        total += years * <span class="number">365</span>;</span><br><span class="line">        <span class="keyword">return</span> total;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着重观察<em>totalDays()<em>，他一开始会将<code>days</code>的值赋给变量<code>total</code> ,由于<code>days</code>的类型是<code>volatile</code>，所以，读取<code>days</code>的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了<code>volatile</code>他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为<code>volatile</code>，读取时必须</em></em>最后**读取带有<code>volatile</code>属性的值）。</p><h1 id="Instruction-Reordering"><a href="#Instruction-Reordering" class="headerlink" title="Instruction Reordering"></a>Instruction Reordering</h1><p>指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">a++;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure><p>这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">1</span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">b++</span><br></pre></td></tr></table></figure><p>然而，当变量属于<code>volatile</code>时，指令排序就需要小心了，看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> days;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.months = months;</span><br><span class="line">        <span class="keyword">this</span>.days = days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果JVM重排指令，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> years, <span class="keyword">int</span> months, <span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里将days赋值动作放到了第一位</span></span><br><span class="line">    <span class="keyword">this</span>.days = days;</span><br><span class="line">    <span class="keyword">this</span>.years = years;</span><br><span class="line">    <span class="keyword">this</span>.months = months;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。</p><h2 id="Volatile-Happens-Before-Guarantee"><a href="#Volatile-Happens-Before-Guarantee" class="headerlink" title="Volatile Happens-Before Guarantee"></a>Volatile Happens-Before Guarantee</h2><p><code>volatile</code>关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。</p><ul><li>如果读/写其他变量出现在写<code>volatile变量</code>之前，那么就不能重排为出现在它之后。当然返回过是允许的。</li><li>如果读/写其他变量出现在读<code>volatile变量</code>之后，那么就不能重排为出现在它之前。</li></ul><h1 id="Volatile-is-Not-Always-Enough"><a href="#Volatile-is-Not-Always-Enough" class="headerlink" title="Volatile is Not Always Enough"></a>Volatile is Not Always Enough</h1><p>很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证<code>原子性</code>的操作了，如<strong>syncronized</strong>或者比并发包下的<code>lock</code>了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个关键字用于将Java变量标记为&lt;code&gt;being stored in main memory&lt;/code&gt;，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="lock" scheme="http://github.com/sebastian/about/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>mq</title>
    <link href="http://github.com/sebastian/about/2020/07/20/mq/"/>
    <id>http://github.com/sebastian/about/2020/07/20/mq/</id>
    <published>2020-07-20T13:04:40.000Z</published>
    <updated>2020-08-16T05:24:15.951Z</updated>
    
    <content type="html"><![CDATA[<p>mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。</p><a id="more"></a><h1 id="MQ的引入"><a href="#MQ的引入" class="headerlink" title="MQ的引入"></a>MQ的引入</h1><p>模拟几个场景：</p><ol><li><p><code>学生模块</code>和<code>老师模块</code>。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。</p><p>解决方式：引入<code>班长模块</code>，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。</p></li><li><p><code>系统A</code>需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。</p><p>上线后又新增了一个需求，<code>D</code>也要接收<code>A</code>的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对<code>A</code>进行改造，开发、联调效率低，耦合严重，增加<code>A</code>的负担。</p></li></ol><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li><p>解决耦合  当新的模块接进来时，可以做到代码改动最小</p></li><li><p>异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力</p></li><li><p>削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨</p></li></ul><h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><table><thead><tr><th>比较项目</th><th>Topic模式队列</th><th>Queue模式队列</th></tr></thead><tbody><tr><td>工作模式</td><td>”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。</td><td>”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。</td></tr><tr><td>有无状态</td><td>无状态</td><td>Queue数据默认会在mq服务器上以文件形式保存</td></tr><tr><td>传递完整性</td><td>如果没有订阅者，消息会被丢弃。不完整。</td><td>消息不会丢弃</td></tr><tr><td>处理效率</td><td>由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异</td><td>由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的</td></tr></tbody></table><h1 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h1><p>Java消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。</p><p>实现JMS接口和规范的消息中间件，即我们的MQ服务器。</p><h2 id="MESSAGE"><a href="#MESSAGE" class="headerlink" title="MESSAGE"></a>MESSAGE</h2><p>JMS message的组成：消息头 + 消息体 + 消息属性</p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>记录常用的</p><ul><li><p>JMSDestination 消息发送的目的地，Queue或Topic</p></li><li><p>JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。</p></li><li><p>JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除</p></li><li><p>JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通</p></li><li><p>JMSMessgeID 唯一ID，判断是否重复消费，幂等性</p></li></ul><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>封装具体消息数据，5种格式。（使用频率高）</p><ul><li><p>TextMessage 普通字符串消息 （使用频率高）</p></li><li><p>MapMessage map类型消息，key为String类型，值为Java基本数据类型</p></li><li><p>BytesMessage 二进制数组消息</p></li><li><p>StreamMessage 流</p></li><li><p>ObjectMessage 可序列化的Java对象</p></li></ul><p>发送和接受的消息类型必须一致。</p><h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><p>如果需要除消息头字段以外的值，那么可以使用消息属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextMessage tm = session.createTextMessage(<span class="string">&quot;wa wa&quot;</span>);</span><br><span class="line">tm.setStringProperty(<span class="string">&quot;c01&quot;</span>,<span class="string">&quot;vip&quot;</span>); <span class="comment">// 增加属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TextMessage tms = (TextMessage) messge;</span><br><span class="line">System.out.println(tms.getStringProperty(<span class="string">&quot;c01&quot;</span>)); <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><p>MQ挂了，消息的持久话和丢失的情况如何？一般有<strong>三个特征</strong>来保障：持久化、事务、签收，其中<strong>事务偏生产者，签收偏消费者</strong>。此外对于对于宕机，还有<strong>多节点集群</strong>。</p><h2 id="持久化-PERSISTENT"><a href="#持久化-PERSISTENT" class="headerlink" title="持久化 PERSISTENT"></a>持久化 PERSISTENT</h2><p>参考redis的持久化（有rdb和aof），消息也有类似的辅助。</p><h3 id="QUEUE"><a href="#QUEUE" class="headerlink" title="QUEUE"></a>QUEUE</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><ol><li><p>非持久 服务器宕机，消息不存在</p><blockquote><p>messaegeProducer.setDeliveryMode(DeliveryMode.<em>NON_PRESISTENT</em>);</p></blockquote></li><li><p>持久化 服务器宕机后消息依然存在</p><blockquote><p>messageProducer.setDelieveryMode(DeliveryMode.<em>PRESISTENT</em>);</p></blockquote></li></ol><h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h4><p>非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。</p><p>持久化时，上述操作后，数据依然存在。</p><p>在队列中，如果<strong>不显示标注持久</strong>，<strong>默认持久化</strong>，因为可靠性是优先考虑的因素。</p><p>持久、事物、签收</p><h3 id="TOPIC"><a href="#TOPIC" class="headerlink" title="TOPIC"></a>TOPIC</h3><p>对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：</p><ol><li><p>先运行一次消费者，等于向MQ注册</p></li><li><p>然后再运行生产者发送信息</p></li><li><p>消费者一定会收到订阅消息。不在线的话下次连接时会接收。</p></li></ol><h2 id="事务-TRANSACTION"><a href="#事务-TRANSACTION" class="headerlink" title="事务 TRANSACTION"></a>事务 TRANSACTION</h2><p>数据库的事务、ACID、隔离级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第一个参数即 事务是否开启</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul><li><p>false 关闭事务，只要执行<code>send</code>就进入到队列中</p></li><li><p>true 开启事物，先执行<code>send</code>再执行<code>commit</code>，消息才被真正提交到队列中。</p></li></ul><p>对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// ok session.commit;</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    session.rollback();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != session)&#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>创建session时将事务改为<code>true</code>，同样需要<code>commit</code>，否则事务会被重复消费。</p><h2 id="签收-ACKNOWLEDGE"><a href="#签收-ACKNOWLEDGE" class="headerlink" title="签收 ACKNOWLEDGE"></a>签收 ACKNOWLEDGE</h2><p>分为事务和非事务两种情况</p><h4 id="非事务"><a href="#非事务" class="headerlink" title="非事务"></a>非事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第个参数即 签收类型</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><ul><li><p>自动签收（默认）   <strong>AUTO_ACKNOWLEDGE</strong>  （使用频率高）</p></li><li><p>手动签收 <strong>CLIENT_ACKNOWLEDGE</strong> （使用频率高）</p></li><li><p>允许重复消息 <strong>DUPS_OK_ACKNOWLEDGE</strong></p></li></ul><p>手动签收时需要手动标记，否则会造成重复消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextMessage tm = (TextMessage)messageConsumer.receive(<span class="number">4000L</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != tm)&#123;</span><br><span class="line">    tm.acknowledge();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建session的第个参数即 签收类型</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><p>有事务就需要<code>commit</code>。</p><h2 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h2><p>基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。类比平时的即时通讯工具。</p><ul><li><p>如果在<strong>Session</strong>关闭时有部分消息已被收到但还没有签收（<strong>acknowledge</strong>)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）</p></li><li><p>队列可以长久地保存消息直到消费者收到消息。<strong>消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态</strong>，充分体现了异步传输模式的优势。</p></li></ul><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>JMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作<strong>topic</strong>，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。</p><h3 id="非持久"><a href="#非持久" class="headerlink" title="非持久"></a>非持久</h3><p>对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。</p><h1 id="BROKER"><a href="#BROKER" class="headerlink" title="BROKER"></a>BROKER</h1><p>集群、配置时会用到。</p><p>相当于一个ActiveMQ服务器<strong>实例</strong>，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。</p><p>之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.</p><h2 id="消息发送模式"><a href="#消息发送模式" class="headerlink" title="消息发送模式"></a>消息发送模式</h2><p>ActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。</p><p><code>ActiveMQ默认使用异步发送的模式</code>，<strong>同步发送有两种情况</strong>：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。</p><p>异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，<code>允许在失败的情况下有少量的数据丢失</code>。</p><h1 id="ACTIVEMQ的传输协议"><a href="#ACTIVEMQ的传输协议" class="headerlink" title="ACTIVEMQ的传输协议"></a>ACTIVEMQ的传输协议</h1><p>Q: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？</p><p>调优：使用NIO传输协议</p><p>支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）</p><table><thead><tr><th>协议</th><th>描述</th></tr></thead><tbody><tr><td>TCP</td><td>默认的协议，性能相对可以</td></tr><tr><td>NIO</td><td>基于TCP协议之上的，进行了扩展和优化</td></tr><tr><td>HTP(s)</td><td>基于HTTP(s)</td></tr></tbody></table><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>要换为NIO，需要修改<code>activemq.xml</code>配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;nio&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;nio://192.168.111.136&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在消费者、生产者修改代码，指定传输协议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> stati <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;nio://192.168.111.136&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ActiveMQConnectionFactory af = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h3><p>Q: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持<code>openwire（TCP）</code>，如何让这个端口支持NIO，又支持多个协议呢？</p><p>默认是<code>BIO+TCP</code>，目前是<code>NIO+TCP</code>，那么如何做到<code>NIO+TCP/Mqtt/stomp</code>。</p><p>A: 开启多协议支持，用<code>auto</code>关键字，<a href="https://activemq.apache.org/auto">reference</a>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;auto://localhost:5761&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>note:</strong> 在activeMQ后台配置面板的<code>Network</code>可以查看开启的网络协议。</p><h1 id="ACTIVEMQ的存储和可持久化"><a href="#ACTIVEMQ的存储和可持久化" class="headerlink" title="ACTIVEMQ的存储和可持久化"></a>ACTIVEMQ的存储和可持久化</h1><p>对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会<code>采用持久化机制</code>（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p><p>主要介绍两个DB：<code>KahaDB</code>, <code>LevelDB</code>, <code>JDBC</code></p><p>Q: AMQ持久化机制</p><h2 id="KahaDB"><a href="#KahaDB" class="headerlink" title="KahaDB"></a>KahaDB</h2><p>基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。</p><p>在配置文件中，有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdpter</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>reference <a href="https://activemq.apache.org/kahadb">here</a></p><p>可用于任何场合，提高了性能和恢复能力。消息存储使用一个<strong>事务日志</strong>和一个<strong>索引文件</strong>（存储所有地址）。</p><p>Kahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）</p><h4 id="db-lt-Number-gt-log"><a href="#db-lt-Number-gt-log" class="headerlink" title="db&lt;Number&gt;.log"></a>db&lt;Number&gt;.log</h4><p>存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。</p><h4 id="db-data"><a href="#db-data" class="headerlink" title="db.data"></a>db.data</h4><p>包含了持久化的<code>BTree索引</code>，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向<code>db-\&lt;Number&gt;.log</code>里面存储的消息。</p><h4 id="db-free"><a href="#db-free" class="headerlink" title="db.free"></a>db.free</h4><p>当前<code>db.data</code>文件里哪些页面是空闲的，文件具体内容是所有空闲页的<strong>ID</strong>. 类比linux的bash命令<code>free</code>。</p><h4 id="db-redo"><a href="#db-redo" class="headerlink" title="db.redo"></a>db.redo</h4><p>用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。</p><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。</p><h2 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h2><h2 id="JDBC-Message-store-with-ActiveMQ-Journal"><a href="#JDBC-Message-store-with-ActiveMQ-Journal" class="headerlink" title="JDBC Message store with ActiveMQ Journal"></a>JDBC Message store with ActiveMQ Journal</h2><p>主要。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li><p>引入消息队列后该如何保证其高可用性</p></li><li><p>异步投递Async Sends</p></li><li><p>延迟投递和定时投递</p></li><li><p>分发策略</p></li><li><p>ActiveMQ消费重试机制</p></li><li><p>死信队列</p></li><li><p>如何保证消息不被重复消费呢？谈谈幂等性问题</p></li></ol><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>zookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。</p><h2 id="异步投递"><a href="#异步投递" class="headerlink" title="异步投递"></a>异步投递</h2><p>如何确认发送成功？ </p><p>在消息发送完后接收回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ActiveMQConnectionFacotry acf = <span class="keyword">new</span> ActiveMQConnectionFactory(URL);</span><br><span class="line"><span class="comment">// 设置为异步发送消息</span></span><br><span class="line">acf.setUseAsyncSend(<span class="keyword">true</span>);</span><br><span class="line">ActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class="line">...</span><br><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line"><span class="comment">// 未message设置属性</span></span><br><span class="line">message.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用带有回调的send方法来发送</span></span><br><span class="line">amp.send(message, <span class="keyword">new</span> AsyncCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSucces</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(message.getJMSmessageID+<span class="string">&quot; succeed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException exception)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 拿到属性来确认发送失败的消息</span></span><br><span class="line">        System.out.println(message.getJMSmessageID+<span class="string">&quot; fail&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="延迟投递和定时投递"><a href="#延迟投递和定时投递" class="headerlink" title="延迟投递和定时投递"></a>延迟投递和定时投递</h2><p>参考<a href="http://activemq.apache.org/delay-and-schedule-message-delivery.html">官网说明</a></p><table><thead><tr><th>Property name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>AMQ_SCHEDULED_DELAY</td><td>long</td><td>延迟投递的时间</td></tr><tr><td>AMQ_SCHEDULED_PERIOD</td><td>long</td><td>重复投递的时间间隔</td></tr><tr><td>AMQ_SCHEDULED_REPEAT</td><td>int</td><td>重复投递次数</td></tr><tr><td>AMQ_SCHEDULED_CRON</td><td>String</td><td>Cron表达式</td></tr></tbody></table><p>在<code>activemq.xml</code>中配置<em>schedulerSupport</em>属性为<em>true</em>且Java代码中封装的辅助消息类型为<em>ScheduledMessage</em>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = <span class="number">3</span> * <span class="number">1000</span>; <span class="comment">//延迟投递的时间，每3秒</span></span><br><span class="line"><span class="keyword">long</span> period = <span class="number">4</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> repeat = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);</span><br><span class="line">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);</span><br><span class="line"></span><br><span class="line">messageProducer.send(mesage);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="ActiveMQ消费重试机制"><a href="#ActiveMQ消费重试机制" class="headerlink" title="ActiveMQ消费重试机制"></a>ActiveMQ消费重试机制</h2><ul><li><p>哪些情况会引起消息重发？</p></li><li><p>消息重发时间间隔和重发次数</p></li><li><p>有毒消息Posion ACK</p></li></ul><p>reference <a href="activemq.apache.org/redelivery-policy">here</a></p><p>重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。</p><h2 id="如何保证消息不被重复消费（幂等性）"><a href="#如何保证消息不被重复消费（幂等性）" class="headerlink" title="如何保证消息不被重复消费（幂等性）"></a>如何保证消息不被重复消费（幂等性）</h2><p><strong>note</strong>: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。</p><ul><li><p>如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突</p></li><li><p>使用第三方服务来做消费记录。以redis为例，给消息分配一个<strong>全局id</strong>，只要消费过该消息，将&lt;id, message&gt;以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。&lt;/p&gt;</summary>
    
    
    
    <category term="MiddleWare" scheme="http://github.com/sebastian/about/categories/MiddleWare/"/>
    
    
    <category term="activemq" scheme="http://github.com/sebastian/about/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>subsets</title>
    <link href="http://github.com/sebastian/about/2020/06/27/subsets/"/>
    <id>http://github.com/sebastian/about/2020/06/27/subsets/</id>
    <published>2020-06-27T15:09:34.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>Return all possible subsets(the power set).</p><a id="more"></a><h1 id="5460-Number-of-Good-Pairs"><a href="#5460-Number-of-Good-Pairs" class="headerlink" title="5460. Number of Good Pairs"></a>5460. Number of Good Pairs</h1><p>Given an array of integers <code>nums</code>.</p><p>A pair (i, j) is called <em>good</em> if <code>nums[i] == nums[j]</code> and <code>i &lt; j</code>.</p><p>Return the numbers of <em>good</em> pairs.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1,1,3]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Each pair in the array are good.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><ul><li>蛮力法获取到所有重复的数字，如何解出符合要求的解？</li><li>用什么数据结构保存数组和对应的下标以保证遍历一次数组而不是两次？</li><li>利用递归求解应该是个不错的选择。</li></ul><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>想多了。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里i、j的命名与题目相反，思路结果是ok的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h1><p>Given a set of distinct integers, <em>nums</em>, return all possible</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> value: nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; a:result)&#123;</span><br><span class="line">            temp.add(<span class="keyword">new</span> ArrayList&lt;&gt;(a));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; a:temp)&#123;</span><br><span class="line">            a.add(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; single = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        single.add(value);</span><br><span class="line">        temp.add(single);</span><br><span class="line"></span><br><span class="line">        result.addAll(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的工作都在一个for循环中完成了，return前的一次add是加入空表，因为空也是原数组的一个子集。来看看for循环中做了什么，把result中的线性表赋给临时表、往临时表中的每个元素添加目前正在遍历的元素、往临时表中作为独立元素添加目前正在遍历的元素，最后是将临时表赋给result。</p><h1 id="90-Subset-II"><a href="#90-Subset-II" class="headerlink" title="90. Subset II"></a>90. Subset II</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Return all possible subsets(the power set).&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://github.com/sebastian/about/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>goodleTest</title>
    <link href="http://github.com/sebastian/about/2020/06/22/goodleTest/"/>
    <id>http://github.com/sebastian/about/2020/06/22/goodleTest/</id>
    <published>2020-06-22T06:38:50.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>googletest，顾名思义，google公司研发的测试框架，适用于C++，协助完成包括单元测试在内的各种类型测试。</p><a id="more"></a><p>谷歌测试团队的理念：</p><ol><li>测试应该是独立且可重复的。</li><li>测试应该是被组织良好的，并且能反映出测试代码的架构。</li><li>测试应该是可拔插、可重用的。</li><li>当测试失败，应该有足够多的问题信息。</li><li>测试框架应该帮助开发人员专注于测试内容，琐碎的事情由框架完成。</li><li>测试的速度应该足够快。</li></ol><p>googletest基于<code>xUnit架构</code>，用过JUnit或者PyUnit的再使用它应该不会陌生。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>注意区分Test, Test Case, Test Suite</p><table><thead><tr><th>Meaning</th><th>googletest Term</th><th>ISTQB Term</th></tr></thead><tbody><tr><td>涉及特定输入输出的测试代码</td><td>TEST()</td><td>Test Case</td></tr></tbody></table><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>tests 使用<strong>断言</strong>来验证测试代码</li><li>test suit 可以裂解为“测试套装”，包含一个或多个tests，多个tests来反映测试代码的结构，一个test suit中多个tests应该是有共享的对象。</li><li>test program 包含多个“测试套装”。</li></ul><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>有<code>ASSERT_*</code>和<code>EXPECT_*</code>。前者会在遇到异常时抛弃当前的方法，后者在遇到非致命的故障时不会抛弃。通常，后者用的比较多，因为输出的异常信息会更多。</p><p>还可以自定义异常消息，使用<strong>stream</strong>特性，可以借助<code>&lt;&lt;</code>来实现，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASSERT_EQ(x.<span class="built_in">size</span>(), y.<span class="built_in">size</span>()) &lt;&lt; <span class="string">&quot;Vectors x and y are of unequal length&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;x.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">    EXPECT_EQ(x[i], y[i]) &lt;&lt; <span class="string">&quot;Vectors x and y differ at index &quot;</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在断言后加上可能出现的异常，好比java中的<code>try-catch</code>块中，不打印异常信息而输出自定义的信息。</p><h2 id="true-false断言"><a href="#true-false断言" class="headerlink" title="true/false断言"></a>true/false断言</h2><table><thead><tr><th>fatal assertion</th><th>nonfatal assertion</th><th>verifies</th></tr></thead><tbody><tr><td>ASSERT_TRUE(condition);</td><td>EXPECT_TRUE(condition);</td><td>condition is true</td></tr><tr><td>ASSERT_FALSE(condition);</td><td>EXPECT_FALSE(condition);</td><td>condition is false</td></tr></tbody></table><p>出现异常时，<code>ASSERT_*</code>会在出现异常的部分返回，不继续进行（类比java中的throw，抛出异常），而<code>EXPECT_*</code>会继续执行后续的代码（类比java中的try-catch块捕捉异常）。但是无论哪种，断言失败都意味着测试失败。</p><h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><p>需要熟悉简写，如EQ、NE、LT……</p><table><thead><tr><th>Fatal assertion</th><th>Nonfatal assertion</th><th>Verifies</th></tr></thead><tbody><tr><td>ASSERT_EQ(val1, val2);</td><td>EXPECT_EQ(val1, val2);</td><td>val1 == val2</td></tr><tr><td>ASSERT_NE(val1, val2);</td><td>EXPECT_EQ(val1, val2);</td><td>val1 !=  val2</td></tr><tr><td>ASSERT_LT(val1, val2);</td><td>EXPECT_LT(val1, val2);</td><td>val1 &lt; val2</td></tr><tr><td>ASSERT_LE(val1, val2);</td><td>EXPECT_LE(val1, val2);</td><td>val1 &lt;= val2</td></tr><tr><td>ASSERT_GT(val1, val2);</td><td>EXPECT_GT(val1, val2);</td><td>val1 &gt; val2</td></tr><tr><td>ASSERT_GE(val1, val2);</td><td>EXPECT_GE(val1, val2);</td><td>val1 &gt;= val2</td></tr></tbody></table><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>注意区分C-strings和string对象的区别。比较两个string对象使用<code>EXPECT_EQ</code>，<code>EXPECT_NE</code>这些方式，参见上方。</p><table><thead><tr><th>Fatal assertion</th><th>Nonfatal assertion</th><th>Verifies</th></tr></thead><tbody><tr><td>ASSERT_STREQ(str1, str2);</td><td>EXPECT_STREQ(str1, str2);</td><td>same content</td></tr><tr><td>ASSERT_STRNE(str1, str2);</td><td>EXPECT_STRNE(str1, str2);</td><td>different contents</td></tr><tr><td>ASSERT_STRCASEEQ(str1, str2);</td><td>EXPECT_STRCASEEQ(str1, str2);</td><td>same content, ignoring case(lower/capital)</td></tr><tr><td>ASSERT_STRCASENE(str1, str2);</td><td>EXPECT_STRCASENE(str1, str2);</td><td>different content, ignoring case</td></tr></tbody></table><h1 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEST(TestSuiteName, TestName)&#123;</span><br><span class="line">    ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意两个入参都要满足c++的命名规范，且不能有下划线。</p><p>例如，有一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// Return the factorial of n</span></span><br></pre></td></tr></table></figure><p>那么它的测试函数可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tests factorial of 0.</span></span><br><span class="line">TEST(FactorialTest, HandlesZeroInput) &#123;</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line">TEST(FactorialTest, HandlesPositiveInput) &#123;</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">2</span>), <span class="number">2</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">3</span>), <span class="number">6</span>);</span><br><span class="line">  EXPECT_EQ(Factorial(<span class="number">8</span>), <span class="number">40320</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>googletest通过test suits把测试分组，上买能的函数中，虽然有两个（<code>HandlesZeroInput</code>, <code>handlesPositiveInput</code>），但是都属于<code>FacotrialTest</code>，跟Java的命名规范有区别。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;googletest，顾名思义，google公司研发的测试框架，适用于C++，协助完成包括单元测试在内的各种类型测试。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://github.com/sebastian/about/categories/C/"/>
    
    
    <category term="test" scheme="http://github.com/sebastian/about/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>decorating</title>
    <link href="http://github.com/sebastian/about/2020/06/12/decorating/"/>
    <id>http://github.com/sebastian/about/2020/06/12/decorating/</id>
    <published>2020-06-12T10:30:28.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。</p><a id="more"></a><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是<code>Beverage</code>抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso… 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。</p><p>如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？</p><blockquote><p>类应该堆扩展开放，对修改关闭。</p></blockquote><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。</p><ol><li>DarkRoast对象</li><li>用摩卡装饰</li><li>用奶泡装饰</li><li>调用cost方法，依赖delegate添加价钱</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png" alt="Screenshot from 2020-06-12 20-50-33.png"></p><p>其中<code>Condiment</code>是调料类，重写了<code>Beverage</code>的<code>getDescription</code>方法。以Whip为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> .<span class="number">30</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的_cost_方法入获取description的方法如出一辙，这样的好处在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage1 = <span class="keyword">new</span> DarRoast();</span><br><span class="line">beverage1 = <span class="keyword">new</span> Mocha(beverage1);</span><br><span class="line">beverage1 = <span class="keyword">new</span> Mocha(beverage1);</span><br><span class="line">beverage1 = <span class="keyword">new</span> Whip(beverage1);</span><br><span class="line">System.out.println(beverage1.getDescription() + <span class="string">&quot; $&quot;</span> + beverage1.cost());</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75</span><br></pre></td></tr></table></figure><p>制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为<strong>委托</strong>.</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><p>大量的<code>Decorator Pattern</code>在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">para1&#x3D;&gt;parallel: FileInputStream</span><br><span class="line">para2&#x3D;&gt;parallel: BufferedInputStream</span><br><span class="line">para3&#x3D;&gt;parallel: LineNumberInputStream</span><br><span class="line">op1&#x3D;&gt;operation: Beferage</span><br><span class="line">op2&#x3D;&gt;operation: Espresso</span><br><span class="line">op3&#x3D;&gt;operation: Mocha</span><br><span class="line">para1(path1, bottom)-&gt;para2</span><br><span class="line">para2(path1,bottom)-&gt;para3</span><br><span class="line">para1(path2, right)-&gt;op1</span><br><span class="line">para2(path2, right)-&gt;op2</span><br><span class="line">para3(path2, right)-&gt;op3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="design_patterns" scheme="http://github.com/sebastian/about/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>observer</title>
    <link href="http://github.com/sebastian/about/2020/06/12/observer/"/>
    <id>http://github.com/sebastian/about/2020/06/12/observer/</id>
    <published>2020-06-12T09:12:38.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？</p><a id="more"></a><p>一个好的设计模式能拯救一堆代码。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">WeatherData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getTemperature()&#123;&#125;;</span><br><span class="line">    getHumidity()&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一旦气象更新，此方法会被调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    measuremetnsChanged()&#123;</span><br><span class="line">        <span class="comment">// our codes go here</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接在<code>measuremetnsChanged</code>这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measuremetnsChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class="line">    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>先看看我们平时是怎么浏览微信订阅号消息：</p><p>首先整个流程应该有两个参与者</p><ul><li>订阅号运营者</li><li>订阅者</li></ul><p>订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。</p><p>那么观察者模式也类似：</p><blockquote><p>订阅号运营者+订阅者=观察者模式</p></blockquote><p>不一样的是名称，订阅号运营者改为“subject”（主题），订阅者改为”observer”（观察者）。</p><p>由于一个主题可以被多个观察者订阅，所以，它实现了对象之间<strong>一对多</strong>；同时，这种对象设计也让主题和观察者之间<strong>松耦合</strong>.</p><p>对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png" alt="Screenshot from 2020-06-12 18-03-04.png"></p><p>我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">    weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。</p><p>完整代码参考：<a href="https://github.com/Sebastian-Getts/designPatternsPractice">项目传送门</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="design_patterns" scheme="http://github.com/sebastian/about/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>FS</title>
    <link href="http://github.com/sebastian/about/2020/06/09/FS/"/>
    <id>http://github.com/sebastian/about/2020/06/09/FS/</id>
    <published>2020-06-09T15:41:57.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>FastDFS, TFS, GFS, HDFS, OSS …</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FastDFS, TFS, GFS, HDFS, OSS …&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="fs" scheme="http://github.com/sebastian/about/tags/fs/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://github.com/sebastian/about/2020/06/09/redis/"/>
    <id>http://github.com/sebastian/about/2020/06/09/redis/</id>
    <published>2020-06-09T13:54:01.000Z</published>
    <updated>2020-08-06T12:11:06.098Z</updated>
    
    <content type="html"><![CDATA[<p>常用redis，深入了解redis的性能和瓶颈。<a href="https://github.com/antirez/redis">reference</a></p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>redis: <strong>内存</strong>中的数据结构存储系统，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>，nosql的一种。</p><h2 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h2><p>关系型数据库不够用，出来了nosql。。。</p><ol><li>一开始单体应用，小用户量能承受。但是当体量变大时：<ul><li>数据量大</li><li>数据的索引大</li><li>访问量大</li></ul></li><li>读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层<strong>memcache</strong>缓存</li><li>集群（水平拆分）：上面的读写分离copy多份。</li></ol><p>mysql早些年使用的是MyISAM引擎，特性是<strong>表锁</strong>（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了<strong>行锁</strong>。</p><p>不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。</li><li>大数据量也高性能（写8万次/秒，读11万次/秒）</li><li>多样型，不需要事先设计数据库</li><li>没有固定的查询语言；最终一致性</li><li>键值对存储，列存储，文档存储，图形存储库（社交）</li><li>高性能、高可用、高可扩</li><li>CAP、BASE，异地多活</li><li>多样、实时、并发（Volume, Variety, Veiocity）</li></ol><p>与关系型一起使用。</p><p>商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）</p><p>商品的基本信息（价格、商家、名称）：MySQL</p><p>图片：FastDFS, GFS, HDFS, OSS…</p><p>商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）</p><p>==没有什么不是加以层解决不了的==： 统一服务层。</p><h3 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h3><p>MongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。</p><h3 id="KV键值对"><a href="#KV键值对" class="headerlink" title="KV键值对"></a>KV键值对</h3><p>Redis，Tair</p><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h3><p>HBase（大数据）</p><p>分布式文件系统</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>类似知识图谱，不是存储图形。主要用于存储社交网络。</p><p>Neo4j，InfoGrid。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Remote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。</p><ul><li>内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）</li><li>计时器、计数器（浏览量）</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>安装后自带的测试工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h localhost -p 6379 -100 -n 100000</span><br></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>默认16个数据库且使用的是第0个。 </p><h3 id="GEOSPATIAL"><a href="#GEOSPATIAL" class="headerlink" title="GEOSPATIAL"></a>GEOSPATIAL</h3><p>地理位置，不仅仅是GET、SET！根据经纬度获取距离。</p><h2 id="springboot集成"><a href="#springboot集成" class="headerlink" title="springboot集成"></a>springboot集成</h2><p>版本&lt;2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。</p><p>版本&gt;2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p><h2 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h2><p>为什么会有这个rdb？</p><p>redis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: start</span><br><span class="line">end&#x3D;&gt;end: end</span><br><span class="line">condition&#x3D;&gt;condition: 触发rdb</span><br><span class="line">rdbfile&#x3D;&gt;inputoutput: dump.rdb</span><br><span class="line">operation&#x3D;&gt;operation: go on dealing with</span><br><span class="line"></span><br><span class="line">start-&gt;condition</span><br><span class="line">condition(yes)-&gt;rdbfile-&gt;end</span><br><span class="line">condition(no)-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><ol><li>save的规则</li><li>执行flushall</li><li>退出redis</li></ol><p>产生备份，会自动生成一个dump.rdb</p><h4 id="用rdb恢复"><a href="#用rdb恢复" class="headerlink" title="用rdb恢复"></a>用rdb恢复</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get dir</span><br></pre></td></tr></table></figure><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>适合大数据</li><li>对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>需要一定的时间间隔进程操作</li><li>fork进程的时候会占用一定的内容空间</li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Append Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。</p><ul><li>大数据的情况下效率会比较低。</li><li>默认是不开启的。</li></ul><p>开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。</p><p>修复aof文件 <code>redis-check-aof --fix</code></p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ol><li>每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据</li><li>从不同步效率最高</li></ol><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>相对于数据文件，aof远大于rdb，修复的速度比rdb慢</li><li>默认是rdb，效率自然高于aof。</li></ol><p><strong>与rdb混合使用</strong></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。</p><p>作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石</p><p>reids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。</p><p>默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication # 查看当前库的信息</span><br></pre></td></tr></table></figure><p>一般情况下只用配置从机即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF ip:port # ip:port为主机</span><br></pre></td></tr></table></figure><p>上面的是命令配置，只是暂时的。<strong>实际生产应该修改配置文件</strong>，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。</p><h4 id="如果主机宕机了呢？"><a href="#如果主机宕机了呢？" class="headerlink" title="如果主机宕机了呢？"></a>如果主机宕机了呢？</h4><p>默认情况下，主机挂了以后，用<code>info replication</code>查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。</p><p>更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。</p><ul><li>全量复制 master将整个数据传送到slaver</li><li>增量复制</li></ul><p>只要重新链接master，一次全量复制将被自动执行</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>Sentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p><p>哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>集群</li><li>主从切换</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>不方便在线扩容，一旦到达上线。</li><li>配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。</li></ol><h2 id="redis异常处理"><a href="#redis异常处理" class="headerlink" title="redis异常处理"></a>redis异常处理</h2><h3 id="缓存穿透（一直查询不到）"><a href="#缓存穿透（一直查询不到）" class="headerlink" title="缓存穿透（一直查询不到）"></a>缓存穿透（一直查询不到）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start&#x3D;&gt;start: request</span><br><span class="line">end&#x3D;&gt;end: response</span><br><span class="line">condition&#x3D;&gt;condition: redis缓存中是否存在</span><br><span class="line">op1&#x3D;&gt;operation: select in mysql</span><br><span class="line">start-&gt;condition</span><br><span class="line">condition(yes)-&gt;end</span><br><span class="line">condition(no)-&gt;op1-&gt;end</span><br></pre></td></tr></table></figure><p>如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><p>活力集中在一个点（一个热评的点，如微博）。</p><h4 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h4><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h4><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。</p><h4 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h4><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><p>正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用redis，深入了解redis的性能和瓶颈。&lt;a href=&quot;https://github.com/antirez/redis&quot;&gt;reference&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="DB" scheme="http://github.com/sebastian/about/categories/DB/"/>
    
    
    <category term="redis" scheme="http://github.com/sebastian/about/tags/redis/"/>
    
    <category term="nosql" scheme="http://github.com/sebastian/about/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>heap</title>
    <link href="http://github.com/sebastian/about/2020/06/06/heap/"/>
    <id>http://github.com/sebastian/about/2020/06/06/heap/</id>
    <published>2020-06-06T14:54:27.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>这里的堆是数据结构中的堆，不是JVM中的堆。</p><p>关键词：堆，二叉树，优先级队列，排序，topN</p><a id="more"></a><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。    </p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul><li>路径长度是指路径上的边数</li><li>结点深度是指从根结点到该结点的路径的长度</li><li>每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置</li></ul><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><ul><li>完全二叉树</li><li>每个结点大于或等于它的任意一个孩子</li></ul><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>可以将二叉堆用数组来存储。</p><p>例如如下一个二叉堆：</p><p><img src="https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png" alt="Screenshot from 2020-06-06 15-24-34.png"></p><p>在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}</p><p>可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题</p><h2 id="TOP-N"><a href="#TOP-N" class="headerlink" title="TOP N"></a>TOP N</h2><p>给一组数据，求其中最大/小的几个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最小的n个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topN(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// default big heap, lambda make it small heap</span></span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n, ((o1, o2) -&gt; Integer.compare(o2, o1)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : array) &#123;</span><br><span class="line">        <span class="comment">// put the integer in when it smaller than the top of integer</span></span><br><span class="line">        <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; n || e &lt; heap.peek()) &#123;</span><br><span class="line">            heap.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &gt; n) &#123;</span><br><span class="line">            <span class="comment">// delete the top of heap integer</span></span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">        res[j++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。</p><p>稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认大顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e: array)&#123;</span><br><span class="line">    <span class="comment">// 大于堆顶的放入优先级队列</span></span><br><span class="line">    <span class="keyword">if</span>(heap.isEmpty() || heap.size() &lt; n || e &gt; heap.peak())&#123;</span><br><span class="line">        heap.offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过要求的个数，清除堆顶元素</span></span><br><span class="line">    <span class="keyword">if</span>(heap.size() &gt; n)&#123;</span><br><span class="line">        heap.pool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里的堆是数据结构中的堆，不是JVM中的堆。&lt;/p&gt;
&lt;p&gt;关键词：堆，二叉树，优先级队列，排序，topN&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="datastructure" scheme="http://github.com/sebastian/about/tags/datastructure/"/>
    
  </entry>
  
  <entry>
    <title>regex</title>
    <link href="http://github.com/sebastian/about/2020/06/01/regex/"/>
    <id>http://github.com/sebastian/about/2020/06/01/regex/</id>
    <published>2020-06-01T15:38:31.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    <content type="html"><![CDATA[<p>Java正则表达式介绍及应用。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>regular expression =&gt; regex。用来描述<strong>匹配</strong>一个字符串集合的<strong>模式</strong>，可以用它来匹配、替换和分割字符串。</p><p>Java里String的方法matches(xxxx)，其中就可以装载正则表达式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java正则表达式介绍及应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="regex" scheme="http://github.com/sebastian/about/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>bitwise</title>
    <link href="http://github.com/sebastian/about/2020/06/01/bitwise/"/>
    <id>http://github.com/sebastian/about/2020/06/01/bitwise/</id>
    <published>2020-06-01T13:11:25.000Z</published>
    <updated>2020-08-08T15:57:25.149Z</updated>
    
    <content type="html"><![CDATA[<p>Introduction of Java bitwise and operation.</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><table><thead><tr><th>操作符</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>1 &amp; 1 = 1 (only)</td></tr><tr><td>|</td><td>或</td><td>0 | 0 = 0 (only)</td></tr><tr><td>^</td><td>异或</td><td>1 ^ 0 = 1</td></tr><tr><td>~</td><td>非</td><td>~ 1 = 0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>右边空出来的补0</td></tr><tr><td>&gt;&gt;</td><td>带符号位右移</td><td>最高位补符号位</td></tr><tr><td>&gt;&gt;&gt;</td><td>无符号位右移</td><td>左边空出来的补0</td></tr></tbody></table><p>位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，&lt;&lt;=以及&gt;&gt;&gt;=。</p><p>位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 11111111111111111111111111111111111(32个1)</span></span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">System.out.printlnl(a&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1111111111111111111111111111111111(32个1)</span></span><br><span class="line">System.out.println(Integer.toBinaryString(a&gt;&gt;<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(a&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 0111111111111111111111111111111111(31个1)</span></span><br><span class="line">System.out.prinlnt(Integer.toBinaryString(a&gt;&gt;&gt;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="a-gt-gt-1"><a href="#a-gt-gt-1" class="headerlink" title="a&gt;&gt;1"></a>a&gt;&gt;1</h4><p>原码：10000000000000000000000000000001</p><p>反码：1111111111111111111111111111111111110</p><p>补码：1111111111111111111111111111111111111</p><p>补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）</p><p>取反：10000000000000000000000000000000</p><p>原码：10000000000000000000000000000001 即 -1.</p><h4 id="a-gt-gt-gt-1"><a href="#a-gt-gt-gt-1" class="headerlink" title="a&gt;&gt;&gt;1"></a>a&gt;&gt;&gt;1</h4><p>同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。</p><p>补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）</p><p>正数原码即补码。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的<code>^</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;&lt;</code>等位运算符。</p><h2 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &amp; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">8</span> &amp; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="number">7</span> &amp; <span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>1的原码：0001</p><p>8的原码：1000</p><p>7的原码：0111</p><p>奇数的最低位永远是1,偶数的为0.</p><h2 id="求非重复数字"><a href="#求非重复数字" class="headerlink" title="求非重复数字"></a>求非重复数字</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ^ 2 ^ 1 = 1</span><br><span class="line">4 ^ 2 ^ 1 ^ 1 ^ 2 = 4</span><br></pre></td></tr></table></figure><p>两个<strong>相同的数字</strong>做<code>^</code>运算时，值为<code>0</code>，再结合<strong>交换律</strong>，可以用来找出一组数字中“落单”的数字。</p><h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><p>……</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Introduction of Java bitwise and operation.&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="bitwise" scheme="http://github.com/sebastian/about/tags/bitwise/"/>
    
  </entry>
  
  <entry>
    <title>elasticSearch</title>
    <link href="http://github.com/sebastian/about/2020/05/30/elasticSearch/"/>
    <id>http://github.com/sebastian/about/2020/05/30/elasticSearch/</id>
    <published>2020-05-30T12:42:30.000Z</published>
    <updated>2020-07-19T17:29:13.366Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>reflect</title>
    <link href="http://github.com/sebastian/about/2020/05/27/annotation/"/>
    <id>http://github.com/sebastian/about/2020/05/27/annotation/</id>
    <published>2020-05-26T16:31:17.000Z</published>
    <updated>2020-08-20T15:01:48.201Z</updated>
    
    <content type="html"><![CDATA[<p>java反射，lang包下的relect包中存放了关于反射相关的实现，通过反射java可以在运行时完成一些动作（如获取值）。反射是框架的基础，平时用的原生注解、自定义注解、以及代理，都离不开反射。</p><a id="more"></a><h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><p>在程序执行期间可以通过Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p>Normal: class -&gt; new -&gt; object</p><p>Reflect: object -&gt; getClass() -&gt; class</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>在运行时代码可以根据某些条件改变自身结构。</p><p>i.e. Object-C, C#, JavaScrit, PHP, Pthon and etc.</p><h3 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h3><p>i.e. Java, C, C++</p><ul><li>Java也有一定的动态性，利用反射机制获得相关特性。</li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Java反射的源头，通过对象反射求出类的名字。</p><p>在Object类中定义了一个方法，自然而然会被所有子类继承：</p><blockquote><p>public final Class getClass()</p></blockquote><h2 id="META-ANNOTATION"><a href="#META-ANNOTATION" class="headerlink" title="META_ANNOTATION"></a>META_ANNOTATION</h2><ul><li><strong>@Target</strong> 用于描述注解的使用范围</li><li><strong>@Retention</strong> 表示需要在什么级别保存该注解信息，描述注解的生命周期（Source&lt;CLASS&lt;<strong>RUNTIME</strong>)，一般默认RUNTIME。</li><li>@Document 说明注解将被包含在JAVADOC中</li><li>@Inherited 说明子类可以继承父类的该注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementTYpe.TYPE,ELementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation()&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是自定义注解的基本格式，内部的参数如<code>name</code>则是在使用注解时填写的，<code>default</code>表明了他的默认值，同时也说明这个参数是选填的。例如使用时如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(name = &quot;Gloria&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">TestAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MyAnnotation(name = &quot;Manny&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beLucky</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在框架中使用了注解，一般都是会去处理（当然，谁也不会定义一个毫无用处的注解），我们自定义注解也是一样，通常会与<strong>切面</strong>结合使用。为什么呢？因为注解的出现是为了方便开发，减少代码量（尤其是配置），所以我们会去集中处理标记了某个注解的方法，通过切面我们可以定义标注了某个注解的方法/类来处理他们。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>用途三三两两就讲完了，其实很多，可以参考源码。下面说说他的实现原理。</p><p>我们都知道，反射离不开<code>Class</code>，那么他是怎么出现的呢？JVM！这得从类加载开始说起，当java代码编译完后成了字节码文件（xx.class）时jvm就可以加载它啦，通过类加载器，他就成为了Class对象，他的相关结构信息会被保存在方法区。被创建出来的对象存在于堆中，通过反射，可以从对象获取到他的结构信息，有点像通过儿子爸爸很像，通过儿子推理出爸爸的样子。具体什么结构信息呢？加载在方法上、类上的注解。当然更详细的等我看完JVM的书！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;java反射，lang包下的relect包中存放了关于反射相关的实现，通过反射java可以在运行时完成一些动作（如获取值）。反射是框架的基础，平时用的原生注解、自定义注解、以及代理，都离不开反射。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://github.com/sebastian/about/categories/Java/"/>
    
    
    <category term="annatation, reflect" scheme="http://github.com/sebastian/about/tags/annatation-reflect/"/>
    
  </entry>
  
</feed>
