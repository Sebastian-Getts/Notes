{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/tranquilpeak/source/assets/css/gitalk.css","path":"assets/css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/all.css","path":"assets/css/all.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/gitment.css","path":"assets/css/gitment.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/jquery.fancybox.css","path":"assets/css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/style-xsmpikcbczzhpff1zqybzgesjqcgmkdkx9b5ntr0bkmk6wqucpktuaodiuvy.min.css","path":"assets/css/style-xsmpikcbczzhpff1zqybzgesjqcgmkdkx9b5ntr0bkmk6wqucpktuaodiuvy.min.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/style.css","path":"assets/css/style.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/thumbs.css","path":"assets/css/thumbs.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/tranquilpeak.css","path":"assets/css/tranquilpeak.css","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.eot","path":"assets/fonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.svg","path":"assets/fonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.ttf","path":"assets/fonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff","path":"assets/fonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff2","path":"assets/fonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.eot","path":"assets/fonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.svg","path":"assets/fonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.ttf","path":"assets/fonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff","path":"assets/fonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff2","path":"assets/fonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.eot","path":"assets/fonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.svg","path":"assets/fonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.ttf","path":"assets/fonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff","path":"assets/fonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff2","path":"assets/fonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold-italic.ttf","path":"assets/fonts/merriweather-bold-italic.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold.ttf","path":"assets/fonts/merriweather-bold.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light-italic.ttf","path":"assets/fonts/merriweather-light-italic.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light.ttf","path":"assets/fonts/merriweather-light.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather.ttf","path":"assets/fonts/merriweather.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans-bold.ttf","path":"assets/fonts/open-sans-bold.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans.ttf","path":"assets/fonts/open-sans.ttf","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/avatar.png","path":"assets/images/avatar.png","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/cover-v1.2.0.jpg","path":"assets/images/cover-v1.2.0.jpg","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/cover.jpg","path":"assets/images/cover.jpg","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/logo-algolia-nebula-blue-full.svg","path":"assets/images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/algoliasearch.js","path":"assets/js/algoliasearch.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/gitalk.js","path":"assets/js/gitalk.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/gitment.js","path":"assets/js/gitment.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/jquery.fancybox.js","path":"assets/js/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/jquery.js","path":"assets/js/jquery.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/moment-with-locales.js","path":"assets/js/moment-with-locales.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/script-jsoeqoqa2ajw9nwj0xf5gmftvb2jhopk3sxu8iodabvev2jdlmr0zsitv3jm.min.js","path":"assets/js/script-jsoeqoqa2ajw9nwj0xf5gmftvb2jhopk3sxu8iodabvev2jdlmr0zsitv3jm.min.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/script.js","path":"assets/js/script.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/thumbs.js","path":"assets/js/thumbs.js","modified":1,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/tranquilpeak.js","path":"assets/js/tranquilpeak.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/2020-end.md","hash":"cd9d0d511e27515685c37ea1a249f8c606fe8888","modified":1614405584586},{"_id":"source/_posts/Spring-Security-AutoConfiguration.md","hash":"14d9ad71bb0b36627e8914f10a2150a307c7e887","modified":1616512559311},{"_id":"source/_posts/binary-search-tre.md","hash":"3646de1d1af4fe0be97eb6e020037f1d44de460d","modified":1614959386597},{"_id":"source/_posts/SpringBoot-startup.md","hash":"97c48ae12de074a609da926ad8431651aa9ad6c0","modified":1613536017895},{"_id":"source/_posts/bitwise.md","hash":"e432378421cad9c100e07bd267360fcbf4e415e0","modified":1604820016381},{"_id":"source/_posts/contest201.md","hash":"bd260341d42c02016a549ee95cbfa97d50c3f513","modified":1604820016385},{"_id":"source/_posts/contest200.md","hash":"c68b5064a92a3fcbd3f84c348dea4bfbdc684ebb","modified":1604820016385},{"_id":"source/_posts/contest202.md","hash":"ff7d44f03dd7681bb0b3d8cf862af07a4a29a40f","modified":1604820016385},{"_id":"source/_posts/contest203.md","hash":"506cdc75078718c8bf5643df8416f5e9dce1b812","modified":1604820016385},{"_id":"source/_posts/heap.md","hash":"712bd551b9ec195eacc671ba92e05fd20a592322","modified":1604820016385},{"_id":"source/_posts/hashmap.md","hash":"8a724a0f8f48897c5561d0485de33d3ec76ce0b9","modified":1608038748842},{"_id":"source/_posts/decorating.md","hash":"12c546c129e1b38f89c7d28f03044fd377f55e47","modified":1616568253967},{"_id":"source/_posts/https.md","hash":"14a02c81c40ec171d0129f5ed75c6207df3e30ce","modified":1604820016385},{"_id":"source/_posts/java-collection-framework.md","hash":"0a52e07f02965bf5339d81767c402adcd5c389fc","modified":1615040336499},{"_id":"source/_posts/SpringBoot-environment.md","hash":"9deec8cc3107afa9d6710501504a7d2fcd3d1b52","modified":1613567556286},{"_id":"source/_posts/SpringBoot-refresh.md","hash":"1ce8dad48c033049bb5e7a24dfc8bb453b1ff53e","modified":1613547972104},{"_id":"source/_posts/jvm.md","hash":"4439ba1ea8ce8e50902e9200e18e28e3e1d6b0e8","modified":1616514034973},{"_id":"source/_posts/mq.md","hash":"cba47c0da597e997b680bd69c9d1880f4e613c4e","modified":1604820016385},{"_id":"source/_posts/lock.md","hash":"c8c80b88f63bfb80eded1cc7505718b07651a0c1","modified":1604820016385},{"_id":"source/_posts/mybatis-autoconfiguration.md","hash":"9d3fffb10c86a004bb7bc7d92b07823407094f0c","modified":1616422553417},{"_id":"source/_posts/mybatis-sql-resolution.md","hash":"3235b26577fa7ec318b0cd9349e7ff4f853e104b","modified":1616512534075},{"_id":"source/_posts/kafka.md","hash":"63c58e790291526a93f022e539758f76a9a83c3a","modified":1604820016385},{"_id":"source/_posts/observer.md","hash":"490d5864c09f76ff42ddf243a6aa9d75932ae044","modified":1604820016385},{"_id":"source/_posts/nginx.md","hash":"43adb94f931736a928d1b2c80bc1b8513d244168","modified":1604820016385},{"_id":"source/_posts/redis.md","hash":"bdc31bde46b4e469d2ef9bcdbc25db0a146fd6d0","modified":1604820016385},{"_id":"source/_posts/uml.md","hash":"3486af2f10efacb5f68dd533568a78f042bfe992","modified":1604820016385},{"_id":"source/_posts/volatile.md","hash":"bfc35bbc8dea0ae74acd0e5d95e9ffcd0a27b0f8","modified":1604820016385},{"_id":"source/all-archives/index.md","hash":"fa34028baad36af6c9feb24ef61cc0f3b3c51746","modified":1604820016385},{"_id":"source/_posts/mybatis_preview.md","hash":"a1b8ac96382b277e100108039ed17346fbcaebd2","modified":1615115067952},{"_id":"source/about/index.md","hash":"1e566d57b2401c7787da33404bdcc9e97247d0f5","modified":1609423171091},{"_id":"source/_posts/subarray.md","hash":"65fd8c2bad3d17a7033f15a5365662a115eaf898","modified":1614411351857},{"_id":"source/_posts/springboot-servlet.md","hash":"c4904ec3449d3c6e71250ef260b825f4b197b0a0","modified":1614700114523},{"_id":"source/all-tags/index.md","hash":"9328f34da1aa2d20dadfdf895d6356720a484353","modified":1604820016385},{"_id":"source/tags/index.md","hash":"9c3e184d51c00399c9ab869d6345d6231025afa5","modified":1604820016385},{"_id":"source/all-categories/index.md","hash":"5ba8c7b70cc60dc7bf0cefeb22b4d9b86d1aa2e0","modified":1604820016385},{"_id":"source/categories/index.md","hash":"5ed5ee833af50b986e1a543ace747994814a7cb0","modified":1604820016385},{"_id":"source/top/index.md","hash":"9f7492a48015822ab20b5c3ca8356d15760667bb","modified":1604820016385},{"_id":"source/_posts/jvm-concurrency.md","hash":"b519a6b75f918944e4ba4ed7fef53508279ea0b7","modified":1616513551607},{"_id":"source/_posts/jvm-classloader.md","hash":"cd00eeefa2df7a7c8cd46ca697b5d8a1333b3090","modified":1616515723178},{"_id":"source/_posts/jvm-memory-manage.md","hash":"3f7226ec73b1b959ce5b6c7464be0acc56e78382","modified":1616688720978},{"_id":"themes/tranquilpeak/.gitignore","hash":"19e27dd778896662e6d604b69411d2dc3cf5fec6","modified":1599420980000},{"_id":"themes/tranquilpeak/DOCUMENTATION.md","hash":"daaa36cff0cf7aeb7682372d6697a55d6a0f2f5b","modified":1599420980000},{"_id":"themes/tranquilpeak/.eslintignore","hash":"1f78f00553adf9ee374b343191ed809b0f8ba073","modified":1599420980000},{"_id":"themes/tranquilpeak/.eslintrc","hash":"ea1da9c0b0863a612ace47bd336cff95497bd878","modified":1599420980000},{"_id":"themes/tranquilpeak/README.md","hash":"c18f2fea9ceeec6efa85d892df67a191d6c84ec5","modified":1599420980000},{"_id":"themes/tranquilpeak/LICENSE","hash":"7a3b30ddb56760b35a6b7cd210aeb271cd292b60","modified":1599420980000},{"_id":"themes/tranquilpeak/Gruntfile.js","hash":"b2b078651cf8c5dcde2e847169ce242ad3319ca3","modified":1599420980000},{"_id":"themes/tranquilpeak/_config.yml","hash":"f53e629d54a936d8ff8710af7e0cd2abe775a161","modified":1609694380775},{"_id":"themes/tranquilpeak/package.json","hash":"e7ae06164db660858af35a2183417a518b081a80","modified":1599420980000},{"_id":"themes/tranquilpeak/renovate.json","hash":"f902d35646d7a6a637f727b02cd832c4339a4ca9","modified":1599420980000},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE.md","hash":"ec6bf3eb708f8eb62736ede6d2080f6610849802","modified":1599420980000},{"_id":"themes/tranquilpeak/.github/CONTRIBUTING.md","hash":"8873700e439b6fc8aa4804b70a90fd81bf310d6c","modified":1599420980000},{"_id":"themes/tranquilpeak/.github/PULL_REQUEST_TEMPLATE.md","hash":"03cdb93ca72cd6a19043ea4bb1ec4f5b7479a0a9","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/de-DE.yml","hash":"c9a7514af3c5c58023f8d3ed9503be4253146015","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/es.yml","hash":"b5f37df87377d985339a21f343bf54db46926f1a","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/fa.yml","hash":"ec86c6fd655ed0c6df017c17f62b784b916d3a4a","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/fr-FR.yml","hash":"c644bb587a5360bb70a12c2d83f8d5973fb0055c","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/it-IT.yml","hash":"a5655d08a311f3292df5805ea2d6d72fd68726ca","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/.eslintrc.json","hash":"4cd7451f0bc15440bc8147912c63a11acd0e280f","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/ja.yml","hash":"3c6f7cda21ac91abc9f728e3093b1e98b42d5295","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/ko.yml","hash":"b56376775c5bc7f8f1d1b356340597cc61aae392","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/en.yml","hash":"a125cd554f890ba414c41a0b03375cfb4cb5622b","modified":1609694691672},{"_id":"themes/tranquilpeak/languages/ru.yml","hash":"262f781591cf2dd1584411ed4a780369d4d2e30a","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/zh-tw.yml","hash":"f04e0e91edacb8f6cae7308007bd5e5158e6c77e","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/zh-cn.yml","hash":"fea995175f5aeb58f8a958b00556bc2336d37a07","modified":1599420980000},{"_id":"themes/tranquilpeak/languages/pt-br.yml","hash":"e2edf45fae5a5290a3dc2111ef38d5cd40d43771","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/archive.ejs","hash":"0df1edf4ed40b316715ef1949b09aa9c98d22359","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/all-categories.ejs","hash":"c2257b8265a9a328e69c92f4a88cb2cdd99c047a","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/all-tags.ejs","hash":"aabb765f51a8d7582a5bafdbc8876b46ff1e6ea1","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/all-archives.ejs","hash":"28a4e97d1cfe4730dbcc8fde27b079320b5eec35","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/index.ejs","hash":"36e89b37f520533bef85fb32b714214257fad1d0","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/layout.ejs","hash":"29c1291c7ca3f5da7bee6385b7f716d179199933","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/category.ejs","hash":"67902c418e299399133fe2a7ebc39cadd17de861","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/page.ejs","hash":"ae761feddc98f4d3260e7591ed9fc91d9a49d0ab","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/filters/excerpt.js","hash":"5e0e473d46f8c7aac988ebf0b25ab2eab0af73bb","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/filters/thumbnail_image_url.js","hash":"0ad2d9304c991e2989708bdbfa6a59030ee691d3","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/helpers/absolute_url.js","hash":"0d520a946b6f0abbac60529017ed3133265aac60","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/helpers/generate_sharing_link.js","hash":"89069677e8acddef5fba0d3093f5f73fde4fa485","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/helpers/is_remote_url.js","hash":"471237ea295bcc9a392a5bb6738ef4c6ab673afb","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/helpers/json_ld.js","hash":"4cd07766ed9436f0c4cb8a9ae22644272918b837","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/tag.ejs","hash":"72bff1ae241fbe2ddca0537e8ed77c791a7d1766","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/tags/fancybox.js","hash":"55ce02f9ef084f43932eb9b0f10db1d5e9c3a250","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/post.ejs","hash":"ae761feddc98f4d3260e7591ed9fc91d9a49d0ab","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/helpers/resolve_asset_url.js","hash":"c813e9daaed374b386b91876923f10c0cf1d624c","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/tags/tabbed_codeblock.js","hash":"7dccd36bdd85c96eb7af125b30d634f44125700c","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/tags/alert.js","hash":"5b86358dd53c9b0d44c385ec12cf9e76383e229a","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/tags/image.js","hash":"ab6b04db8fe2ad21ec52dac5e1c3ee76400c6a79","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/tags/video.js","hash":"497d64fd454cc6fd5c26a42cb8e38db90b83cf4f","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/tags/highlight_text.js","hash":"8e093f21e9a4b10c19be6f300dc90bcc39685ec9","modified":1599420980000},{"_id":"themes/tranquilpeak/scripts/tags/wide_image.js","hash":"d3596c62694548a3a684e8dfeb5372038ef6f450","modified":1599420980000},{"_id":"themes/tranquilpeak/.github/workflows/nodejs.yml","hash":"595c32bcb8ba72cd0737c6009f24dabda12af834","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/pipeline.js","hash":"75b65cbd6d6ae471739ba80c9f792f602a0769d4","modified":1599420980000},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/feature-request---improvement.md","hash":"7d53b0c0d65dd28da17ff9d948e842883cab467f","modified":1599420980000},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/question.md","hash":"443c4f27268d39e89390edb7dcffda407a070fd7","modified":1599420980000},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/bug-report.md","hash":"b9a9ffe556f1fca39009403f87bb8c8e840dc369","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/about.ejs","hash":"c92588fcb4435e19b8c7e10fe24484aa6639060e","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/archive-post.ejs","hash":"e19455749c5c1bf773214d965f173613dd8f30f6","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/archive.ejs","hash":"bdd73d1f70bd91533863943f940f8193d44e0fdd","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/baidu-analytics.ejs","hash":"736eca2ecf6fdeea032d47c02c51688f006cafb4","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/cover.ejs","hash":"18b9a620fca9b648fd59467a66b3f4fdbba42613","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/google-analytics.ejs","hash":"b756aa731678a37d22c97c7dc30767331b08d109","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/header.ejs","hash":"94bde50d2911814ae08c4a9c681657cc3392c05b","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/head.ejs","hash":"52459d08c7d6b172124fa1ea09bd7414419fc779","modified":1607953738996},{"_id":"themes/tranquilpeak/layout/_partial/index.ejs","hash":"34d9260021e4b8b4bf232c2786d8e90e0db5bd20","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/footer.ejs","hash":"67962257d9e3cb6a4d56e3f0263f192ba9a413dd","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/pagination.ejs","hash":"89d3be71ff2f5a847850d50e117896056f0ca1a6","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/script.ejs","hash":"30f080e514007a8411b30373592d257407fe7aaf","modified":1607953738996},{"_id":"themes/tranquilpeak/layout/_partial/search.ejs","hash":"0fd5f75117912cd1e6e7e6094079bccdc79c0000","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/sidebar.ejs","hash":"39fb0c9f214cc36f4f96cbcacc832e542d723881","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-bold-italic.ttf","hash":"c1b8593dc9ddbf1a1a6268d31e08c4041448ed76","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-bold.ttf","hash":"e6d0ffb2d0348d9e22de97e57214b7db795e9513","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post.ejs","hash":"cdccf8f0ea1c01997fafdabb7cf044d3939cbb6c","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-light-italic.ttf","hash":"c3835119c62e78a21cfb33e2de6686fb4a5929a0","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-light.ttf","hash":"69bd3f15962cf91348a133d3d38571a5c67eca65","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_fonts/open-sans-bold.ttf","hash":"3823779db9f51a34658809ce66bdd6ed1145ed8e","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_fonts/open-sans.ttf","hash":"618b78a8f6ffe7e1998eab67268859e2ab54be8e","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather.ttf","hash":"d392237948e74246a2fb0d0d886498776a185e54","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/about.js","hash":"ce68bcc929192dfca6e699fe8e528990cd2d9590","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_images/avatar.png","hash":"fae7a4bc08bad88136de5f66c9abe97954741234","modified":1609693880725},{"_id":"themes/tranquilpeak/source/_js/.eslintrc.json","hash":"27d4e7223eee3eca7eb717bea2d28d35714eccbc","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_images/logo-algolia-nebula-blue-full.svg","hash":"d5e4426b6bd2d8b8c3f477f83d348d8f3b3ec1ca","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/archives-filter.js","hash":"8b8998b0e67c745a20450001c0739f6977b63309","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/categories-filter.js","hash":"a5f3c4b9bbef1c8ec881eb39551060ca95bfbb33","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/codeblock-resizer.js","hash":"391c2c9135579ea50c2060e0612e7105e06a8ff7","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/header.js","hash":"58ca619f851ebff35724c07dca7f1ed25e9cd5f2","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/fancybox.js","hash":"659aaad375ecff9748a5d3b0ff1378a549236513","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/image-gallery.js","hash":"90efc47246af69b7e17fab6e0bd1578043fcc2b0","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/post-bottom-bar.js","hash":"64f78c44d29d3559d5e14e436b8cfe1d24b8c965","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/share-options.js","hash":"c2046697540786721ff7c4754774f94fcaf32696","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/search-modal.js","hash":"7ea9ab668bc3118c28e6212516f366ef764d3550","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/sidebar.js","hash":"18dc623dd237c519bb79ce93283a5446cc11a487","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/smartresize.js","hash":"7342a21f94d7bb0525ccbd917d43a6824d7ae63e","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/tabbed-codeblocks.js","hash":"1282e11aacb036c8c9310cac49b75d7e2200125c","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_js/tags-filter.js","hash":"d33625df51d7b9788eeea338626f04387c96f053","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/tranquilpeak.scss","hash":"e69c62b19ece4ab35d992e163b47f2a8374d7611","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/build.js","hash":"f64c77127a2d4bfdbb9866fcf368913334f44603","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/buildProd.js","hash":"450ff77a1bf631d1799206d218c6468592a59862","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/compileAssets.js","hash":"a65122ba0d1a1b6044e3b635a644882577b628ba","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/default.js","hash":"80174db9b8a729980770e639e70999ce5a816b78","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/eslint.js","hash":"718cd8a80d060e2587b84e0e20ceaa39c2cc9411","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/linkAssets.js","hash":"079cd274cb29f9984eb7150d88f61819d2ef6235","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/linkAssetsProd.js","hash":"37f2fab80f25757be3e34b40bc5a26a82f088491","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/register/syncAssets.js","hash":"0813093c3e252a58371db53e914183a97e3186a1","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/replace.js","hash":"984ba7ed966c16b1fadf47c62f76e99940d4b12d","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/sails-linker.js","hash":"c1103119ec7d1f04cfbb1cda83b40d11e8f2d218","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/copy.js","hash":"4b9a4e724c65ec71cfec36b387a2625fc0f1074c","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/concat.js","hash":"0c2c4dbbfac52f20a3035a2f8cd1c24f1759b17e","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/sass.js","hash":"84ba6be74f99c502543b7f77a105ce16931fd38e","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/sync.js","hash":"fbc09d0ed201993bc1918223b8f8ad5b68f50490","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/cssmin.js","hash":"352185864437728c9c19169f4fec6fc3308e8b6d","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/actions.ejs","hash":"419223bff6146c46d4e993e4aa2e3636b051edc8","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/category.ejs","hash":"d4b26aa8c66aa8dbfae7a4aafed874745efb2f8e","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/disqus.ejs","hash":"9e0d238ed918e3138d5a9bb23a90408669e19169","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/duoshuo.ejs","hash":"992368f8863f34d1dccf90c0cabc33d5dcdbe92a","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/uglify.js","hash":"57c7341a004b61539f5b3f02bd772f40494b8306","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/watch.js","hash":"933eecd8a2506c627dbb9a1137305a16dd2d9f9a","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/gitalk.ejs","hash":"8c91c60ffeab780a8a628145c572456187142101","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/gallery.ejs","hash":"71b4ad77ab08c0980bf85b85c98a90c7de2be107","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/gitment.ejs","hash":"1dcfdca4d20bab5a43bda44cf37df506ab3a0fb7","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/header-cover.ejs","hash":"4d3a73d0c6f26769f778d02a559e5055ef1ee0ca","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/meta.ejs","hash":"f13cb5089b0d5898c9606519d1c872725a63a5f9","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/header.ejs","hash":"19c5f0d680db08fe2880f41de3a085ef0298a386","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/share-options.ejs","hash":"896158d62beba2ecb7d6af6e0f01f8f1ea23e706","modified":1599420980000},{"_id":"themes/tranquilpeak/layout/_partial/post/tag.ejs","hash":"2a52f38fa359f8ec8ae776e44e92c48795e31272","modified":1599420980000},{"_id":"themes/tranquilpeak/tasks/config/clean.js","hash":"ea70743eb4ed0d9ead68d6fc8b65b9f936229a00","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_archive.scss","hash":"cfdf53475d228643d5c5e62689b3c6a593e4ccce","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_alert.scss","hash":"1e6bf40de34a341dd0228357e288153b9292977c","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/base/_base.scss","hash":"f0a46b090a0a4dd21edfd89095761895c5278ecb","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_box.scss","hash":"eebaacf55234fdaa156edb7dc4d9a4f382eaf4d4","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_button.scss","hash":"ea9bd41800fe04860f7e892c17010588b2563a06","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_form.scss","hash":"368187e0c5f1a57d8c423f2ec23e897ee94a1a27","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_caption.scss","hash":"dad2683f5f3235b335eebcbda3db59a1cfbb2283","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_fancybox.scss","hash":"e162e2ecafc2be70238a9885fd57a9a7ad642757","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_figure.scss","hash":"9828521c34d91f04813db23e174708f510fe30bf","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_icon.scss","hash":"60dc972bcd81b4f95ab2c067ca910a5bf324d907","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_highlight-text.scss","hash":"7a7a8a78f75d6c43a46fd020e2d44546e716751b","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_hide.scss","hash":"c2f5ed51086b9ea5d94ff548bdc4653ea5cd7912","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_code.scss","hash":"0a14fe197c221a4d4d91ee9d41541ce7969043ca","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_link.scss","hash":"7460155ebf7ce0d3e9acd090b6b99673127fd0be","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_media.scss","hash":"84aa03c01b741bbeb31c6b48122930f30ad40de3","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_main-content.scss","hash":"90c46c87289a8b3cf7c14d36900f5ced9db36c25","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_image-gallery.scss","hash":"95ee5be04c523bf914596042574780ee527e6b38","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_markdown.scss","hash":"ba6d7e8f84b3b6dfef339f28b5c6ae372ead674f","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_modal.scss","hash":"bc56f823cd67b2ed65b5cf2c3e1851fa3e82f0f9","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_pagination.scss","hash":"809b9330a0e2d79c9285c1a452d61648248c8b70","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_post-actions.scss","hash":"1cc3ba46b1752043207bb820f4f886b0f982e445","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_post.scss","hash":"0457c281b7893f8fde8a0590e4c1ff2ffb4bc1a6","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_post-header-cover.scss","hash":"c4bf950602ccb3fbdad54938979651a7b488236e","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_postShorten.scss","hash":"9a2fdf8021c71d09fcd6ef5bc269055d78290fdb","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_pullquote.scss","hash":"86bc35ba358d1340debc459a344f5f6d34acaa42","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_tag.scss","hash":"ddd1c2ce17f0116655bdacda598e7f1d6fd18262","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_share-options-bar.scss","hash":"f6289a7cce6efe039614c77085945923c32d9673","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_text.scss","hash":"7b38858248da2f73cf64c5949fd475a8e0a246ae","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_video.scss","hash":"f9727fd300d73e8844abf0e2575c45e6c7769333","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_blog.scss","hash":"2450e07594a5e5186170fb5b5b157cc340808a9a","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/components/_tooltip.scss","hash":"f33ad3e677761af1ceb42d337691b8b354ff70bd","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_bottom-bar.scss","hash":"c7816c7ebc253d46466355860ead6669a3707ac6","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_footer.scss","hash":"645161942c66e6afbd666b4755337a6a6261e5e0","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_about.scss","hash":"4a1c4cca6623449602208256dee6422173daf1ef","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_cover.scss","hash":"03a951c9b35dd4e35456caa36950e6d6bef77ac3","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_header.scss","hash":"d840a4be850cb258167ee1081e1b288dc64b3d2c","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/pages/_search.scss","hash":"5f7cde0b68156ea802c3caf6cd673cab948b09d9","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_main.scss","hash":"ee4648502b355db51fc6cb7b05375003331f2f6e","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/_fonts.scss","hash":"4da4074668be0e0abe756aa537a406d14da7ceff","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/layouts/_sidebar.scss","hash":"facaff0ca816a4ace67c7689e4286e88eb1010c2","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1607953729145},{"_id":"themes/tranquilpeak/source/_css/utils/_variables.scss","hash":"fc62fcffcdb16fb823c3cb170bbcf34493f0467f","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/css/gitalk.css","hash":"fe5406a41cf222f39919630efd9012d08b7414aa","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/css/jquery.fancybox.css","hash":"00ce8430edb0a4ca35e08a9813e039d3a4b7868c","modified":1607953729388},{"_id":"themes/tranquilpeak/source/assets/css/thumbs.css","hash":"133acf84f948218219d3f23eb466fe54aceda97d","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.eot","hash":"3306178c90d9df939d2a5eabf533ba3650fbe80e","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.ttf","hash":"517a3b41c1e01b65898b5f1074434d43a361a54f","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff","hash":"da17a9f1dcae379c8ba20f1089059c202216cba7","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff2","hash":"5e4d45052f43e55aaad7f14d13280215e39aa45b","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold-italic.ttf","hash":"c1b8593dc9ddbf1a1a6268d31e08c4041448ed76","modified":1607953729364},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold.ttf","hash":"e6d0ffb2d0348d9e22de97e57214b7db795e9513","modified":1607953729364},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light.ttf","hash":"69bd3f15962cf91348a133d3d38571a5c67eca65","modified":1607953729380},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light-italic.ttf","hash":"c3835119c62e78a21cfb33e2de6686fb4a5929a0","modified":1607953729364},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-custom.scss","hash":"a0ffab53db35bbd4881aeb077400cba55551f3bd","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather.ttf","hash":"d392237948e74246a2fb0d0d886498776a185e54","modified":1607953729380},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans-bold.ttf","hash":"3823779db9f51a34658809ce66bdd6ed1145ed8e","modified":1607953729380},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans.ttf","hash":"618b78a8f6ffe7e1998eab67268859e2ab54be8e","modified":1607953729380},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-tranquilpeak.scss","hash":"3c1e0d8b6e2f37820d00572878d060080c5a6fe7","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/images/avatar.png","hash":"fae7a4bc08bad88136de5f66c9abe97954741234","modified":1609693880725},{"_id":"themes/tranquilpeak/source/assets/images/logo-algolia-nebula-blue-full.svg","hash":"d5e4426b6bd2d8b8c3f477f83d348d8f3b3ec1ca","modified":1607953729364},{"_id":"themes/tranquilpeak/source/assets/js/thumbs.js","hash":"ee9a65e280178b9525441b751ad7c0e6eb887022","modified":499162500000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_button.scss","hash":"70c64560144d7d6015bbedeca0531258f9bafa07","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_bottom-bar.scss","hash":"ab28b4d66f021e44d7a46a76157c6a2b5fd23496","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_category.scss","hash":"8cfc45772365e537949a4cd20cfa2a79e1a75dc8","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/js/tranquilpeak.js","hash":"ed9d93b9de4037c97c8699b7b9b985ec48c1b25d","modified":1607953729416},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_header.scss","hash":"52de2cb5f49a3b5748557fe2d25791ce52457d62","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_form.scss","hash":"14026f13b54ef9f2cd7109cf1bca43040816e542","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_main.scss","hash":"0ad55a6191d0a533917845006ceae329353c0b90","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_opacity.scss","hash":"cfc9905b6df3b5100a30b5c47fd331068f238f97","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_share-options-bar.scss","hash":"06f84bceb82df4d3bda64144f6fe4ad8e3e45f89","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_post-header-cover.scss","hash":"ecd9078372d8bd1b7f4979bae3251e8efb345a9b","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_prefix.scss","hash":"5e04cd54ba375f69c97b62b7d4e535118ec78177","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/css/all.css","hash":"9e798ebfbdf41ffcd68b02a5af2a9d997ddd6d12","modified":1607953729392},{"_id":"themes/tranquilpeak/source/assets/css/tranquilpeak.css","hash":"a6c317a8f3222d738f6cad9273729f8a915eb918","modified":1607953729412},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff","hash":"fddb95d7a0f48d2bf90a5ee3095e8264dca18053","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff2","hash":"62584b9868428fd75af3fc5ee2f9918dda428be5","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff2","hash":"6290834672aba86d5b6c1c73b30b57c9c53996f7","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff","hash":"f13e252f8a51a5279fd21e26ada0bd2f55bcefd8","modified":499162500000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_sidebar.scss","hash":"6c3dc034c3d5fdf7f0c4c39a6913f5bae4fc4767","modified":1599420980000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_tag.scss","hash":"c8a87e586e27f999ffa46f273f78a812f1cf2f0a","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.eot","hash":"40c8f2a0dc154160fde50e0c27f694f12c7b1636","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.ttf","hash":"29f59b4eecc72052d9110a5d4030a10ad9bf73d7","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.svg","hash":"51afca56e309df6fdc56b53fa6a7d3ce64826490","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/jquery.fancybox.js","hash":"048f1f8464eba59ccc706250693bc2ab060098a9","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1607953729145},{"_id":"themes/tranquilpeak/source/assets/js/script-jsoeqoqa2ajw9nwj0xf5gmftvb2jhopk3sxu8iodabvev2jdlmr0zsitv3jm.min.js","hash":"5f7046b160a695d9cac75b4eace17a2f70d7c365","modified":1607953738972},{"_id":"themes/tranquilpeak/package-lock.json","hash":"da9b5df3e93b6e72d4c0c9e8f1839de886ab1e77","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/css/style.css","hash":"cdef36fb7aba6b5157a5d7389275b5d94c39d886","modified":1607953729440},{"_id":"themes/tranquilpeak/source/assets/css/style-xsmpikcbczzhpff1zqybzgesjqcgmkdkx9b5ntr0bkmk6wqucpktuaodiuvy.min.css","hash":"5373bff083c63d4e6f97f9fcf9c53cd76553770c","modified":1607953731375},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.ttf","hash":"874c650701d0cbfb8f1de48a496dabed3bbf22e6","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":499162500000},{"_id":"themes/tranquilpeak/source/_images/cover.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.eot","hash":"96a5637429426764ea9b28bf4d1eb55ae10de57e","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/images/cover.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1607953729360},{"_id":"themes/tranquilpeak/source/assets/js/jquery.js","hash":"ad16c4a132ad2a03b4951185fed46d55397b5e88","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/images/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1607953729356},{"_id":"themes/tranquilpeak/source/_images/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1599420980000},{"_id":"themes/tranquilpeak/source/assets/js/script.js","hash":"a7d90b628cd71bc7a40ffab53f2bfeb73bb352da","modified":1607953729472},{"_id":"themes/tranquilpeak/source/assets/js/gitalk.js","hash":"c7a382307a7fdc77ba4c4f5a440bd14483741ff1","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/moment-with-locales.js","hash":"d39047f5013a835e3db43fa17b78bf625712825d","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.svg","hash":"5501fb62e20a89bdd89bf3fa147ca4dbcd2fc67f","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.svg","hash":"99dff0739882276ad6c434d73228efc7971b0a66","modified":499162500000},{"_id":"public/about/index.html","hash":"055ba52fd9ae1a4043e2e2ad07ab30b118d82f8f","modified":1617596584243},{"_id":"public/categories/index.html","hash":"1691cea1e17a6eacb6368a504b93cb5f62b18d34","modified":1617596584243},{"_id":"public/tags/index.html","hash":"6fa9a59bdb62d9a820ca351dc586aa3a8681547d","modified":1617596584243},{"_id":"public/top/index.html","hash":"cf2e35bbfa1693a54eccdf9e54948d1690391d8a","modified":1617596584243},{"_id":"public/archives/2019/12/index.html","hash":"67458c7107677f88478873620662814fe1d82ee7","modified":1617596584243},{"_id":"public/archives/2020/01/index.html","hash":"15f4ed74cad6c84a5f2aba31ce482a021bd45f36","modified":1617596584243},{"_id":"public/archives/2020/03/index.html","hash":"270f970d83e324adc1db933a8878ca1c0c85ddb8","modified":1617596584243},{"_id":"public/archives/2020/05/index.html","hash":"2afdc2b0b5669b24c7cbca8f436e46fb986cc131","modified":1617596584243},{"_id":"public/archives/2020/06/index.html","hash":"223703bd2ee4082fa67b6eea1c4448e873ecc8a9","modified":1617596584243},{"_id":"public/archives/2020/07/index.html","hash":"e03c6eae154238c071635a7b9d1419d5035799dd","modified":1617596584243},{"_id":"public/archives/2021/page/2/index.html","hash":"dff6f3c0d837d8c06145b63cd01e99f458e6d1a1","modified":1617596584243},{"_id":"public/archives/2021/01/index.html","hash":"e5e91fca5d86a74660f43b0aecf92adb7c45069e","modified":1617596584243},{"_id":"public/categories/framework/index.html","hash":"dacdd9de54fd53e12649c2a472d2707f91317899","modified":1617596584243},{"_id":"public/categories/Leetcode/index.html","hash":"a2dd66979ca1658090998746224b3497ae36fce3","modified":1617596584243},{"_id":"public/categories/Java/index.html","hash":"dea558419a5ba222a3c7e8a2d5ef05f96c92cf4b","modified":1617596584243},{"_id":"public/categories/DesignPatterns/index.html","hash":"60a5791521f6008dc82e81333c41c7fc970653d4","modified":1617596584243},{"_id":"public/categories/springboot/index.html","hash":"af62160293ab6ec855099f616c11742116d3dc67","modified":1617596584243},{"_id":"public/categories/JVM/index.html","hash":"87d40ed98da4fdb1417dd831c8f27a3c5635c28e","modified":1617596584243},{"_id":"public/categories/MiddleWare/index.html","hash":"c2ada3e25974eaa1c1c2a0ad9dc51c8474afd480","modified":1617596584243},{"_id":"public/categories/DB/index.html","hash":"92e9cd54218ed82479d4f61207c53c7b4a2fb482","modified":1617596584243},{"_id":"public/categories/Utils/index.html","hash":"276eb93fd5dddc34ab8bf5bd68cec059865e2258","modified":1617596584243},{"_id":"public/tags/summary/index.html","hash":"f03c98cea4a938f5004e48cd9fa950c0193dec7d","modified":1617596584243},{"_id":"public/tags/spring-security/index.html","hash":"5994bdbc58eae2de68b4b46e70bf23873e3d5ed9","modified":1617596584243},{"_id":"public/tags/bst/index.html","hash":"50b73ed84fc5c07ec57a859d077958cfa0cbabf8","modified":1617596584243},{"_id":"public/tags/bitwise/index.html","hash":"180a64ded43b2c38b393092c21dfcfd08f45f3ef","modified":1617596584243},{"_id":"public/tags/algorithm/index.html","hash":"0e344e62f33746830a74b0e5f04caf6ac0a887ba","modified":1617596584243},{"_id":"public/tags/LeetCode/index.html","hash":"2dce6a70692d79194eebd7911568bd5438f1f61f","modified":1617596584243},{"_id":"public/tags/design-patterns/index.html","hash":"6bf2efd1f448454c4cf8f16e6dce1d330156359a","modified":1617596584243},{"_id":"public/tags/hashmap-data-structure/index.html","hash":"6481ede781d99594d2ded40b1373b3cfca037885","modified":1617596584243},{"_id":"public/tags/datastructure/index.html","hash":"ce2398566057bd9fca9e279ed2281526c6ff3902","modified":1617596584243},{"_id":"public/tags/http/index.html","hash":"8f87f3400a065765d52b09f96159835273ffb303","modified":1617596584243},{"_id":"public/tags/https/index.html","hash":"e6a814e17883999e39a3d52a47614fd46fee675d","modified":1617596584243},{"_id":"public/tags/source/index.html","hash":"a3de3a6766b305918e20c2895ec79397847f2d21","modified":1617596584243},{"_id":"public/tags/kafka/index.html","hash":"2b2f7cd0a3ff00423bb8b9e336331e239c30b871","modified":1617596584243},{"_id":"public/tags/lock/index.html","hash":"2d4b46484f210abc5f2d8a7e8710295253cd4aea","modified":1617596584243},{"_id":"public/tags/mybatis/index.html","hash":"6419806ae0d0e544cc25ff7d122c6479bf4f6df8","modified":1617596584243},{"_id":"public/tags/redis/index.html","hash":"6ce7472295570946c7b1d05fd5abb838689e330f","modified":1617596584243},{"_id":"public/tags/nosql/index.html","hash":"652f4353c939ca9ee4e1792be4c595ee72260e54","modified":1617596584243},{"_id":"public/tags/double-poiters/index.html","hash":"34a3557f8642b759fdf149c917f9b306ebfb531a","modified":1617596584243},{"_id":"public/tags/map-preSum/index.html","hash":"0d0abb45a22ec5221e5b4a7bfdd1338a52b228cb","modified":1617596584243},{"_id":"public/tags/utils/index.html","hash":"dedee965b1cca19e1f64cbaae7f601b5f4fb429b","modified":1617596584243},{"_id":"public/tags/classloader/index.html","hash":"78be7df284e01f0c9a965c6f57005d396a8d18ab","modified":1617596584243},{"_id":"public/tags/memory/index.html","hash":"27e42538c44ed14fd7467f14d5c0d52c597d7c4d","modified":1617596584243},{"_id":"public/tags/activemq/index.html","hash":"0832fe3b064290532d4979abcae73b2045eda7de","modified":1617596584243},{"_id":"public/all-archives/index.html","hash":"99af3093a57351c01eed98e3731224206857a256","modified":1617596584243},{"_id":"public/all-categories/index.html","hash":"ccf882f267076f1864a7cb32ee4a46638cf9f355","modified":1617596584243},{"_id":"public/all-tags/index.html","hash":"76bac447a39f2bb9bd2be3e6c6956d249f9c9d0c","modified":1617596584243},{"_id":"public/2021/03/23/jvm-memory-manage/index.html","hash":"387bddcf1469292669409e534f4f7a85cf6e0c4b","modified":1617596584243},{"_id":"public/2021/03/23/jvm-concurrency/index.html","hash":"d2c3c77e0a11ffd93d553dff6e5785248fb1ddcd","modified":1617596584243},{"_id":"public/2021/03/23/jvm-classloader/index.html","hash":"c153137aa2b864d0ab65dfed0f463eab700e0012","modified":1617596584243},{"_id":"public/2021/03/22/Spring-Security-AutoConfiguration/index.html","hash":"7e346cdf422121fb7168ca7598ff1009c3b5bdf4","modified":1617596584243},{"_id":"public/2021/03/09/mybatis-autoconfiguration/index.html","hash":"1c544bbd814e44a43ee6f0005e40fddcfd60c348","modified":1617596584243},{"_id":"public/2021/03/07/mybatis-sql-resolution/index.html","hash":"276aaea625eb9923274fefb272ffac6dc4cea72f","modified":1617596584243},{"_id":"public/2021/03/06/java-collection-framework/index.html","hash":"71b3d61920caf0cf75ded16772a6392fe999dd1c","modified":1617596584243},{"_id":"public/2021/02/28/springboot-servlet/index.html","hash":"907c5222aff61e2032164eaace91dadb484aebcb","modified":1617596584243},{"_id":"public/2021/02/27/binary-search-tre/index.html","hash":"7fa0a21a36b10c9f6f4cfd34eb6381de7b1363fa","modified":1617596584243},{"_id":"public/2021/02/27/subarray/index.html","hash":"8cb0a9d9fd1d79ad8d7199c5f8773be5e776e6e1","modified":1617596584243},{"_id":"public/2021/02/15/SpringBoot-refresh/index.html","hash":"5685fe3971f56b0b8c47cc2c9f07e17d856ca405","modified":1617596584243},{"_id":"public/2021/02/15/SpringBoot-environment/index.html","hash":"6c6013edba21e6b86dcdba9ab0254937e2add19a","modified":1617596584243},{"_id":"public/2021/02/15/SpringBoot-startup/index.html","hash":"c52a510a72e49995b967dc5c67d272d31d66bbab","modified":1617596584243},{"_id":"public/2021/01/03/2020-end/index.html","hash":"ac3bfc050a59e0ec53bdc75f53c7e02521c0c6e3","modified":1617596584243},{"_id":"public/2020/08/23/contest203/index.html","hash":"03cd469dd54c2a05aa3664b6447bd0cfafa35924","modified":1617596584243},{"_id":"public/2020/08/20/hashmap/index.html","hash":"8aafbf699cebb802fcb3aa0311c2b5fc627ee098","modified":1617596584243},{"_id":"public/2020/08/16/contest202/index.html","hash":"9cdd4280310346363cf995334a7ba0b9e7254d36","modified":1617596584243},{"_id":"public/2020/08/09/contest201/index.html","hash":"aef8860e0ac30fed185b9f1e7d37189e869fd6dd","modified":1617596584243},{"_id":"public/2020/08/05/mybatis_preview/index.html","hash":"0491be544085c23f94682b06cf1a6e13cdf51070","modified":1617596584243},{"_id":"public/2020/08/02/contest200/index.html","hash":"2707a371e000374b8f0f7a71056d5699a8d5abe4","modified":1617596584243},{"_id":"public/2020/07/20/lock/index.html","hash":"69bc09f4a6de972ad47449e7ca85fd2a0c8f9811","modified":1617596584243},{"_id":"public/2020/07/20/volatile/index.html","hash":"38ad0340606657f5b58e7fefa02cb36e89eb1335","modified":1617596584243},{"_id":"public/2020/07/20/mq/index.html","hash":"2b4f47a75323ea5fddb7076e126fe523a71a1e1f","modified":1617596584243},{"_id":"public/2020/06/12/decorating/index.html","hash":"5208edc732520f07449d4b4f204f6f1cdd4fd56b","modified":1617596584243},{"_id":"public/2020/06/12/observer/index.html","hash":"e313ed89264eaaff2ab4ec4b21e25ef528998368","modified":1617596584243},{"_id":"public/2020/06/09/redis/index.html","hash":"a1cfeb8351ac3fd5d53f4c9d1aa65f6aee7a080c","modified":1617596584243},{"_id":"public/2020/06/06/heap/index.html","hash":"d8049b1334ddb45bd265d8a3502a2abde0f3930a","modified":1617596584243},{"_id":"public/2020/06/01/bitwise/index.html","hash":"931ed14b6e88fb40db6e3bd297d4053c3a50ed5a","modified":1617596584243},{"_id":"public/2020/05/24/jvm/index.html","hash":"146180466a127cb46ec398cda0c8c1c38814bd4a","modified":1617596584243},{"_id":"public/2020/03/14/https/index.html","hash":"e2195096128d35742462d34c17f241087b07997a","modified":1617596584243},{"_id":"public/2020/01/12/uml/index.html","hash":"b56e74fb85c8efaa6995586249b313532a870e28","modified":1617596584243},{"_id":"public/2019/12/03/kafka/index.html","hash":"d0084f6037dbb6ad5344bb2484b06b0152429a3f","modified":1617596584243},{"_id":"public/2019/11/02/nginx/index.html","hash":"ab07185d56b4ff185a96f18d5e9469bb6c7a26f6","modified":1617596584243},{"_id":"public/archives/index.html","hash":"7e8cede2be6811dcd39af9d0ad821789eda79b64","modified":1617596584243},{"_id":"public/archives/page/2/index.html","hash":"f1bc9010b7828e2cb92e8a8303e860167ba54b0b","modified":1617596584243},{"_id":"public/archives/page/3/index.html","hash":"e75d6c492e7288306853937ea630894d898d21b8","modified":1617596584243},{"_id":"public/archives/page/4/index.html","hash":"06c6a38132f94a3d0140fbd4f352679840176754","modified":1617596584243},{"_id":"public/archives/2019/index.html","hash":"e9be115ecbc685cf1e86af47c0721439ce4b3b33","modified":1617596584243},{"_id":"public/archives/2019/11/index.html","hash":"18a0afb05a408b5b4b4481817f10b06a1a697601","modified":1617596584243},{"_id":"public/archives/2020/index.html","hash":"cc8f6a1cf1fc20a4da5df60eafc208811b3c2ff3","modified":1617596584243},{"_id":"public/archives/2020/page/2/index.html","hash":"9e0354190d6d25c835268694bcd6ca8912b030c1","modified":1617596584243},{"_id":"public/archives/2020/08/index.html","hash":"d7cce4d8ec9c01cf3082190070c95233a95ea052","modified":1617596584243},{"_id":"public/archives/2021/index.html","hash":"1a0eae29b63fce85086ea80c78ffc5a8ba65ec01","modified":1617596584243},{"_id":"public/archives/2021/02/index.html","hash":"5bc90c3b3d5a60ba274d1622336b2db053f4fcc9","modified":1617596584243},{"_id":"public/archives/2021/03/index.html","hash":"9e0b93e6451946365064f6668a11981ab533c654","modified":1617596584243},{"_id":"public/categories/Network/index.html","hash":"efbe74e96f456e1608aad146f31bfe00d82cb28f","modified":1617596584243},{"_id":"public/categories/jdk/index.html","hash":"9431f85cf2911b4f1c93b4372966c8e495185a69","modified":1617596584243},{"_id":"public/index.html","hash":"a5f42c908bbe2d09cb464e55cf906912dc33a034","modified":1617596584243},{"_id":"public/page/2/index.html","hash":"298cd2d7248cbc7f6500125a59c6aa5bbee2047f","modified":1617596584243},{"_id":"public/page/3/index.html","hash":"381b91e888fce0b632dd4aab23c314dd0f91a736","modified":1617596584243},{"_id":"public/page/4/index.html","hash":"2a2ff60a3ecb5c1cafd47417afb2d504b21f83fc","modified":1617596584243},{"_id":"public/tags/framework/index.html","hash":"5c7a5207dfe7ac4305533c386532b05624a47c6f","modified":1617596584243},{"_id":"public/tags/network/index.html","hash":"01da345350aefd799225ef7eb2287ca20fdcb8ca","modified":1617596584243},{"_id":"public/assets/fonts/fa-regular-400.eot","hash":"3306178c90d9df939d2a5eabf533ba3650fbe80e","modified":1617596584243},{"_id":"public/assets/fonts/fa-regular-400.ttf","hash":"517a3b41c1e01b65898b5f1074434d43a361a54f","modified":1617596584243},{"_id":"public/assets/fonts/fa-regular-400.woff2","hash":"5e4d45052f43e55aaad7f14d13280215e39aa45b","modified":1617596584243},{"_id":"public/assets/fonts/fa-regular-400.woff","hash":"da17a9f1dcae379c8ba20f1089059c202216cba7","modified":1617596584243},{"_id":"public/assets/fonts/merriweather-bold-italic.ttf","hash":"c1b8593dc9ddbf1a1a6268d31e08c4041448ed76","modified":1617596584243},{"_id":"public/assets/fonts/merriweather-bold.ttf","hash":"e6d0ffb2d0348d9e22de97e57214b7db795e9513","modified":1617596584243},{"_id":"public/assets/fonts/merriweather-light-italic.ttf","hash":"c3835119c62e78a21cfb33e2de6686fb4a5929a0","modified":1617596584243},{"_id":"public/assets/fonts/merriweather-light.ttf","hash":"69bd3f15962cf91348a133d3d38571a5c67eca65","modified":1617596584243},{"_id":"public/assets/fonts/merriweather.ttf","hash":"d392237948e74246a2fb0d0d886498776a185e54","modified":1617596584243},{"_id":"public/assets/fonts/open-sans-bold.ttf","hash":"3823779db9f51a34658809ce66bdd6ed1145ed8e","modified":1617596584243},{"_id":"public/assets/fonts/open-sans.ttf","hash":"618b78a8f6ffe7e1998eab67268859e2ab54be8e","modified":1617596584243},{"_id":"public/assets/images/avatar.png","hash":"fae7a4bc08bad88136de5f66c9abe97954741234","modified":1617596584243},{"_id":"public/assets/images/logo-algolia-nebula-blue-full.svg","hash":"d5e4426b6bd2d8b8c3f477f83d348d8f3b3ec1ca","modified":1617596584243},{"_id":"public/assets/fonts/fa-brands-400.woff","hash":"fddb95d7a0f48d2bf90a5ee3095e8264dca18053","modified":1617596584243},{"_id":"public/assets/fonts/fa-brands-400.woff2","hash":"62584b9868428fd75af3fc5ee2f9918dda428be5","modified":1617596584243},{"_id":"public/assets/fonts/fa-solid-900.woff","hash":"f13e252f8a51a5279fd21e26ada0bd2f55bcefd8","modified":1617596584243},{"_id":"public/assets/fonts/fa-solid-900.woff2","hash":"6290834672aba86d5b6c1c73b30b57c9c53996f7","modified":1617596584243},{"_id":"public/assets/fonts/fa-brands-400.eot","hash":"40c8f2a0dc154160fde50e0c27f694f12c7b1636","modified":1617596584243},{"_id":"public/assets/fonts/fa-brands-400.ttf","hash":"29f59b4eecc72052d9110a5d4030a10ad9bf73d7","modified":1617596584243},{"_id":"public/assets/fonts/fa-regular-400.svg","hash":"51afca56e309df6fdc56b53fa6a7d3ce64826490","modified":1617596584243},{"_id":"public/assets/css/thumbs.css","hash":"3673ba1f616738f588fe887863846a958343b970","modified":1617596584243},{"_id":"public/assets/js/thumbs.js","hash":"1dacca749bad458211a886d3bcbbeb4600aaceac","modified":1617596584243},{"_id":"public/assets/fonts/fa-solid-900.eot","hash":"96a5637429426764ea9b28bf4d1eb55ae10de57e","modified":1617596584243},{"_id":"public/assets/css/gitalk.css","hash":"fe5406a41cf222f39919630efd9012d08b7414aa","modified":1617596584243},{"_id":"public/assets/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1617596584243},{"_id":"public/assets/css/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1617596584243},{"_id":"public/assets/fonts/fa-solid-900.ttf","hash":"874c650701d0cbfb8f1de48a496dabed3bbf22e6","modified":1617596584243},{"_id":"public/assets/images/cover.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1617596584243},{"_id":"public/assets/js/tranquilpeak.js","hash":"ed9d93b9de4037c97c8699b7b9b985ec48c1b25d","modified":1617596584243},{"_id":"public/assets/css/all.css","hash":"9e798ebfbdf41ffcd68b02a5af2a9d997ddd6d12","modified":1617596584243},{"_id":"public/assets/images/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1617596584243},{"_id":"public/assets/css/tranquilpeak.css","hash":"a6c317a8f3222d738f6cad9273729f8a915eb918","modified":1617596584243},{"_id":"public/assets/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1617596584243},{"_id":"public/assets/js/jquery.fancybox.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1617596584243},{"_id":"public/assets/js/script-jsoeqoqa2ajw9nwj0xf5gmftvb2jhopk3sxu8iodabvev2jdlmr0zsitv3jm.min.js","hash":"5f7046b160a695d9cac75b4eace17a2f70d7c365","modified":1617596584243},{"_id":"public/assets/css/style-xsmpikcbczzhpff1zqybzgesjqcgmkdkx9b5ntr0bkmk6wqucpktuaodiuvy.min.css","hash":"5373bff083c63d4e6f97f9fcf9c53cd76553770c","modified":1617596584243},{"_id":"public/assets/fonts/fa-brands-400.svg","hash":"99dff0739882276ad6c434d73228efc7971b0a66","modified":1617596584243},{"_id":"public/assets/js/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1617596584243},{"_id":"public/assets/css/style.css","hash":"7c2eb380692c74e85bc36d9c9b4c248249283d47","modified":1617596584243},{"_id":"public/assets/fonts/fa-solid-900.svg","hash":"5501fb62e20a89bdd89bf3fa147ca4dbcd2fc67f","modified":1617596584243},{"_id":"public/assets/js/jquery.js","hash":"ad16c4a132ad2a03b4951185fed46d55397b5e88","modified":1617596584243},{"_id":"public/assets/js/gitalk.js","hash":"869bb1868a939f57810799bd42cbcea251c72a7c","modified":1617596584243},{"_id":"public/assets/js/script.js","hash":"a3510d7a8965b5e51b66aa76c210a1afd44c00f0","modified":1617596584243},{"_id":"public/assets/js/moment-with-locales.js","hash":"d39047f5013a835e3db43fa17b78bf625712825d","modified":1617596584243}],"Category":[{"name":"framework","_id":"ckn438q6w0007w5ihfov39dki"},{"name":"Leetcode","_id":"ckn438q72000gw5ih4fz680oe"},{"name":"Java","_id":"ckn438q77000nw5ihe8o31505"},{"name":"DesignPatterns","_id":"ckn438q7i0015w5ih7i3w3bry"},{"name":"Network","_id":"ckn438q7m001dw5ih88ir7jkg"},{"name":"jdk","_id":"ckn438q7p001mw5ih7xcsbosh"},{"name":"springboot","_id":"ckn438q7y001sw5ih0sg45v3l"},{"name":"JVM","_id":"ckn438q880026w5ih6eyq98uq"},{"name":"MiddleWare","_id":"ckn438q8b002dw5ih57sx7km6"},{"name":"DB","_id":"ckn438q8f002mw5ihg5u9d8op"},{"name":"Utils","_id":"ckn438q8h002rw5ihb64d1w7t"}],"Data":[],"Page":[{"title":"all-archives","layout":"all-archives","date":"2020-08-16T04:51:57.000Z","_content":"","source":"all-archives/index.md","raw":"---\ntitle: all-archives\nlayout: all-archives\ndate: 2020-08-16 12:51:57\n---\n","updated":"2020-11-08T07:20:16.385Z","path":"all-archives/index.html","comments":1,"_id":"ckn438q6i0000w5ihgf0oh54x","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"about","date":"2019-11-02T16:17:30.000Z","type":"about","_content":"\n- 2019年毕业\n- 目前在深圳\n- 司职Java后端开发","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-11-03 00:17:30\ntype: about\n---\n\n- 2019年毕业\n- 目前在深圳\n- 司职Java后端开发","updated":"2020-12-31T13:59:31.091Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckn438q6p0002w5ih5txc3rbk","content":"<ul>\n<li>2019年毕业</li>\n<li>目前在深圳</li>\n<li>司职Java后端开发</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<ul>\n<li>2019年毕业</li>\n<li>目前在深圳</li>\n<li>司职Java后端开发</li>\n</ul>\n"},{"title":"all-categories","layout":"all-categories","date":"2020-08-16T04:51:22.000Z","_content":"","source":"all-categories/index.md","raw":"---\ntitle: all-categories\nlayout: all-categories\ndate: 2020-08-16 12:51:22\n---\n","updated":"2020-11-08T07:20:16.385Z","path":"all-categories/index.html","comments":1,"_id":"ckn438q6u0005w5ihg26qandf","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"categories","date":"2019-11-01T07:35:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-11-01 15:35:36\ntype: categories\n---\n","updated":"2020-11-08T07:20:16.385Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckn438q6x0008w5ih0qi91zrx","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"tags","date":"2019-11-01T07:08:49.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-11-01 15:08:49\ntype: tags\n---","updated":"2020-11-08T07:20:16.385Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckn438q6y000aw5ihbt9ph6tk","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"all-tags","layout":"all-tags","date":"2020-08-16T04:51:43.000Z","_content":"","source":"all-tags/index.md","raw":"---\ntitle: all-tags\nlayout: all-tags\ndate: 2020-08-16 12:51:43\n---\n","updated":"2020-11-08T07:20:16.385Z","path":"all-tags/index.html","comments":1,"_id":"ckn438q71000ew5ih42de6665","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"top","date":"2019-11-01T13:50:25.000Z","_content":"<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>","source":"top/index.md","raw":"---\ntitle: top\ndate: 2019-11-01 21:50:25\n---\n<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>","updated":"2020-11-08T07:20:16.385Z","path":"top/index.html","comments":1,"layout":"page","_id":"ckn438q73000hw5ihejx6ckp5","content":"<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>"}],"Post":[{"title":"2020_end","date":"2021-01-03T13:35:35.000Z","_content":"\n2020过完了，做个总结，同时简要规划新一年的目标。\n\n<!-- more -->\n\n时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。\n\n<!--toc-->\n\n## 上半年\n\n### 19年的下半年\n\n从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。\n\n从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门\n\n- 熟悉Java集合框架\n- 熟悉使用SpringBoot，SpringCloud\n\n关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。\n\n- Java语言程序设计-基础版\n- Java语言程序设计-进阶版\n\n### 20年的上半年\n\n预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。\n\n这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路\n\n- 微信小程序开发\n  - Javascript, css（flowbox）\n- Leetcode入门\n\n这半年也有持续的看书，主要是HeadFirst系列:\n\n- HeadFirst Servlet JSP\n- HeadFirst Java\n- HeadFirst DesignPattern\n\n## 下半年\n\n下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。\n\n主要业务点\n\n- ElasticSearch\n- Spring Security\n\n除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。\n\n- 深入理解Java虚拟机\n- Java8实战，lambda表达式减轻了后端对数据的解析的代码压力\n\n为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。\n\n## 目标\n\n- [ ] 书读完要有自己的一个认识，**做好读书笔记**，目前看来艾派德不理想。\n- [ ] 一直希望有开源项目方面的贡献，**pull request** 争取突破0。加入一些有趣的组织，同样争取突破0.\n- [ ] **框架理解透彻**，能自己写个demo验证，或者写个插件、扩展等。\n- [ ] 把Java刷过的Leetcode用**Python**和**C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。**算法导论**安排上\n- [ ] **408**，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟\n- [ ] 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出**高质量博客**。\n- [ ] **多线程**、**网络编程**，做个能运行的demo\n- [ ] 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。","source":"_posts/2020-end.md","raw":"---\ntitle: 2020_end\ndate: 2021-01-03 21:35:35\ntags: summary\n---\n\n2020过完了，做个总结，同时简要规划新一年的目标。\n\n<!-- more -->\n\n时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。\n\n<!--toc-->\n\n## 上半年\n\n### 19年的下半年\n\n从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。\n\n从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门\n\n- 熟悉Java集合框架\n- 熟悉使用SpringBoot，SpringCloud\n\n关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。\n\n- Java语言程序设计-基础版\n- Java语言程序设计-进阶版\n\n### 20年的上半年\n\n预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。\n\n这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路\n\n- 微信小程序开发\n  - Javascript, css（flowbox）\n- Leetcode入门\n\n这半年也有持续的看书，主要是HeadFirst系列:\n\n- HeadFirst Servlet JSP\n- HeadFirst Java\n- HeadFirst DesignPattern\n\n## 下半年\n\n下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。\n\n主要业务点\n\n- ElasticSearch\n- Spring Security\n\n除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。\n\n- 深入理解Java虚拟机\n- Java8实战，lambda表达式减轻了后端对数据的解析的代码压力\n\n为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。\n\n## 目标\n\n- [ ] 书读完要有自己的一个认识，**做好读书笔记**，目前看来艾派德不理想。\n- [ ] 一直希望有开源项目方面的贡献，**pull request** 争取突破0。加入一些有趣的组织，同样争取突破0.\n- [ ] **框架理解透彻**，能自己写个demo验证，或者写个插件、扩展等。\n- [ ] 把Java刷过的Leetcode用**Python**和**C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。**算法导论**安排上\n- [ ] **408**，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟\n- [ ] 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出**高质量博客**。\n- [ ] **多线程**、**网络编程**，做个能运行的demo\n- [ ] 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。","slug":"2020-end","published":1,"updated":"2021-02-27T05:59:44.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q6m0001w5ih4jvxamag","content":"<p>2020过完了，做个总结，同时简要规划新一年的目标。</p>\n<a id=\"more\"></a>\n\n<p>时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。</p>\n<!--toc-->\n\n<h2 id=\"上半年\"><a href=\"#上半年\" class=\"headerlink\" title=\"上半年\"></a>上半年</h2><h3 id=\"19年的下半年\"><a href=\"#19年的下半年\" class=\"headerlink\" title=\"19年的下半年\"></a>19年的下半年</h3><p>从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。</p>\n<p>从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门</p>\n<ul>\n<li>熟悉Java集合框架</li>\n<li>熟悉使用SpringBoot，SpringCloud</li>\n</ul>\n<p>关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。</p>\n<ul>\n<li>Java语言程序设计-基础版</li>\n<li>Java语言程序设计-进阶版</li>\n</ul>\n<h3 id=\"20年的上半年\"><a href=\"#20年的上半年\" class=\"headerlink\" title=\"20年的上半年\"></a>20年的上半年</h3><p>预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。</p>\n<p>这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路</p>\n<ul>\n<li>微信小程序开发<ul>\n<li>Javascript, css（flowbox）</li>\n</ul>\n</li>\n<li>Leetcode入门</li>\n</ul>\n<p>这半年也有持续的看书，主要是HeadFirst系列:</p>\n<ul>\n<li>HeadFirst Servlet JSP</li>\n<li>HeadFirst Java</li>\n<li>HeadFirst DesignPattern</li>\n</ul>\n<h2 id=\"下半年\"><a href=\"#下半年\" class=\"headerlink\" title=\"下半年\"></a>下半年</h2><p>下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。</p>\n<p>主要业务点</p>\n<ul>\n<li>ElasticSearch</li>\n<li>Spring Security</li>\n</ul>\n<p>除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。</p>\n<ul>\n<li>深入理解Java虚拟机</li>\n<li>Java8实战，lambda表达式减轻了后端对数据的解析的代码压力</li>\n</ul>\n<p>为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 书读完要有自己的一个认识，<strong>做好读书笔记</strong>，目前看来艾派德不理想。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一直希望有开源项目方面的贡献，<strong>pull request</strong> 争取突破0。加入一些有趣的组织，同样争取突破0.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>框架理解透彻</strong>，能自己写个demo验证，或者写个插件、扩展等。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 把Java刷过的Leetcode用<strong>Python</strong>和<strong>C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。</strong>算法导论**安排上</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>408</strong>，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟</li>\n<li><input disabled=\"\" type=\"checkbox\"> 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出<strong>高质量博客</strong>。</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>多线程</strong>、<strong>网络编程</strong>，做个能运行的demo</li>\n<li><input disabled=\"\" type=\"checkbox\"> 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>2020过完了，做个总结，同时简要规划新一年的目标。</p>","more":"<p>时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。</p>\n<!--toc-->\n\n<h2 id=\"上半年\"><a href=\"#上半年\" class=\"headerlink\" title=\"上半年\"></a>上半年</h2><h3 id=\"19年的下半年\"><a href=\"#19年的下半年\" class=\"headerlink\" title=\"19年的下半年\"></a>19年的下半年</h3><p>从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。</p>\n<p>从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门</p>\n<ul>\n<li>熟悉Java集合框架</li>\n<li>熟悉使用SpringBoot，SpringCloud</li>\n</ul>\n<p>关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。</p>\n<ul>\n<li>Java语言程序设计-基础版</li>\n<li>Java语言程序设计-进阶版</li>\n</ul>\n<h3 id=\"20年的上半年\"><a href=\"#20年的上半年\" class=\"headerlink\" title=\"20年的上半年\"></a>20年的上半年</h3><p>预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。</p>\n<p>这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路</p>\n<ul>\n<li>微信小程序开发<ul>\n<li>Javascript, css（flowbox）</li>\n</ul>\n</li>\n<li>Leetcode入门</li>\n</ul>\n<p>这半年也有持续的看书，主要是HeadFirst系列:</p>\n<ul>\n<li>HeadFirst Servlet JSP</li>\n<li>HeadFirst Java</li>\n<li>HeadFirst DesignPattern</li>\n</ul>\n<h2 id=\"下半年\"><a href=\"#下半年\" class=\"headerlink\" title=\"下半年\"></a>下半年</h2><p>下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。</p>\n<p>主要业务点</p>\n<ul>\n<li>ElasticSearch</li>\n<li>Spring Security</li>\n</ul>\n<p>除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。</p>\n<ul>\n<li>深入理解Java虚拟机</li>\n<li>Java8实战，lambda表达式减轻了后端对数据的解析的代码压力</li>\n</ul>\n<p>为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 书读完要有自己的一个认识，<strong>做好读书笔记</strong>，目前看来艾派德不理想。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一直希望有开源项目方面的贡献，<strong>pull request</strong> 争取突破0。加入一些有趣的组织，同样争取突破0.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>框架理解透彻</strong>，能自己写个demo验证，或者写个插件、扩展等。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 把Java刷过的Leetcode用<strong>Python</strong>和<strong>C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。</strong>算法导论**安排上</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>408</strong>，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟</li>\n<li><input disabled=\"\" type=\"checkbox\"> 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出<strong>高质量博客</strong>。</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>多线程</strong>、<strong>网络编程</strong>，做个能运行的demo</li>\n<li><input disabled=\"\" type=\"checkbox\"> 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。</li>\n</ul>"},{"title":"Spring Security AutoConfiguration","date":"2021-03-22T14:18:10.000Z","_content":"\n​\t\t最近有设计权限模块，用到了*Spring Security*，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 入口\n\n​\t\t在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration*的天下，开启一个模块的功能同样需要它。开头提到的那个注解*@EnableWebSecurity*就是探究的入口：\n\n```java\n@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)\n@Target(value = { java.lang.annotation.ElementType.TYPE })\n@Documented\n@Import({ WebSecurityConfiguration.class,\n\t\tSpringWebMvcImportSelector.class,\n\t\tOAuth2ImportSelector.class })\n@EnableGlobalAuthentication\n@Configuration\npublic @interface EnableWebSecurity {\n\n\t/**\n\t * Controls debugging support for Spring Security. Default is false.\n\t * @return if true, enables debug support with Spring Security\n\t */\n\tboolean debug() default false;\n}\n```\n\n我们看到通过*@Import(...)*导入了三个class，后两个都是以*Selector*结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地*@Import(...)*，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个*WebSecurityConfiguration*配置类。\n\n在进入第一个配置类之前有必要看一下这个注解的注释信息：\n\n>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods\n\n告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：\n\n```java\n@EnableWebSecurity\n@Configuration\npublic class MyWebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    public void confugre(HttpSecurity httpSecurity){\n        // ....\n    }\n}\n```\n\n下面我们进入配置类。\n\n# 配置类\n\nSpring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：\n\n> Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.\n\n我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：\n\n## setFilterChainProxySecurityConfigurer\n\n```java\n@Autowired(required = false)\npublic void setFilterChainProxySecurityConfigurer(\n    // 入参一\n    ObjectPostProcessor<Object> objectPostProcessor,\n    // 入参二\n    @Value(\"#{@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()}\") List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers)\n    throws Exception {\n    webSecurity = objectPostProcessor\n        .postProcess(new WebSecurity(objectPostProcessor));\n    if (debugEnabled != null) {\n        webSecurity.debug(debugEnabled);\n    }\n    \n    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);\n\n    Integer previousOrder = null;\n    Object previousConfig = null;\n    for (SecurityConfigurer<Filter, WebSecurity> config : webSecurityConfigurers) {\n        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);\n        if (previousOrder != null && previousOrder.equals(order)) {\n            throw new IllegalStateException(\n                \"@Order on WebSecurityConfigurers must be unique. Order of \"\n                + order + \" was already used on \" + previousConfig + \", so it cannot be used on \"\n                + config + \" too.\");\n        }\n        previousOrder = order;\n        previousConfig = config;\n    }\n    for (SecurityConfigurer<Filter, WebSecurity> webSecurityConfigurer : webSecurityConfigurers) {\n        // 遍历webSecurityConfigures，执行webSecurity的apply\n        webSecurity.apply(webSecurityConfigurer);\n    }\n    // 将confugures赋给势力变量\n    this.webSecurityConfigurers = webSecurityConfigurers;\n}\n```\n\n\n\n### getWebSecurityConfigurers\n\n入参二是有些奇怪的，实际上是执行了类`AutowiredWebSecurityConfigurersIgnoreParents`中的静态方法*getWebSecurityConfigurers*，目的是从上下文中获取到configures：\n\n```java\npublic List<SecurityConfigurer<Filter, WebSecurity>> getWebSecurityConfigurers() {\n   List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers = new ArrayList<>();\n   Map<String, WebSecurityConfigurer> beansOfType = beanFactory\n         .getBeansOfType(WebSecurityConfigurer.class);\n   for (Entry<String, WebSecurityConfigurer> entry : beansOfType.entrySet()) {\n      webSecurityConfigurers.add(entry.getValue());\n   }\n   return webSecurityConfigurers;\n}\n```\n\n\n\n### apply\n\n这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。\n\n```java\nprivate <C extends SecurityConfigurer<O, B>> void add(C configurer) {\n    // ...\n    synchronized (configurers) {\n        // ...\n        List<SecurityConfigurer<O, B>> configs = allowConfigurersOfSameType ? this.configurers\n            .get(clazz) : null;\n        if (configs == null) {\n            configs = new ArrayList<>(1);\n        }\n        configs.add(configurer);\n        // private final LinkedHashMap<Class<? extends SecurityConfigurer<O, B>>, List<SecurityConfigurer<O, B>>> configurers = new LinkedHashMap<>();\n        this.configurers.put(clazz, configs);\n        // ...\n    }\n}\n```\n\n要知道，我们在*入口*处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个*WebSecurityConfigurer*，他实现了接口：\n\n```java\npublic abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer<WebSecurity> {\n    // ...\n}\n```\n\n所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法*getWebSecurityConfigurers*从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。\n\n\n\n## springSecurityFilterChain\n\n准备工作之后是过滤器链。\n\n```java\n// \tpublic static final String DEFAULT_FILTER_NAME = \"springSecurityFilterChain\";\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)\npublic Filter springSecurityFilterChain() throws Exception {\n    // 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true\n    boolean hasConfigurers = webSecurityConfigurers != null\n        && !webSecurityConfigurers.isEmpty();\n    if (!hasConfigurers) {\n        // 为空的话新建一个\n        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor\n            .postProcess(new WebSecurityConfigurerAdapter() {\n            });\n        // 再次执行apply\n        webSecurity.apply(adapter);\n    }\n    // 不为空的话 会直接执行这里的build方法\n    return webSecurity.build();\n}\n```\n\n到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。\n\n```java\nprivate AtomicBoolean building = new AtomicBoolean();\n\npublic final O build() throws Exception {\n    // 这里对build方法用了自旋CAS防止重复构建\n    if (this.building.compareAndSet(false, true)) {\n        this.object = doBuild();\n        return this.object;\n    }\n    throw new AlreadyBuiltException(\"This object has already been built\");\n}\n```\n\n在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。\n\n### init\n\n初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：\n\n```java\npublic void init(final WebSecurity web) throws Exception {\n    // 获取httpSecurity\n    final HttpSecurity http = getHttp();\n    // web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值\n    web.addSecurityFilterChainBuilder(http).postBuildAction(() -> {\n        FilterSecurityInterceptor securityInterceptor = http\n            .getSharedObject(FilterSecurityInterceptor.class);\n        web.securityInterceptor(securityInterceptor);\n    });\n}\n```\n\n#### getHttp\n\n```java\nprotected final HttpSecurity getHttp() throws Exception {\n   if (http != null) {\n      return http;\n   }\n\n   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();\n   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);\n\n   AuthenticationManager authenticationManager = authenticationManager();\n   authenticationBuilder.parentAuthenticationManager(authenticationManager);\n   Map<Class<?>, Object> sharedObjects = createSharedObjects();\n\n    // 生成对象\n   http = new HttpSecurity(objectPostProcessor, authenticationBuilder,\n         sharedObjects);\n    // 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置\n   if (!disableDefaults) {\n      // @formatter:off\n      http\n         .csrf().and()\n         .addFilter(new WebAsyncManagerIntegrationFilter())\n         .exceptionHandling().and()\n         .headers().and()\n         .sessionManagement().and()\n         .securityContext().and()\n         .requestCache().and()\n         .anonymous().and()\n         .servletApi().and()\n         .apply(new DefaultLoginPageConfigurer<>()).and()\n         .logout();\n      // @formatter:on\n      ClassLoader classLoader = this.context.getClassLoader();\n      List<AbstractHttpConfigurer> defaultHttpConfigurers =\n            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);\n\n      for (AbstractHttpConfigurer configurer : defaultHttpConfigurers) {\n         http.apply(configurer);\n      }\n   }\n    // 配置httpSecurity\n   configure(http);\n   return http;\n}\n```\n\n上面的方法中在返回httpSecurity对象之前会执行*configure*方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity*？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写*configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。\n\n\n\n# 小结\n\n以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。","source":"_posts/Spring-Security-AutoConfiguration.md","raw":"---\ntitle: Spring Security AutoConfiguration\ndate: 2021-03-22 22:18:10\ncategories: framework\ntags: spring security\n---\n\n​\t\t最近有设计权限模块，用到了*Spring Security*，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 入口\n\n​\t\t在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration*的天下，开启一个模块的功能同样需要它。开头提到的那个注解*@EnableWebSecurity*就是探究的入口：\n\n```java\n@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)\n@Target(value = { java.lang.annotation.ElementType.TYPE })\n@Documented\n@Import({ WebSecurityConfiguration.class,\n\t\tSpringWebMvcImportSelector.class,\n\t\tOAuth2ImportSelector.class })\n@EnableGlobalAuthentication\n@Configuration\npublic @interface EnableWebSecurity {\n\n\t/**\n\t * Controls debugging support for Spring Security. Default is false.\n\t * @return if true, enables debug support with Spring Security\n\t */\n\tboolean debug() default false;\n}\n```\n\n我们看到通过*@Import(...)*导入了三个class，后两个都是以*Selector*结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地*@Import(...)*，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个*WebSecurityConfiguration*配置类。\n\n在进入第一个配置类之前有必要看一下这个注解的注释信息：\n\n>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods\n\n告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：\n\n```java\n@EnableWebSecurity\n@Configuration\npublic class MyWebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    public void confugre(HttpSecurity httpSecurity){\n        // ....\n    }\n}\n```\n\n下面我们进入配置类。\n\n# 配置类\n\nSpring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：\n\n> Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.\n\n我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：\n\n## setFilterChainProxySecurityConfigurer\n\n```java\n@Autowired(required = false)\npublic void setFilterChainProxySecurityConfigurer(\n    // 入参一\n    ObjectPostProcessor<Object> objectPostProcessor,\n    // 入参二\n    @Value(\"#{@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()}\") List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers)\n    throws Exception {\n    webSecurity = objectPostProcessor\n        .postProcess(new WebSecurity(objectPostProcessor));\n    if (debugEnabled != null) {\n        webSecurity.debug(debugEnabled);\n    }\n    \n    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);\n\n    Integer previousOrder = null;\n    Object previousConfig = null;\n    for (SecurityConfigurer<Filter, WebSecurity> config : webSecurityConfigurers) {\n        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);\n        if (previousOrder != null && previousOrder.equals(order)) {\n            throw new IllegalStateException(\n                \"@Order on WebSecurityConfigurers must be unique. Order of \"\n                + order + \" was already used on \" + previousConfig + \", so it cannot be used on \"\n                + config + \" too.\");\n        }\n        previousOrder = order;\n        previousConfig = config;\n    }\n    for (SecurityConfigurer<Filter, WebSecurity> webSecurityConfigurer : webSecurityConfigurers) {\n        // 遍历webSecurityConfigures，执行webSecurity的apply\n        webSecurity.apply(webSecurityConfigurer);\n    }\n    // 将confugures赋给势力变量\n    this.webSecurityConfigurers = webSecurityConfigurers;\n}\n```\n\n\n\n### getWebSecurityConfigurers\n\n入参二是有些奇怪的，实际上是执行了类`AutowiredWebSecurityConfigurersIgnoreParents`中的静态方法*getWebSecurityConfigurers*，目的是从上下文中获取到configures：\n\n```java\npublic List<SecurityConfigurer<Filter, WebSecurity>> getWebSecurityConfigurers() {\n   List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers = new ArrayList<>();\n   Map<String, WebSecurityConfigurer> beansOfType = beanFactory\n         .getBeansOfType(WebSecurityConfigurer.class);\n   for (Entry<String, WebSecurityConfigurer> entry : beansOfType.entrySet()) {\n      webSecurityConfigurers.add(entry.getValue());\n   }\n   return webSecurityConfigurers;\n}\n```\n\n\n\n### apply\n\n这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。\n\n```java\nprivate <C extends SecurityConfigurer<O, B>> void add(C configurer) {\n    // ...\n    synchronized (configurers) {\n        // ...\n        List<SecurityConfigurer<O, B>> configs = allowConfigurersOfSameType ? this.configurers\n            .get(clazz) : null;\n        if (configs == null) {\n            configs = new ArrayList<>(1);\n        }\n        configs.add(configurer);\n        // private final LinkedHashMap<Class<? extends SecurityConfigurer<O, B>>, List<SecurityConfigurer<O, B>>> configurers = new LinkedHashMap<>();\n        this.configurers.put(clazz, configs);\n        // ...\n    }\n}\n```\n\n要知道，我们在*入口*处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个*WebSecurityConfigurer*，他实现了接口：\n\n```java\npublic abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer<WebSecurity> {\n    // ...\n}\n```\n\n所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法*getWebSecurityConfigurers*从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。\n\n\n\n## springSecurityFilterChain\n\n准备工作之后是过滤器链。\n\n```java\n// \tpublic static final String DEFAULT_FILTER_NAME = \"springSecurityFilterChain\";\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)\npublic Filter springSecurityFilterChain() throws Exception {\n    // 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true\n    boolean hasConfigurers = webSecurityConfigurers != null\n        && !webSecurityConfigurers.isEmpty();\n    if (!hasConfigurers) {\n        // 为空的话新建一个\n        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor\n            .postProcess(new WebSecurityConfigurerAdapter() {\n            });\n        // 再次执行apply\n        webSecurity.apply(adapter);\n    }\n    // 不为空的话 会直接执行这里的build方法\n    return webSecurity.build();\n}\n```\n\n到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。\n\n```java\nprivate AtomicBoolean building = new AtomicBoolean();\n\npublic final O build() throws Exception {\n    // 这里对build方法用了自旋CAS防止重复构建\n    if (this.building.compareAndSet(false, true)) {\n        this.object = doBuild();\n        return this.object;\n    }\n    throw new AlreadyBuiltException(\"This object has already been built\");\n}\n```\n\n在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。\n\n### init\n\n初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：\n\n```java\npublic void init(final WebSecurity web) throws Exception {\n    // 获取httpSecurity\n    final HttpSecurity http = getHttp();\n    // web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值\n    web.addSecurityFilterChainBuilder(http).postBuildAction(() -> {\n        FilterSecurityInterceptor securityInterceptor = http\n            .getSharedObject(FilterSecurityInterceptor.class);\n        web.securityInterceptor(securityInterceptor);\n    });\n}\n```\n\n#### getHttp\n\n```java\nprotected final HttpSecurity getHttp() throws Exception {\n   if (http != null) {\n      return http;\n   }\n\n   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();\n   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);\n\n   AuthenticationManager authenticationManager = authenticationManager();\n   authenticationBuilder.parentAuthenticationManager(authenticationManager);\n   Map<Class<?>, Object> sharedObjects = createSharedObjects();\n\n    // 生成对象\n   http = new HttpSecurity(objectPostProcessor, authenticationBuilder,\n         sharedObjects);\n    // 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置\n   if (!disableDefaults) {\n      // @formatter:off\n      http\n         .csrf().and()\n         .addFilter(new WebAsyncManagerIntegrationFilter())\n         .exceptionHandling().and()\n         .headers().and()\n         .sessionManagement().and()\n         .securityContext().and()\n         .requestCache().and()\n         .anonymous().and()\n         .servletApi().and()\n         .apply(new DefaultLoginPageConfigurer<>()).and()\n         .logout();\n      // @formatter:on\n      ClassLoader classLoader = this.context.getClassLoader();\n      List<AbstractHttpConfigurer> defaultHttpConfigurers =\n            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);\n\n      for (AbstractHttpConfigurer configurer : defaultHttpConfigurers) {\n         http.apply(configurer);\n      }\n   }\n    // 配置httpSecurity\n   configure(http);\n   return http;\n}\n```\n\n上面的方法中在返回httpSecurity对象之前会执行*configure*方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity*？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写*configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。\n\n\n\n# 小结\n\n以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。","slug":"Spring-Security-AutoConfiguration","published":1,"updated":"2021-03-23T15:15:59.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q6q0003w5ih0fh0ht7b","content":"<p>​        最近有设计权限模块，用到了<em>Spring Security</em>，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。</p>\n<a id=\"more\"></a>\n\n<!-- toc -->\n\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>​        在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration<em>的天下，开启一个模块的功能同样需要它。开头提到的那个注解</em>@EnableWebSecurity*就是探究的入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; WebSecurityConfiguration.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tSpringWebMvcImportSelector.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tOAuth2ImportSelector.class &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableGlobalAuthentication</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableWebSecurity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Controls debugging support for Spring Security. Default is false.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> if true, enables debug support with Spring Security</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">debug</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到通过*@Import(…)<em>导入了三个class，后两个都是以</em>Selector<em>结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地</em>@Import(…)<em>，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个</em>WebSecurityConfiguration*配置类。</p>\n<p>在进入第一个配置类之前有必要看一下这个注解的注释信息：</p>\n<blockquote>\n<p>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods</p>\n</blockquote>\n<p>告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebSecurityConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confugre</span><span class=\"params\">(HttpSecurity httpSecurity)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们进入配置类。</p>\n<h1 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h1><p>Spring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：</p>\n<blockquote>\n<p>Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.</p>\n</blockquote>\n<p>我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：</p>\n<h2 id=\"setFilterChainProxySecurityConfigurer\"><a href=\"#setFilterChainProxySecurityConfigurer\" class=\"headerlink\" title=\"setFilterChainProxySecurityConfigurer\"></a>setFilterChainProxySecurityConfigurer</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired(required = false)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFilterChainProxySecurityConfigurer</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参一</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参二</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"meta\">@Value(&quot;#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;&quot;)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    webSecurity = objectPostProcessor</span><br><span class=\"line\">        .postProcess(<span class=\"keyword\">new</span> WebSecurity(objectPostProcessor));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (debugEnabled != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        webSecurity.debug(debugEnabled);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer previousOrder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Object previousConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previousOrder != <span class=\"keyword\">null</span> &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;@Order on WebSecurityConfigurers must be unique. Order of &quot;</span></span><br><span class=\"line\">                + order + <span class=\"string\">&quot; was already used on &quot;</span> + previousConfig + <span class=\"string\">&quot;, so it cannot be used on &quot;</span></span><br><span class=\"line\">                + config + <span class=\"string\">&quot; too.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previousOrder = order;</span><br><span class=\"line\">        previousConfig = config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历webSecurityConfigures，执行webSecurity的apply</span></span><br><span class=\"line\">        webSecurity.apply(webSecurityConfigurer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将confugures赋给势力变量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webSecurityConfigurers = webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"getWebSecurityConfigurers\"><a href=\"#getWebSecurityConfigurers\" class=\"headerlink\" title=\"getWebSecurityConfigurers\"></a>getWebSecurityConfigurers</h3><p>入参二是有些奇怪的，实际上是执行了类<code>AutowiredWebSecurityConfigurersIgnoreParents</code>中的静态方法<em>getWebSecurityConfigurers</em>，目的是从上下文中获取到configures：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; getWebSecurityConfigurers() &#123;</span><br><span class=\"line\">   List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">   Map&lt;String, WebSecurityConfigurer&gt; beansOfType = beanFactory</span><br><span class=\"line\">         .getBeansOfType(WebSecurityConfigurer.class);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, WebSecurityConfigurer&gt; entry : beansOfType.entrySet()) &#123;</span><br><span class=\"line\">      webSecurityConfigurers.add(entry.getValue());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;C extends SecurityConfigurer&lt;O, B&gt;&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(C configurer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (configurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = allowConfigurersOfSameType ? <span class=\"keyword\">this</span>.configurers</span><br><span class=\"line\">            .get(clazz) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            configs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        configs.add(configurer);</span><br><span class=\"line\">        <span class=\"comment\">// private final LinkedHashMap&lt;Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt;, List&lt;SecurityConfigurer&lt;O, B&gt;&gt;&gt; configurers = new LinkedHashMap&lt;&gt;();</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configurers.put(clazz, configs);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要知道，我们在<em>入口</em>处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个<em>WebSecurityConfigurer</em>，他实现了接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebSecurityConfigurer</span>&lt;<span class=\"title\">WebSecurity</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法<em>getWebSecurityConfigurers</em>从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。</p>\n<h2 id=\"springSecurityFilterChain\"><a href=\"#springSecurityFilterChain\" class=\"headerlink\" title=\"springSecurityFilterChain\"></a>springSecurityFilterChain</h2><p>准备工作之后是过滤器链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \tpublic static final String DEFAULT_FILTER_NAME = &quot;springSecurityFilterChain&quot;;</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Filter <span class=\"title\">springSecurityFilterChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> hasConfigurers = webSecurityConfigurers != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为空的话新建一个</span></span><br><span class=\"line\">        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor</span><br><span class=\"line\">            .postProcess(<span class=\"keyword\">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 再次执行apply</span></span><br><span class=\"line\">        webSecurity.apply(adapter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为空的话 会直接执行这里的build方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> webSecurity.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> AtomicBoolean building = <span class=\"keyword\">new</span> AtomicBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> O <span class=\"title\">build</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里对build方法用了自旋CAS防止重复构建</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.building.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = doBuild();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AlreadyBuiltException(<span class=\"string\">&quot;This object has already been built&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。</p>\n<h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><p>初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取httpSecurity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> HttpSecurity http = getHttp();</span><br><span class=\"line\">    <span class=\"comment\">// web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值</span></span><br><span class=\"line\">    web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123;</span><br><span class=\"line\">        FilterSecurityInterceptor securityInterceptor = http</span><br><span class=\"line\">            .getSharedObject(FilterSecurityInterceptor.class);</span><br><span class=\"line\">        web.securityInterceptor(securityInterceptor);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"getHttp\"><a href=\"#getHttp\" class=\"headerlink\" title=\"getHttp\"></a>getHttp</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> HttpSecurity <span class=\"title\">getHttp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (http != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();</span><br><span class=\"line\">   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationManager authenticationManager = authenticationManager();</span><br><span class=\"line\">   authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class=\"line\">   Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成对象</span></span><br><span class=\"line\">   http = <span class=\"keyword\">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class=\"line\">         sharedObjects);</span><br><span class=\"line\">    <span class=\"comment\">// 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!disableDefaults) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:off</span></span><br><span class=\"line\">      http</span><br><span class=\"line\">         .csrf().and()</span><br><span class=\"line\">         .addFilter(<span class=\"keyword\">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class=\"line\">         .exceptionHandling().and()</span><br><span class=\"line\">         .headers().and()</span><br><span class=\"line\">         .sessionManagement().and()</span><br><span class=\"line\">         .securityContext().and()</span><br><span class=\"line\">         .requestCache().and()</span><br><span class=\"line\">         .anonymous().and()</span><br><span class=\"line\">         .servletApi().and()</span><br><span class=\"line\">         .apply(<span class=\"keyword\">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class=\"line\">         .logout();</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:on</span></span><br><span class=\"line\">      ClassLoader classLoader = <span class=\"keyword\">this</span>.context.getClassLoader();</span><br><span class=\"line\">      List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class=\"line\">            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class=\"line\">         http.apply(configurer);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 配置httpSecurity</span></span><br><span class=\"line\">   configure(http);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法中在返回httpSecurity对象之前会执行<em>configure</em>方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity<em>？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写</em>configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>​        最近有设计权限模块，用到了<em>Spring Security</em>，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。</p>","more":"<!-- toc -->\n\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>​        在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration<em>的天下，开启一个模块的功能同样需要它。开头提到的那个注解</em>@EnableWebSecurity*就是探究的入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; WebSecurityConfiguration.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tSpringWebMvcImportSelector.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tOAuth2ImportSelector.class &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableGlobalAuthentication</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableWebSecurity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Controls debugging support for Spring Security. Default is false.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> if true, enables debug support with Spring Security</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">debug</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到通过*@Import(…)<em>导入了三个class，后两个都是以</em>Selector<em>结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地</em>@Import(…)<em>，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个</em>WebSecurityConfiguration*配置类。</p>\n<p>在进入第一个配置类之前有必要看一下这个注解的注释信息：</p>\n<blockquote>\n<p>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods</p>\n</blockquote>\n<p>告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebSecurityConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confugre</span><span class=\"params\">(HttpSecurity httpSecurity)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们进入配置类。</p>\n<h1 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h1><p>Spring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：</p>\n<blockquote>\n<p>Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.</p>\n</blockquote>\n<p>我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：</p>\n<h2 id=\"setFilterChainProxySecurityConfigurer\"><a href=\"#setFilterChainProxySecurityConfigurer\" class=\"headerlink\" title=\"setFilterChainProxySecurityConfigurer\"></a>setFilterChainProxySecurityConfigurer</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired(required = false)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFilterChainProxySecurityConfigurer</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参一</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参二</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"meta\">@Value(&quot;#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;&quot;)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    webSecurity = objectPostProcessor</span><br><span class=\"line\">        .postProcess(<span class=\"keyword\">new</span> WebSecurity(objectPostProcessor));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (debugEnabled != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        webSecurity.debug(debugEnabled);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer previousOrder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Object previousConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previousOrder != <span class=\"keyword\">null</span> &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;@Order on WebSecurityConfigurers must be unique. Order of &quot;</span></span><br><span class=\"line\">                + order + <span class=\"string\">&quot; was already used on &quot;</span> + previousConfig + <span class=\"string\">&quot;, so it cannot be used on &quot;</span></span><br><span class=\"line\">                + config + <span class=\"string\">&quot; too.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previousOrder = order;</span><br><span class=\"line\">        previousConfig = config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历webSecurityConfigures，执行webSecurity的apply</span></span><br><span class=\"line\">        webSecurity.apply(webSecurityConfigurer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将confugures赋给势力变量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webSecurityConfigurers = webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"getWebSecurityConfigurers\"><a href=\"#getWebSecurityConfigurers\" class=\"headerlink\" title=\"getWebSecurityConfigurers\"></a>getWebSecurityConfigurers</h3><p>入参二是有些奇怪的，实际上是执行了类<code>AutowiredWebSecurityConfigurersIgnoreParents</code>中的静态方法<em>getWebSecurityConfigurers</em>，目的是从上下文中获取到configures：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; getWebSecurityConfigurers() &#123;</span><br><span class=\"line\">   List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">   Map&lt;String, WebSecurityConfigurer&gt; beansOfType = beanFactory</span><br><span class=\"line\">         .getBeansOfType(WebSecurityConfigurer.class);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, WebSecurityConfigurer&gt; entry : beansOfType.entrySet()) &#123;</span><br><span class=\"line\">      webSecurityConfigurers.add(entry.getValue());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;C extends SecurityConfigurer&lt;O, B&gt;&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(C configurer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (configurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = allowConfigurersOfSameType ? <span class=\"keyword\">this</span>.configurers</span><br><span class=\"line\">            .get(clazz) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            configs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        configs.add(configurer);</span><br><span class=\"line\">        <span class=\"comment\">// private final LinkedHashMap&lt;Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt;, List&lt;SecurityConfigurer&lt;O, B&gt;&gt;&gt; configurers = new LinkedHashMap&lt;&gt;();</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configurers.put(clazz, configs);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要知道，我们在<em>入口</em>处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个<em>WebSecurityConfigurer</em>，他实现了接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebSecurityConfigurer</span>&lt;<span class=\"title\">WebSecurity</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法<em>getWebSecurityConfigurers</em>从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。</p>\n<h2 id=\"springSecurityFilterChain\"><a href=\"#springSecurityFilterChain\" class=\"headerlink\" title=\"springSecurityFilterChain\"></a>springSecurityFilterChain</h2><p>准备工作之后是过滤器链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \tpublic static final String DEFAULT_FILTER_NAME = &quot;springSecurityFilterChain&quot;;</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Filter <span class=\"title\">springSecurityFilterChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> hasConfigurers = webSecurityConfigurers != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为空的话新建一个</span></span><br><span class=\"line\">        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor</span><br><span class=\"line\">            .postProcess(<span class=\"keyword\">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 再次执行apply</span></span><br><span class=\"line\">        webSecurity.apply(adapter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为空的话 会直接执行这里的build方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> webSecurity.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> AtomicBoolean building = <span class=\"keyword\">new</span> AtomicBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> O <span class=\"title\">build</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里对build方法用了自旋CAS防止重复构建</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.building.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = doBuild();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AlreadyBuiltException(<span class=\"string\">&quot;This object has already been built&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。</p>\n<h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><p>初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取httpSecurity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> HttpSecurity http = getHttp();</span><br><span class=\"line\">    <span class=\"comment\">// web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值</span></span><br><span class=\"line\">    web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123;</span><br><span class=\"line\">        FilterSecurityInterceptor securityInterceptor = http</span><br><span class=\"line\">            .getSharedObject(FilterSecurityInterceptor.class);</span><br><span class=\"line\">        web.securityInterceptor(securityInterceptor);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"getHttp\"><a href=\"#getHttp\" class=\"headerlink\" title=\"getHttp\"></a>getHttp</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> HttpSecurity <span class=\"title\">getHttp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (http != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();</span><br><span class=\"line\">   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationManager authenticationManager = authenticationManager();</span><br><span class=\"line\">   authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class=\"line\">   Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成对象</span></span><br><span class=\"line\">   http = <span class=\"keyword\">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class=\"line\">         sharedObjects);</span><br><span class=\"line\">    <span class=\"comment\">// 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!disableDefaults) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:off</span></span><br><span class=\"line\">      http</span><br><span class=\"line\">         .csrf().and()</span><br><span class=\"line\">         .addFilter(<span class=\"keyword\">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class=\"line\">         .exceptionHandling().and()</span><br><span class=\"line\">         .headers().and()</span><br><span class=\"line\">         .sessionManagement().and()</span><br><span class=\"line\">         .securityContext().and()</span><br><span class=\"line\">         .requestCache().and()</span><br><span class=\"line\">         .anonymous().and()</span><br><span class=\"line\">         .servletApi().and()</span><br><span class=\"line\">         .apply(<span class=\"keyword\">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class=\"line\">         .logout();</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:on</span></span><br><span class=\"line\">      ClassLoader classLoader = <span class=\"keyword\">this</span>.context.getClassLoader();</span><br><span class=\"line\">      List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class=\"line\">            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class=\"line\">         http.apply(configurer);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 配置httpSecurity</span></span><br><span class=\"line\">   configure(http);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法中在返回httpSecurity对象之前会执行<em>configure</em>方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity<em>？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写</em>configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。</p>"},{"title":"binary search tree","date":"2021-02-27T07:58:06.000Z","_content":"\n这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 遍历\n\n二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。\n\n```java\npublic List<Integer> getValuesFromBST(TreeNode root){\n    TreeNode p = root;\n    List<Integer> list = new ArrayList<>();\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        list.add(p.val); // u can do anything here\n        p = p.right;\n    }\n    \n    return list;\n}\n```\n\n按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。\n\n# 有效\n\n根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：\n\n```java\npublic boolean isBSTValid(TreeNode root){\n    TreeNode p = root;\n    TreeNode pre = null; // 记录前一个节点\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p.left != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        if(pre != null && p.val <= pre.val){ // 判断是否合法\n            return false;\n        }\n        pre = p;\n        p = p.right;\n    }\n\n    return true;\n}\n```\n\n\n\n# 其他\n\n其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*[Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)*。","source":"_posts/binary-search-tre.md","raw":"---\ntitle: binary search tree\ndate: 2021-02-27 15:58:06\ncategories: Leetcode\ntags: bst\n---\n\n这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 遍历\n\n二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。\n\n```java\npublic List<Integer> getValuesFromBST(TreeNode root){\n    TreeNode p = root;\n    List<Integer> list = new ArrayList<>();\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        list.add(p.val); // u can do anything here\n        p = p.right;\n    }\n    \n    return list;\n}\n```\n\n按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。\n\n# 有效\n\n根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：\n\n```java\npublic boolean isBSTValid(TreeNode root){\n    TreeNode p = root;\n    TreeNode pre = null; // 记录前一个节点\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p.left != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        if(pre != null && p.val <= pre.val){ // 判断是否合法\n            return false;\n        }\n        pre = p;\n        p = p.right;\n    }\n\n    return true;\n}\n```\n\n\n\n# 其他\n\n其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*[Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)*。","slug":"binary-search-tre","published":1,"updated":"2021-03-05T15:49:46.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q6v0006w5ih90kr1epz","content":"<p>这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。</p>\n<a id=\"more\"></a>\n\n<!-- toc -->\n\n<h1 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h1><p>二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">getValuesFromBST</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        list.add(p.val); <span class=\"comment\">// u can do anything here</span></span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。</p>\n<h1 id=\"有效\"><a href=\"#有效\" class=\"headerlink\" title=\"有效\"></a>有效</h1><p>根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBSTValid</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    TreeNode pre = <span class=\"keyword\">null</span>; <span class=\"comment\">// 记录前一个节点</span></span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"keyword\">null</span> &amp;&amp; p.val &lt;= pre.val)&#123; <span class=\"comment\">// 判断是否合法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*<a href=\"https://leetcode.com/problems/score-of-parentheses/\">Score of Parentheses</a>*。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。</p>","more":"<!-- toc -->\n\n<h1 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h1><p>二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">getValuesFromBST</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        list.add(p.val); <span class=\"comment\">// u can do anything here</span></span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。</p>\n<h1 id=\"有效\"><a href=\"#有效\" class=\"headerlink\" title=\"有效\"></a>有效</h1><p>根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBSTValid</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    TreeNode pre = <span class=\"keyword\">null</span>; <span class=\"comment\">// 记录前一个节点</span></span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"keyword\">null</span> &amp;&amp; p.val &lt;= pre.val)&#123; <span class=\"comment\">// 判断是否合法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*<a href=\"https://leetcode.com/problems/score-of-parentheses/\">Score of Parentheses</a>*。</p>"},{"title":"bitwise","date":"2020-06-01T13:11:25.000Z","_content":"\nIntroduction of Java bitwise and operation.\n\n<!-- more -->\n\n# 简介\n\n| 操作符 | 名称         | 描述              |\n| ------ | ------------ | ----------------- |\n| &      | 与           | 1 & 1 = 1 (only)  |\n| \\|     | 或           | 0 \\| 0 = 0 (only) |\n| ^      | 异或         | 1 ^ 0 = 1         |\n| ~      | 非           | ~ 1 = 0           |\n| <<     | 左移         | 右边空出来的补0   |\n| >>     | 带符号位右移 | 最高位补符号位    |\n| >>>    | 无符号位右移 | 左边空出来的补0   |\n\n位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，<<=以及>>>=。\n\n位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。\n\n## 举例\n\n```java\nint a = -1;\n// 11111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a));\n// -1\nSystem.out.printlnl(a>>1);\n// 1111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a>>1));\n// 2147483647\nSystem.out.println(a>>>1);\n// 0111111111111111111111111111111111(31个1)\nSystem.out.prinlnt(Integer.toBinaryString(a>>>1));\n```\n\n### 分析：\n\n#### a>>1\n\n原码：10000000000000000000000000000001\n\n反码：1111111111111111111111111111111111110\n\n补码：1111111111111111111111111111111111111\n\n补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）\n\n取反：10000000000000000000000000000000\n\n原码：10000000000000000000000000000001 即 -1.\n\n#### a>>>1\n\n同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。\n\n补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）\n\n正数原码即补码。\n\n# 应用\n\n## HashMap\n\n```java\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的`^`, `|`, `<<`, `<<<`等位运算符。\n\n## 奇偶性\n\n```java\n2 & 1; // 0\n8 & 1; // 0\n7 & 1; // 1\n```\n\n1的原码：0001\n\n8的原码：1000\n\n7的原码：0111\n\n奇数的最低位永远是1,偶数的为0.\n\n## 求非重复数字\n\n```markdown\n2 ^ 2 ^ 1 = 1\n4 ^ 2 ^ 1 ^ 1 ^ 2 = 4\n```\n\n两个**相同的数字**做`^`运算时，值为`0`，再结合**交换律**，可以用来找出一组数字中“落单”的数字。\n\n## etc\n\n……\n\n","source":"_posts/bitwise.md","raw":"---\ntitle: bitwise\ndate: 2020-06-01 21:11:25\ncategories: Java\ntags: bitwise\n---\n\nIntroduction of Java bitwise and operation.\n\n<!-- more -->\n\n# 简介\n\n| 操作符 | 名称         | 描述              |\n| ------ | ------------ | ----------------- |\n| &      | 与           | 1 & 1 = 1 (only)  |\n| \\|     | 或           | 0 \\| 0 = 0 (only) |\n| ^      | 异或         | 1 ^ 0 = 1         |\n| ~      | 非           | ~ 1 = 0           |\n| <<     | 左移         | 右边空出来的补0   |\n| >>     | 带符号位右移 | 最高位补符号位    |\n| >>>    | 无符号位右移 | 左边空出来的补0   |\n\n位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，<<=以及>>>=。\n\n位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。\n\n## 举例\n\n```java\nint a = -1;\n// 11111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a));\n// -1\nSystem.out.printlnl(a>>1);\n// 1111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a>>1));\n// 2147483647\nSystem.out.println(a>>>1);\n// 0111111111111111111111111111111111(31个1)\nSystem.out.prinlnt(Integer.toBinaryString(a>>>1));\n```\n\n### 分析：\n\n#### a>>1\n\n原码：10000000000000000000000000000001\n\n反码：1111111111111111111111111111111111110\n\n补码：1111111111111111111111111111111111111\n\n补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）\n\n取反：10000000000000000000000000000000\n\n原码：10000000000000000000000000000001 即 -1.\n\n#### a>>>1\n\n同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。\n\n补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）\n\n正数原码即补码。\n\n# 应用\n\n## HashMap\n\n```java\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的`^`, `|`, `<<`, `<<<`等位运算符。\n\n## 奇偶性\n\n```java\n2 & 1; // 0\n8 & 1; // 0\n7 & 1; // 1\n```\n\n1的原码：0001\n\n8的原码：1000\n\n7的原码：0111\n\n奇数的最低位永远是1,偶数的为0.\n\n## 求非重复数字\n\n```markdown\n2 ^ 2 ^ 1 = 1\n4 ^ 2 ^ 1 ^ 1 ^ 2 = 4\n```\n\n两个**相同的数字**做`^`运算时，值为`0`，再结合**交换律**，可以用来找出一组数字中“落单”的数字。\n\n## etc\n\n……\n\n","slug":"bitwise","published":1,"updated":"2020-11-08T07:20:16.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q6x0009w5ihdile7yi8","content":"<p>Introduction of Java bitwise and operation.</p>\n<a id=\"more\"></a>\n\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>与</td>\n<td>1 &amp; 1 = 1 (only)</td>\n</tr>\n<tr>\n<td>|</td>\n<td>或</td>\n<td>0 | 0 = 0 (only)</td>\n</tr>\n<tr>\n<td>^</td>\n<td>异或</td>\n<td>1 ^ 0 = 1</td>\n</tr>\n<tr>\n<td>~</td>\n<td>非</td>\n<td>~ 1 = 0</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移</td>\n<td>右边空出来的补0</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>带符号位右移</td>\n<td>最高位补符号位</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td>无符号位右移</td>\n<td>左边空出来的补0</td>\n</tr>\n</tbody></table>\n<p>位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，&lt;&lt;=以及&gt;&gt;&gt;=。</p>\n<p>位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 11111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a));</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\">System.out.printlnl(a&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a&gt;&gt;<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2147483647</span></span><br><span class=\"line\">System.out.println(a&gt;&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 0111111111111111111111111111111111(31个1)</span></span><br><span class=\"line\">System.out.prinlnt(Integer.toBinaryString(a&gt;&gt;&gt;<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><h4 id=\"a-gt-gt-1\"><a href=\"#a-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;1\"></a>a&gt;&gt;1</h4><p>原码：10000000000000000000000000000001</p>\n<p>反码：1111111111111111111111111111111111110</p>\n<p>补码：1111111111111111111111111111111111111</p>\n<p>补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）</p>\n<p>取反：10000000000000000000000000000000</p>\n<p>原码：10000000000000000000000000000001 即 -1.</p>\n<h4 id=\"a-gt-gt-gt-1\"><a href=\"#a-gt-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;&gt;1\"></a>a&gt;&gt;&gt;1</h4><p>同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。</p>\n<p>补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）</p>\n<p>正数原码即补码。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的<code>^</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;&lt;</code>等位运算符。</p>\n<h2 id=\"奇偶性\"><a href=\"#奇偶性\" class=\"headerlink\" title=\"奇偶性\"></a>奇偶性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">8</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">7</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>1的原码：0001</p>\n<p>8的原码：1000</p>\n<p>7的原码：0111</p>\n<p>奇数的最低位永远是1,偶数的为0.</p>\n<h2 id=\"求非重复数字\"><a href=\"#求非重复数字\" class=\"headerlink\" title=\"求非重复数字\"></a>求非重复数字</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 ^ 2 ^ 1 = 1</span><br><span class=\"line\">4 ^ 2 ^ 1 ^ 1 ^ 2 = 4</span><br></pre></td></tr></table></figure>\n\n<p>两个<strong>相同的数字</strong>做<code>^</code>运算时，值为<code>0</code>，再结合<strong>交换律</strong>，可以用来找出一组数字中“落单”的数字。</p>\n<h2 id=\"etc\"><a href=\"#etc\" class=\"headerlink\" title=\"etc\"></a>etc</h2><p>……</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Introduction of Java bitwise and operation.</p>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>与</td>\n<td>1 &amp; 1 = 1 (only)</td>\n</tr>\n<tr>\n<td>|</td>\n<td>或</td>\n<td>0 | 0 = 0 (only)</td>\n</tr>\n<tr>\n<td>^</td>\n<td>异或</td>\n<td>1 ^ 0 = 1</td>\n</tr>\n<tr>\n<td>~</td>\n<td>非</td>\n<td>~ 1 = 0</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移</td>\n<td>右边空出来的补0</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>带符号位右移</td>\n<td>最高位补符号位</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td>无符号位右移</td>\n<td>左边空出来的补0</td>\n</tr>\n</tbody></table>\n<p>位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，&lt;&lt;=以及&gt;&gt;&gt;=。</p>\n<p>位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 11111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a));</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\">System.out.printlnl(a&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a&gt;&gt;<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2147483647</span></span><br><span class=\"line\">System.out.println(a&gt;&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 0111111111111111111111111111111111(31个1)</span></span><br><span class=\"line\">System.out.prinlnt(Integer.toBinaryString(a&gt;&gt;&gt;<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><h4 id=\"a-gt-gt-1\"><a href=\"#a-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;1\"></a>a&gt;&gt;1</h4><p>原码：10000000000000000000000000000001</p>\n<p>反码：1111111111111111111111111111111111110</p>\n<p>补码：1111111111111111111111111111111111111</p>\n<p>补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）</p>\n<p>取反：10000000000000000000000000000000</p>\n<p>原码：10000000000000000000000000000001 即 -1.</p>\n<h4 id=\"a-gt-gt-gt-1\"><a href=\"#a-gt-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;&gt;1\"></a>a&gt;&gt;&gt;1</h4><p>同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。</p>\n<p>补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）</p>\n<p>正数原码即补码。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的<code>^</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;&lt;</code>等位运算符。</p>\n<h2 id=\"奇偶性\"><a href=\"#奇偶性\" class=\"headerlink\" title=\"奇偶性\"></a>奇偶性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">8</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">7</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>1的原码：0001</p>\n<p>8的原码：1000</p>\n<p>7的原码：0111</p>\n<p>奇数的最低位永远是1,偶数的为0.</p>\n<h2 id=\"求非重复数字\"><a href=\"#求非重复数字\" class=\"headerlink\" title=\"求非重复数字\"></a>求非重复数字</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 ^ 2 ^ 1 = 1</span><br><span class=\"line\">4 ^ 2 ^ 1 ^ 1 ^ 2 = 4</span><br></pre></td></tr></table></figure>\n\n<p>两个<strong>相同的数字</strong>做<code>^</code>运算时，值为<code>0</code>，再结合<strong>交换律</strong>，可以用来找出一组数字中“落单”的数字。</p>\n<h2 id=\"etc\"><a href=\"#etc\" class=\"headerlink\" title=\"etc\"></a>etc</h2><p>……</p>"},{"title":"contest200","date":"2020-08-02T04:56:29.000Z","_content":"\nRecord Leetcode contest 200.\n\n<!--more-->\n\n# Q1\n\npassed.\n\n# Q2\n\nFind the winner of an Array Game.\n\nGiven an integer array `arr` of **distinct** integers and an integer `k`.\n\nA game will be played between the first two elements of the array (i.e. `arr[0]` and `arr[1]`). In each round of the game, we compare `arr[0]` with `arr[1]`, the larger integer wins and remains at position `0` and the smaller integer moves to the end of the array. The game ends when an integer wins `k` consecutive rounds.\n\nReturn *the integer which will win the game*.\n\nIt is **guaranteed** that there will be a winner of the game.\n\n**Example 1:**\n\n```markdown\nInput: arr = [2,1,3,5,4,6,7], k = 2\nOutput: 5\nExplanation: Let's see the rounds of the game:\nRound |       arr       | winner | win_count\n  1   | [2,1,3,5,4,6,7] | 2      | 1\n  2   | [2,3,5,4,6,7,1] | 3      | 1\n  3   | [3,5,4,6,7,1,2] | 5      | 1\n  4   | [5,4,6,7,1,2,3] | 5      | 2\nSo we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.\n```\n\n**Example 2:**\n\n```markdown\nInput: arr = [3,2,1], k = 10\nOutput: 3\nExplanation: 3 will win the first 10 rounds consecutively.\n```\n\n**Example 3:**\n\n```markdown\nInput: arr = [1,9,8,2,3,7,6,4,5], k = 7\nOutput: 9\n```\n\n**Example 4:**\n\n```markdown\nInput: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000\nOutput: 99\n```\n\n## My Solution\n\n看到这题，首先我认为这题清晰明了，用__迭代__去完成全部流程，用**k**去做结束的标志，是一道从头到尾很明确的题。但是:joy:\n\n贴上我稚嫩的代码：\n\n```java\npublic int getWinner(int[] arr, int k) {\n    int res = -1;\n    int zero = k-1;\n    int solution = 0;\n    while(k>0){\n        int currMax = Math.max(arr[0],arr[1]);\n        int currMin = Math.min(arr[0], arr[1]);\n        helper(currMax, currMin, arr);\n        if(res == -1){\n            // initial, no compare\n            res = currMax;\n        }else{\n            if(currMax == res){\n                k--;\n                solution = currMax;\n            }else{\n                k = zero;\n                res = currMax;\n            }\n        }\n    }\n    return solution;\n}\n\nprivate void helper(int max, int min, int[] arr){\n    arr[0] = max;\n    for (int i = 1; i < arr.length - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    arr[arr.length-1] = min;\n}\n```\n\n没通过，因为`Time Limited`，跑得太慢了！\n\n## Niubility Solution\n\n```java\npublic int getWinner(int[] arr, int k) {\n    // 数组长度\n    int n = arr.length;\n    // 数组长度与k之间取最小的。\n    k = Math.min(k, n);\n    int A = arr[0];\n    // 标志位，记录相同次数\n    int rep = 0;\n    // 从第二个开始iterate，无终结条件\n    for(int i = 1;;i++){\n        // “i%n“ 取余数，逻辑变换数组。由于for循环无终结条件，所以i会无限增加超过n。\n        int B = arr[i%n];\n        if(A >= B){\n            rep++;\n        }else{\n            A = B;\n            rep = 1;\n        }\n        // 终结条件在这里，rep等于k时结束。\n        if(rep == k){\n            return A;\n        }\n    }\n}\n```\n\n**通过对比可以发现，我耗时的原因在于：** \n\n1. 我是真的挪了数组！物理上的挪动，实际上，逻辑移动数组即可！我的程序算例4要6秒，这个只需要0秒。\n2. `Math.min(k, n)`，如果题目给的k为`10000000`,数组长度为`8`,那么最后也是按`8` 来算，那么多循环无意义，一遍遍历即可获取最大（这样也行？）\n\n况且，逻辑i上也没有去变换位置，题目的本质还是挨个遍历！\n\ni.e. arr = [2,1,3,5,4,6,7], k = 2","source":"_posts/contest200.md","raw":"---\ntitle: contest200\ndate: 2020-08-02 12:56:29\ncategories: Leetcode\ntags: algorithm\n---\n\nRecord Leetcode contest 200.\n\n<!--more-->\n\n# Q1\n\npassed.\n\n# Q2\n\nFind the winner of an Array Game.\n\nGiven an integer array `arr` of **distinct** integers and an integer `k`.\n\nA game will be played between the first two elements of the array (i.e. `arr[0]` and `arr[1]`). In each round of the game, we compare `arr[0]` with `arr[1]`, the larger integer wins and remains at position `0` and the smaller integer moves to the end of the array. The game ends when an integer wins `k` consecutive rounds.\n\nReturn *the integer which will win the game*.\n\nIt is **guaranteed** that there will be a winner of the game.\n\n**Example 1:**\n\n```markdown\nInput: arr = [2,1,3,5,4,6,7], k = 2\nOutput: 5\nExplanation: Let's see the rounds of the game:\nRound |       arr       | winner | win_count\n  1   | [2,1,3,5,4,6,7] | 2      | 1\n  2   | [2,3,5,4,6,7,1] | 3      | 1\n  3   | [3,5,4,6,7,1,2] | 5      | 1\n  4   | [5,4,6,7,1,2,3] | 5      | 2\nSo we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.\n```\n\n**Example 2:**\n\n```markdown\nInput: arr = [3,2,1], k = 10\nOutput: 3\nExplanation: 3 will win the first 10 rounds consecutively.\n```\n\n**Example 3:**\n\n```markdown\nInput: arr = [1,9,8,2,3,7,6,4,5], k = 7\nOutput: 9\n```\n\n**Example 4:**\n\n```markdown\nInput: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000\nOutput: 99\n```\n\n## My Solution\n\n看到这题，首先我认为这题清晰明了，用__迭代__去完成全部流程，用**k**去做结束的标志，是一道从头到尾很明确的题。但是:joy:\n\n贴上我稚嫩的代码：\n\n```java\npublic int getWinner(int[] arr, int k) {\n    int res = -1;\n    int zero = k-1;\n    int solution = 0;\n    while(k>0){\n        int currMax = Math.max(arr[0],arr[1]);\n        int currMin = Math.min(arr[0], arr[1]);\n        helper(currMax, currMin, arr);\n        if(res == -1){\n            // initial, no compare\n            res = currMax;\n        }else{\n            if(currMax == res){\n                k--;\n                solution = currMax;\n            }else{\n                k = zero;\n                res = currMax;\n            }\n        }\n    }\n    return solution;\n}\n\nprivate void helper(int max, int min, int[] arr){\n    arr[0] = max;\n    for (int i = 1; i < arr.length - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    arr[arr.length-1] = min;\n}\n```\n\n没通过，因为`Time Limited`，跑得太慢了！\n\n## Niubility Solution\n\n```java\npublic int getWinner(int[] arr, int k) {\n    // 数组长度\n    int n = arr.length;\n    // 数组长度与k之间取最小的。\n    k = Math.min(k, n);\n    int A = arr[0];\n    // 标志位，记录相同次数\n    int rep = 0;\n    // 从第二个开始iterate，无终结条件\n    for(int i = 1;;i++){\n        // “i%n“ 取余数，逻辑变换数组。由于for循环无终结条件，所以i会无限增加超过n。\n        int B = arr[i%n];\n        if(A >= B){\n            rep++;\n        }else{\n            A = B;\n            rep = 1;\n        }\n        // 终结条件在这里，rep等于k时结束。\n        if(rep == k){\n            return A;\n        }\n    }\n}\n```\n\n**通过对比可以发现，我耗时的原因在于：** \n\n1. 我是真的挪了数组！物理上的挪动，实际上，逻辑移动数组即可！我的程序算例4要6秒，这个只需要0秒。\n2. `Math.min(k, n)`，如果题目给的k为`10000000`,数组长度为`8`,那么最后也是按`8` 来算，那么多循环无意义，一遍遍历即可获取最大（这样也行？）\n\n况且，逻辑i上也没有去变换位置，题目的本质还是挨个遍历！\n\ni.e. arr = [2,1,3,5,4,6,7], k = 2","slug":"contest200","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q6z000bw5iheq0k9nyw","content":"<p>Record Leetcode contest 200.</p>\n<a id=\"more\"></a>\n\n<h1 id=\"Q1\"><a href=\"#Q1\" class=\"headerlink\" title=\"Q1\"></a>Q1</h1><p>passed.</p>\n<h1 id=\"Q2\"><a href=\"#Q2\" class=\"headerlink\" title=\"Q2\"></a>Q2</h1><p>Find the winner of an Array Game.</p>\n<p>Given an integer array <code>arr</code> of <strong>distinct</strong> integers and an integer <code>k</code>.</p>\n<p>A game will be played between the first two elements of the array (i.e. <code>arr[0]</code> and <code>arr[1]</code>). In each round of the game, we compare <code>arr[0]</code> with <code>arr[1]</code>, the larger integer wins and remains at position <code>0</code> and the smaller integer moves to the end of the array. The game ends when an integer wins <code>k</code> consecutive rounds.</p>\n<p>Return <em>the integer which will win the game</em>.</p>\n<p>It is <strong>guaranteed</strong> that there will be a winner of the game.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [2,1,3,5,4,6,7], k = 2</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: Let&#x27;s see the rounds of the game:</span><br><span class=\"line\">Round |       arr       | winner | win<span class=\"emphasis\">_count</span></span><br><span class=\"line\"><span class=\"emphasis\">  1   | [2,1,3,5,4,6,7] | 2      | 1</span></span><br><span class=\"line\"><span class=\"emphasis\">  2   | [2,3,5,4,6,7,1] | 3      | 1</span></span><br><span class=\"line\"><span class=\"emphasis\">  3   | [3,5,4,6,7,1,2] | 5      | 1</span></span><br><span class=\"line\"><span class=\"emphasis\">  4   | [5,4,6,7,1,2,3] | 5      | 2</span></span><br><span class=\"line\"><span class=\"emphasis\">So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [3,2,1], k = 10</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 will win the first 10 rounds consecutively.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [1,9,8,2,3,7,6,4,5], k = 7</span><br><span class=\"line\">Output: 9</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000</span><br><span class=\"line\">Output: 99</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><p>看到这题，首先我认为这题清晰明了，用__迭代__去完成全部流程，用<strong>k</strong>去做结束的标志，是一道从头到尾很明确的题。但是:joy:</p>\n<p>贴上我稚嫩的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zero = k-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> solution = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currMax = Math.max(arr[<span class=\"number\">0</span>],arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currMin = Math.min(arr[<span class=\"number\">0</span>], arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        helper(currMax, currMin, arr);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// initial, no compare</span></span><br><span class=\"line\">            res = currMax;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(currMax == res)&#123;</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">                solution = currMax;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                k = zero;</span><br><span class=\"line\">                res = currMax;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> solution;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> max, <span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    arr[<span class=\"number\">0</span>] = max;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        arr[i] = arr[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[arr.length-<span class=\"number\">1</span>] = min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没通过，因为<code>Time Limited</code>，跑得太慢了！</p>\n<h2 id=\"Niubility-Solution\"><a href=\"#Niubility-Solution\" class=\"headerlink\" title=\"Niubility Solution\"></a>Niubility Solution</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度与k之间取最小的。</span></span><br><span class=\"line\">    k = Math.min(k, n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> A = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 标志位，记录相同次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rep = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 从第二个开始iterate，无终结条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;;i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// “i%n“ 取余数，逻辑变换数组。由于for循环无终结条件，所以i会无限增加超过n。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> B = arr[i%n];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A &gt;= B)&#123;</span><br><span class=\"line\">            rep++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            A = B;</span><br><span class=\"line\">            rep = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 终结条件在这里，rep等于k时结束。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rep == k)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过对比可以发现，我耗时的原因在于：</strong> </p>\n<ol>\n<li>我是真的挪了数组！物理上的挪动，实际上，逻辑移动数组即可！我的程序算例4要6秒，这个只需要0秒。</li>\n<li><code>Math.min(k, n)</code>，如果题目给的k为<code>10000000</code>,数组长度为<code>8</code>,那么最后也是按<code>8</code> 来算，那么多循环无意义，一遍遍历即可获取最大（这样也行？）</li>\n</ol>\n<p>况且，逻辑i上也没有去变换位置，题目的本质还是挨个遍历！</p>\n<p>i.e. arr = [2,1,3,5,4,6,7], k = 2</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Record Leetcode contest 200.</p>","more":"<h1 id=\"Q1\"><a href=\"#Q1\" class=\"headerlink\" title=\"Q1\"></a>Q1</h1><p>passed.</p>\n<h1 id=\"Q2\"><a href=\"#Q2\" class=\"headerlink\" title=\"Q2\"></a>Q2</h1><p>Find the winner of an Array Game.</p>\n<p>Given an integer array <code>arr</code> of <strong>distinct</strong> integers and an integer <code>k</code>.</p>\n<p>A game will be played between the first two elements of the array (i.e. <code>arr[0]</code> and <code>arr[1]</code>). In each round of the game, we compare <code>arr[0]</code> with <code>arr[1]</code>, the larger integer wins and remains at position <code>0</code> and the smaller integer moves to the end of the array. The game ends when an integer wins <code>k</code> consecutive rounds.</p>\n<p>Return <em>the integer which will win the game</em>.</p>\n<p>It is <strong>guaranteed</strong> that there will be a winner of the game.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [2,1,3,5,4,6,7], k = 2</span><br><span class=\"line\">Output: 5</span><br><span class=\"line\">Explanation: Let&#x27;s see the rounds of the game:</span><br><span class=\"line\">Round |       arr       | winner | win<span class=\"emphasis\">_count</span></span><br><span class=\"line\"><span class=\"emphasis\">  1   | [2,1,3,5,4,6,7] | 2      | 1</span></span><br><span class=\"line\"><span class=\"emphasis\">  2   | [2,3,5,4,6,7,1] | 3      | 1</span></span><br><span class=\"line\"><span class=\"emphasis\">  3   | [3,5,4,6,7,1,2] | 5      | 1</span></span><br><span class=\"line\"><span class=\"emphasis\">  4   | [5,4,6,7,1,2,3] | 5      | 2</span></span><br><span class=\"line\"><span class=\"emphasis\">So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [3,2,1], k = 10</span><br><span class=\"line\">Output: 3</span><br><span class=\"line\">Explanation: 3 will win the first 10 rounds consecutively.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [1,9,8,2,3,7,6,4,5], k = 7</span><br><span class=\"line\">Output: 9</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000</span><br><span class=\"line\">Output: 99</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><p>看到这题，首先我认为这题清晰明了，用__迭代__去完成全部流程，用<strong>k</strong>去做结束的标志，是一道从头到尾很明确的题。但是:joy:</p>\n<p>贴上我稚嫩的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zero = k-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> solution = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currMax = Math.max(arr[<span class=\"number\">0</span>],arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currMin = Math.min(arr[<span class=\"number\">0</span>], arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        helper(currMax, currMin, arr);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// initial, no compare</span></span><br><span class=\"line\">            res = currMax;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(currMax == res)&#123;</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">                solution = currMax;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                k = zero;</span><br><span class=\"line\">                res = currMax;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> solution;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span> max, <span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    arr[<span class=\"number\">0</span>] = max;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        arr[i] = arr[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[arr.length-<span class=\"number\">1</span>] = min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没通过，因为<code>Time Limited</code>，跑得太慢了！</p>\n<h2 id=\"Niubility-Solution\"><a href=\"#Niubility-Solution\" class=\"headerlink\" title=\"Niubility Solution\"></a>Niubility Solution</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度与k之间取最小的。</span></span><br><span class=\"line\">    k = Math.min(k, n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> A = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 标志位，记录相同次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rep = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 从第二个开始iterate，无终结条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;;i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// “i%n“ 取余数，逻辑变换数组。由于for循环无终结条件，所以i会无限增加超过n。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> B = arr[i%n];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A &gt;= B)&#123;</span><br><span class=\"line\">            rep++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            A = B;</span><br><span class=\"line\">            rep = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 终结条件在这里，rep等于k时结束。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rep == k)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过对比可以发现，我耗时的原因在于：</strong> </p>\n<ol>\n<li>我是真的挪了数组！物理上的挪动，实际上，逻辑移动数组即可！我的程序算例4要6秒，这个只需要0秒。</li>\n<li><code>Math.min(k, n)</code>，如果题目给的k为<code>10000000</code>,数组长度为<code>8</code>,那么最后也是按<code>8</code> 来算，那么多循环无意义，一遍遍历即可获取最大（这样也行？）</li>\n</ol>\n<p>况且，逻辑i上也没有去变换位置，题目的本质还是挨个遍历！</p>\n<p>i.e. arr = [2,1,3,5,4,6,7], k = 2</p>"},{"title":"contest201","date":"2020-08-09T04:22:53.000Z","_content":"\nLeetcode周赛201.\n\n<!--more-->\n\n# 1544 Make The String Great\n\nGiven a string `s` of lower and upper case English letters.\n\nA good string is a string which doesn't have **two adjacent characters** `s[i]` and `s[i + 1]` where:\n\n- `0 <= i <= s.length - 2`\n- `s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or **vice-versa**.\n\nTo make the string good, you can choose **two adjacent** characters that make the string bad and remove them. You can keep doing this until the string becomes good.\n\nReturn *the string* after making it good. The answer is guaranteed to be unique under the given constraints.\n\n**Notice** that an empty string is also good.\n\n**Example 1:**\n\n```\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".\n```\n\n**Example 2:**\n\n```\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: We have many possible scenarios, and all lead to the same answer. For example:\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\n```\n\n**Example 3:**\n\n```\nInput: s = \"s\"\nOutput: \"s\"\n```\n\n## Solution\n\n- 首先要注意审题，明确界限的判断。尤其是`vice-versa`，反之亦然的意思，就是**相邻两个字母忽略大小写时相同，且一个大写一个小写**，需要将这两个字母剔除。\n- 通过`example 2`可以看出算法应有*循环*的动作，剔除后还应该重新审视。\n\n### mine\n\n```java\npublic String makeGood(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (!stack.empty() && (\n                (Character.isUpperCase(c) && Character.isLowerCase(stack.peek()) && ((stack.peek() - 'a') == (c - 'A')))\n                        ||\n                        (Character.isLowerCase(c) && Character.isUpperCase(stack.peek()) && ((stack.peek() - 'A') == (c - 'a')))\n        )) {\n            stack.pop();\n        } else {\n            stack.push(c);\n        }\n    }\n    Iterator<Character> iterator = stack.iterator();\n    StringBuilder sb = new StringBuilder();\n    while (iterator.hasNext()) {\n        sb.append(iterator.next());\n    }\n\t// 因为是iterator，不用reverse()\n    return sb.toString();\n}\n```\n### better\n\n```java\nboolean ch = true;\nwhile (ch) {\n    ch = false;\n    String t = s;\n    for (int i = 0; i < s.length() - 1; ++i) {\n        if (s.charAt(i) + 32 == s.charAt(i + 1) || s.charAt(i + 1) + 32 == s.charAt(i)) {\n            t = s.substring(0, i) + s.substring(i + 2);\n            ch = true;\n            break;\n        }\n    }\n    s = t;\n}\nreturn s;\n```\n\n# 1545 Find Kth Bit in Nth Binary String\n\nGiven two positive integers `n` and `k`, the binary string `Sn` is formed as follows:\n\n- `S1 = \"0\"`\n- `Si = Si-1 + \"1\" + reverse(invert(Si-1))` for `i > 1`\n\nWhere `+` denotes the concatenation operation, `reverse(x)` returns the reversed string x, and `invert(x)` inverts all the bits in x (0 changes to 1 and 1 changes to 0).\n\nFor example, the first 4 strings in the above sequence are:\n\n- S1 = \"0\"\n- S2 = \"0**1**1\"\n- S3 = \"011**1**001\"\n- S4 = \"0111001**1**0110001\"\n\nReturn *the* `kth` *bit* *in* `Sn`. It is guaranteed that `k` is valid for the given `n`.\n\n \n\n**Example 1:**\n\n```\nInput: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\". The first bit is \"0\".\n```\n\n**Example 2:**\n\n```\nInput: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\". The 11th bit is \"1\".\n```\n\n**Example 3:**\n\n```\nInput: n = 1, k = 1\nOutput: \"0\"\n```\n\n**Example 4:**\n\n```\nInput: n = 2, k = 3\nOutput: \"1\"\n```\n\n## Solution\n\n题目中已经给了计算式，根据式子来计算结果。\n\n```java\npublic char findKthBit(int n, int k) {\n    StringBuilder sb = new StringBuilder(\"0\");\n    while (n > 1) {\n        int integer = Integer.parseInt(sb.toString());\n        StringBuilder stringBuilder = new StringBuilder(Integer.toBinaryString(integer));\n        // 0-1 inverse\n        for (int i = 0; i < stringBuilder.length(); i++) {\n            if (stringBuilder.charAt(i) == '0') {\n                stringBuilder.replace(i, i + 1, \"1\");\n            } else {\n                stringBuilder.replace(i, i + 1, \"0\");\n            }\n        }\n        stringBuilder.reverse();\n        sb.append(\"1\").append(stringBuilder);\n        n--;\n        System.out.println(sb.toString());\n    }\n\n    char[] chars = sb.toString().toCharArray();\n    return chars[k - 1];\n}\n```\n\n上面的解题过程是错的，我觉得最好的方式应该是用递归，但是不太会，用来迭代，在n=4时的结果就错了。\n\n### better\n\n做`0-1`转换时，当时想用位运算，怎奈不熟练、没想起来`异或`。\n\n- 异或 ^ ：相同为0，0异或任何数为任何数。在二进制的情况下，与`1`异或等同于`0-1`翻转。\n\n#### method 1\n\n一目了然，迭代\n\n```java\npublic char findKthBit(int n, int k) {\n    String s = \"0\";\n    while (n>1) {\n        --n;\n        s = s+\"1\"+sinv(s);\n    }\n    // 从0开始，k-1\n    return s.charAt(k-1);\n}\n\npublic String sinv(String s) {\n    StringBuilder a = new StringBuilder();\n    // 从后遍历，reverse()\n    for (int i = s.length()-1; i>=0; --i) {\n        char c = s.charAt(i);\n        // 0-1翻转\n        c^=1;\n        a.append(c);\n    }\n    return a.toString();\n}\n```\n\n#### method 2\n\n别具一格\n\n```java\npublic char findKthBit(int n, int k){\n    char findKthBit(int n, int k) \n    s[1]=\"0\";\n    t[1]=\"1\";\n    for(int i=2;i<=n;i++){\n        s[i]=s[i-1];\n        s[i]+='1';\n        s[i]+=t[i-1];\n        t[i]=s[i-1];\n        t[i]+='0';\n        t[i]+=t[i-1];\n    }\n    return s[n][k-1];\n}\n```\n\n#### method 3\n\n清清楚楚，深度优先\n\n```java\nchar dfs(int n, int k) {\n    if (n == 1) {\n        return '0';\n    } else {\n        int len = (1 << n) - 1;\n        int base = (1 << (n - 1)) - 1;\n        if (k == base + 1) {\n            return '1';\n        } else if (k <= base) {\n            return dfs(n - 1, k);\n        } else {\n            return dfs(n - 1, len - k + 1) ^ 1;\n        }\n    }\n}\n\nchar findKthBit(int n, int k) {\n    return dfs(n, k);\n}\n```\n\n","source":"_posts/contest201.md","raw":"---\ntitle: contest201\ndate: 2020-08-09 12:22:53\ncategories: Leetcode\ntags: algorithm\n---\n\nLeetcode周赛201.\n\n<!--more-->\n\n# 1544 Make The String Great\n\nGiven a string `s` of lower and upper case English letters.\n\nA good string is a string which doesn't have **two adjacent characters** `s[i]` and `s[i + 1]` where:\n\n- `0 <= i <= s.length - 2`\n- `s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or **vice-versa**.\n\nTo make the string good, you can choose **two adjacent** characters that make the string bad and remove them. You can keep doing this until the string becomes good.\n\nReturn *the string* after making it good. The answer is guaranteed to be unique under the given constraints.\n\n**Notice** that an empty string is also good.\n\n**Example 1:**\n\n```\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".\n```\n\n**Example 2:**\n\n```\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: We have many possible scenarios, and all lead to the same answer. For example:\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\n```\n\n**Example 3:**\n\n```\nInput: s = \"s\"\nOutput: \"s\"\n```\n\n## Solution\n\n- 首先要注意审题，明确界限的判断。尤其是`vice-versa`，反之亦然的意思，就是**相邻两个字母忽略大小写时相同，且一个大写一个小写**，需要将这两个字母剔除。\n- 通过`example 2`可以看出算法应有*循环*的动作，剔除后还应该重新审视。\n\n### mine\n\n```java\npublic String makeGood(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (!stack.empty() && (\n                (Character.isUpperCase(c) && Character.isLowerCase(stack.peek()) && ((stack.peek() - 'a') == (c - 'A')))\n                        ||\n                        (Character.isLowerCase(c) && Character.isUpperCase(stack.peek()) && ((stack.peek() - 'A') == (c - 'a')))\n        )) {\n            stack.pop();\n        } else {\n            stack.push(c);\n        }\n    }\n    Iterator<Character> iterator = stack.iterator();\n    StringBuilder sb = new StringBuilder();\n    while (iterator.hasNext()) {\n        sb.append(iterator.next());\n    }\n\t// 因为是iterator，不用reverse()\n    return sb.toString();\n}\n```\n### better\n\n```java\nboolean ch = true;\nwhile (ch) {\n    ch = false;\n    String t = s;\n    for (int i = 0; i < s.length() - 1; ++i) {\n        if (s.charAt(i) + 32 == s.charAt(i + 1) || s.charAt(i + 1) + 32 == s.charAt(i)) {\n            t = s.substring(0, i) + s.substring(i + 2);\n            ch = true;\n            break;\n        }\n    }\n    s = t;\n}\nreturn s;\n```\n\n# 1545 Find Kth Bit in Nth Binary String\n\nGiven two positive integers `n` and `k`, the binary string `Sn` is formed as follows:\n\n- `S1 = \"0\"`\n- `Si = Si-1 + \"1\" + reverse(invert(Si-1))` for `i > 1`\n\nWhere `+` denotes the concatenation operation, `reverse(x)` returns the reversed string x, and `invert(x)` inverts all the bits in x (0 changes to 1 and 1 changes to 0).\n\nFor example, the first 4 strings in the above sequence are:\n\n- S1 = \"0\"\n- S2 = \"0**1**1\"\n- S3 = \"011**1**001\"\n- S4 = \"0111001**1**0110001\"\n\nReturn *the* `kth` *bit* *in* `Sn`. It is guaranteed that `k` is valid for the given `n`.\n\n \n\n**Example 1:**\n\n```\nInput: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\". The first bit is \"0\".\n```\n\n**Example 2:**\n\n```\nInput: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\". The 11th bit is \"1\".\n```\n\n**Example 3:**\n\n```\nInput: n = 1, k = 1\nOutput: \"0\"\n```\n\n**Example 4:**\n\n```\nInput: n = 2, k = 3\nOutput: \"1\"\n```\n\n## Solution\n\n题目中已经给了计算式，根据式子来计算结果。\n\n```java\npublic char findKthBit(int n, int k) {\n    StringBuilder sb = new StringBuilder(\"0\");\n    while (n > 1) {\n        int integer = Integer.parseInt(sb.toString());\n        StringBuilder stringBuilder = new StringBuilder(Integer.toBinaryString(integer));\n        // 0-1 inverse\n        for (int i = 0; i < stringBuilder.length(); i++) {\n            if (stringBuilder.charAt(i) == '0') {\n                stringBuilder.replace(i, i + 1, \"1\");\n            } else {\n                stringBuilder.replace(i, i + 1, \"0\");\n            }\n        }\n        stringBuilder.reverse();\n        sb.append(\"1\").append(stringBuilder);\n        n--;\n        System.out.println(sb.toString());\n    }\n\n    char[] chars = sb.toString().toCharArray();\n    return chars[k - 1];\n}\n```\n\n上面的解题过程是错的，我觉得最好的方式应该是用递归，但是不太会，用来迭代，在n=4时的结果就错了。\n\n### better\n\n做`0-1`转换时，当时想用位运算，怎奈不熟练、没想起来`异或`。\n\n- 异或 ^ ：相同为0，0异或任何数为任何数。在二进制的情况下，与`1`异或等同于`0-1`翻转。\n\n#### method 1\n\n一目了然，迭代\n\n```java\npublic char findKthBit(int n, int k) {\n    String s = \"0\";\n    while (n>1) {\n        --n;\n        s = s+\"1\"+sinv(s);\n    }\n    // 从0开始，k-1\n    return s.charAt(k-1);\n}\n\npublic String sinv(String s) {\n    StringBuilder a = new StringBuilder();\n    // 从后遍历，reverse()\n    for (int i = s.length()-1; i>=0; --i) {\n        char c = s.charAt(i);\n        // 0-1翻转\n        c^=1;\n        a.append(c);\n    }\n    return a.toString();\n}\n```\n\n#### method 2\n\n别具一格\n\n```java\npublic char findKthBit(int n, int k){\n    char findKthBit(int n, int k) \n    s[1]=\"0\";\n    t[1]=\"1\";\n    for(int i=2;i<=n;i++){\n        s[i]=s[i-1];\n        s[i]+='1';\n        s[i]+=t[i-1];\n        t[i]=s[i-1];\n        t[i]+='0';\n        t[i]+=t[i-1];\n    }\n    return s[n][k-1];\n}\n```\n\n#### method 3\n\n清清楚楚，深度优先\n\n```java\nchar dfs(int n, int k) {\n    if (n == 1) {\n        return '0';\n    } else {\n        int len = (1 << n) - 1;\n        int base = (1 << (n - 1)) - 1;\n        if (k == base + 1) {\n            return '1';\n        } else if (k <= base) {\n            return dfs(n - 1, k);\n        } else {\n            return dfs(n - 1, len - k + 1) ^ 1;\n        }\n    }\n}\n\nchar findKthBit(int n, int k) {\n    return dfs(n, k);\n}\n```\n\n","slug":"contest201","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q72000fw5ih3h1zgn5l","content":"<p>Leetcode周赛201.</p>\n<a id=\"more\"></a>\n\n<h1 id=\"1544-Make-The-String-Great\"><a href=\"#1544-Make-The-String-Great\" class=\"headerlink\" title=\"1544 Make The String Great\"></a>1544 Make The String Great</h1><p>Given a string <code>s</code> of lower and upper case English letters.</p>\n<p>A good string is a string which doesn’t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p>\n<ul>\n<li><code>0 &lt;= i &lt;= s.length - 2</code></li>\n<li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li>\n</ul>\n<p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p>\n<p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p>\n<p><strong>Notice</strong> that an empty string is also good.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;leEeetcode&quot;</span><br><span class=\"line\">Output: &quot;leetcode&quot;</span><br><span class=\"line\">Explanation: In the first step, either you choose i &#x3D; 1 or i &#x3D; 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abBAcC&quot;</span><br><span class=\"line\">Output: &quot;&quot;</span><br><span class=\"line\">Explanation: We have many possible scenarios, and all lead to the same answer. For example:</span><br><span class=\"line\">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class=\"line\">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;s&quot;</span><br><span class=\"line\">Output: &quot;s&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><ul>\n<li>首先要注意审题，明确界限的判断。尤其是<code>vice-versa</code>，反之亦然的意思，就是<strong>相邻两个字母忽略大小写时相同，且一个大写一个小写</strong>，需要将这两个字母剔除。</li>\n<li>通过<code>example 2</code>可以看出算法应有<em>循环</em>的动作，剔除后还应该重新审视。</li>\n</ul>\n<h3 id=\"mine\"><a href=\"#mine\" class=\"headerlink\" title=\"mine\"></a>mine</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">makeGood</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stack.empty() &amp;&amp; (</span><br><span class=\"line\">                (Character.isUpperCase(c) &amp;&amp; Character.isLowerCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class=\"string\">&#x27;a&#x27;</span>) == (c - <span class=\"string\">&#x27;A&#x27;</span>)))</span><br><span class=\"line\">                        ||</span><br><span class=\"line\">                        (Character.isLowerCase(c) &amp;&amp; Character.isUpperCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class=\"string\">&#x27;A&#x27;</span>) == (c - <span class=\"string\">&#x27;a&#x27;</span>)))</span><br><span class=\"line\">        )) &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stack.push(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Iterator&lt;Character&gt; iterator = stack.iterator();</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">        sb.append(iterator.next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 因为是iterator，不用reverse()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"better\"><a href=\"#better\" class=\"headerlink\" title=\"better\"></a>better</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> ch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (ch) &#123;</span><br><span class=\"line\">    ch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    String t = s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length() - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) + <span class=\"number\">32</span> == s.charAt(i + <span class=\"number\">1</span>) || s.charAt(i + <span class=\"number\">1</span>) + <span class=\"number\">32</span> == s.charAt(i)) &#123;</span><br><span class=\"line\">            t = s.substring(<span class=\"number\">0</span>, i) + s.substring(i + <span class=\"number\">2</span>);</span><br><span class=\"line\">            ch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"1545-Find-Kth-Bit-in-Nth-Binary-String\"><a href=\"#1545-Find-Kth-Bit-in-Nth-Binary-String\" class=\"headerlink\" title=\"1545 Find Kth Bit in Nth Binary String\"></a>1545 Find Kth Bit in Nth Binary String</h1><p>Given two positive integers <code>n</code> and <code>k</code>, the binary string <code>Sn</code> is formed as follows:</p>\n<ul>\n<li><code>S1 = &quot;0&quot;</code></li>\n<li><code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code> for <code>i &gt; 1</code></li>\n</ul>\n<p>Where <code>+</code> denotes the concatenation operation, <code>reverse(x)</code> returns the reversed string x, and <code>invert(x)</code> inverts all the bits in x (0 changes to 1 and 1 changes to 0).</p>\n<p>For example, the first 4 strings in the above sequence are:</p>\n<ul>\n<li>S1 = “0”</li>\n<li>S2 = “0<strong>1</strong>1”</li>\n<li>S3 = “011<strong>1</strong>001”</li>\n<li>S4 = “0111001<strong>1</strong>0110001”</li>\n</ul>\n<p>Return <em>the</em> <code>kth</code> <em>bit</em> <em>in</em> <code>Sn</code>. It is guaranteed that <code>k</code> is valid for the given <code>n</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3, k &#x3D; 1</span><br><span class=\"line\">Output: &quot;0&quot;</span><br><span class=\"line\">Explanation: S3 is &quot;0111001&quot;. The first bit is &quot;0&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, k &#x3D; 11</span><br><span class=\"line\">Output: &quot;1&quot;</span><br><span class=\"line\">Explanation: S4 is &quot;011100110110001&quot;. The 11th bit is &quot;1&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 1, k &#x3D; 1</span><br><span class=\"line\">Output: &quot;0&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 2, k &#x3D; 3</span><br><span class=\"line\">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>题目中已经给了计算式，根据式子来计算结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> integer = Integer.parseInt(sb.toString());</span><br><span class=\"line\">        StringBuilder stringBuilder = <span class=\"keyword\">new</span> StringBuilder(Integer.toBinaryString(integer));</span><br><span class=\"line\">        <span class=\"comment\">// 0-1 inverse</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; stringBuilder.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stringBuilder.charAt(i) == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                stringBuilder.replace(i, i + <span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stringBuilder.replace(i, i + <span class=\"number\">1</span>, <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stringBuilder.reverse();</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;1&quot;</span>).append(stringBuilder);</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] chars = sb.toString().toCharArray();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chars[k - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的解题过程是错的，我觉得最好的方式应该是用递归，但是不太会，用来迭代，在n=4时的结果就错了。</p>\n<h3 id=\"better-1\"><a href=\"#better-1\" class=\"headerlink\" title=\"better\"></a>better</h3><p>做<code>0-1</code>转换时，当时想用位运算，怎奈不熟练、没想起来<code>异或</code>。</p>\n<ul>\n<li>异或 ^ ：相同为0，0异或任何数为任何数。在二进制的情况下，与<code>1</code>异或等同于<code>0-1</code>翻转。</li>\n</ul>\n<h4 id=\"method-1\"><a href=\"#method-1\" class=\"headerlink\" title=\"method 1\"></a>method 1</h4><p>一目了然，迭代</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    String s = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n&gt;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        --n;</span><br><span class=\"line\">        s = s+<span class=\"string\">&quot;1&quot;</span>+sinv(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 从0开始，k-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.charAt(k-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sinv</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder a = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"comment\">// 从后遍历，reverse()</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = s.length()-<span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">        <span class=\"comment\">// 0-1翻转</span></span><br><span class=\"line\">        c^=<span class=\"number\">1</span>;</span><br><span class=\"line\">        a.append(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"method-2\"><a href=\"#method-2\" class=\"headerlink\" title=\"method 2\"></a>method 2</h4><p>别具一格</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span></span><br><span class=\"line\"><span class=\"function\">    s[1]</span>=<span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">    t[<span class=\"number\">1</span>]=<span class=\"string\">&quot;1&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        s[i]=s[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        s[i]+=<span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">        s[i]+=t[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        t[i]=s[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        t[i]+=<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        t[i]+=t[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[n][k-<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"method-3\"><a href=\"#method-3\" class=\"headerlink\" title=\"method 3\"></a>method 3</h4><p>清清楚楚，深度优先</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = (<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> base = (<span class=\"number\">1</span> &lt;&lt; (n - <span class=\"number\">1</span>)) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == base + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt;= base) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dfs(n - <span class=\"number\">1</span>, k);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dfs(n - <span class=\"number\">1</span>, len - k + <span class=\"number\">1</span>) ^ <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(n, k);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Leetcode周赛201.</p>","more":"<h1 id=\"1544-Make-The-String-Great\"><a href=\"#1544-Make-The-String-Great\" class=\"headerlink\" title=\"1544 Make The String Great\"></a>1544 Make The String Great</h1><p>Given a string <code>s</code> of lower and upper case English letters.</p>\n<p>A good string is a string which doesn’t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p>\n<ul>\n<li><code>0 &lt;= i &lt;= s.length - 2</code></li>\n<li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li>\n</ul>\n<p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p>\n<p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p>\n<p><strong>Notice</strong> that an empty string is also good.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;leEeetcode&quot;</span><br><span class=\"line\">Output: &quot;leetcode&quot;</span><br><span class=\"line\">Explanation: In the first step, either you choose i &#x3D; 1 or i &#x3D; 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;abBAcC&quot;</span><br><span class=\"line\">Output: &quot;&quot;</span><br><span class=\"line\">Explanation: We have many possible scenarios, and all lead to the same answer. For example:</span><br><span class=\"line\">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class=\"line\">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s &#x3D; &quot;s&quot;</span><br><span class=\"line\">Output: &quot;s&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><ul>\n<li>首先要注意审题，明确界限的判断。尤其是<code>vice-versa</code>，反之亦然的意思，就是<strong>相邻两个字母忽略大小写时相同，且一个大写一个小写</strong>，需要将这两个字母剔除。</li>\n<li>通过<code>example 2</code>可以看出算法应有<em>循环</em>的动作，剔除后还应该重新审视。</li>\n</ul>\n<h3 id=\"mine\"><a href=\"#mine\" class=\"headerlink\" title=\"mine\"></a>mine</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">makeGood</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stack.empty() &amp;&amp; (</span><br><span class=\"line\">                (Character.isUpperCase(c) &amp;&amp; Character.isLowerCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class=\"string\">&#x27;a&#x27;</span>) == (c - <span class=\"string\">&#x27;A&#x27;</span>)))</span><br><span class=\"line\">                        ||</span><br><span class=\"line\">                        (Character.isLowerCase(c) &amp;&amp; Character.isUpperCase(stack.peek()) &amp;&amp; ((stack.peek() - <span class=\"string\">&#x27;A&#x27;</span>) == (c - <span class=\"string\">&#x27;a&#x27;</span>)))</span><br><span class=\"line\">        )) &#123;</span><br><span class=\"line\">            stack.pop();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stack.push(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Iterator&lt;Character&gt; iterator = stack.iterator();</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">        sb.append(iterator.next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 因为是iterator，不用reverse()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"better\"><a href=\"#better\" class=\"headerlink\" title=\"better\"></a>better</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> ch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (ch) &#123;</span><br><span class=\"line\">    ch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    String t = s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length() - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) + <span class=\"number\">32</span> == s.charAt(i + <span class=\"number\">1</span>) || s.charAt(i + <span class=\"number\">1</span>) + <span class=\"number\">32</span> == s.charAt(i)) &#123;</span><br><span class=\"line\">            t = s.substring(<span class=\"number\">0</span>, i) + s.substring(i + <span class=\"number\">2</span>);</span><br><span class=\"line\">            ch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> s;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"1545-Find-Kth-Bit-in-Nth-Binary-String\"><a href=\"#1545-Find-Kth-Bit-in-Nth-Binary-String\" class=\"headerlink\" title=\"1545 Find Kth Bit in Nth Binary String\"></a>1545 Find Kth Bit in Nth Binary String</h1><p>Given two positive integers <code>n</code> and <code>k</code>, the binary string <code>Sn</code> is formed as follows:</p>\n<ul>\n<li><code>S1 = &quot;0&quot;</code></li>\n<li><code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code> for <code>i &gt; 1</code></li>\n</ul>\n<p>Where <code>+</code> denotes the concatenation operation, <code>reverse(x)</code> returns the reversed string x, and <code>invert(x)</code> inverts all the bits in x (0 changes to 1 and 1 changes to 0).</p>\n<p>For example, the first 4 strings in the above sequence are:</p>\n<ul>\n<li>S1 = “0”</li>\n<li>S2 = “0<strong>1</strong>1”</li>\n<li>S3 = “011<strong>1</strong>001”</li>\n<li>S4 = “0111001<strong>1</strong>0110001”</li>\n</ul>\n<p>Return <em>the</em> <code>kth</code> <em>bit</em> <em>in</em> <code>Sn</code>. It is guaranteed that <code>k</code> is valid for the given <code>n</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3, k &#x3D; 1</span><br><span class=\"line\">Output: &quot;0&quot;</span><br><span class=\"line\">Explanation: S3 is &quot;0111001&quot;. The first bit is &quot;0&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, k &#x3D; 11</span><br><span class=\"line\">Output: &quot;1&quot;</span><br><span class=\"line\">Explanation: S4 is &quot;011100110110001&quot;. The 11th bit is &quot;1&quot;.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 1, k &#x3D; 1</span><br><span class=\"line\">Output: &quot;0&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 2, k &#x3D; 3</span><br><span class=\"line\">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>题目中已经给了计算式，根据式子来计算结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> integer = Integer.parseInt(sb.toString());</span><br><span class=\"line\">        StringBuilder stringBuilder = <span class=\"keyword\">new</span> StringBuilder(Integer.toBinaryString(integer));</span><br><span class=\"line\">        <span class=\"comment\">// 0-1 inverse</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; stringBuilder.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stringBuilder.charAt(i) == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                stringBuilder.replace(i, i + <span class=\"number\">1</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stringBuilder.replace(i, i + <span class=\"number\">1</span>, <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stringBuilder.reverse();</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;1&quot;</span>).append(stringBuilder);</span><br><span class=\"line\">        n--;</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] chars = sb.toString().toCharArray();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chars[k - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的解题过程是错的，我觉得最好的方式应该是用递归，但是不太会，用来迭代，在n=4时的结果就错了。</p>\n<h3 id=\"better-1\"><a href=\"#better-1\" class=\"headerlink\" title=\"better\"></a>better</h3><p>做<code>0-1</code>转换时，当时想用位运算，怎奈不熟练、没想起来<code>异或</code>。</p>\n<ul>\n<li>异或 ^ ：相同为0，0异或任何数为任何数。在二进制的情况下，与<code>1</code>异或等同于<code>0-1</code>翻转。</li>\n</ul>\n<h4 id=\"method-1\"><a href=\"#method-1\" class=\"headerlink\" title=\"method 1\"></a>method 1</h4><p>一目了然，迭代</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    String s = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n&gt;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        --n;</span><br><span class=\"line\">        s = s+<span class=\"string\">&quot;1&quot;</span>+sinv(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 从0开始，k-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.charAt(k-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sinv</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder a = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"comment\">// 从后遍历，reverse()</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = s.length()-<span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">        <span class=\"comment\">// 0-1翻转</span></span><br><span class=\"line\">        c^=<span class=\"number\">1</span>;</span><br><span class=\"line\">        a.append(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"method-2\"><a href=\"#method-2\" class=\"headerlink\" title=\"method 2\"></a>method 2</h4><p>别具一格</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span></span><br><span class=\"line\"><span class=\"function\">    s[1]</span>=<span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">    t[<span class=\"number\">1</span>]=<span class=\"string\">&quot;1&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        s[i]=s[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        s[i]+=<span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">        s[i]+=t[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        t[i]=s[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">        t[i]+=<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        t[i]+=t[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[n][k-<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"method-3\"><a href=\"#method-3\" class=\"headerlink\" title=\"method 3\"></a>method 3</h4><p>清清楚楚，深度优先</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = (<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> base = (<span class=\"number\">1</span> &lt;&lt; (n - <span class=\"number\">1</span>)) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == base + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (k &lt;= base) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dfs(n - <span class=\"number\">1</span>, k);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dfs(n - <span class=\"number\">1</span>, len - k + <span class=\"number\">1</span>) ^ <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">findKthBit</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dfs(n, k);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"contest202","date":"2020-08-16T06:36:31.000Z","_content":"\nLeetocode周赛202\n\n<!--more-->\n\n# 1550. Three Consecutive Odds\n\nGiven an integer array `arr`, return `true` if there are three consecutive odd numbers in the array. Otherwise, return `false`.\n\n**Example 1:**\n\n```\nInput: arr = [2,6,4,1]\nOutput: false\nExplanation: There are no three consecutive odds.\n```\n\n**Example 2:**\n\n```\nInput: arr = [1,2,34,3,4,5,7,23,12]\nOutput: true\nExplanation: [5,7,23] are three consecutive odds.\n```\n\n## solution\n\n题目难度不高，因此重点关注代码技巧上。“连续三个基数”则返回true，否则false，一般情况下都会想到遍历数组的同时维护一个变量，变量达到三时返回。直到我看到了神级代码：\n\n```java\npublic boolean threeConsecutiveOdds(int[] a) {\n    for(int i = 0;i+2 < a.length;i++){\n        if(a[i]%2 + a[i+1] % 2 + a[i+2] % 2 == 3){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nrank榜单的前几名整齐化一地这样写。我们来看看这样写的原理：\n\n同样是for循环，它的 判断条件是`i+2<a.length`，为何要`+2`,原因在for循环中，它每次在第i处下标都会同时获取到i的后两位，把和三个数与2相除取余，如果是奇数余数为1,那么这三个数相加即为3,好处是不用额外维护一个变量，代码也简单易懂。\n\n**note:** 循环时同时做三个数的运算；取余判断奇偶\n\n\n\n# 1551. Minimum Operations to Make Array Equal\n\nYou have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e. `0 <= i < n`).\n\nIn one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e. perform `arr[x] -=1 `and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations.\n\nGiven an integer `n`, the length of the array. Return *the minimum number of operations* needed to make all the elements of arr equal.\n\n**Example 1:**\n\n```\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\n```\n\n**Example 2:**\n\n```\nInput: n = 6\nOutput: 9\n```\n\n## solution\n\n这道题看着挺复杂，行数多，其实像是在`找规律`（我就是没找出来，n=6时output=9？），是一道数学题。\n\n```java\npublic int minOperations(int n) {\n    // Take care of overflow if n is too large.\n    if(n%2==1){\n        n/=2;\n        return (n*(n+1));\n    }        \n    n/=2;\n    return n*n;\n}\n```\n\n上面的解法是将其分两种情况--奇数与偶数。考得不是算法， 是脑子吧。。。","source":"_posts/contest202.md","raw":"---\ntitle: contest202\ndate: 2020-08-16 14:36:31\ncategories: Leetcode\ntags: algorithm\n---\n\nLeetocode周赛202\n\n<!--more-->\n\n# 1550. Three Consecutive Odds\n\nGiven an integer array `arr`, return `true` if there are three consecutive odd numbers in the array. Otherwise, return `false`.\n\n**Example 1:**\n\n```\nInput: arr = [2,6,4,1]\nOutput: false\nExplanation: There are no three consecutive odds.\n```\n\n**Example 2:**\n\n```\nInput: arr = [1,2,34,3,4,5,7,23,12]\nOutput: true\nExplanation: [5,7,23] are three consecutive odds.\n```\n\n## solution\n\n题目难度不高，因此重点关注代码技巧上。“连续三个基数”则返回true，否则false，一般情况下都会想到遍历数组的同时维护一个变量，变量达到三时返回。直到我看到了神级代码：\n\n```java\npublic boolean threeConsecutiveOdds(int[] a) {\n    for(int i = 0;i+2 < a.length;i++){\n        if(a[i]%2 + a[i+1] % 2 + a[i+2] % 2 == 3){\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nrank榜单的前几名整齐化一地这样写。我们来看看这样写的原理：\n\n同样是for循环，它的 判断条件是`i+2<a.length`，为何要`+2`,原因在for循环中，它每次在第i处下标都会同时获取到i的后两位，把和三个数与2相除取余，如果是奇数余数为1,那么这三个数相加即为3,好处是不用额外维护一个变量，代码也简单易懂。\n\n**note:** 循环时同时做三个数的运算；取余判断奇偶\n\n\n\n# 1551. Minimum Operations to Make Array Equal\n\nYou have an array `arr` of length `n` where `arr[i] = (2 * i) + 1` for all valid values of `i` (i.e. `0 <= i < n`).\n\nIn one operation, you can select two indices `x` and `y` where `0 <= x, y < n` and subtract `1` from `arr[x]` and add `1` to `arr[y]` (i.e. perform `arr[x] -=1 `and `arr[y] += 1`). The goal is to make all the elements of the array **equal**. It is **guaranteed** that all the elements of the array can be made equal using some operations.\n\nGiven an integer `n`, the length of the array. Return *the minimum number of operations* needed to make all the elements of arr equal.\n\n**Example 1:**\n\n```\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\n```\n\n**Example 2:**\n\n```\nInput: n = 6\nOutput: 9\n```\n\n## solution\n\n这道题看着挺复杂，行数多，其实像是在`找规律`（我就是没找出来，n=6时output=9？），是一道数学题。\n\n```java\npublic int minOperations(int n) {\n    // Take care of overflow if n is too large.\n    if(n%2==1){\n        n/=2;\n        return (n*(n+1));\n    }        \n    n/=2;\n    return n*n;\n}\n```\n\n上面的解法是将其分两种情况--奇数与偶数。考得不是算法， 是脑子吧。。。","slug":"contest202","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q74000iw5ih3umqdncr","content":"<p>Leetocode周赛202</p>\n<a id=\"more\"></a>\n\n<h1 id=\"1550-Three-Consecutive-Odds\"><a href=\"#1550-Three-Consecutive-Odds\" class=\"headerlink\" title=\"1550. Three Consecutive Odds\"></a>1550. Three Consecutive Odds</h1><p>Given an integer array <code>arr</code>, return <code>true</code> if there are three consecutive odd numbers in the array. Otherwise, return <code>false</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [2,6,4,1]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: There are no three consecutive odds.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,2,34,3,4,5,7,23,12]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: [5,7,23] are three consecutive odds.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solution\"><a href=\"#solution\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>题目难度不高，因此重点关注代码技巧上。“连续三个基数”则返回true，否则false，一般情况下都会想到遍历数组的同时维护一个变量，变量达到三时返回。直到我看到了神级代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">threeConsecutiveOdds</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i+<span class=\"number\">2</span> &lt; a.length;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]%<span class=\"number\">2</span> + a[i+<span class=\"number\">1</span>] % <span class=\"number\">2</span> + a[i+<span class=\"number\">2</span>] % <span class=\"number\">2</span> == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>rank榜单的前几名整齐化一地这样写。我们来看看这样写的原理：</p>\n<p>同样是for循环，它的 判断条件是<code>i+2&lt;a.length</code>，为何要<code>+2</code>,原因在for循环中，它每次在第i处下标都会同时获取到i的后两位，把和三个数与2相除取余，如果是奇数余数为1,那么这三个数相加即为3,好处是不用额外维护一个变量，代码也简单易懂。</p>\n<p><strong>note:</strong> 循环时同时做三个数的运算；取余判断奇偶</p>\n<h1 id=\"1551-Minimum-Operations-to-Make-Array-Equal\"><a href=\"#1551-Minimum-Operations-to-Make-Array-Equal\" class=\"headerlink\" title=\"1551. Minimum Operations to Make Array Equal\"></a>1551. Minimum Operations to Make Array Equal</h1><p>You have an array <code>arr</code> of length <code>n</code> where <code>arr[i] = (2 * i) + 1</code> for all valid values of <code>i</code> (i.e. <code>0 &lt;= i &lt; n</code>).</p>\n<p>In one operation, you can select two indices <code>x</code> and <code>y</code> where <code>0 &lt;= x, y &lt; n</code> and subtract <code>1</code> from <code>arr[x]</code> and add <code>1</code> to <code>arr[y]</code> (i.e. perform <code>arr[x] -=1 </code>and <code>arr[y] += 1</code>). The goal is to make all the elements of the array <strong>equal</strong>. It is <strong>guaranteed</strong> that all the elements of the array can be made equal using some operations.</p>\n<p>Given an integer <code>n</code>, the length of the array. Return <em>the minimum number of operations</em> needed to make all the elements of arr equal.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: arr &#x3D; [1, 3, 5]</span><br><span class=\"line\">First operation choose x &#x3D; 2 and y &#x3D; 0, this leads arr to be [2, 3, 4]</span><br><span class=\"line\">In the second operation choose x &#x3D; 2 and y &#x3D; 0 again, thus arr &#x3D; [3, 3, 3].</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 6</span><br><span class=\"line\">Output: 9</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solution-1\"><a href=\"#solution-1\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>这道题看着挺复杂，行数多，其实像是在<code>找规律</code>（我就是没找出来，n=6时output=9？），是一道数学题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Take care of overflow if n is too large.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        n/=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n*(n+<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    n/=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n*n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的解法是将其分两种情况–奇数与偶数。考得不是算法， 是脑子吧。。。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Leetocode周赛202</p>","more":"<h1 id=\"1550-Three-Consecutive-Odds\"><a href=\"#1550-Three-Consecutive-Odds\" class=\"headerlink\" title=\"1550. Three Consecutive Odds\"></a>1550. Three Consecutive Odds</h1><p>Given an integer array <code>arr</code>, return <code>true</code> if there are three consecutive odd numbers in the array. Otherwise, return <code>false</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [2,6,4,1]</span><br><span class=\"line\">Output: false</span><br><span class=\"line\">Explanation: There are no three consecutive odds.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: arr &#x3D; [1,2,34,3,4,5,7,23,12]</span><br><span class=\"line\">Output: true</span><br><span class=\"line\">Explanation: [5,7,23] are three consecutive odds.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solution\"><a href=\"#solution\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>题目难度不高，因此重点关注代码技巧上。“连续三个基数”则返回true，否则false，一般情况下都会想到遍历数组的同时维护一个变量，变量达到三时返回。直到我看到了神级代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">threeConsecutiveOdds</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i+<span class=\"number\">2</span> &lt; a.length;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]%<span class=\"number\">2</span> + a[i+<span class=\"number\">1</span>] % <span class=\"number\">2</span> + a[i+<span class=\"number\">2</span>] % <span class=\"number\">2</span> == <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>rank榜单的前几名整齐化一地这样写。我们来看看这样写的原理：</p>\n<p>同样是for循环，它的 判断条件是<code>i+2&lt;a.length</code>，为何要<code>+2</code>,原因在for循环中，它每次在第i处下标都会同时获取到i的后两位，把和三个数与2相除取余，如果是奇数余数为1,那么这三个数相加即为3,好处是不用额外维护一个变量，代码也简单易懂。</p>\n<p><strong>note:</strong> 循环时同时做三个数的运算；取余判断奇偶</p>\n<h1 id=\"1551-Minimum-Operations-to-Make-Array-Equal\"><a href=\"#1551-Minimum-Operations-to-Make-Array-Equal\" class=\"headerlink\" title=\"1551. Minimum Operations to Make Array Equal\"></a>1551. Minimum Operations to Make Array Equal</h1><p>You have an array <code>arr</code> of length <code>n</code> where <code>arr[i] = (2 * i) + 1</code> for all valid values of <code>i</code> (i.e. <code>0 &lt;= i &lt; n</code>).</p>\n<p>In one operation, you can select two indices <code>x</code> and <code>y</code> where <code>0 &lt;= x, y &lt; n</code> and subtract <code>1</code> from <code>arr[x]</code> and add <code>1</code> to <code>arr[y]</code> (i.e. perform <code>arr[x] -=1 </code>and <code>arr[y] += 1</code>). The goal is to make all the elements of the array <strong>equal</strong>. It is <strong>guaranteed</strong> that all the elements of the array can be made equal using some operations.</p>\n<p>Given an integer <code>n</code>, the length of the array. Return <em>the minimum number of operations</em> needed to make all the elements of arr equal.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 3</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: arr &#x3D; [1, 3, 5]</span><br><span class=\"line\">First operation choose x &#x3D; 2 and y &#x3D; 0, this leads arr to be [2, 3, 4]</span><br><span class=\"line\">In the second operation choose x &#x3D; 2 and y &#x3D; 0 again, thus arr &#x3D; [3, 3, 3].</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 6</span><br><span class=\"line\">Output: 9</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solution-1\"><a href=\"#solution-1\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>这道题看着挺复杂，行数多，其实像是在<code>找规律</code>（我就是没找出来，n=6时output=9？），是一道数学题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Take care of overflow if n is too large.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        n/=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (n*(n+<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">    n/=<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n*n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的解法是将其分两种情况–奇数与偶数。考得不是算法， 是脑子吧。。。</p>"},{"title":"contest203","date":"2020-08-23T04:22:22.000Z","_content":"\nLeetcode周赛203\n\n<!--more-->\n\n# 1560. Most Visited Sector in a Circular Track\n\nGiven an integer `n` and an integer array `rounds`. We have a circular track which consists of `n` sectors labeled from `1` to `n`. A marathon will be held on this track, the marathon consists of `m` rounds. The `ith` round starts at sector `rounds[i - 1]` and ends at sector `rounds[i]`. For example, round 1 starts at sector `rounds[0]` and ends at sector `rounds[1]`\n\nReturn *an array of the most visited sectors* sorted in **ascending** order.\n\nNotice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).\n\n**Example 1:**\n\n![img](https://assets.leetcode.com/uploads/2020/08/14/tmp.jpg)\n\n```\nInput: n = 4, rounds = [1,3,1,2]\nOutput: [1,2]\nExplanation: The marathon starts at sector 1. The order of the visited sectors is as follows:\n1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\nWe can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n```\n\n**Example 2:**\n\n```\nInput: n = 2, rounds = [2,1,2,1,2,1,2,1,2]\nOutput: [2]\n```\n\n**Example 3:**\n\n```\nInput: n = 7, rounds = [1,3,5,7]\nOutput: [1,2,3,4,5,6,7]\n```\n\n## solution\n\n这道题虽然看起来长，但是难度是`easy`的，所以一定不会复杂，仔细看来只是求重复次数最多的sectors，我觉得难点是在头一个数比后一个数大的情况下（相当与跑步比赛中的套圈），如何去从头开始循环。\n\n```java\npublic List<Integer> mostVisited(int n, int[] rounds) {\n    // 取数组第一个和最后一个数字\n    int f = rounds[0], t = rounds[rounds.length-1];\n    List<Integer> ret = new ArrayList<>();\n    for(int i = f;;){\n        ret.add(i);\n        if(i == t)break;\n        i++;\n        if(i == n+1)i = 1;\n    }\n    Collections.sort(ret);\n    return ret;\n}\n```\n\nemmmm上面这个有些取巧，不明白的先看看下面这个：\n\n```java\npublic List<Integer> mostVisited(int n, int[] A) {\n    List<Integer> res = new ArrayList<>();\n    for (int i = A[0]; i <= A[A.length - 1]; ++i)\n        res.add(i);\n    if (res.size() > 0) return res;\n    // 下面计算的是start>end的情况，[1, end] + [start, n]\n    for (int i = 1; i <= A[A.length - 1]; ++i)\n        res.add(i);\n    for (int i = A[0]; i <= n; ++i)\n        res.add(i);\n    return res;\n}\n```\n\n实际上，我们只需要关注首节点和末节点就行了，因为要求的是重复次数最多的sector，那么，必然会涉及到首尾，完全不必考虑中间节点。\n\n- 如果start<=end，返回\\[start, end\\]\n- 如果start>end，返回\\[start, n\\]+\\[1, end\\]\n\n另外一个版本，更好理解：\n\n```java\npublic List<Integer> mostVisited(int n, int[] rounds) {\n    int len = rounds.length, fr = rounds[0], to = rounds[len - 1];\n    List<Integer> res = new ArrayList<>();\n    if (to >= fr) {     // no circle, such as [1,3,1,2]\n        for (int i = fr; i <= to; i++) res.add(i);\n    } else {            // cross a circle, such as [2,3,2,1]\n        // 这里遍历每个sector\n        for (int i = 1; i <= n; i++) {\n            // 如果到最后一个sector的下一个，就从数组中第一个开始，相当于从“后端”开始了，省去了中间部分。\n            if (i == to + 1) i = fr;\n            res.add(i);\n        }\n    }\n    return res;\n}\n```\n\n涉及`环`的问题，要找到问题本质。这里说的首尾，一是指给定n个sector中的首尾，二是指给定round中的首尾。\n\n\n\n# 1561. Maximum Number of Coins You Can Get\n\nThere are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:\n\n- In each step, you will choose **any** 3 piles of coins (not necessarily consecutive).\n- Of your choice, Alice will pick the pile with the maximum number of coins.\n- You will pick the next pile with maximum number of coins.\n- Your friend Bob will pick the last pile.\n- Repeat until there are no more piles of coins.\n\nGiven an array of integers `piles` where `piles[i]` is the number of coins in the `ith` pile.\n\nReturn the maximum number of coins which you can have.\n\n \n\n**Example 1:**\n\n```\nInput: piles = [2,4,1,2,7,8]\nOutput: 9\nExplanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.\n```\n\n**Example 2:**\n\n```\nInput: piles = [2,4,5]\nOutput: 4\n```\n\n**Example 3:**\n\n```\nInput: piles = [9,8,7,6,5,1,2,3,4]\nOutput: 18\n```\n\n\n\n## solution\n\n我觉得这道题本质是个排序的题，但是要按一定的规则排序，最初设想的是每三个数排序，取中间那个。\n\n然而好的算法都是讲究技巧的，不是靠蛮力。完全可以放心地对数组进行排序，可以理解为逆向思维，例如example1中的数组排好序后：*[1,2,2,4,7,8]*，无论我们怎么分，最优解必然是Bob拿到前两个数，剩下的四个是我们与Alice分，由于是我拿第二大的，所以先分我，在分给Alice，依照这样的一个思路，问题就解决了。\n\n```java\npublic int maxCoins(int[] A) {\n    Arrays.sort(A);\n    int res = 0, n = A.length;\n    for (int i = n / 3; i < n; i += 2)\n        res += A[i];\n    return res;\n}\n```\n\n","source":"_posts/contest203.md","raw":"---\ntitle: contest203\ndate: 2020-08-23 12:22:22\ntags: LeetCode\n---\n\nLeetcode周赛203\n\n<!--more-->\n\n# 1560. Most Visited Sector in a Circular Track\n\nGiven an integer `n` and an integer array `rounds`. We have a circular track which consists of `n` sectors labeled from `1` to `n`. A marathon will be held on this track, the marathon consists of `m` rounds. The `ith` round starts at sector `rounds[i - 1]` and ends at sector `rounds[i]`. For example, round 1 starts at sector `rounds[0]` and ends at sector `rounds[1]`\n\nReturn *an array of the most visited sectors* sorted in **ascending** order.\n\nNotice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).\n\n**Example 1:**\n\n![img](https://assets.leetcode.com/uploads/2020/08/14/tmp.jpg)\n\n```\nInput: n = 4, rounds = [1,3,1,2]\nOutput: [1,2]\nExplanation: The marathon starts at sector 1. The order of the visited sectors is as follows:\n1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\nWe can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n```\n\n**Example 2:**\n\n```\nInput: n = 2, rounds = [2,1,2,1,2,1,2,1,2]\nOutput: [2]\n```\n\n**Example 3:**\n\n```\nInput: n = 7, rounds = [1,3,5,7]\nOutput: [1,2,3,4,5,6,7]\n```\n\n## solution\n\n这道题虽然看起来长，但是难度是`easy`的，所以一定不会复杂，仔细看来只是求重复次数最多的sectors，我觉得难点是在头一个数比后一个数大的情况下（相当与跑步比赛中的套圈），如何去从头开始循环。\n\n```java\npublic List<Integer> mostVisited(int n, int[] rounds) {\n    // 取数组第一个和最后一个数字\n    int f = rounds[0], t = rounds[rounds.length-1];\n    List<Integer> ret = new ArrayList<>();\n    for(int i = f;;){\n        ret.add(i);\n        if(i == t)break;\n        i++;\n        if(i == n+1)i = 1;\n    }\n    Collections.sort(ret);\n    return ret;\n}\n```\n\nemmmm上面这个有些取巧，不明白的先看看下面这个：\n\n```java\npublic List<Integer> mostVisited(int n, int[] A) {\n    List<Integer> res = new ArrayList<>();\n    for (int i = A[0]; i <= A[A.length - 1]; ++i)\n        res.add(i);\n    if (res.size() > 0) return res;\n    // 下面计算的是start>end的情况，[1, end] + [start, n]\n    for (int i = 1; i <= A[A.length - 1]; ++i)\n        res.add(i);\n    for (int i = A[0]; i <= n; ++i)\n        res.add(i);\n    return res;\n}\n```\n\n实际上，我们只需要关注首节点和末节点就行了，因为要求的是重复次数最多的sector，那么，必然会涉及到首尾，完全不必考虑中间节点。\n\n- 如果start<=end，返回\\[start, end\\]\n- 如果start>end，返回\\[start, n\\]+\\[1, end\\]\n\n另外一个版本，更好理解：\n\n```java\npublic List<Integer> mostVisited(int n, int[] rounds) {\n    int len = rounds.length, fr = rounds[0], to = rounds[len - 1];\n    List<Integer> res = new ArrayList<>();\n    if (to >= fr) {     // no circle, such as [1,3,1,2]\n        for (int i = fr; i <= to; i++) res.add(i);\n    } else {            // cross a circle, such as [2,3,2,1]\n        // 这里遍历每个sector\n        for (int i = 1; i <= n; i++) {\n            // 如果到最后一个sector的下一个，就从数组中第一个开始，相当于从“后端”开始了，省去了中间部分。\n            if (i == to + 1) i = fr;\n            res.add(i);\n        }\n    }\n    return res;\n}\n```\n\n涉及`环`的问题，要找到问题本质。这里说的首尾，一是指给定n个sector中的首尾，二是指给定round中的首尾。\n\n\n\n# 1561. Maximum Number of Coins You Can Get\n\nThere are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:\n\n- In each step, you will choose **any** 3 piles of coins (not necessarily consecutive).\n- Of your choice, Alice will pick the pile with the maximum number of coins.\n- You will pick the next pile with maximum number of coins.\n- Your friend Bob will pick the last pile.\n- Repeat until there are no more piles of coins.\n\nGiven an array of integers `piles` where `piles[i]` is the number of coins in the `ith` pile.\n\nReturn the maximum number of coins which you can have.\n\n \n\n**Example 1:**\n\n```\nInput: piles = [2,4,1,2,7,8]\nOutput: 9\nExplanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.\n```\n\n**Example 2:**\n\n```\nInput: piles = [2,4,5]\nOutput: 4\n```\n\n**Example 3:**\n\n```\nInput: piles = [9,8,7,6,5,1,2,3,4]\nOutput: 18\n```\n\n\n\n## solution\n\n我觉得这道题本质是个排序的题，但是要按一定的规则排序，最初设想的是每三个数排序，取中间那个。\n\n然而好的算法都是讲究技巧的，不是靠蛮力。完全可以放心地对数组进行排序，可以理解为逆向思维，例如example1中的数组排好序后：*[1,2,2,4,7,8]*，无论我们怎么分，最优解必然是Bob拿到前两个数，剩下的四个是我们与Alice分，由于是我拿第二大的，所以先分我，在分给Alice，依照这样的一个思路，问题就解决了。\n\n```java\npublic int maxCoins(int[] A) {\n    Arrays.sort(A);\n    int res = 0, n = A.length;\n    for (int i = n / 3; i < n; i += 2)\n        res += A[i];\n    return res;\n}\n```\n\n","slug":"contest203","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q76000kw5ihc54z9u0j","content":"<p>Leetcode周赛203</p>\n<a id=\"more\"></a>\n\n<h1 id=\"1560-Most-Visited-Sector-in-a-Circular-Track\"><a href=\"#1560-Most-Visited-Sector-in-a-Circular-Track\" class=\"headerlink\" title=\"1560. Most Visited Sector in a Circular Track\"></a>1560. Most Visited Sector in a Circular Track</h1><p>Given an integer <code>n</code> and an integer array <code>rounds</code>. We have a circular track which consists of <code>n</code> sectors labeled from <code>1</code> to <code>n</code>. A marathon will be held on this track, the marathon consists of <code>m</code> rounds. The <code>ith</code> round starts at sector <code>rounds[i - 1]</code> and ends at sector <code>rounds[i]</code>. For example, round 1 starts at sector <code>rounds[0]</code> and ends at sector <code>rounds[1]</code></p>\n<p>Return <em>an array of the most visited sectors</em> sorted in <strong>ascending</strong> order.</p>\n<p>Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).</p>\n<p><strong>Example 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/14/tmp.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, rounds &#x3D; [1,3,1,2]</span><br><span class=\"line\">Output: [1,2]</span><br><span class=\"line\">Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:</span><br><span class=\"line\">1 --&gt; 2 --&gt; 3 (end of round 1) --&gt; 4 --&gt; 1 (end of round 2) --&gt; 2 (end of round 3 and the marathon)</span><br><span class=\"line\">We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 2, rounds &#x3D; [2,1,2,1,2,1,2,1,2]</span><br><span class=\"line\">Output: [2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 7, rounds &#x3D; [1,3,5,7]</span><br><span class=\"line\">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solution\"><a href=\"#solution\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>这道题虽然看起来长，但是难度是<code>easy</code>的，所以一定不会复杂，仔细看来只是求重复次数最多的sectors，我觉得难点是在头一个数比后一个数大的情况下（相当与跑步比赛中的套圈），如何去从头开始循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">mostVisited</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] rounds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取数组第一个和最后一个数字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> f = rounds[<span class=\"number\">0</span>], t = rounds[rounds.length-<span class=\"number\">1</span>];</span><br><span class=\"line\">    List&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = f;;)&#123;</span><br><span class=\"line\">        ret.add(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == t)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == n+<span class=\"number\">1</span>)i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collections.sort(ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmmm上面这个有些取巧，不明白的先看看下面这个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">mostVisited</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = A[<span class=\"number\">0</span>]; i &lt;= A[A.length - <span class=\"number\">1</span>]; ++i)</span><br><span class=\"line\">        res.add(i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.size() &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    <span class=\"comment\">// 下面计算的是start&gt;end的情况，[1, end] + [start, n]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= A[A.length - <span class=\"number\">1</span>]; ++i)</span><br><span class=\"line\">        res.add(i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = A[<span class=\"number\">0</span>]; i &lt;= n; ++i)</span><br><span class=\"line\">        res.add(i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，我们只需要关注首节点和末节点就行了，因为要求的是重复次数最多的sector，那么，必然会涉及到首尾，完全不必考虑中间节点。</p>\n<ul>\n<li>如果start&lt;=end，返回[start, end]</li>\n<li>如果start&gt;end，返回[start, n]+[1, end]</li>\n</ul>\n<p>另外一个版本，更好理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">mostVisited</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] rounds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = rounds.length, fr = rounds[<span class=\"number\">0</span>], to = rounds[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">    List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (to &gt;= fr) &#123;     <span class=\"comment\">// no circle, such as [1,3,1,2]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = fr; i &lt;= to; i++) res.add(i);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;            <span class=\"comment\">// cross a circle, such as [2,3,2,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里遍历每个sector</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果到最后一个sector的下一个，就从数组中第一个开始，相当于从“后端”开始了，省去了中间部分。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == to + <span class=\"number\">1</span>) i = fr;</span><br><span class=\"line\">            res.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>涉及<code>环</code>的问题，要找到问题本质。这里说的首尾，一是指给定n个sector中的首尾，二是指给定round中的首尾。</p>\n<h1 id=\"1561-Maximum-Number-of-Coins-You-Can-Get\"><a href=\"#1561-Maximum-Number-of-Coins-You-Can-Get\" class=\"headerlink\" title=\"1561. Maximum Number of Coins You Can Get\"></a>1561. Maximum Number of Coins You Can Get</h1><p>There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:</p>\n<ul>\n<li>In each step, you will choose <strong>any</strong> 3 piles of coins (not necessarily consecutive).</li>\n<li>Of your choice, Alice will pick the pile with the maximum number of coins.</li>\n<li>You will pick the next pile with maximum number of coins.</li>\n<li>Your friend Bob will pick the last pile.</li>\n<li>Repeat until there are no more piles of coins.</li>\n</ul>\n<p>Given an array of integers <code>piles</code> where <code>piles[i]</code> is the number of coins in the <code>ith</code> pile.</p>\n<p>Return the maximum number of coins which you can have.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [2,4,1,2,7,8]</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.</span><br><span class=\"line\">Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.</span><br><span class=\"line\">The maximum number of coins which you can have are: 7 + 2 &#x3D; 9.</span><br><span class=\"line\">On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 &#x3D; 6 coins which is not optimal.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [2,4,5]</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [9,8,7,6,5,1,2,3,4]</span><br><span class=\"line\">Output: 18</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"solution-1\"><a href=\"#solution-1\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>我觉得这道题本质是个排序的题，但是要按一定的规则排序，最初设想的是每三个数排序，取中间那个。</p>\n<p>然而好的算法都是讲究技巧的，不是靠蛮力。完全可以放心地对数组进行排序，可以理解为逆向思维，例如example1中的数组排好序后：*[1,2,2,4,7,8]*，无论我们怎么分，最优解必然是Bob拿到前两个数，剩下的四个是我们与Alice分，由于是我拿第二大的，所以先分我，在分给Alice，依照这样的一个思路，问题就解决了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxCoins</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">    Arrays.sort(A);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, n = A.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n / <span class=\"number\">3</span>; i &lt; n; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">        res += A[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Leetcode周赛203</p>","more":"<h1 id=\"1560-Most-Visited-Sector-in-a-Circular-Track\"><a href=\"#1560-Most-Visited-Sector-in-a-Circular-Track\" class=\"headerlink\" title=\"1560. Most Visited Sector in a Circular Track\"></a>1560. Most Visited Sector in a Circular Track</h1><p>Given an integer <code>n</code> and an integer array <code>rounds</code>. We have a circular track which consists of <code>n</code> sectors labeled from <code>1</code> to <code>n</code>. A marathon will be held on this track, the marathon consists of <code>m</code> rounds. The <code>ith</code> round starts at sector <code>rounds[i - 1]</code> and ends at sector <code>rounds[i]</code>. For example, round 1 starts at sector <code>rounds[0]</code> and ends at sector <code>rounds[1]</code></p>\n<p>Return <em>an array of the most visited sectors</em> sorted in <strong>ascending</strong> order.</p>\n<p>Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).</p>\n<p><strong>Example 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/14/tmp.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 4, rounds &#x3D; [1,3,1,2]</span><br><span class=\"line\">Output: [1,2]</span><br><span class=\"line\">Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:</span><br><span class=\"line\">1 --&gt; 2 --&gt; 3 (end of round 1) --&gt; 4 --&gt; 1 (end of round 2) --&gt; 2 (end of round 3 and the marathon)</span><br><span class=\"line\">We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 2, rounds &#x3D; [2,1,2,1,2,1,2,1,2]</span><br><span class=\"line\">Output: [2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: n &#x3D; 7, rounds &#x3D; [1,3,5,7]</span><br><span class=\"line\">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"solution\"><a href=\"#solution\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>这道题虽然看起来长，但是难度是<code>easy</code>的，所以一定不会复杂，仔细看来只是求重复次数最多的sectors，我觉得难点是在头一个数比后一个数大的情况下（相当与跑步比赛中的套圈），如何去从头开始循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">mostVisited</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] rounds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取数组第一个和最后一个数字</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> f = rounds[<span class=\"number\">0</span>], t = rounds[rounds.length-<span class=\"number\">1</span>];</span><br><span class=\"line\">    List&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = f;;)&#123;</span><br><span class=\"line\">        ret.add(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == t)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == n+<span class=\"number\">1</span>)i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collections.sort(ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>emmmm上面这个有些取巧，不明白的先看看下面这个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">mostVisited</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = A[<span class=\"number\">0</span>]; i &lt;= A[A.length - <span class=\"number\">1</span>]; ++i)</span><br><span class=\"line\">        res.add(i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.size() &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    <span class=\"comment\">// 下面计算的是start&gt;end的情况，[1, end] + [start, n]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= A[A.length - <span class=\"number\">1</span>]; ++i)</span><br><span class=\"line\">        res.add(i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = A[<span class=\"number\">0</span>]; i &lt;= n; ++i)</span><br><span class=\"line\">        res.add(i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，我们只需要关注首节点和末节点就行了，因为要求的是重复次数最多的sector，那么，必然会涉及到首尾，完全不必考虑中间节点。</p>\n<ul>\n<li>如果start&lt;=end，返回[start, end]</li>\n<li>如果start&gt;end，返回[start, n]+[1, end]</li>\n</ul>\n<p>另外一个版本，更好理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">mostVisited</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>[] rounds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = rounds.length, fr = rounds[<span class=\"number\">0</span>], to = rounds[len - <span class=\"number\">1</span>];</span><br><span class=\"line\">    List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (to &gt;= fr) &#123;     <span class=\"comment\">// no circle, such as [1,3,1,2]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = fr; i &lt;= to; i++) res.add(i);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;            <span class=\"comment\">// cross a circle, such as [2,3,2,1]</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里遍历每个sector</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果到最后一个sector的下一个，就从数组中第一个开始，相当于从“后端”开始了，省去了中间部分。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == to + <span class=\"number\">1</span>) i = fr;</span><br><span class=\"line\">            res.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>涉及<code>环</code>的问题，要找到问题本质。这里说的首尾，一是指给定n个sector中的首尾，二是指给定round中的首尾。</p>\n<h1 id=\"1561-Maximum-Number-of-Coins-You-Can-Get\"><a href=\"#1561-Maximum-Number-of-Coins-You-Can-Get\" class=\"headerlink\" title=\"1561. Maximum Number of Coins You Can Get\"></a>1561. Maximum Number of Coins You Can Get</h1><p>There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:</p>\n<ul>\n<li>In each step, you will choose <strong>any</strong> 3 piles of coins (not necessarily consecutive).</li>\n<li>Of your choice, Alice will pick the pile with the maximum number of coins.</li>\n<li>You will pick the next pile with maximum number of coins.</li>\n<li>Your friend Bob will pick the last pile.</li>\n<li>Repeat until there are no more piles of coins.</li>\n</ul>\n<p>Given an array of integers <code>piles</code> where <code>piles[i]</code> is the number of coins in the <code>ith</code> pile.</p>\n<p>Return the maximum number of coins which you can have.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [2,4,1,2,7,8]</span><br><span class=\"line\">Output: 9</span><br><span class=\"line\">Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.</span><br><span class=\"line\">Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.</span><br><span class=\"line\">The maximum number of coins which you can have are: 7 + 2 &#x3D; 9.</span><br><span class=\"line\">On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 &#x3D; 6 coins which is not optimal.</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [2,4,5]</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: piles &#x3D; [9,8,7,6,5,1,2,3,4]</span><br><span class=\"line\">Output: 18</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"solution-1\"><a href=\"#solution-1\" class=\"headerlink\" title=\"solution\"></a>solution</h2><p>我觉得这道题本质是个排序的题，但是要按一定的规则排序，最初设想的是每三个数排序，取中间那个。</p>\n<p>然而好的算法都是讲究技巧的，不是靠蛮力。完全可以放心地对数组进行排序，可以理解为逆向思维，例如example1中的数组排好序后：*[1,2,2,4,7,8]*，无论我们怎么分，最优解必然是Bob拿到前两个数，剩下的四个是我们与Alice分，由于是我拿第二大的，所以先分我，在分给Alice，依照这样的一个思路，问题就解决了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxCoins</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A)</span> </span>&#123;</span><br><span class=\"line\">    Arrays.sort(A);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, n = A.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n / <span class=\"number\">3</span>; i &lt; n; i += <span class=\"number\">2</span>)</span><br><span class=\"line\">        res += A[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"decorating","date":"2020-06-12T10:30:28.000Z","_content":"\n继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。\n\n<!-- more -->\n\n# 场景\n\n一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是`Beverage`抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso... 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。\n\n如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？\n\n> 类应该堆扩展开放，对修改关闭。\n\n\n\n# 装饰者模式\n\n以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。\n\n1. DarkRoast对象\n2. 用摩卡装饰\n3. 用奶泡装饰\n4. 调用cost方法，依赖delegate添加价钱\n\n\n\n# 实现\n\n![Screenshot from 2020-06-12 20-50-33.png](https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png)\n\n\n\n其中`Condiment`是调料类，重写了`Beverage`的`getDescription`方法。以Whip为例：\n\n```java\npublic class Whip extends Condiment {\n    Beverage beverage;\n\n    public Whip(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription() {\n        return beverage.getDescription() + \", Whip\";\n    }\n\n    @Override\n    public double cost() {\n        return .30 + beverage.cost();\n    }\n}\n```\n\n它的_cost_方法入获取description的方法如出一辙，这样的好处在于：\n\n```java\nBeverage beverage1 = new DarRoast();\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Whip(beverage1);\nSystem.out.println(beverage1.getDescription() + \" $\" + beverage1.cost());\n```\n\n```console\nBrazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75\n```\n\n制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为**委托**.\n\n# 应用\n\n## Java I/O\n\n大量的`Decorator Pattern`在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。\n\n```flow\npara1=>parallel: FileInputStream\npara2=>parallel: BufferedInputStream\npara3=>parallel: LineNumberInputStream\nop1=>operation: Beferage\nop2=>operation: Espresso\nop3=>operation: Mocha\npara1(path1, bottom)->para2\npara2(path1,bottom)->para3\npara1(path2, right)->op1\npara2(path2, right)->op2\npara3(path2, right)->op3\n```\n\n","source":"_posts/decorating.md","raw":"---\n\ntitle: decorating\ndate: 2020-06-12 18:30:28\ncategories: DesignPatterns\ntags: design_patterns\n---\n\n继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。\n\n<!-- more -->\n\n# 场景\n\n一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是`Beverage`抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso... 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。\n\n如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？\n\n> 类应该堆扩展开放，对修改关闭。\n\n\n\n# 装饰者模式\n\n以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。\n\n1. DarkRoast对象\n2. 用摩卡装饰\n3. 用奶泡装饰\n4. 调用cost方法，依赖delegate添加价钱\n\n\n\n# 实现\n\n![Screenshot from 2020-06-12 20-50-33.png](https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png)\n\n\n\n其中`Condiment`是调料类，重写了`Beverage`的`getDescription`方法。以Whip为例：\n\n```java\npublic class Whip extends Condiment {\n    Beverage beverage;\n\n    public Whip(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription() {\n        return beverage.getDescription() + \", Whip\";\n    }\n\n    @Override\n    public double cost() {\n        return .30 + beverage.cost();\n    }\n}\n```\n\n它的_cost_方法入获取description的方法如出一辙，这样的好处在于：\n\n```java\nBeverage beverage1 = new DarRoast();\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Whip(beverage1);\nSystem.out.println(beverage1.getDescription() + \" $\" + beverage1.cost());\n```\n\n```console\nBrazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75\n```\n\n制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为**委托**.\n\n# 应用\n\n## Java I/O\n\n大量的`Decorator Pattern`在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。\n\n```flow\npara1=>parallel: FileInputStream\npara2=>parallel: BufferedInputStream\npara3=>parallel: LineNumberInputStream\nop1=>operation: Beferage\nop2=>operation: Espresso\nop3=>operation: Mocha\npara1(path1, bottom)->para2\npara2(path1,bottom)->para3\npara1(path2, right)->op1\npara2(path2, right)->op2\npara3(path2, right)->op3\n```\n\n","slug":"decorating","published":1,"updated":"2021-03-24T06:44:13.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q78000ow5ih6vi74u1i","content":"<p>继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是<code>Beverage</code>抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso… 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。</p>\n<p>如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？</p>\n<blockquote>\n<p>类应该堆扩展开放，对修改关闭。</p>\n</blockquote>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><p>以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。</p>\n<ol>\n<li>DarkRoast对象</li>\n<li>用摩卡装饰</li>\n<li>用奶泡装饰</li>\n<li>调用cost方法，依赖delegate添加价钱</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p><img src=\"https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png\" alt=\"Screenshot from 2020-06-12 20-50-33.png\"></p>\n<p>其中<code>Condiment</code>是调料类，重写了<code>Beverage</code>的<code>getDescription</code>方法。以Whip为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Whip</span> <span class=\"keyword\">extends</span> <span class=\"title\">Condiment</span> </span>&#123;</span><br><span class=\"line\">    Beverage beverage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Whip</span><span class=\"params\">(Beverage beverage)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.beverage = beverage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDescription</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> beverage.getDescription() + <span class=\"string\">&quot;, Whip&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">cost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">.30</span> + beverage.cost();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的_cost_方法入获取description的方法如出一辙，这样的好处在于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Beverage beverage1 = <span class=\"keyword\">new</span> DarRoast();</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Whip(beverage1);</span><br><span class=\"line\">System.out.println(beverage1.getDescription() + <span class=\"string\">&quot; $&quot;</span> + beverage1.cost());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Brazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75</span><br></pre></td></tr></table></figure>\n\n<p>制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为<strong>委托</strong>.</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"Java-I-O\"><a href=\"#Java-I-O\" class=\"headerlink\" title=\"Java I/O\"></a>Java I/O</h2><p>大量的<code>Decorator Pattern</code>在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para1&#x3D;&gt;parallel: FileInputStream</span><br><span class=\"line\">para2&#x3D;&gt;parallel: BufferedInputStream</span><br><span class=\"line\">para3&#x3D;&gt;parallel: LineNumberInputStream</span><br><span class=\"line\">op1&#x3D;&gt;operation: Beferage</span><br><span class=\"line\">op2&#x3D;&gt;operation: Espresso</span><br><span class=\"line\">op3&#x3D;&gt;operation: Mocha</span><br><span class=\"line\">para1(path1, bottom)-&gt;para2</span><br><span class=\"line\">para2(path1,bottom)-&gt;para3</span><br><span class=\"line\">para1(path2, right)-&gt;op1</span><br><span class=\"line\">para2(path2, right)-&gt;op2</span><br><span class=\"line\">para3(path2, right)-&gt;op3</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。</p>","more":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是<code>Beverage</code>抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso… 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。</p>\n<p>如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？</p>\n<blockquote>\n<p>类应该堆扩展开放，对修改关闭。</p>\n</blockquote>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><p>以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。</p>\n<ol>\n<li>DarkRoast对象</li>\n<li>用摩卡装饰</li>\n<li>用奶泡装饰</li>\n<li>调用cost方法，依赖delegate添加价钱</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p><img src=\"https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png\" alt=\"Screenshot from 2020-06-12 20-50-33.png\"></p>\n<p>其中<code>Condiment</code>是调料类，重写了<code>Beverage</code>的<code>getDescription</code>方法。以Whip为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Whip</span> <span class=\"keyword\">extends</span> <span class=\"title\">Condiment</span> </span>&#123;</span><br><span class=\"line\">    Beverage beverage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Whip</span><span class=\"params\">(Beverage beverage)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.beverage = beverage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDescription</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> beverage.getDescription() + <span class=\"string\">&quot;, Whip&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">cost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">.30</span> + beverage.cost();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的_cost_方法入获取description的方法如出一辙，这样的好处在于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Beverage beverage1 = <span class=\"keyword\">new</span> DarRoast();</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Whip(beverage1);</span><br><span class=\"line\">System.out.println(beverage1.getDescription() + <span class=\"string\">&quot; $&quot;</span> + beverage1.cost());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Brazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75</span><br></pre></td></tr></table></figure>\n\n<p>制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为<strong>委托</strong>.</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"Java-I-O\"><a href=\"#Java-I-O\" class=\"headerlink\" title=\"Java I/O\"></a>Java I/O</h2><p>大量的<code>Decorator Pattern</code>在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para1&#x3D;&gt;parallel: FileInputStream</span><br><span class=\"line\">para2&#x3D;&gt;parallel: BufferedInputStream</span><br><span class=\"line\">para3&#x3D;&gt;parallel: LineNumberInputStream</span><br><span class=\"line\">op1&#x3D;&gt;operation: Beferage</span><br><span class=\"line\">op2&#x3D;&gt;operation: Espresso</span><br><span class=\"line\">op3&#x3D;&gt;operation: Mocha</span><br><span class=\"line\">para1(path1, bottom)-&gt;para2</span><br><span class=\"line\">para2(path1,bottom)-&gt;para3</span><br><span class=\"line\">para1(path2, right)-&gt;op1</span><br><span class=\"line\">para2(path2, right)-&gt;op2</span><br><span class=\"line\">para3(path2, right)-&gt;op3</span><br></pre></td></tr></table></figure>"},{"title":"hashmap","date":"2020-08-20T15:04:30.000Z","_content":"\nJava Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。\n\n<!--more-->\n\n# Example\n\n```java\nMap<String, Object> map = new HashMap<>();\nmap.put(\"name\", \"Gloria\");\nmap.put(\"age\", 3);\nmap.put(\"wage\", 539.8);\nSystem.out.println(map);\n```\n\n通过一个简单的`put`操作，来看看究竟发生了什么。\n\n## 构造\n\n初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：\n\n```java\nMap<String, Object> map1 = new HashMap<>(map); // map为上方那个\n```\n\n来看看初始化容量时的装载因子：\n\n```java\n    /**\n     * The load factor for the hash table.\n     *\n     * @serial\n     */\n    final float loadFactor;\n```\n\nHashMap的容量是我们存入的数值乘以`0.75`,例如：\n\n```java\nMap<String, Object> map = new HashMap<>(16);\n```\n\n那么，这个map的**实际容量**就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的`0.75`,自定义**初始容量**。\n\n## put初识\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    return putVal(hash(key), key, value, false, true);\n}key\n```\n\nput有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个**位运算**:\n\n- ^ 异或(两个相同的数做异或运算结果为0)\n- \\>\\>\\> 无符号右移，左边空出来的补0\n\n首先是给h赋值为key的hashCode，key的hashcode是通过Object的`native方法`，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。\n\n关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量`table`，他的类型是`Noe<K,V> []`，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。\n\n\n\n# Node\n\n它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。\n\n```java\n /**\n  * Basic hash bin node, used for most entries.  (See below for\n  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)\n  */\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; // 用来定位数组索引位置\n    final K key;\n    V value;\n    Node<K,V> next; // 链接下一个Node\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    \n    // get, set equals ...\n}\n```\n\n- 脱脱的链表有么有！！！ `Node<K, V> next`！！！\n- 上面提到的`table`就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。\n- 实现了`Map.Entry<K, V>`接口，所以，他的本质（或者说表现）就是一个k-v键值对。\n- 与算法题通常定义的简易链表不同，除了`next`外这里存储了三个值：`hash`, `key`, `value`\n\n\n\n# 冲突解决\n\n首先想想：什么是哈希表。\n\n哈希表=数组+链表。通过`Node<K, V>`以及`Node<K, V> []`我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是`数组+链表`。\n\n哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于**桶**（即之前提到的`table`数组）和**哈希算法**，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：\n\n```java\n/**\n  * The number of key-value mappings contained in this map.\n  */\ntransient int size;\n\n/**\n  * The number of times this HashMap has been structurally modified\n  * Structural modifications are those that change the number of mappings in\n  * the HashMap or otherwise modify its internal structure (e.g.,\n  * rehash).  This field is used to make iterators on Collection-views of\n  * the HashMap fail-fast.  (See ConcurrentModificationException).\n  */\ntransient int modCount;\n\n/**\n  * The next size value at which to resize (capacity * load factor).\n  *\n  * @serial\n  */\n// (The javadoc description is true upon serialization.\n// Additionally, if the table array has not been allocated, this\n// field holds the initial array capacity, or zero signifying\n// DEFAULT_INITIAL_CAPACITY.)\nint threshold;\n\n/**\n  * The load factor for the hash table.\n  *\n  * @serial\n  */\nfinal float loadFactor;\n```\n\n`threshold`临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node<K,V>[] table的length是16, loadFactor是0.75,，那么\n\n> threshold = loadFactor * length\n\n也就是说，table数组中所能容纳的Node个数由`threshold`指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.\n\nsize就是表示目前存储的Node的数量。\n\n在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种**非常规**设计，为什么呢？一个冷知识：\n\n- 2的n次方的数为`合数`，实际上`质数`导致哈希冲突的概率要小于合数。\n\n参考HashTable的初始化，`initialCapacity`就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了**红黑树**，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。\n\n\n\n# 确定索引\n\n我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：\n\n> 取值（key的hashCode），高位运算，取模运算\n\n我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：\n\n```java\nif ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n```\n\n在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以`(n-1)&hash`等价于对length取模，比使用`%`具有更高的效率。\n\n \n\n# put详解\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 判断table的是否为空，是则执行扩容操作\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算插入数组的索引，如果为null，新建节点\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 判断key是否存在，如ugo存在直接覆盖掉value\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 判断是否是红黑树，如果是的话就在树中操作，\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 遍历table\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    // 链表的插入操作\n                    p.next = newNode(hash, key, value, null);\n                    // 长度大于8时转红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 超过最大容量就扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n\n\n# 扩容\n\n我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？\n\n> note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。\n\n```java\n/**\n * Initializes or doubles table size.  If null, allocates in\n * accord with initial capacity target held in field threshold.\n * Otherwise, because we are using power-of-two expansion, the\n * elements from each bin must either stay at same index, or move\n * with a power of two offset in the new table.\n *\n * @return the table\n */\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 太大就不管了，let it go\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，左移一位（X2）\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算resize的上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 遍历数组，把每个桶都移动到新的中去\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n","source":"_posts/hashmap.md","raw":"---\ntitle: hashmap\ndate: 2020-08-20 23:04:30\ncategories: Java\ntags: hashmap, data structure\n---\n\nJava Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。\n\n<!--more-->\n\n# Example\n\n```java\nMap<String, Object> map = new HashMap<>();\nmap.put(\"name\", \"Gloria\");\nmap.put(\"age\", 3);\nmap.put(\"wage\", 539.8);\nSystem.out.println(map);\n```\n\n通过一个简单的`put`操作，来看看究竟发生了什么。\n\n## 构造\n\n初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：\n\n```java\nMap<String, Object> map1 = new HashMap<>(map); // map为上方那个\n```\n\n来看看初始化容量时的装载因子：\n\n```java\n    /**\n     * The load factor for the hash table.\n     *\n     * @serial\n     */\n    final float loadFactor;\n```\n\nHashMap的容量是我们存入的数值乘以`0.75`,例如：\n\n```java\nMap<String, Object> map = new HashMap<>(16);\n```\n\n那么，这个map的**实际容量**就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的`0.75`,自定义**初始容量**。\n\n## put初识\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    return putVal(hash(key), key, value, false, true);\n}key\n```\n\nput有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个**位运算**:\n\n- ^ 异或(两个相同的数做异或运算结果为0)\n- \\>\\>\\> 无符号右移，左边空出来的补0\n\n首先是给h赋值为key的hashCode，key的hashcode是通过Object的`native方法`，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。\n\n关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量`table`，他的类型是`Noe<K,V> []`，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。\n\n\n\n# Node\n\n它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。\n\n```java\n /**\n  * Basic hash bin node, used for most entries.  (See below for\n  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)\n  */\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; // 用来定位数组索引位置\n    final K key;\n    V value;\n    Node<K,V> next; // 链接下一个Node\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    \n    // get, set equals ...\n}\n```\n\n- 脱脱的链表有么有！！！ `Node<K, V> next`！！！\n- 上面提到的`table`就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。\n- 实现了`Map.Entry<K, V>`接口，所以，他的本质（或者说表现）就是一个k-v键值对。\n- 与算法题通常定义的简易链表不同，除了`next`外这里存储了三个值：`hash`, `key`, `value`\n\n\n\n# 冲突解决\n\n首先想想：什么是哈希表。\n\n哈希表=数组+链表。通过`Node<K, V>`以及`Node<K, V> []`我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是`数组+链表`。\n\n哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于**桶**（即之前提到的`table`数组）和**哈希算法**，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：\n\n```java\n/**\n  * The number of key-value mappings contained in this map.\n  */\ntransient int size;\n\n/**\n  * The number of times this HashMap has been structurally modified\n  * Structural modifications are those that change the number of mappings in\n  * the HashMap or otherwise modify its internal structure (e.g.,\n  * rehash).  This field is used to make iterators on Collection-views of\n  * the HashMap fail-fast.  (See ConcurrentModificationException).\n  */\ntransient int modCount;\n\n/**\n  * The next size value at which to resize (capacity * load factor).\n  *\n  * @serial\n  */\n// (The javadoc description is true upon serialization.\n// Additionally, if the table array has not been allocated, this\n// field holds the initial array capacity, or zero signifying\n// DEFAULT_INITIAL_CAPACITY.)\nint threshold;\n\n/**\n  * The load factor for the hash table.\n  *\n  * @serial\n  */\nfinal float loadFactor;\n```\n\n`threshold`临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node<K,V>[] table的length是16, loadFactor是0.75,，那么\n\n> threshold = loadFactor * length\n\n也就是说，table数组中所能容纳的Node个数由`threshold`指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.\n\nsize就是表示目前存储的Node的数量。\n\n在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种**非常规**设计，为什么呢？一个冷知识：\n\n- 2的n次方的数为`合数`，实际上`质数`导致哈希冲突的概率要小于合数。\n\n参考HashTable的初始化，`initialCapacity`就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了**红黑树**，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。\n\n\n\n# 确定索引\n\n我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：\n\n> 取值（key的hashCode），高位运算，取模运算\n\n我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：\n\n```java\nif ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n```\n\n在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以`(n-1)&hash`等价于对length取模，比使用`%`具有更高的效率。\n\n \n\n# put详解\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 判断table的是否为空，是则执行扩容操作\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算插入数组的索引，如果为null，新建节点\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 判断key是否存在，如ugo存在直接覆盖掉value\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 判断是否是红黑树，如果是的话就在树中操作，\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 遍历table\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    // 链表的插入操作\n                    p.next = newNode(hash, key, value, null);\n                    // 长度大于8时转红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 超过最大容量就扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n\n\n# 扩容\n\n我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？\n\n> note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。\n\n```java\n/**\n * Initializes or doubles table size.  If null, allocates in\n * accord with initial capacity target held in field threshold.\n * Otherwise, because we are using power-of-two expansion, the\n * elements from each bin must either stay at same index, or move\n * with a power of two offset in the new table.\n *\n * @return the table\n */\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 太大就不管了，let it go\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，左移一位（X2）\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算resize的上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 遍历数组，把每个桶都移动到新的中去\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n","slug":"hashmap","published":1,"updated":"2020-12-15T13:25:48.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7a000qw5ihcptj9jqw","content":"<p>Java Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Gloria&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;wage&quot;</span>, <span class=\"number\">539.8</span>);</span><br><span class=\"line\">System.out.println(map);</span><br></pre></td></tr></table></figure>\n\n<p>通过一个简单的<code>put</code>操作，来看看究竟发生了什么。</p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p>初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map1 = <span class=\"keyword\">new</span> HashMap&lt;&gt;(map); <span class=\"comment\">// map为上方那个</span></span><br></pre></td></tr></table></figure>\n\n<p>来看看初始化容量时的装载因子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p>HashMap的容量是我们存入的数值乘以<code>0.75</code>,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么，这个map的<strong>实际容量</strong>就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的<code>0.75</code>,自定义<strong>初始容量</strong>。</p>\n<h2 id=\"put初识\"><a href=\"#put初识\" class=\"headerlink\" title=\"put初识\"></a>put初识</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;key</span><br></pre></td></tr></table></figure>\n\n<p>put有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个<strong>位运算</strong>:</p>\n<ul>\n<li>^ 异或(两个相同的数做异或运算结果为0)</li>\n<li>&gt;&gt;&gt; 无符号右移，左边空出来的补0</li>\n</ul>\n<p>首先是给h赋值为key的hashCode，key的hashcode是通过Object的<code>native方法</code>，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。</p>\n<p>关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量<code>table</code>，他的类型是<code>Noe&lt;K,V&gt; []</code>，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。</p>\n<h1 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h1><p>它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class=\"line\"><span class=\"comment\">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// 用来定位数组索引位置</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next; <span class=\"comment\">// 链接下一个Node</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// get, set equals ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脱脱的链表有么有！！！ <code>Node&lt;K, V&gt; next</code>！！！</li>\n<li>上面提到的<code>table</code>就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。</li>\n<li>实现了<code>Map.Entry&lt;K, V&gt;</code>接口，所以，他的本质（或者说表现）就是一个k-v键值对。</li>\n<li>与算法题通常定义的简易链表不同，除了<code>next</code>外这里存储了三个值：<code>hash</code>, <code>key</code>, <code>value</code></li>\n</ul>\n<h1 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h1><p>首先想想：什么是哈希表。</p>\n<p>哈希表=数组+链表。通过<code>Node&lt;K, V&gt;</code>以及<code>Node&lt;K, V&gt; []</code>我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是<code>数组+链表</code>。</p>\n<p>哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于<strong>桶</strong>（即之前提到的<code>table</code>数组）和<strong>哈希算法</strong>，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of key-value mappings contained in this map.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of times this HashMap has been structurally modified</span></span><br><span class=\"line\"><span class=\"comment\">  * Structural modifications are those that change the number of mappings in</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\">  * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"comment\">// (The javadoc description is true upon serialization.</span></span><br><span class=\"line\"><span class=\"comment\">// Additionally, if the table array has not been allocated, this</span></span><br><span class=\"line\"><span class=\"comment\">// field holds the initial array capacity, or zero signifying</span></span><br><span class=\"line\"><span class=\"comment\">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p><code>threshold</code>临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node&lt;K,V&gt;[] table的length是16, loadFactor是0.75,，那么</p>\n<blockquote>\n<p>threshold = loadFactor * length</p>\n</blockquote>\n<p>也就是说，table数组中所能容纳的Node个数由<code>threshold</code>指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.</p>\n<p>size就是表示目前存储的Node的数量。</p>\n<p>在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种<strong>非常规</strong>设计，为什么呢？一个冷知识：</p>\n<ul>\n<li>2的n次方的数为<code>合数</code>，实际上<code>质数</code>导致哈希冲突的概率要小于合数。</li>\n</ul>\n<p>参考HashTable的初始化，<code>initialCapacity</code>就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了<strong>红黑树</strong>，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。</p>\n<h1 id=\"确定索引\"><a href=\"#确定索引\" class=\"headerlink\" title=\"确定索引\"></a>确定索引</h1><p>我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：</p>\n<blockquote>\n<p>取值（key的hashCode），高位运算，取模运算</p>\n</blockquote>\n<p>我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以<code>(n-1)&amp;hash</code>等价于对length取模，比使用<code>%</code>具有更高的效率。</p>\n<h1 id=\"put详解\"><a href=\"#put详解\" class=\"headerlink\" title=\"put详解\"></a>put详解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 判断table的是否为空，是则执行扩容操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 计算插入数组的索引，如果为null，新建节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 判断key是否存在，如ugo存在直接覆盖掉value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是红黑树，如果是的话就在树中操作，</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历table</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 链表的插入操作</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 长度大于8时转红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 超过最大容量就扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h1><p>我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？</p>\n<blockquote>\n<p>note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class=\"line\"><span class=\"comment\"> * accord with initial capacity target held in field threshold.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements from each bin must either stay at same index, or move</span></span><br><span class=\"line\"><span class=\"comment\"> * with a power of two offset in the new table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the table</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 太大就不管了，let it go</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，左移一位（X2）</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算resize的上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历数组，把每个桶都移动到新的中去</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Java Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。</p>","more":"<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Gloria&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;wage&quot;</span>, <span class=\"number\">539.8</span>);</span><br><span class=\"line\">System.out.println(map);</span><br></pre></td></tr></table></figure>\n\n<p>通过一个简单的<code>put</code>操作，来看看究竟发生了什么。</p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p>初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map1 = <span class=\"keyword\">new</span> HashMap&lt;&gt;(map); <span class=\"comment\">// map为上方那个</span></span><br></pre></td></tr></table></figure>\n\n<p>来看看初始化容量时的装载因子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p>HashMap的容量是我们存入的数值乘以<code>0.75</code>,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么，这个map的<strong>实际容量</strong>就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的<code>0.75</code>,自定义<strong>初始容量</strong>。</p>\n<h2 id=\"put初识\"><a href=\"#put初识\" class=\"headerlink\" title=\"put初识\"></a>put初识</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;key</span><br></pre></td></tr></table></figure>\n\n<p>put有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个<strong>位运算</strong>:</p>\n<ul>\n<li>^ 异或(两个相同的数做异或运算结果为0)</li>\n<li>&gt;&gt;&gt; 无符号右移，左边空出来的补0</li>\n</ul>\n<p>首先是给h赋值为key的hashCode，key的hashcode是通过Object的<code>native方法</code>，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。</p>\n<p>关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量<code>table</code>，他的类型是<code>Noe&lt;K,V&gt; []</code>，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。</p>\n<h1 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h1><p>它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class=\"line\"><span class=\"comment\">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// 用来定位数组索引位置</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next; <span class=\"comment\">// 链接下一个Node</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// get, set equals ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脱脱的链表有么有！！！ <code>Node&lt;K, V&gt; next</code>！！！</li>\n<li>上面提到的<code>table</code>就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。</li>\n<li>实现了<code>Map.Entry&lt;K, V&gt;</code>接口，所以，他的本质（或者说表现）就是一个k-v键值对。</li>\n<li>与算法题通常定义的简易链表不同，除了<code>next</code>外这里存储了三个值：<code>hash</code>, <code>key</code>, <code>value</code></li>\n</ul>\n<h1 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h1><p>首先想想：什么是哈希表。</p>\n<p>哈希表=数组+链表。通过<code>Node&lt;K, V&gt;</code>以及<code>Node&lt;K, V&gt; []</code>我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是<code>数组+链表</code>。</p>\n<p>哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于<strong>桶</strong>（即之前提到的<code>table</code>数组）和<strong>哈希算法</strong>，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of key-value mappings contained in this map.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of times this HashMap has been structurally modified</span></span><br><span class=\"line\"><span class=\"comment\">  * Structural modifications are those that change the number of mappings in</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\">  * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"comment\">// (The javadoc description is true upon serialization.</span></span><br><span class=\"line\"><span class=\"comment\">// Additionally, if the table array has not been allocated, this</span></span><br><span class=\"line\"><span class=\"comment\">// field holds the initial array capacity, or zero signifying</span></span><br><span class=\"line\"><span class=\"comment\">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p><code>threshold</code>临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node&lt;K,V&gt;[] table的length是16, loadFactor是0.75,，那么</p>\n<blockquote>\n<p>threshold = loadFactor * length</p>\n</blockquote>\n<p>也就是说，table数组中所能容纳的Node个数由<code>threshold</code>指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.</p>\n<p>size就是表示目前存储的Node的数量。</p>\n<p>在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种<strong>非常规</strong>设计，为什么呢？一个冷知识：</p>\n<ul>\n<li>2的n次方的数为<code>合数</code>，实际上<code>质数</code>导致哈希冲突的概率要小于合数。</li>\n</ul>\n<p>参考HashTable的初始化，<code>initialCapacity</code>就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了<strong>红黑树</strong>，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。</p>\n<h1 id=\"确定索引\"><a href=\"#确定索引\" class=\"headerlink\" title=\"确定索引\"></a>确定索引</h1><p>我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：</p>\n<blockquote>\n<p>取值（key的hashCode），高位运算，取模运算</p>\n</blockquote>\n<p>我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以<code>(n-1)&amp;hash</code>等价于对length取模，比使用<code>%</code>具有更高的效率。</p>\n<h1 id=\"put详解\"><a href=\"#put详解\" class=\"headerlink\" title=\"put详解\"></a>put详解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 判断table的是否为空，是则执行扩容操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 计算插入数组的索引，如果为null，新建节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 判断key是否存在，如ugo存在直接覆盖掉value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是红黑树，如果是的话就在树中操作，</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历table</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 链表的插入操作</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 长度大于8时转红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 超过最大容量就扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h1><p>我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？</p>\n<blockquote>\n<p>note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class=\"line\"><span class=\"comment\"> * accord with initial capacity target held in field threshold.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements from each bin must either stay at same index, or move</span></span><br><span class=\"line\"><span class=\"comment\"> * with a power of two offset in the new table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the table</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 太大就不管了，let it go</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，左移一位（X2）</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算resize的上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历数组，把每个桶都移动到新的中去</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"heap","date":"2020-06-06T14:54:27.000Z","_content":"\n这里的堆是数据结构中的堆，不是JVM中的堆。\n\n关键词：堆，二叉树，优先级队列，排序，topN\n\n<!-- more -->\n\n# 结构\n\n堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。\t\n\n## 完全二叉树\n\n- 路径长度是指路径上的边数\n- 结点深度是指从根结点到该结点的路径的长度\n- 每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置\n\n## 二叉堆\n\n- 完全二叉树\n- 每个结点大于或等于它的任意一个孩子\n\n# 存储\n\n可以将二叉堆用数组来存储。\n\n例如如下一个二叉堆：\n\n![Screenshot from 2020-06-06 15-24-34.png](https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png)\n\n在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}\n\n可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。\n\n# 应用\n\n## 优先级队列\n\n优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题\n\n## TOP N\n\n给一组数据，求其中最大/小的几个数。\n\n```java\n// 求最小的n个数\npublic static int[] topN(int[] array, int n) {\n    if (n == 0) {\n        return new int[0];\n    }\n    // default big heap, lambda make it small heap\n    Queue<Integer> heap = new PriorityQueue<>(n, ((o1, o2) -> Integer.compare(o2, o1)));\n\n    for (int e : array) {\n        // put the integer in when it smaller than the top of integer\n        if (heap.isEmpty() || heap.size() < n || e < heap.peek()) {\n            heap.offer(e);\n        }\n        if (heap.size() > n) {\n            // delete the top of heap integer\n            heap.poll();\n        }\n    }\n\n    int[] res = new int[heap.size()];\n    int j = 0;\n    for (int e : heap) {\n        res[j++] = e;\n    }\n    return res;\n}\n```\n\n上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。\n\n稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：\n\n```java\n// 默认大顶堆\nQueue<Integer> heap = new PriorityQueue<>(n);\nfor(int e: array){\n    // 大于堆顶的放入优先级队列\n    if(heap.isEmpty() || heap.size() < n || e > heap.peak()){\n        heap.offer(e);\n    }\n    // 超过要求的个数，清除堆顶元素\n    if(heap.size() > n){\n        heap.pool();\n    }\n}\n```\n\n\n\n\n\n","source":"_posts/heap.md","raw":"---\ntitle: heap\ndate: 2020-06-06 22:54:27\ncategories: Java\ntags: datastructure\n---\n\n这里的堆是数据结构中的堆，不是JVM中的堆。\n\n关键词：堆，二叉树，优先级队列，排序，topN\n\n<!-- more -->\n\n# 结构\n\n堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。\t\n\n## 完全二叉树\n\n- 路径长度是指路径上的边数\n- 结点深度是指从根结点到该结点的路径的长度\n- 每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置\n\n## 二叉堆\n\n- 完全二叉树\n- 每个结点大于或等于它的任意一个孩子\n\n# 存储\n\n可以将二叉堆用数组来存储。\n\n例如如下一个二叉堆：\n\n![Screenshot from 2020-06-06 15-24-34.png](https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png)\n\n在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}\n\n可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。\n\n# 应用\n\n## 优先级队列\n\n优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题\n\n## TOP N\n\n给一组数据，求其中最大/小的几个数。\n\n```java\n// 求最小的n个数\npublic static int[] topN(int[] array, int n) {\n    if (n == 0) {\n        return new int[0];\n    }\n    // default big heap, lambda make it small heap\n    Queue<Integer> heap = new PriorityQueue<>(n, ((o1, o2) -> Integer.compare(o2, o1)));\n\n    for (int e : array) {\n        // put the integer in when it smaller than the top of integer\n        if (heap.isEmpty() || heap.size() < n || e < heap.peek()) {\n            heap.offer(e);\n        }\n        if (heap.size() > n) {\n            // delete the top of heap integer\n            heap.poll();\n        }\n    }\n\n    int[] res = new int[heap.size()];\n    int j = 0;\n    for (int e : heap) {\n        res[j++] = e;\n    }\n    return res;\n}\n```\n\n上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。\n\n稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：\n\n```java\n// 默认大顶堆\nQueue<Integer> heap = new PriorityQueue<>(n);\nfor(int e: array){\n    // 大于堆顶的放入优先级队列\n    if(heap.isEmpty() || heap.size() < n || e > heap.peak()){\n        heap.offer(e);\n    }\n    // 超过要求的个数，清除堆顶元素\n    if(heap.size() > n){\n        heap.pool();\n    }\n}\n```\n\n\n\n\n\n","slug":"heap","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7c000uw5ihbz9pcsev","content":"<p>这里的堆是数据结构中的堆，不是JVM中的堆。</p>\n<p>关键词：堆，二叉树，优先级队列，排序，topN</p>\n<a id=\"more\"></a>\n\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。    </p>\n<h2 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h2><ul>\n<li>路径长度是指路径上的边数</li>\n<li>结点深度是指从根结点到该结点的路径的长度</li>\n<li>每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置</li>\n</ul>\n<h2 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h2><ul>\n<li>完全二叉树</li>\n<li>每个结点大于或等于它的任意一个孩子</li>\n</ul>\n<h1 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h1><p>可以将二叉堆用数组来存储。</p>\n<p>例如如下一个二叉堆：</p>\n<p><img src=\"https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png\" alt=\"Screenshot from 2020-06-06 15-24-34.png\"></p>\n<p>在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}</p>\n<p>可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><p>优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题</p>\n<h2 id=\"TOP-N\"><a href=\"#TOP-N\" class=\"headerlink\" title=\"TOP N\"></a>TOP N</h2><p>给一组数据，求其中最大/小的几个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求最小的n个数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] topN(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// default big heap, lambda make it small heap</span></span><br><span class=\"line\">    Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n, ((o1, o2) -&gt; Integer.compare(o2, o1)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : array) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// put the integer in when it smaller than the top of integer</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.isEmpty() || heap.size() &lt; n || e &lt; heap.peek()) &#123;</span><br><span class=\"line\">            heap.offer(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.size() &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// delete the top of heap integer</span></span><br><span class=\"line\">            heap.poll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[heap.size()];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : heap) &#123;</span><br><span class=\"line\">        res[j++] = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。</p>\n<p>稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认大顶堆</span></span><br><span class=\"line\">Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e: array)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 大于堆顶的放入优先级队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.isEmpty() || heap.size() &lt; n || e &gt; heap.peak())&#123;</span><br><span class=\"line\">        heap.offer(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 超过要求的个数，清除堆顶元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.size() &gt; n)&#123;</span><br><span class=\"line\">        heap.pool();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这里的堆是数据结构中的堆，不是JVM中的堆。</p>\n<p>关键词：堆，二叉树，优先级队列，排序，topN</p>","more":"<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。    </p>\n<h2 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h2><ul>\n<li>路径长度是指路径上的边数</li>\n<li>结点深度是指从根结点到该结点的路径的长度</li>\n<li>每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置</li>\n</ul>\n<h2 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h2><ul>\n<li>完全二叉树</li>\n<li>每个结点大于或等于它的任意一个孩子</li>\n</ul>\n<h1 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h1><p>可以将二叉堆用数组来存储。</p>\n<p>例如如下一个二叉堆：</p>\n<p><img src=\"https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png\" alt=\"Screenshot from 2020-06-06 15-24-34.png\"></p>\n<p>在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}</p>\n<p>可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><p>优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题</p>\n<h2 id=\"TOP-N\"><a href=\"#TOP-N\" class=\"headerlink\" title=\"TOP N\"></a>TOP N</h2><p>给一组数据，求其中最大/小的几个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求最小的n个数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] topN(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// default big heap, lambda make it small heap</span></span><br><span class=\"line\">    Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n, ((o1, o2) -&gt; Integer.compare(o2, o1)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : array) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// put the integer in when it smaller than the top of integer</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.isEmpty() || heap.size() &lt; n || e &lt; heap.peek()) &#123;</span><br><span class=\"line\">            heap.offer(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.size() &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// delete the top of heap integer</span></span><br><span class=\"line\">            heap.poll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[heap.size()];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : heap) &#123;</span><br><span class=\"line\">        res[j++] = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。</p>\n<p>稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认大顶堆</span></span><br><span class=\"line\">Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e: array)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 大于堆顶的放入优先级队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.isEmpty() || heap.size() &lt; n || e &gt; heap.peak())&#123;</span><br><span class=\"line\">        heap.offer(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 超过要求的个数，清除堆顶元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.size() &gt; n)&#123;</span><br><span class=\"line\">        heap.pool();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"https","date":"2020-03-14T02:43:29.000Z","_content":"\n**Hypertext Transfer Protocol Secure**, an extension of the Hypertext Transfer Protocol. \n\nHow to encrypt communication? Through referred to as **HTTP over TLS**, or **HTTP over SSL**\n\n- Transport Layer Security\n- Secure Sockets Layer\n\n<!-- more -->\n\n# HTTP与HTTPS\n\n\n\n## Difference\n\nHTTPS的URL地址开头是`https://`，默认使用的的端口是`443`，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。\n\n---\n\nHTTP的URL地址开头是`http://`，默认使用的端口是`80`，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。\n\n\n\n## Limitation\n\nSSL/TSL没有禁止网络搜索器（website crawler）搜索它的索引，所以在这种情况下，请求和响应的报文的大小是会被知晓的（内容仍然加密无法破解）。\n\n\n\n# URI、URL与URN\n\nurl是uri的子集。\n\n## URI\n\n统一资源标识符。*A string of characters that unambiguously identifies a particular resource*.  它规定了一些特定的语法规则，并且在规则下还可以自有扩展，例如`http://`。\n\n## URN\n\n统一资源名称。*A Uniform Resource Name(URN) is a URI that identifies a resource by name in a particular namespace.* 它能标识一个唯一的名称，但不清楚它的位置。\n\n## URL\n\n统一资源定位符。*A Uniform Resource Locator(URL) is a URI that specifies the means of acting upon or obtaining the representation of a resource.* 就是我们常见的http请求地址。\n\n[reference](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)","source":"_posts/https.md","raw":"---\ntitle: https\ndate: 2020-03-14 10:43:29\ncategories: Network\ntags: ['http','https']\n---\n\n**Hypertext Transfer Protocol Secure**, an extension of the Hypertext Transfer Protocol. \n\nHow to encrypt communication? Through referred to as **HTTP over TLS**, or **HTTP over SSL**\n\n- Transport Layer Security\n- Secure Sockets Layer\n\n<!-- more -->\n\n# HTTP与HTTPS\n\n\n\n## Difference\n\nHTTPS的URL地址开头是`https://`，默认使用的的端口是`443`，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。\n\n---\n\nHTTP的URL地址开头是`http://`，默认使用的端口是`80`，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。\n\n\n\n## Limitation\n\nSSL/TSL没有禁止网络搜索器（website crawler）搜索它的索引，所以在这种情况下，请求和响应的报文的大小是会被知晓的（内容仍然加密无法破解）。\n\n\n\n# URI、URL与URN\n\nurl是uri的子集。\n\n## URI\n\n统一资源标识符。*A string of characters that unambiguously identifies a particular resource*.  它规定了一些特定的语法规则，并且在规则下还可以自有扩展，例如`http://`。\n\n## URN\n\n统一资源名称。*A Uniform Resource Name(URN) is a URI that identifies a resource by name in a particular namespace.* 它能标识一个唯一的名称，但不清楚它的位置。\n\n## URL\n\n统一资源定位符。*A Uniform Resource Locator(URL) is a URI that specifies the means of acting upon or obtaining the representation of a resource.* 就是我们常见的http请求地址。\n\n[reference](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)","slug":"https","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7e000xw5ih6igs72r5","content":"<p><strong>Hypertext Transfer Protocol Secure</strong>, an extension of the Hypertext Transfer Protocol. </p>\n<p>How to encrypt communication? Through referred to as <strong>HTTP over TLS</strong>, or <strong>HTTP over SSL</strong></p>\n<ul>\n<li>Transport Layer Security</li>\n<li>Secure Sockets Layer</li>\n</ul>\n<a id=\"more\"></a>\n\n<h1 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h1><h2 id=\"Difference\"><a href=\"#Difference\" class=\"headerlink\" title=\"Difference\"></a>Difference</h2><p>HTTPS的URL地址开头是<code>https://</code>，默认使用的的端口是<code>443</code>，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。</p>\n<hr>\n<p>HTTP的URL地址开头是<code>http://</code>，默认使用的端口是<code>80</code>，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。</p>\n<h2 id=\"Limitation\"><a href=\"#Limitation\" class=\"headerlink\" title=\"Limitation\"></a>Limitation</h2><p>SSL/TSL没有禁止网络搜索器（website crawler）搜索它的索引，所以在这种情况下，请求和响应的报文的大小是会被知晓的（内容仍然加密无法破解）。</p>\n<h1 id=\"URI、URL与URN\"><a href=\"#URI、URL与URN\" class=\"headerlink\" title=\"URI、URL与URN\"></a>URI、URL与URN</h1><p>url是uri的子集。</p>\n<h2 id=\"URI\"><a href=\"#URI\" class=\"headerlink\" title=\"URI\"></a>URI</h2><p>统一资源标识符。<em>A string of characters that unambiguously identifies a particular resource</em>.  它规定了一些特定的语法规则，并且在规则下还可以自有扩展，例如<code>http://</code>。</p>\n<h2 id=\"URN\"><a href=\"#URN\" class=\"headerlink\" title=\"URN\"></a>URN</h2><p>统一资源名称。<em>A Uniform Resource Name(URN) is a URI that identifies a resource by name in a particular namespace.</em> 它能标识一个唯一的名称，但不清楚它的位置。</p>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>统一资源定位符。<em>A Uniform Resource Locator(URL) is a URI that specifies the means of acting upon or obtaining the representation of a resource.</em> 就是我们常见的http请求地址。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\">reference</a></p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p><strong>Hypertext Transfer Protocol Secure</strong>, an extension of the Hypertext Transfer Protocol. </p>\n<p>How to encrypt communication? Through referred to as <strong>HTTP over TLS</strong>, or <strong>HTTP over SSL</strong></p>\n<ul>\n<li>Transport Layer Security</li>\n<li>Secure Sockets Layer</li>\n</ul>","more":"<h1 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h1><h2 id=\"Difference\"><a href=\"#Difference\" class=\"headerlink\" title=\"Difference\"></a>Difference</h2><p>HTTPS的URL地址开头是<code>https://</code>，默认使用的的端口是<code>443</code>，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。</p>\n<hr>\n<p>HTTP的URL地址开头是<code>http://</code>，默认使用的端口是<code>80</code>，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。</p>\n<h2 id=\"Limitation\"><a href=\"#Limitation\" class=\"headerlink\" title=\"Limitation\"></a>Limitation</h2><p>SSL/TSL没有禁止网络搜索器（website crawler）搜索它的索引，所以在这种情况下，请求和响应的报文的大小是会被知晓的（内容仍然加密无法破解）。</p>\n<h1 id=\"URI、URL与URN\"><a href=\"#URI、URL与URN\" class=\"headerlink\" title=\"URI、URL与URN\"></a>URI、URL与URN</h1><p>url是uri的子集。</p>\n<h2 id=\"URI\"><a href=\"#URI\" class=\"headerlink\" title=\"URI\"></a>URI</h2><p>统一资源标识符。<em>A string of characters that unambiguously identifies a particular resource</em>.  它规定了一些特定的语法规则，并且在规则下还可以自有扩展，例如<code>http://</code>。</p>\n<h2 id=\"URN\"><a href=\"#URN\" class=\"headerlink\" title=\"URN\"></a>URN</h2><p>统一资源名称。<em>A Uniform Resource Name(URN) is a URI that identifies a resource by name in a particular namespace.</em> 它能标识一个唯一的名称，但不清楚它的位置。</p>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p>统一资源定位符。<em>A Uniform Resource Locator(URL) is a URI that specifies the means of acting upon or obtaining the representation of a resource.</em> 就是我们常见的http请求地址。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\">reference</a></p>"},{"title":"java collection framework","date":"2021-03-06T04:03:11.000Z","_content":"\n之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：**如果是你，你会怎么设计？**\n\n<!-- import -->\n\n<!-- toc -->\n\n# 换身份了\n\n​\t\t作为jdk的设计者，我希望推广我的作品--JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！\n\n# 容器的种类\n\n​\t\t装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。\n\n​\t\t银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他`Collection`吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个`iterator`接口出来，让`collection`继承了`iterator`。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：\n\n```java\npublic abstract Iterator<E> iterator();\n\npublic abstract int size();\n\npublic void clear() {\n    Iterator<E> it = iterator();\n    while (it.hasNext()) {\n        it.next();\n        it.remove();\n    }\n}\n\npublic Object[] toArray() {\n    // Estimate size of array; be prepared to see more or fewer elements\n    Object[] r = new Object[size()];\n    Iterator<E> it = iterator();\n    for (int i = 0; i < r.length; i++) {\n        if (! it.hasNext()) // fewer elements than expected\n            return Arrays.copyOf(r, i);\n        r[i] = it.next();\n    }\n    return it.hasNext() ? finishToArray(r, it) : r;\n}\n\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n```\n\n我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计`collection`接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有`List`、`Set`、`Queue`接口。有了接口，又回到刚才考虑`Collection`接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了`Collection`，所以要避免重复实现，我们的接口也是集成了`Collection`，这个时候我们具体容器的抽象类得集成`Collection`的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。\n\njdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。\n\n# 设计规律\n\n（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。\n\n","source":"_posts/java-collection-framework.md","raw":"---\ntitle: java collection framework\ndate: 2021-03-06 12:03:11\ncategories: jdk\ntags: framework\n---\n\n之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：**如果是你，你会怎么设计？**\n\n<!-- import -->\n\n<!-- toc -->\n\n# 换身份了\n\n​\t\t作为jdk的设计者，我希望推广我的作品--JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！\n\n# 容器的种类\n\n​\t\t装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。\n\n​\t\t银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他`Collection`吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个`iterator`接口出来，让`collection`继承了`iterator`。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：\n\n```java\npublic abstract Iterator<E> iterator();\n\npublic abstract int size();\n\npublic void clear() {\n    Iterator<E> it = iterator();\n    while (it.hasNext()) {\n        it.next();\n        it.remove();\n    }\n}\n\npublic Object[] toArray() {\n    // Estimate size of array; be prepared to see more or fewer elements\n    Object[] r = new Object[size()];\n    Iterator<E> it = iterator();\n    for (int i = 0; i < r.length; i++) {\n        if (! it.hasNext()) // fewer elements than expected\n            return Arrays.copyOf(r, i);\n        r[i] = it.next();\n    }\n    return it.hasNext() ? finishToArray(r, it) : r;\n}\n\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n```\n\n我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计`collection`接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有`List`、`Set`、`Queue`接口。有了接口，又回到刚才考虑`Collection`接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了`Collection`，所以要避免重复实现，我们的接口也是集成了`Collection`，这个时候我们具体容器的抽象类得集成`Collection`的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。\n\njdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。\n\n# 设计规律\n\n（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。\n\n","slug":"java-collection-framework","published":1,"updated":"2021-03-06T14:18:56.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7g0011w5ih3swj1f2a","content":"<p>之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：<strong>如果是你，你会怎么设计？</strong></p>\n<!-- import -->\n\n<!-- toc -->\n\n<h1 id=\"换身份了\"><a href=\"#换身份了\" class=\"headerlink\" title=\"换身份了\"></a>换身份了</h1><p>​        作为jdk的设计者，我希望推广我的作品–JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！</p>\n<h1 id=\"容器的种类\"><a href=\"#容器的种类\" class=\"headerlink\" title=\"容器的种类\"></a>容器的种类</h1><p>​        装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。</p>\n<p>​        银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他<code>Collection</code>吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个<code>iterator</code>接口出来，让<code>collection</code>继承了<code>iterator</code>。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        it.next();</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class=\"line\">    Object[] r = <span class=\"keyword\">new</span> Object[size()];</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! it.hasNext()) <span class=\"comment\">// fewer elements than expected</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(r, i);</span><br><span class=\"line\">        r[i] = it.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计<code>collection</code>接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有<code>List</code>、<code>Set</code>、<code>Queue</code>接口。有了接口，又回到刚才考虑<code>Collection</code>接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了<code>Collection</code>，所以要避免重复实现，我们的接口也是集成了<code>Collection</code>，这个时候我们具体容器的抽象类得集成<code>Collection</code>的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。</p>\n<p>jdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。</p>\n<h1 id=\"设计规律\"><a href=\"#设计规律\" class=\"headerlink\" title=\"设计规律\"></a>设计规律</h1><p>（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<p>之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：<strong>如果是你，你会怎么设计？</strong></p>\n<!-- import -->\n\n<!-- toc -->\n\n<h1 id=\"换身份了\"><a href=\"#换身份了\" class=\"headerlink\" title=\"换身份了\"></a>换身份了</h1><p>​        作为jdk的设计者，我希望推广我的作品–JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！</p>\n<h1 id=\"容器的种类\"><a href=\"#容器的种类\" class=\"headerlink\" title=\"容器的种类\"></a>容器的种类</h1><p>​        装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。</p>\n<p>​        银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他<code>Collection</code>吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个<code>iterator</code>接口出来，让<code>collection</code>继承了<code>iterator</code>。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        it.next();</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class=\"line\">    Object[] r = <span class=\"keyword\">new</span> Object[size()];</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! it.hasNext()) <span class=\"comment\">// fewer elements than expected</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(r, i);</span><br><span class=\"line\">        r[i] = it.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计<code>collection</code>接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有<code>List</code>、<code>Set</code>、<code>Queue</code>接口。有了接口，又回到刚才考虑<code>Collection</code>接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了<code>Collection</code>，所以要避免重复实现，我们的接口也是集成了<code>Collection</code>，这个时候我们具体容器的抽象类得集成<code>Collection</code>的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。</p>\n<p>jdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。</p>\n<h1 id=\"设计规律\"><a href=\"#设计规律\" class=\"headerlink\" title=\"设计规律\"></a>设计规律</h1><p>（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。</p>\n"},{"title":"SpringBoot refresh","date":"2021-02-15T08:19:30.000Z","_content":"\n这篇主要分析SpringBoot在run阶段的*refresh*过程。\n\n<!--more-->\n\n之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：\n\n```java\nsynchronized (this.startupShutdownMonitor) {\n    // Prepare this context for refreshing.\n    prepareRefresh();\n\n    // Tell the subclass to refresh the internal bean factory.\n    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n    // Prepare the bean factory for use in this context.\n    prepareBeanFactory(beanFactory);\n\n    try {\n        // Allows post-processing of the bean factory in context subclasses.\n        postProcessBeanFactory(beanFactory);\n\n        // Invoke factory processors registered as beans in the context.\n        invokeBeanFactoryPostProcessors(beanFactory);\n\n        // Register bean processors that intercept bean creation.\n        registerBeanPostProcessors(beanFactory);\n\n        // Initialize message source for this context.\n        initMessageSource();\n\n        // Initialize event multicaster for this context.\n        initApplicationEventMulticaster();\n\n        // Initialize other special beans in specific context subclasses.\n        onRefresh();\n\n        // Check for listener beans and register them.\n        registerListeners();\n\n        // Instantiate all remaining (non-lazy-init) singletons.\n        finishBeanFactoryInitialization(beanFactory);\n\n        // Last step: publish corresponding event.\n        finishRefresh();\n    }\n```\n\n<!--toc-->\n\n# prepareRefresh\n\n刷新前的准备工作，设置一些开关；初始化property。\n\n\n\n# prepareBeanFactory\n\n准备beanFactory，可以分为以下几个部分：\n\n1. 设置类加载器和bean解析器\n\n2. 添加beanPostProcessor：`ApplicationContextAwarePostProcessor`，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。\n\n   ```java\n   // Configure the bean factory with context callbacks.\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n   ```\n\n3. 手动设置注入的bean，相当与初始化。*registerResolvableDependency*方法是将对应的入参以key-value的形式放入map中。\n\n   ```java\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   // this是上下文容器\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n   ```\n\n\n\n# postProcessBeanFactory\n\n添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。\n\n```java\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    // add之后紧接着ignore，说明加入的processor实现了后者的功能\n    beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n\n    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);\n}\n```\n\n\n\n# invokeBeanFactoryPostProcessors\n\n参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给`PostProcessorRegistrationDelegate`，实现的细节代码较长，这里就不贴了。\n\n​\t\t首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往*BeanDefinitionRegistry*加入postProcessor。\n\n```java\nString[] postProcessorNames =\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) {\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n        // configurationClassPostProcessor，用来解析@Config注解\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    }\n}\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n```\n\n​\t\t随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类`ConfigurationClassParser`，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在*doProcessConfigurationClass*方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的`selector`并再次递归，如此往复。\n\n​\t\t以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration // 启动自动装配\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ...\n}\n```\n\n我们主要查看他自动装配的原理：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class) // 这里的代码会被解析\npublic @interface EnableAutoConfiguration {\n    // ...\n}\n```\n\n在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有`getCandidateConfigurations`，顾名思义，根据*EnableAutoConfiguration.class*这个key从*spring.factories*中获取对应的values：\n\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n# ...\n```\n\n共一百多个，这些会被解析后放入beanFactory中。\n\n\n\n# registerBeanPostProcessors\n\n这个方法内的步骤与上一个一样。委托给`PostProcessorRegistrationDelegate`来做事。\n\n\n\n# InitMessageSource\n\n国际化处理\n\n\n\n# initApplicationEventMulticaster\n\n初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。\n\n\n\n# onRefresh\n\n抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。\n\n\n\n# registerListeners\n\n添加监听器到持有者中。\n\n\n\n# finishBeanFactoryInitialization\n\n这一步是实例化所有的bean了。\n\n\n\n# finishRefresh\n\n最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。\n\n\n\n# 总结\n\nrefresh的内容还是很多的。重点关注这几个方面：\n\n- 实现了与注解的联动\n- 完成了自动化配置\n- 解析bean之间的依赖并实例化","source":"_posts/SpringBoot-refresh.md","raw":"---\ntitle: SpringBoot refresh\ndate: 2021-02-15 16:19:30\ncategories: springboot\ntags: source\n---\n\n这篇主要分析SpringBoot在run阶段的*refresh*过程。\n\n<!--more-->\n\n之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：\n\n```java\nsynchronized (this.startupShutdownMonitor) {\n    // Prepare this context for refreshing.\n    prepareRefresh();\n\n    // Tell the subclass to refresh the internal bean factory.\n    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n    // Prepare the bean factory for use in this context.\n    prepareBeanFactory(beanFactory);\n\n    try {\n        // Allows post-processing of the bean factory in context subclasses.\n        postProcessBeanFactory(beanFactory);\n\n        // Invoke factory processors registered as beans in the context.\n        invokeBeanFactoryPostProcessors(beanFactory);\n\n        // Register bean processors that intercept bean creation.\n        registerBeanPostProcessors(beanFactory);\n\n        // Initialize message source for this context.\n        initMessageSource();\n\n        // Initialize event multicaster for this context.\n        initApplicationEventMulticaster();\n\n        // Initialize other special beans in specific context subclasses.\n        onRefresh();\n\n        // Check for listener beans and register them.\n        registerListeners();\n\n        // Instantiate all remaining (non-lazy-init) singletons.\n        finishBeanFactoryInitialization(beanFactory);\n\n        // Last step: publish corresponding event.\n        finishRefresh();\n    }\n```\n\n<!--toc-->\n\n# prepareRefresh\n\n刷新前的准备工作，设置一些开关；初始化property。\n\n\n\n# prepareBeanFactory\n\n准备beanFactory，可以分为以下几个部分：\n\n1. 设置类加载器和bean解析器\n\n2. 添加beanPostProcessor：`ApplicationContextAwarePostProcessor`，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。\n\n   ```java\n   // Configure the bean factory with context callbacks.\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n   ```\n\n3. 手动设置注入的bean，相当与初始化。*registerResolvableDependency*方法是将对应的入参以key-value的形式放入map中。\n\n   ```java\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   // this是上下文容器\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n   ```\n\n\n\n# postProcessBeanFactory\n\n添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。\n\n```java\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    // add之后紧接着ignore，说明加入的processor实现了后者的功能\n    beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n\n    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);\n}\n```\n\n\n\n# invokeBeanFactoryPostProcessors\n\n参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给`PostProcessorRegistrationDelegate`，实现的细节代码较长，这里就不贴了。\n\n​\t\t首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往*BeanDefinitionRegistry*加入postProcessor。\n\n```java\nString[] postProcessorNames =\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) {\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n        // configurationClassPostProcessor，用来解析@Config注解\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    }\n}\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n```\n\n​\t\t随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类`ConfigurationClassParser`，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在*doProcessConfigurationClass*方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的`selector`并再次递归，如此往复。\n\n​\t\t以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration // 启动自动装配\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ...\n}\n```\n\n我们主要查看他自动装配的原理：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class) // 这里的代码会被解析\npublic @interface EnableAutoConfiguration {\n    // ...\n}\n```\n\n在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有`getCandidateConfigurations`，顾名思义，根据*EnableAutoConfiguration.class*这个key从*spring.factories*中获取对应的values：\n\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n# ...\n```\n\n共一百多个，这些会被解析后放入beanFactory中。\n\n\n\n# registerBeanPostProcessors\n\n这个方法内的步骤与上一个一样。委托给`PostProcessorRegistrationDelegate`来做事。\n\n\n\n# InitMessageSource\n\n国际化处理\n\n\n\n# initApplicationEventMulticaster\n\n初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。\n\n\n\n# onRefresh\n\n抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。\n\n\n\n# registerListeners\n\n添加监听器到持有者中。\n\n\n\n# finishBeanFactoryInitialization\n\n这一步是实例化所有的bean了。\n\n\n\n# finishRefresh\n\n最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。\n\n\n\n# 总结\n\nrefresh的内容还是很多的。重点关注这几个方面：\n\n- 实现了与注解的联动\n- 完成了自动化配置\n- 解析bean之间的依赖并实例化","slug":"SpringBoot-refresh","published":1,"updated":"2021-02-17T07:46:12.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7h0013w5ihhdjgbwme","content":"<p>这篇主要分析SpringBoot在run阶段的<em>refresh</em>过程。</p>\n<a id=\"more\"></a>\n\n<p>之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Prepare this context for refreshing.</span></span><br><span class=\"line\">    prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prepare the bean factory for use in this context.</span></span><br><span class=\"line\">    prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class=\"line\">        postProcessBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Invoke factory processors registered as beans in the context.</span></span><br><span class=\"line\">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Register bean processors that intercept bean creation.</span></span><br><span class=\"line\">        registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize message source for this context.</span></span><br><span class=\"line\">        initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize event multicaster for this context.</span></span><br><span class=\"line\">        initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize other special beans in specific context subclasses.</span></span><br><span class=\"line\">        onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check for listener beans and register them.</span></span><br><span class=\"line\">        registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class=\"line\">        finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Last step: publish corresponding event.</span></span><br><span class=\"line\">        finishRefresh();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<!--toc-->\n\n<h1 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h1><p>刷新前的准备工作，设置一些开关；初始化property。</p>\n<h1 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h1><p>准备beanFactory，可以分为以下几个部分：</p>\n<ol>\n<li><p>设置类加载器和bean解析器</p>\n</li>\n<li><p>添加beanPostProcessor：<code>ApplicationContextAwarePostProcessor</code>，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Configure the bean factory with context callbacks.</span></span><br><span class=\"line\">beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>手动设置注入的bean，相当与初始化。<em>registerResolvableDependency</em>方法是将对应的入参以key-value的形式放入map中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class=\"line\"><span class=\"comment\">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\"><span class=\"comment\">// this是上下文容器</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h1 id=\"postProcessBeanFactory\"><a href=\"#postProcessBeanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory\"></a>postProcessBeanFactory</h1><p>添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// add之后紧接着ignore，说明加入的processor实现了后者的功能</span></span><br><span class=\"line\">    beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ServletContextAwareProcessor(<span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig));</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class=\"keyword\">this</span>.servletContext);</span><br><span class=\"line\">    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h1><p>参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给<code>PostProcessorRegistrationDelegate</code>，实现的细节代码较长，这里就不贴了。</p>\n<p>​        首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往<em>BeanDefinitionRegistry</em>加入postProcessor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] postProcessorNames =</span><br><span class=\"line\">    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// configurationClassPostProcessor，用来解析@Config注解</span></span><br><span class=\"line\">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">        processedBeans.add(ppName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">currentRegistryProcessors.clear();</span><br></pre></td></tr></table></figure>\n\n<p>​        随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类<code>ConfigurationClassParser</code>，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在<em>doProcessConfigurationClass</em>方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的<code>selector</code>并再次递归，如此往复。</p>\n<p>​        以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span> <span class=\"comment\">// 启动自动装配</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要查看他自动装配的原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationImportSelector.class)</span> <span class=\"comment\">// 这里的代码会被解析</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有<code>getCandidateConfigurations</code>，顾名思义，根据<em>EnableAutoConfiguration.class</em>这个key从<em>spring.factories</em>中获取对应的values：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n\n<p>共一百多个，这些会被解析后放入beanFactory中。</p>\n<h1 id=\"registerBeanPostProcessors\"><a href=\"#registerBeanPostProcessors\" class=\"headerlink\" title=\"registerBeanPostProcessors\"></a>registerBeanPostProcessors</h1><p>这个方法内的步骤与上一个一样。委托给<code>PostProcessorRegistrationDelegate</code>来做事。</p>\n<h1 id=\"InitMessageSource\"><a href=\"#InitMessageSource\" class=\"headerlink\" title=\"InitMessageSource\"></a>InitMessageSource</h1><p>国际化处理</p>\n<h1 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster\"></a>initApplicationEventMulticaster</h1><p>初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。</p>\n<h1 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh\"></a>onRefresh</h1><p>抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。</p>\n<h1 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners\"></a>registerListeners</h1><p>添加监听器到持有者中。</p>\n<h1 id=\"finishBeanFactoryInitialization\"><a href=\"#finishBeanFactoryInitialization\" class=\"headerlink\" title=\"finishBeanFactoryInitialization\"></a>finishBeanFactoryInitialization</h1><p>这一步是实例化所有的bean了。</p>\n<h1 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh\"></a>finishRefresh</h1><p>最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>refresh的内容还是很多的。重点关注这几个方面：</p>\n<ul>\n<li>实现了与注解的联动</li>\n<li>完成了自动化配置</li>\n<li>解析bean之间的依赖并实例化</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇主要分析SpringBoot在run阶段的<em>refresh</em>过程。</p>","more":"<p>之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Prepare this context for refreshing.</span></span><br><span class=\"line\">    prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prepare the bean factory for use in this context.</span></span><br><span class=\"line\">    prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class=\"line\">        postProcessBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Invoke factory processors registered as beans in the context.</span></span><br><span class=\"line\">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Register bean processors that intercept bean creation.</span></span><br><span class=\"line\">        registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize message source for this context.</span></span><br><span class=\"line\">        initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize event multicaster for this context.</span></span><br><span class=\"line\">        initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize other special beans in specific context subclasses.</span></span><br><span class=\"line\">        onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check for listener beans and register them.</span></span><br><span class=\"line\">        registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class=\"line\">        finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Last step: publish corresponding event.</span></span><br><span class=\"line\">        finishRefresh();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<!--toc-->\n\n<h1 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h1><p>刷新前的准备工作，设置一些开关；初始化property。</p>\n<h1 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h1><p>准备beanFactory，可以分为以下几个部分：</p>\n<ol>\n<li><p>设置类加载器和bean解析器</p>\n</li>\n<li><p>添加beanPostProcessor：<code>ApplicationContextAwarePostProcessor</code>，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Configure the bean factory with context callbacks.</span></span><br><span class=\"line\">beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>手动设置注入的bean，相当与初始化。<em>registerResolvableDependency</em>方法是将对应的入参以key-value的形式放入map中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class=\"line\"><span class=\"comment\">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\"><span class=\"comment\">// this是上下文容器</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h1 id=\"postProcessBeanFactory\"><a href=\"#postProcessBeanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory\"></a>postProcessBeanFactory</h1><p>添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// add之后紧接着ignore，说明加入的processor实现了后者的功能</span></span><br><span class=\"line\">    beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ServletContextAwareProcessor(<span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig));</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class=\"keyword\">this</span>.servletContext);</span><br><span class=\"line\">    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h1><p>参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给<code>PostProcessorRegistrationDelegate</code>，实现的细节代码较长，这里就不贴了。</p>\n<p>​        首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往<em>BeanDefinitionRegistry</em>加入postProcessor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] postProcessorNames =</span><br><span class=\"line\">    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// configurationClassPostProcessor，用来解析@Config注解</span></span><br><span class=\"line\">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">        processedBeans.add(ppName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">currentRegistryProcessors.clear();</span><br></pre></td></tr></table></figure>\n\n<p>​        随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类<code>ConfigurationClassParser</code>，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在<em>doProcessConfigurationClass</em>方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的<code>selector</code>并再次递归，如此往复。</p>\n<p>​        以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span> <span class=\"comment\">// 启动自动装配</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要查看他自动装配的原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationImportSelector.class)</span> <span class=\"comment\">// 这里的代码会被解析</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有<code>getCandidateConfigurations</code>，顾名思义，根据<em>EnableAutoConfiguration.class</em>这个key从<em>spring.factories</em>中获取对应的values：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n\n<p>共一百多个，这些会被解析后放入beanFactory中。</p>\n<h1 id=\"registerBeanPostProcessors\"><a href=\"#registerBeanPostProcessors\" class=\"headerlink\" title=\"registerBeanPostProcessors\"></a>registerBeanPostProcessors</h1><p>这个方法内的步骤与上一个一样。委托给<code>PostProcessorRegistrationDelegate</code>来做事。</p>\n<h1 id=\"InitMessageSource\"><a href=\"#InitMessageSource\" class=\"headerlink\" title=\"InitMessageSource\"></a>InitMessageSource</h1><p>国际化处理</p>\n<h1 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster\"></a>initApplicationEventMulticaster</h1><p>初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。</p>\n<h1 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh\"></a>onRefresh</h1><p>抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。</p>\n<h1 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners\"></a>registerListeners</h1><p>添加监听器到持有者中。</p>\n<h1 id=\"finishBeanFactoryInitialization\"><a href=\"#finishBeanFactoryInitialization\" class=\"headerlink\" title=\"finishBeanFactoryInitialization\"></a>finishBeanFactoryInitialization</h1><p>这一步是实例化所有的bean了。</p>\n<h1 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh\"></a>finishRefresh</h1><p>最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>refresh的内容还是很多的。重点关注这几个方面：</p>\n<ul>\n<li>实现了与注解的联动</li>\n<li>完成了自动化配置</li>\n<li>解析bean之间的依赖并实例化</li>\n</ul>"},{"title":"SpringBoot environment","date":"2021-02-15T08:19:17.000Z","_content":"\n​\t\tSpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？\n\n<!--more-->\n\n<!--toc-->\n\n前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的\n\n```java\nprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {\n    // 根据应用类型创建对应的环境\n    ConfigurableEnvironment environment = getOrCreateEnvironment();\n    configureEnvironment(environment, applicationArguments.getSourceArgs());\n    ConfigurationPropertySources.attach(environment);\n    listeners.environmentPrepared(environment);\n    bindToSpringApplication(environment);\n    if (!this.isCustomEnvironment) {\n        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());\n    }\n    ConfigurationPropertySources.attach(environment);\n    return environment;\n}\n```\n\n一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。\n\n# 创建环境\n\n首先我们先看创建环境。`getOrCreateEnvironment`会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：*默认*，*Servlet*， *REACTIVE*。这三个环境的都会继承一个接口`ConfigurableEnvironment`，我们看看接口都做了什么\n\n```java\nvoid setActiveProfiles(String... profiles);\n\nvoid addActiveProfile(String profile);\n\nvoid setDefaultProfiles(String... profiles);\n\nMutablePropertySources getPropertySources();\n\nMap<String, Object> getSystemProperties();\n\nMap<String, Object> getSystemEnvironment();\n\nvoid merge(ConfigurableEnvironment parent);\n```\n\n可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。\n\n# 配置环境\n\n配置环境的方法是模板方法，详细分为了`property`和`profile`。前者是添加默认配置和命令行配置，后者是选择激活的profile。\n\n接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理\n\n```java\nprivate static final String ATTACHED_PROPERTY_SOURCE_NAME = \"configurationProperties\";\n```\n\n除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个*CopyOnWriteArrayList*实现的线性表，仅此而已，返型是PropertySource对象。\n\n下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener `ConfigFileApplicationListener`被触发后的执行：\n\n```java\nprivate void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {\n    List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();\n    // 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor\n    postProcessors.add(this);\n    AnnotationAwareOrderComparator.sort(postProcessors);\n    for (EnvironmentPostProcessor postProcessor : postProcessors) {\n        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());\n    }\n}\n```\n\n响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。\n\n```java\nList<EnvironmentPostProcessor> loadPostProcessors() {\n    // 获取环境后置处理器的方式与之前的监听器初始化器相同\n    return SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());\n}\n```\n\n```properties\n# Environment Post Processors\norg.springframework.boot.env.EnvironmentPostProcessor=\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\\norg.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\\norg.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor\n```\n\n由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。\n\n## Load\n\n后置处理也是层层委托\n\n```java\nprotected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {\n    RandomValuePropertySource.addToEnvironment(environment);\n    // 创建loader后调用load方法\n    new Loader(environment, resourceLoader).load();\n}\n```\n\n```java\nprivate static final Set<String> LOAD_FILTERED_PROPERTY;\n\nstatic {\n    Set<String> filteredProperties = new HashSet<>();\n    filteredProperties.add(\"spring.profiles.active\");\n    filteredProperties.add(\"spring.profiles.include\");\n    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);\n}\nvoid load() {\n    // defaultProperties\n    FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,\n                                 (defaultProperties) -> {\n                                     this.profiles = new LinkedList<>();\n                                     this.processedProfiles = new LinkedList<>();\n                                     this.activatedProfiles = false;\n                                     this.loaded = new LinkedHashMap<>();\n                                     initializeProfiles();\n                                     while (!this.profiles.isEmpty()) {\n                                         Profile profile = this.profiles.poll();\n                                         if (isDefaultProfile(profile)) {\n                                             addProfileToEnvironment(profile.getName());\n                                         }\n                                         // 重载load\n                                         load(profile, this::getPositiveProfileFilter,\n                                              addToLoaded(MutablePropertySources::addLast, false));\n                                         this.processedProfiles.add(profile);\n                                     }\n                                     // 重载load\n                                     load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true));\n                                     addLoadedPropertySources();\n                                     applyActiveProfiles(defaultProperties);\n                                 });\n\n```\n\n上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用*propertySourceLoaders*中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：`PropertiesPropertySourceLoader`和`YamlPropertySourceLoader`。\n\n## 自定义\n\n我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了`EnvironmentPostProcessor`的类。可以参考给出的类来写，将配置文件加入列表即可。","source":"_posts/SpringBoot-environment.md","raw":"---\ntitle: SpringBoot environment\ndate: 2021-02-15 16:19:17\ncategories: springboot\ntags: source\n---\n\n​\t\tSpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？\n\n<!--more-->\n\n<!--toc-->\n\n前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的\n\n```java\nprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {\n    // 根据应用类型创建对应的环境\n    ConfigurableEnvironment environment = getOrCreateEnvironment();\n    configureEnvironment(environment, applicationArguments.getSourceArgs());\n    ConfigurationPropertySources.attach(environment);\n    listeners.environmentPrepared(environment);\n    bindToSpringApplication(environment);\n    if (!this.isCustomEnvironment) {\n        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());\n    }\n    ConfigurationPropertySources.attach(environment);\n    return environment;\n}\n```\n\n一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。\n\n# 创建环境\n\n首先我们先看创建环境。`getOrCreateEnvironment`会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：*默认*，*Servlet*， *REACTIVE*。这三个环境的都会继承一个接口`ConfigurableEnvironment`，我们看看接口都做了什么\n\n```java\nvoid setActiveProfiles(String... profiles);\n\nvoid addActiveProfile(String profile);\n\nvoid setDefaultProfiles(String... profiles);\n\nMutablePropertySources getPropertySources();\n\nMap<String, Object> getSystemProperties();\n\nMap<String, Object> getSystemEnvironment();\n\nvoid merge(ConfigurableEnvironment parent);\n```\n\n可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。\n\n# 配置环境\n\n配置环境的方法是模板方法，详细分为了`property`和`profile`。前者是添加默认配置和命令行配置，后者是选择激活的profile。\n\n接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理\n\n```java\nprivate static final String ATTACHED_PROPERTY_SOURCE_NAME = \"configurationProperties\";\n```\n\n除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个*CopyOnWriteArrayList*实现的线性表，仅此而已，返型是PropertySource对象。\n\n下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener `ConfigFileApplicationListener`被触发后的执行：\n\n```java\nprivate void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {\n    List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();\n    // 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor\n    postProcessors.add(this);\n    AnnotationAwareOrderComparator.sort(postProcessors);\n    for (EnvironmentPostProcessor postProcessor : postProcessors) {\n        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());\n    }\n}\n```\n\n响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。\n\n```java\nList<EnvironmentPostProcessor> loadPostProcessors() {\n    // 获取环境后置处理器的方式与之前的监听器初始化器相同\n    return SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());\n}\n```\n\n```properties\n# Environment Post Processors\norg.springframework.boot.env.EnvironmentPostProcessor=\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\\norg.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\\norg.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor\n```\n\n由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。\n\n## Load\n\n后置处理也是层层委托\n\n```java\nprotected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {\n    RandomValuePropertySource.addToEnvironment(environment);\n    // 创建loader后调用load方法\n    new Loader(environment, resourceLoader).load();\n}\n```\n\n```java\nprivate static final Set<String> LOAD_FILTERED_PROPERTY;\n\nstatic {\n    Set<String> filteredProperties = new HashSet<>();\n    filteredProperties.add(\"spring.profiles.active\");\n    filteredProperties.add(\"spring.profiles.include\");\n    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);\n}\nvoid load() {\n    // defaultProperties\n    FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,\n                                 (defaultProperties) -> {\n                                     this.profiles = new LinkedList<>();\n                                     this.processedProfiles = new LinkedList<>();\n                                     this.activatedProfiles = false;\n                                     this.loaded = new LinkedHashMap<>();\n                                     initializeProfiles();\n                                     while (!this.profiles.isEmpty()) {\n                                         Profile profile = this.profiles.poll();\n                                         if (isDefaultProfile(profile)) {\n                                             addProfileToEnvironment(profile.getName());\n                                         }\n                                         // 重载load\n                                         load(profile, this::getPositiveProfileFilter,\n                                              addToLoaded(MutablePropertySources::addLast, false));\n                                         this.processedProfiles.add(profile);\n                                     }\n                                     // 重载load\n                                     load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true));\n                                     addLoadedPropertySources();\n                                     applyActiveProfiles(defaultProperties);\n                                 });\n\n```\n\n上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用*propertySourceLoaders*中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：`PropertiesPropertySourceLoader`和`YamlPropertySourceLoader`。\n\n## 自定义\n\n我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了`EnvironmentPostProcessor`的类。可以参考给出的类来写，将配置文件加入列表即可。","slug":"SpringBoot-environment","published":1,"updated":"2021-02-17T13:12:36.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7j0018w5ihfke5chrb","content":"<p>​        SpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？</p>\n<a id=\"more\"></a>\n\n<!--toc-->\n\n<p>前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">prepareEnvironment</span><span class=\"params\">(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据应用类型创建对应的环境</span></span><br><span class=\"line\">    ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class=\"line\">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    listeners.environmentPrepared(environment);</span><br><span class=\"line\">    bindToSpringApplication(environment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isCustomEnvironment) &#123;</span><br><span class=\"line\">        environment = <span class=\"keyword\">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> environment;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。</p>\n<h1 id=\"创建环境\"><a href=\"#创建环境\" class=\"headerlink\" title=\"创建环境\"></a>创建环境</h1><p>首先我们先看创建环境。<code>getOrCreateEnvironment</code>会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：<em>默认</em>，<em>Servlet</em>， <em>REACTIVE</em>。这三个环境的都会继承一个接口<code>ConfigurableEnvironment</code>，我们看看接口都做了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setActiveProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addActiveProfile</span><span class=\"params\">(String profile)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDefaultProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MutablePropertySources <span class=\"title\">getPropertySources</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemProperties</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ConfigurableEnvironment parent)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。</p>\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h1><p>配置环境的方法是模板方法，详细分为了<code>property</code>和<code>profile</code>。前者是添加默认配置和命令行配置，后者是选择激活的profile。</p>\n<p>接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ATTACHED_PROPERTY_SOURCE_NAME = <span class=\"string\">&quot;configurationProperties&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个<em>CopyOnWriteArrayList</em>实现的线性表，仅此而已，返型是PropertySource对象。</p>\n<p>下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener <code>ConfigFileApplicationListener</code>被触发后的执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEnvironmentPreparedEvent</span><span class=\"params\">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();</span><br><span class=\"line\">    <span class=\"comment\">// 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor</span></span><br><span class=\"line\">    postProcessors.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    AnnotationAwareOrderComparator.sort(postProcessors);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;</span><br><span class=\"line\">        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;EnvironmentPostProcessor&gt; <span class=\"title\">loadPostProcessors</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取环境后置处理器的方式与之前的监听器初始化器相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Environment Post Processors</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span></span><br></pre></td></tr></table></figure>\n\n<p>由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。</p>\n<h2 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h2><p>后置处理也是层层委托</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addPropertySources</span><span class=\"params\">(ConfigurableEnvironment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class=\"line\">    RandomValuePropertySource.addToEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 创建loader后调用load方法</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Loader(environment, resourceLoader).load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;String&gt; LOAD_FILTERED_PROPERTY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; filteredProperties = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.active&quot;</span>);</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.include&quot;</span>);</span><br><span class=\"line\">    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// defaultProperties</span></span><br><span class=\"line\">    FilteredPropertySource.apply(<span class=\"keyword\">this</span>.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,</span><br><span class=\"line\">                                 (defaultProperties) -&gt; &#123;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.profiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.processedProfiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.activatedProfiles = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.loaded = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">                                     initializeProfiles();</span><br><span class=\"line\">                                     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.profiles.isEmpty()) &#123;</span><br><span class=\"line\">                                         Profile profile = <span class=\"keyword\">this</span>.profiles.poll();</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span> (isDefaultProfile(profile)) &#123;</span><br><span class=\"line\">                                             addProfileToEnvironment(profile.getName());</span><br><span class=\"line\">                                         &#125;</span><br><span class=\"line\">                                         <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                         load(profile, <span class=\"keyword\">this</span>::getPositiveProfileFilter,</span><br><span class=\"line\">                                              addToLoaded(MutablePropertySources::addLast, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">                                         <span class=\"keyword\">this</span>.processedProfiles.add(profile);</span><br><span class=\"line\">                                     &#125;</span><br><span class=\"line\">                                     <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                     load(<span class=\"keyword\">null</span>, <span class=\"keyword\">this</span>::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">                                     addLoadedPropertySources();</span><br><span class=\"line\">                                     applyActiveProfiles(defaultProperties);</span><br><span class=\"line\">                                 &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用<em>propertySourceLoaders</em>中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：<code>PropertiesPropertySourceLoader</code>和<code>YamlPropertySourceLoader</code>。</p>\n<h2 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h2><p>我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了<code>EnvironmentPostProcessor</code>的类。可以参考给出的类来写，将配置文件加入列表即可。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>​        SpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？</p>","more":"<!--toc-->\n\n<p>前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">prepareEnvironment</span><span class=\"params\">(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据应用类型创建对应的环境</span></span><br><span class=\"line\">    ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class=\"line\">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    listeners.environmentPrepared(environment);</span><br><span class=\"line\">    bindToSpringApplication(environment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isCustomEnvironment) &#123;</span><br><span class=\"line\">        environment = <span class=\"keyword\">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> environment;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。</p>\n<h1 id=\"创建环境\"><a href=\"#创建环境\" class=\"headerlink\" title=\"创建环境\"></a>创建环境</h1><p>首先我们先看创建环境。<code>getOrCreateEnvironment</code>会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：<em>默认</em>，<em>Servlet</em>， <em>REACTIVE</em>。这三个环境的都会继承一个接口<code>ConfigurableEnvironment</code>，我们看看接口都做了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setActiveProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addActiveProfile</span><span class=\"params\">(String profile)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDefaultProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MutablePropertySources <span class=\"title\">getPropertySources</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemProperties</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ConfigurableEnvironment parent)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。</p>\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h1><p>配置环境的方法是模板方法，详细分为了<code>property</code>和<code>profile</code>。前者是添加默认配置和命令行配置，后者是选择激活的profile。</p>\n<p>接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ATTACHED_PROPERTY_SOURCE_NAME = <span class=\"string\">&quot;configurationProperties&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个<em>CopyOnWriteArrayList</em>实现的线性表，仅此而已，返型是PropertySource对象。</p>\n<p>下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener <code>ConfigFileApplicationListener</code>被触发后的执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEnvironmentPreparedEvent</span><span class=\"params\">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();</span><br><span class=\"line\">    <span class=\"comment\">// 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor</span></span><br><span class=\"line\">    postProcessors.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    AnnotationAwareOrderComparator.sort(postProcessors);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;</span><br><span class=\"line\">        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;EnvironmentPostProcessor&gt; <span class=\"title\">loadPostProcessors</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取环境后置处理器的方式与之前的监听器初始化器相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Environment Post Processors</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span></span><br></pre></td></tr></table></figure>\n\n<p>由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。</p>\n<h2 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h2><p>后置处理也是层层委托</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addPropertySources</span><span class=\"params\">(ConfigurableEnvironment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class=\"line\">    RandomValuePropertySource.addToEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 创建loader后调用load方法</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Loader(environment, resourceLoader).load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;String&gt; LOAD_FILTERED_PROPERTY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; filteredProperties = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.active&quot;</span>);</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.include&quot;</span>);</span><br><span class=\"line\">    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// defaultProperties</span></span><br><span class=\"line\">    FilteredPropertySource.apply(<span class=\"keyword\">this</span>.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,</span><br><span class=\"line\">                                 (defaultProperties) -&gt; &#123;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.profiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.processedProfiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.activatedProfiles = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.loaded = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">                                     initializeProfiles();</span><br><span class=\"line\">                                     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.profiles.isEmpty()) &#123;</span><br><span class=\"line\">                                         Profile profile = <span class=\"keyword\">this</span>.profiles.poll();</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span> (isDefaultProfile(profile)) &#123;</span><br><span class=\"line\">                                             addProfileToEnvironment(profile.getName());</span><br><span class=\"line\">                                         &#125;</span><br><span class=\"line\">                                         <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                         load(profile, <span class=\"keyword\">this</span>::getPositiveProfileFilter,</span><br><span class=\"line\">                                              addToLoaded(MutablePropertySources::addLast, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">                                         <span class=\"keyword\">this</span>.processedProfiles.add(profile);</span><br><span class=\"line\">                                     &#125;</span><br><span class=\"line\">                                     <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                     load(<span class=\"keyword\">null</span>, <span class=\"keyword\">this</span>::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">                                     addLoadedPropertySources();</span><br><span class=\"line\">                                     applyActiveProfiles(defaultProperties);</span><br><span class=\"line\">                                 &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用<em>propertySourceLoaders</em>中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：<code>PropertiesPropertySourceLoader</code>和<code>YamlPropertySourceLoader</code>。</p>\n<h2 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h2><p>我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了<code>EnvironmentPostProcessor</code>的类。可以参考给出的类来写，将配置文件加入列表即可。</p>"},{"title":"jvm","date":"2020-05-24T09:39:25.000Z","_content":"\nassociate with juc\n\n<!--more-->\n\n<!--toc-->\n\n# 系统图\n\n![Screenshot from 2020-06-04 20-11-48.png](https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png)\n\n- 灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收\n- 亮色代表存在垃圾回收\n\n# 类加载器\n\n经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。\n\n> Car.class -> Class Loader -> Car Class -> car1/car2/car3\n\nCar Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。\n\n![Screenshot from 2020-06-04 20-33-54.png](https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png)\n\n## 种类\n\n### 启动类加载器（Bootstrap）\n\n由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。\n\n### 扩展类加载器（Extension）\n\nJava编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。\n\n### 应用程序类加载器（AppClassLoader）\n\n我们编写程序时定义的类所用的加载器\n\n### 用户自定义加载器\n\n定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。\n\n## 双亲委派\n\n比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。\n\n**Bootstrap** --> **Extension** --> **Application**\n\n```java\npublic class String{\n    public static void main(String[] args){\n        System.out.println(\"hello world!\");\n    }\n}\n```\n\n> 在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。\n\n## 沙箱安全机制\n\n**note**: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。\n\n## 本地方法接口（Native Interface）\n\n融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。\n\n异构领域间通信发达，Socket通信或webService。\n\n### Native\n\n只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。\n\n### 本地方法栈\n\n装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。\n\n# PC寄存器\n\n实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。\n\n是当前线程所执行的字节码的行号指示器。\n\n# 栈\n\n- 不存在垃圾回收问题\n- ==线程私有==（想想加锁，不就在方法上/中加的么）\n\n也叫栈内存，**主管Java程序的运行**，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。\n\n## 存储\n\n在java中的方法装载在虚拟机的栈中叫栈帧。\n\n- Local Variables: 输入参数、输出参数以及方法内的变量\n\n  ```java\n  // 入参为 x, y， 输出为result，方法内变量为result，均在栈中。\n  public int add(int x, int y){\n      int result = 0;\n      result = x + y;\n      return result;\n  }\n  ```\n\n- Operand Stack: 记录出栈、入栈的操作\n\n- Frame Data: 包括类文件、方法等等\n\n## 运行\n\n栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。\n\n```java\n// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误\npublic static void m1(){\n    m1();\n}\n```\n\n\n\n每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。\n\n栈管运行，堆管存储。\n\n# 方法区\n\nclass文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是`永久代(PermGen space)`和`元空间(Metaspace)`。\n\n- 所有==线程共享==\n- 存在垃圾回收\n\n存储每个类的**结构信息**（模板）\n\n```java\npublic class Car{\n    int price = 1233435;\n    public park(){\n        System.out.println(\"stop ...\");\n    }\n}\n```\n\n例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。\n\n元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是**本机物理内存**。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。\n\n实例变量存在堆内存中，与方法区无关。i.e.\n\n```java\npublic class Demo{\n    public void hello(){}\n    public static void main(String[] args){\n        Demo demo = new Demo();\n        demo.hello();\n    }\n}\n```\n\n每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。\n\n# 方法区、栈、堆\n\n```java\nPerson person1 = new Person();\nPerson person2 = new Person();\n```\n\n左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。\n\n要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。\n\nhotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈-->堆-->方法区\n\n# 堆\n\n（Java7之前）\t一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。\n\n(Java8)\t永久区换成了元空间。\n\n物理上为新生区+养老区。\n\n## 堆内存\n\n逻辑上分为三部分：新生+养老+永久\n\n新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)\n\n养老区：Tenure Generation Space\n\n永久存储区：Permanent Space\n\n- Eden: 0space: 1space  = 8 : 1 : 1\n- Young : Old = 1 : 2\n\n## 静态\n\n实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。\n\n## 动态\n\nSurvivor 0 space: from区\n\nSurrivor 1 space: to区\n\n他们的位置不固定，每次GC之后位置会交换，空的为to区。\n\n1. Eden, SurvivorFrom copy to SurviviorTo\n2. clean up Eden, SurvivorFrom\n3. Swap SurvivorTo and SurvivorFrom\n\n## 永久代\n\n是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。\n\n## 调优\n\n```java\npublic static void main(String[] args){\n    // Returns the maximum amount of memory that the Java virtual machine will attempt to use.\n    long l = Runtime.getRuntime().maxMemory();\n\n    // Returns the total amount of memory in the Java virtual machine.\n    long l1 = Runtime.getRuntime().totalMemory();\n\n    // 1/4\n    System.out.println(\"(-xmx) MAX_MEMORY: \" + l + \"bytes, \" + (l / (double) 1024 / 1024 + \"MB\"));\n    \n    // 1/64\n    System.out.println(\"(-xms) TOTAL_MEMORY: \" + l1 + \"bytes, \" + (l1 / (double) 1024 / 1024 + \"MB\"));\n}\n```\n\n**note:** 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。\n\n> -XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）\n\n# GC\n\n- minor GC\n- major/full GC\n\nmajor GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。\n\n## 垃圾回收算法\n\n分代收集，根据各个代来使用\n\n### 引用计数法\n\n每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。\n\n### 复制算法（Copying）\n\nMinor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。\n\n因为存活率都很低，复制也没啥。\n\n### 标记清除法（Mark-Sweep）\n\nMajor GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。\n\n### 标记压缩（Mark-Compact）\n\nMark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。\n\n也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。\n\n# JMM\n\nJava的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（**包括实例字段、静态字段以及构成数组对象的元素**）的访问方式。\n\n在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，`工作内存`是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作\n\n内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。\n\n## violatile\n\njava虚拟机提供的轻量级的同步机制，乞丐版syncronized。\n\n- 保证可见性\n- 不保证原子性\n- 禁止指令重排\n\n\n\n# 总结\n\n这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于*native*以及便以后的*class*，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。\n\n\n\n","source":"_posts/jvm.md","raw":"---\ntitle: jvm\ndate: 2020-05-24 17:39:25\ncategories: JVM\ntags: summary\n---\n\nassociate with juc\n\n<!--more-->\n\n<!--toc-->\n\n# 系统图\n\n![Screenshot from 2020-06-04 20-11-48.png](https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png)\n\n- 灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收\n- 亮色代表存在垃圾回收\n\n# 类加载器\n\n经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。\n\n> Car.class -> Class Loader -> Car Class -> car1/car2/car3\n\nCar Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。\n\n![Screenshot from 2020-06-04 20-33-54.png](https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png)\n\n## 种类\n\n### 启动类加载器（Bootstrap）\n\n由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。\n\n### 扩展类加载器（Extension）\n\nJava编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。\n\n### 应用程序类加载器（AppClassLoader）\n\n我们编写程序时定义的类所用的加载器\n\n### 用户自定义加载器\n\n定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。\n\n## 双亲委派\n\n比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。\n\n**Bootstrap** --> **Extension** --> **Application**\n\n```java\npublic class String{\n    public static void main(String[] args){\n        System.out.println(\"hello world!\");\n    }\n}\n```\n\n> 在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。\n\n## 沙箱安全机制\n\n**note**: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。\n\n## 本地方法接口（Native Interface）\n\n融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。\n\n异构领域间通信发达，Socket通信或webService。\n\n### Native\n\n只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。\n\n### 本地方法栈\n\n装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。\n\n# PC寄存器\n\n实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。\n\n是当前线程所执行的字节码的行号指示器。\n\n# 栈\n\n- 不存在垃圾回收问题\n- ==线程私有==（想想加锁，不就在方法上/中加的么）\n\n也叫栈内存，**主管Java程序的运行**，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。\n\n## 存储\n\n在java中的方法装载在虚拟机的栈中叫栈帧。\n\n- Local Variables: 输入参数、输出参数以及方法内的变量\n\n  ```java\n  // 入参为 x, y， 输出为result，方法内变量为result，均在栈中。\n  public int add(int x, int y){\n      int result = 0;\n      result = x + y;\n      return result;\n  }\n  ```\n\n- Operand Stack: 记录出栈、入栈的操作\n\n- Frame Data: 包括类文件、方法等等\n\n## 运行\n\n栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。\n\n```java\n// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误\npublic static void m1(){\n    m1();\n}\n```\n\n\n\n每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。\n\n栈管运行，堆管存储。\n\n# 方法区\n\nclass文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是`永久代(PermGen space)`和`元空间(Metaspace)`。\n\n- 所有==线程共享==\n- 存在垃圾回收\n\n存储每个类的**结构信息**（模板）\n\n```java\npublic class Car{\n    int price = 1233435;\n    public park(){\n        System.out.println(\"stop ...\");\n    }\n}\n```\n\n例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。\n\n元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是**本机物理内存**。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。\n\n实例变量存在堆内存中，与方法区无关。i.e.\n\n```java\npublic class Demo{\n    public void hello(){}\n    public static void main(String[] args){\n        Demo demo = new Demo();\n        demo.hello();\n    }\n}\n```\n\n每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。\n\n# 方法区、栈、堆\n\n```java\nPerson person1 = new Person();\nPerson person2 = new Person();\n```\n\n左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。\n\n要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。\n\nhotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈-->堆-->方法区\n\n# 堆\n\n（Java7之前）\t一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。\n\n(Java8)\t永久区换成了元空间。\n\n物理上为新生区+养老区。\n\n## 堆内存\n\n逻辑上分为三部分：新生+养老+永久\n\n新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)\n\n养老区：Tenure Generation Space\n\n永久存储区：Permanent Space\n\n- Eden: 0space: 1space  = 8 : 1 : 1\n- Young : Old = 1 : 2\n\n## 静态\n\n实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。\n\n## 动态\n\nSurvivor 0 space: from区\n\nSurrivor 1 space: to区\n\n他们的位置不固定，每次GC之后位置会交换，空的为to区。\n\n1. Eden, SurvivorFrom copy to SurviviorTo\n2. clean up Eden, SurvivorFrom\n3. Swap SurvivorTo and SurvivorFrom\n\n## 永久代\n\n是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。\n\n## 调优\n\n```java\npublic static void main(String[] args){\n    // Returns the maximum amount of memory that the Java virtual machine will attempt to use.\n    long l = Runtime.getRuntime().maxMemory();\n\n    // Returns the total amount of memory in the Java virtual machine.\n    long l1 = Runtime.getRuntime().totalMemory();\n\n    // 1/4\n    System.out.println(\"(-xmx) MAX_MEMORY: \" + l + \"bytes, \" + (l / (double) 1024 / 1024 + \"MB\"));\n    \n    // 1/64\n    System.out.println(\"(-xms) TOTAL_MEMORY: \" + l1 + \"bytes, \" + (l1 / (double) 1024 / 1024 + \"MB\"));\n}\n```\n\n**note:** 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。\n\n> -XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）\n\n# GC\n\n- minor GC\n- major/full GC\n\nmajor GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。\n\n## 垃圾回收算法\n\n分代收集，根据各个代来使用\n\n### 引用计数法\n\n每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。\n\n### 复制算法（Copying）\n\nMinor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。\n\n因为存活率都很低，复制也没啥。\n\n### 标记清除法（Mark-Sweep）\n\nMajor GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。\n\n### 标记压缩（Mark-Compact）\n\nMark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。\n\n也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。\n\n# JMM\n\nJava的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（**包括实例字段、静态字段以及构成数组对象的元素**）的访问方式。\n\n在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，`工作内存`是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作\n\n内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。\n\n## violatile\n\njava虚拟机提供的轻量级的同步机制，乞丐版syncronized。\n\n- 保证可见性\n- 不保证原子性\n- 禁止指令重排\n\n\n\n# 总结\n\n这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于*native*以及便以后的*class*，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。\n\n\n\n","slug":"jvm","published":1,"updated":"2021-03-23T15:40:34.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7k001aw5ih69a14lt6","content":"<p>associate with juc</p>\n<a id=\"more\"></a>\n\n<!--toc-->\n\n<h1 id=\"系统图\"><a href=\"#系统图\" class=\"headerlink\" title=\"系统图\"></a>系统图</h1><p><img src=\"https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png\" alt=\"Screenshot from 2020-06-04 20-11-48.png\"></p>\n<ul>\n<li>灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收</li>\n<li>亮色代表存在垃圾回收</li>\n</ul>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。</p>\n<blockquote>\n<p>Car.class -&gt; Class Loader -&gt; Car Class -&gt; car1/car2/car3</p>\n</blockquote>\n<p>Car Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。</p>\n<p><img src=\"https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png\" alt=\"Screenshot from 2020-06-04 20-33-54.png\"></p>\n<h2 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h2><h3 id=\"启动类加载器（Bootstrap）\"><a href=\"#启动类加载器（Bootstrap）\" class=\"headerlink\" title=\"启动类加载器（Bootstrap）\"></a>启动类加载器（Bootstrap）</h3><p>由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。</p>\n<h3 id=\"扩展类加载器（Extension）\"><a href=\"#扩展类加载器（Extension）\" class=\"headerlink\" title=\"扩展类加载器（Extension）\"></a>扩展类加载器（Extension）</h3><p>Java编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。</p>\n<h3 id=\"应用程序类加载器（AppClassLoader）\"><a href=\"#应用程序类加载器（AppClassLoader）\" class=\"headerlink\" title=\"应用程序类加载器（AppClassLoader）\"></a>应用程序类加载器（AppClassLoader）</h3><p>我们编写程序时定义的类所用的加载器</p>\n<h3 id=\"用户自定义加载器\"><a href=\"#用户自定义加载器\" class=\"headerlink\" title=\"用户自定义加载器\"></a>用户自定义加载器</h3><p>定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。</p>\n<h2 id=\"双亲委派\"><a href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"></a>双亲委派</h2><p>比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。</p>\n<p><strong>Bootstrap</strong> –&gt; <strong>Extension</strong> –&gt; <strong>Application</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。</p>\n</blockquote>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p><strong>note</strong>: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。</p>\n<h2 id=\"本地方法接口（Native-Interface）\"><a href=\"#本地方法接口（Native-Interface）\" class=\"headerlink\" title=\"本地方法接口（Native Interface）\"></a>本地方法接口（Native Interface）</h2><p>融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。</p>\n<p>异构领域间通信发达，Socket通信或webService。</p>\n<h3 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h3><p>只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。</p>\n<h1 id=\"PC寄存器\"><a href=\"#PC寄存器\" class=\"headerlink\" title=\"PC寄存器\"></a>PC寄存器</h1><p>实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。</p>\n<p>是当前线程所执行的字节码的行号指示器。</p>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><ul>\n<li>不存在垃圾回收问题</li>\n<li>==线程私有==（想想加锁，不就在方法上/中加的么）</li>\n</ul>\n<p>也叫栈内存，<strong>主管Java程序的运行</strong>，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><p>在java中的方法装载在虚拟机的栈中叫栈帧。</p>\n<ul>\n<li><p>Local Variables: 输入参数、输出参数以及方法内的变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入参为 x, y， 输出为result，方法内变量为result，均在栈中。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    result = x + y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Operand Stack: 记录出栈、入栈的操作</p>\n</li>\n<li><p>Frame Data: 包括类文件、方法等等</p>\n</li>\n</ul>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">m1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    m1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。</p>\n<p>栈管运行，堆管存储。</p>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><p>class文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是<code>永久代(PermGen space)</code>和<code>元空间(Metaspace)</code>。</p>\n<ul>\n<li>所有==线程共享==</li>\n<li>存在垃圾回收</li>\n</ul>\n<p>存储每个类的<strong>结构信息</strong>（模板）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> price = <span class=\"number\">1233435</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">park</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;stop ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。</p>\n<p>元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是<strong>本机物理内存</strong>。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p>\n<p>实例变量存在堆内存中，与方法区无关。i.e.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。</p>\n<h1 id=\"方法区、栈、堆\"><a href=\"#方法区、栈、堆\" class=\"headerlink\" title=\"方法区、栈、堆\"></a>方法区、栈、堆</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person person2 = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p>左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。</p>\n<p>要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。</p>\n<p>hotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈–&gt;堆–&gt;方法区</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>（Java7之前）    一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p>\n<p>(Java8)    永久区换成了元空间。</p>\n<p>物理上为新生区+养老区。</p>\n<h2 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h2><p>逻辑上分为三部分：新生+养老+永久</p>\n<p>新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)</p>\n<p>养老区：Tenure Generation Space</p>\n<p>永久存储区：Permanent Space</p>\n<ul>\n<li>Eden: 0space: 1space  = 8 : 1 : 1</li>\n<li>Young : Old = 1 : 2</li>\n</ul>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。</p>\n<h2 id=\"动态\"><a href=\"#动态\" class=\"headerlink\" title=\"动态\"></a>动态</h2><p>Survivor 0 space: from区</p>\n<p>Surrivor 1 space: to区</p>\n<p>他们的位置不固定，每次GC之后位置会交换，空的为to区。</p>\n<ol>\n<li>Eden, SurvivorFrom copy to SurviviorTo</li>\n<li>clean up Eden, SurvivorFrom</li>\n<li>Swap SurvivorTo and SurvivorFrom</li>\n</ol>\n<h2 id=\"永久代\"><a href=\"#永久代\" class=\"headerlink\" title=\"永久代\"></a>永久代</h2><p>是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。</p>\n<h2 id=\"调优\"><a href=\"#调优\" class=\"headerlink\" title=\"调优\"></a>调优</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Returns the maximum amount of memory that the Java virtual machine will attempt to use.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l = Runtime.getRuntime().maxMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns the total amount of memory in the Java virtual machine.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l1 = Runtime.getRuntime().totalMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1/4</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xmx) MAX_MEMORY: &quot;</span> + l + <span class=\"string\">&quot;bytes, &quot;</span> + (l / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1/64</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xms) TOTAL_MEMORY: &quot;</span> + l1 + <span class=\"string\">&quot;bytes, &quot;</span> + (l1 / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。</p>\n<blockquote>\n<p>-XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）</p>\n</blockquote>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><ul>\n<li>minor GC</li>\n<li>major/full GC</li>\n</ul>\n<p>major GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。</p>\n<h2 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h2><p>分代收集，根据各个代来使用</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。</p>\n<h3 id=\"复制算法（Copying）\"><a href=\"#复制算法（Copying）\" class=\"headerlink\" title=\"复制算法（Copying）\"></a>复制算法（Copying）</h3><p>Minor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。</p>\n<p>因为存活率都很低，复制也没啥。</p>\n<h3 id=\"标记清除法（Mark-Sweep）\"><a href=\"#标记清除法（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除法（Mark-Sweep）\"></a>标记清除法（Mark-Sweep）</h3><p>Major GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。</p>\n<h3 id=\"标记压缩（Mark-Compact）\"><a href=\"#标记压缩（Mark-Compact）\" class=\"headerlink\" title=\"标记压缩（Mark-Compact）\"></a>标记压缩（Mark-Compact）</h3><p>Mark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。</p>\n<p>也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。</p>\n<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>Java的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（<strong>包括实例字段、静态字段以及构成数组对象的元素</strong>）的访问方式。</p>\n<p>在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，<code>工作内存</code>是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作</p>\n<p>内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p>\n<h2 id=\"violatile\"><a href=\"#violatile\" class=\"headerlink\" title=\"violatile\"></a>violatile</h2><p>java虚拟机提供的轻量级的同步机制，乞丐版syncronized。</p>\n<ul>\n<li>保证可见性</li>\n<li>不保证原子性</li>\n<li>禁止指令重排</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于<em>native</em>以及便以后的<em>class</em>，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>associate with juc</p>","more":"<!--toc-->\n\n<h1 id=\"系统图\"><a href=\"#系统图\" class=\"headerlink\" title=\"系统图\"></a>系统图</h1><p><img src=\"https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png\" alt=\"Screenshot from 2020-06-04 20-11-48.png\"></p>\n<ul>\n<li>灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收</li>\n<li>亮色代表存在垃圾回收</li>\n</ul>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。</p>\n<blockquote>\n<p>Car.class -&gt; Class Loader -&gt; Car Class -&gt; car1/car2/car3</p>\n</blockquote>\n<p>Car Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。</p>\n<p><img src=\"https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png\" alt=\"Screenshot from 2020-06-04 20-33-54.png\"></p>\n<h2 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h2><h3 id=\"启动类加载器（Bootstrap）\"><a href=\"#启动类加载器（Bootstrap）\" class=\"headerlink\" title=\"启动类加载器（Bootstrap）\"></a>启动类加载器（Bootstrap）</h3><p>由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。</p>\n<h3 id=\"扩展类加载器（Extension）\"><a href=\"#扩展类加载器（Extension）\" class=\"headerlink\" title=\"扩展类加载器（Extension）\"></a>扩展类加载器（Extension）</h3><p>Java编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。</p>\n<h3 id=\"应用程序类加载器（AppClassLoader）\"><a href=\"#应用程序类加载器（AppClassLoader）\" class=\"headerlink\" title=\"应用程序类加载器（AppClassLoader）\"></a>应用程序类加载器（AppClassLoader）</h3><p>我们编写程序时定义的类所用的加载器</p>\n<h3 id=\"用户自定义加载器\"><a href=\"#用户自定义加载器\" class=\"headerlink\" title=\"用户自定义加载器\"></a>用户自定义加载器</h3><p>定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。</p>\n<h2 id=\"双亲委派\"><a href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"></a>双亲委派</h2><p>比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。</p>\n<p><strong>Bootstrap</strong> –&gt; <strong>Extension</strong> –&gt; <strong>Application</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。</p>\n</blockquote>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p><strong>note</strong>: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。</p>\n<h2 id=\"本地方法接口（Native-Interface）\"><a href=\"#本地方法接口（Native-Interface）\" class=\"headerlink\" title=\"本地方法接口（Native Interface）\"></a>本地方法接口（Native Interface）</h2><p>融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。</p>\n<p>异构领域间通信发达，Socket通信或webService。</p>\n<h3 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h3><p>只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。</p>\n<h1 id=\"PC寄存器\"><a href=\"#PC寄存器\" class=\"headerlink\" title=\"PC寄存器\"></a>PC寄存器</h1><p>实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。</p>\n<p>是当前线程所执行的字节码的行号指示器。</p>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><ul>\n<li>不存在垃圾回收问题</li>\n<li>==线程私有==（想想加锁，不就在方法上/中加的么）</li>\n</ul>\n<p>也叫栈内存，<strong>主管Java程序的运行</strong>，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><p>在java中的方法装载在虚拟机的栈中叫栈帧。</p>\n<ul>\n<li><p>Local Variables: 输入参数、输出参数以及方法内的变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入参为 x, y， 输出为result，方法内变量为result，均在栈中。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    result = x + y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Operand Stack: 记录出栈、入栈的操作</p>\n</li>\n<li><p>Frame Data: 包括类文件、方法等等</p>\n</li>\n</ul>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">m1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    m1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。</p>\n<p>栈管运行，堆管存储。</p>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><p>class文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是<code>永久代(PermGen space)</code>和<code>元空间(Metaspace)</code>。</p>\n<ul>\n<li>所有==线程共享==</li>\n<li>存在垃圾回收</li>\n</ul>\n<p>存储每个类的<strong>结构信息</strong>（模板）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> price = <span class=\"number\">1233435</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">park</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;stop ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。</p>\n<p>元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是<strong>本机物理内存</strong>。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p>\n<p>实例变量存在堆内存中，与方法区无关。i.e.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。</p>\n<h1 id=\"方法区、栈、堆\"><a href=\"#方法区、栈、堆\" class=\"headerlink\" title=\"方法区、栈、堆\"></a>方法区、栈、堆</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person person2 = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p>左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。</p>\n<p>要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。</p>\n<p>hotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈–&gt;堆–&gt;方法区</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>（Java7之前）    一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p>\n<p>(Java8)    永久区换成了元空间。</p>\n<p>物理上为新生区+养老区。</p>\n<h2 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h2><p>逻辑上分为三部分：新生+养老+永久</p>\n<p>新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)</p>\n<p>养老区：Tenure Generation Space</p>\n<p>永久存储区：Permanent Space</p>\n<ul>\n<li>Eden: 0space: 1space  = 8 : 1 : 1</li>\n<li>Young : Old = 1 : 2</li>\n</ul>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。</p>\n<h2 id=\"动态\"><a href=\"#动态\" class=\"headerlink\" title=\"动态\"></a>动态</h2><p>Survivor 0 space: from区</p>\n<p>Surrivor 1 space: to区</p>\n<p>他们的位置不固定，每次GC之后位置会交换，空的为to区。</p>\n<ol>\n<li>Eden, SurvivorFrom copy to SurviviorTo</li>\n<li>clean up Eden, SurvivorFrom</li>\n<li>Swap SurvivorTo and SurvivorFrom</li>\n</ol>\n<h2 id=\"永久代\"><a href=\"#永久代\" class=\"headerlink\" title=\"永久代\"></a>永久代</h2><p>是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。</p>\n<h2 id=\"调优\"><a href=\"#调优\" class=\"headerlink\" title=\"调优\"></a>调优</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Returns the maximum amount of memory that the Java virtual machine will attempt to use.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l = Runtime.getRuntime().maxMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns the total amount of memory in the Java virtual machine.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l1 = Runtime.getRuntime().totalMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1/4</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xmx) MAX_MEMORY: &quot;</span> + l + <span class=\"string\">&quot;bytes, &quot;</span> + (l / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1/64</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xms) TOTAL_MEMORY: &quot;</span> + l1 + <span class=\"string\">&quot;bytes, &quot;</span> + (l1 / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。</p>\n<blockquote>\n<p>-XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）</p>\n</blockquote>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><ul>\n<li>minor GC</li>\n<li>major/full GC</li>\n</ul>\n<p>major GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。</p>\n<h2 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h2><p>分代收集，根据各个代来使用</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。</p>\n<h3 id=\"复制算法（Copying）\"><a href=\"#复制算法（Copying）\" class=\"headerlink\" title=\"复制算法（Copying）\"></a>复制算法（Copying）</h3><p>Minor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。</p>\n<p>因为存活率都很低，复制也没啥。</p>\n<h3 id=\"标记清除法（Mark-Sweep）\"><a href=\"#标记清除法（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除法（Mark-Sweep）\"></a>标记清除法（Mark-Sweep）</h3><p>Major GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。</p>\n<h3 id=\"标记压缩（Mark-Compact）\"><a href=\"#标记压缩（Mark-Compact）\" class=\"headerlink\" title=\"标记压缩（Mark-Compact）\"></a>标记压缩（Mark-Compact）</h3><p>Mark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。</p>\n<p>也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。</p>\n<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>Java的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（<strong>包括实例字段、静态字段以及构成数组对象的元素</strong>）的访问方式。</p>\n<p>在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，<code>工作内存</code>是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作</p>\n<p>内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p>\n<h2 id=\"violatile\"><a href=\"#violatile\" class=\"headerlink\" title=\"violatile\"></a>violatile</h2><p>java虚拟机提供的轻量级的同步机制，乞丐版syncronized。</p>\n<ul>\n<li>保证可见性</li>\n<li>不保证原子性</li>\n<li>禁止指令重排</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于<em>native</em>以及便以后的<em>class</em>，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。</p>"},{"title":"kafka","date":"2019-12-03T14:34:16.000Z","_content":"\n卡夫卡，消息中间件，注意同类型的异同。\n\n<!-- mroe -->\n\n# 序\n`分布式`的基于`发布、订阅`的`消息队列`（Message Queue)，主要应用于大数据实时处理领域。\n\n## 消息队列\n一个场景，用户注册某网站时填写个人信息，需要短信验证码，这时页面响应，有两种模式：\n1. 同步：用户填写信息，提交（信息入库），触发短信发送接口，发送短信，页面反馈给用户\n2. 异步：用户填写信息，提交（信息入库），页面反馈给用户，同时触发接口，发送短信\n\n消息队列的主要特点：解耦、削峰\n\n### 消息队列的两种模式\n\n1. 点对点模式: 消费者主动拉取数据，消息收到后信息清除。消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息，消息被消费后Queue中不再有存储。。。。。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。\n    消息不能复用，比如A生产消息，B消费消息，此时如果C也想消费A的消息，那么只能让A再开一个队列让C接受。`只是消息队列，不是消息的存储系统`（一对一）\n\n2. 发布订阅模式：消费者消费数据后不会清除消息。相当于消息生产者将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。发布到topic的消息会被所有订阅者消费。（一对多）\n   \n    1. 队列主动推送\n    2. 消费者主动拉取\n    \n    - 不想要的消息？？\n    - 推送速度如何确定？\n    \n    而卡夫卡属于消费者拉取。所以卡夫卡内有个`长轮询`来不断地问topic内有没有消息。\n\n## 基础架构\n\n生产者、消费者、kafka集群。(集群就是消息暂停的地方)\n\n1. 集群中，分布式，多台服务器。服务器中的broker就是卡夫卡的进程。broker中还有组件：主题。主题将消息分类。partition提高卡夫卡的负载能力和并发度。有leader和follower，后者做数据冗余，提升安全性，且前后者不会出现在同一台服务器。生产者只会寻找leader。主题：分区+主副本。\n2. 消费者，有消费者组，将多个消费者用一个组名。`一个分区只能被一个消费者组内的某一个消费者消费`。消费者组可以提高消费能力。并发度最好的时候就是消费者个数与分支数相等。\n3. zookeeper，集群要正常工作就要依赖zookeeper，要想多台装有卡夫卡的机器组成集群，只要他们所用的zookeeper是同一套集群就ok了。除了帮卡夫卡存贮信息外还存储消费到何处的位置信息。（0.9版本之前存才zk，之后存在kafka（存在磁盘，默认7天）。目的都一样：记住消费到的位置）\n\n## 安装部署\n\n","source":"_posts/kafka.md","raw":"---\ntitle: kafka\ndate: 2019-12-03 22:34:16\ncategories: MiddleWare\ntags: kafka\n---\n\n卡夫卡，消息中间件，注意同类型的异同。\n\n<!-- mroe -->\n\n# 序\n`分布式`的基于`发布、订阅`的`消息队列`（Message Queue)，主要应用于大数据实时处理领域。\n\n## 消息队列\n一个场景，用户注册某网站时填写个人信息，需要短信验证码，这时页面响应，有两种模式：\n1. 同步：用户填写信息，提交（信息入库），触发短信发送接口，发送短信，页面反馈给用户\n2. 异步：用户填写信息，提交（信息入库），页面反馈给用户，同时触发接口，发送短信\n\n消息队列的主要特点：解耦、削峰\n\n### 消息队列的两种模式\n\n1. 点对点模式: 消费者主动拉取数据，消息收到后信息清除。消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息，消息被消费后Queue中不再有存储。。。。。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。\n    消息不能复用，比如A生产消息，B消费消息，此时如果C也想消费A的消息，那么只能让A再开一个队列让C接受。`只是消息队列，不是消息的存储系统`（一对一）\n\n2. 发布订阅模式：消费者消费数据后不会清除消息。相当于消息生产者将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。发布到topic的消息会被所有订阅者消费。（一对多）\n   \n    1. 队列主动推送\n    2. 消费者主动拉取\n    \n    - 不想要的消息？？\n    - 推送速度如何确定？\n    \n    而卡夫卡属于消费者拉取。所以卡夫卡内有个`长轮询`来不断地问topic内有没有消息。\n\n## 基础架构\n\n生产者、消费者、kafka集群。(集群就是消息暂停的地方)\n\n1. 集群中，分布式，多台服务器。服务器中的broker就是卡夫卡的进程。broker中还有组件：主题。主题将消息分类。partition提高卡夫卡的负载能力和并发度。有leader和follower，后者做数据冗余，提升安全性，且前后者不会出现在同一台服务器。生产者只会寻找leader。主题：分区+主副本。\n2. 消费者，有消费者组，将多个消费者用一个组名。`一个分区只能被一个消费者组内的某一个消费者消费`。消费者组可以提高消费能力。并发度最好的时候就是消费者个数与分支数相等。\n3. zookeeper，集群要正常工作就要依赖zookeeper，要想多台装有卡夫卡的机器组成集群，只要他们所用的zookeeper是同一套集群就ok了。除了帮卡夫卡存贮信息外还存储消费到何处的位置信息。（0.9版本之前存才zk，之后存在kafka（存在磁盘，默认7天）。目的都一样：记住消费到的位置）\n\n## 安装部署\n\n","slug":"kafka","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7m001fw5ih3bqj38se","content":"<p>卡夫卡，消息中间件，注意同类型的异同。</p>\n<!-- mroe -->\n\n<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p><code>分布式</code>的基于<code>发布、订阅</code>的<code>消息队列</code>（Message Queue)，主要应用于大数据实时处理领域。</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>一个场景，用户注册某网站时填写个人信息，需要短信验证码，这时页面响应，有两种模式：</p>\n<ol>\n<li>同步：用户填写信息，提交（信息入库），触发短信发送接口，发送短信，页面反馈给用户</li>\n<li>异步：用户填写信息，提交（信息入库），页面反馈给用户，同时触发接口，发送短信</li>\n</ol>\n<p>消息队列的主要特点：解耦、削峰</p>\n<h3 id=\"消息队列的两种模式\"><a href=\"#消息队列的两种模式\" class=\"headerlink\" title=\"消息队列的两种模式\"></a>消息队列的两种模式</h3><ol>\n<li><p>点对点模式: 消费者主动拉取数据，消息收到后信息清除。消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息，消息被消费后Queue中不再有存储。。。。。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。<br> 消息不能复用，比如A生产消息，B消费消息，此时如果C也想消费A的消息，那么只能让A再开一个队列让C接受。<code>只是消息队列，不是消息的存储系统</code>（一对一）</p>\n</li>\n<li><p>发布订阅模式：消费者消费数据后不会清除消息。相当于消息生产者将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。发布到topic的消息会被所有订阅者消费。（一对多）</p>\n<ol>\n<li>队列主动推送</li>\n<li>消费者主动拉取</li>\n</ol>\n<ul>\n<li><p>不想要的消息？？</p>\n</li>\n<li><p>推送速度如何确定？</p>\n<p>而卡夫卡属于消费者拉取。所以卡夫卡内有个<code>长轮询</code>来不断地问topic内有没有消息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基础架构\"><a href=\"#基础架构\" class=\"headerlink\" title=\"基础架构\"></a>基础架构</h2><p>生产者、消费者、kafka集群。(集群就是消息暂停的地方)</p>\n<ol>\n<li>集群中，分布式，多台服务器。服务器中的broker就是卡夫卡的进程。broker中还有组件：主题。主题将消息分类。partition提高卡夫卡的负载能力和并发度。有leader和follower，后者做数据冗余，提升安全性，且前后者不会出现在同一台服务器。生产者只会寻找leader。主题：分区+主副本。</li>\n<li>消费者，有消费者组，将多个消费者用一个组名。<code>一个分区只能被一个消费者组内的某一个消费者消费</code>。消费者组可以提高消费能力。并发度最好的时候就是消费者个数与分支数相等。</li>\n<li>zookeeper，集群要正常工作就要依赖zookeeper，要想多台装有卡夫卡的机器组成集群，只要他们所用的zookeeper是同一套集群就ok了。除了帮卡夫卡存贮信息外还存储消费到何处的位置信息。（0.9版本之前存才zk，之后存在kafka（存在磁盘，默认7天）。目的都一样：记住消费到的位置）</li>\n</ol>\n<h2 id=\"安装部署\"><a href=\"#安装部署\" class=\"headerlink\" title=\"安装部署\"></a>安装部署</h2>","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<p>卡夫卡，消息中间件，注意同类型的异同。</p>\n<!-- mroe -->\n\n<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p><code>分布式</code>的基于<code>发布、订阅</code>的<code>消息队列</code>（Message Queue)，主要应用于大数据实时处理领域。</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>一个场景，用户注册某网站时填写个人信息，需要短信验证码，这时页面响应，有两种模式：</p>\n<ol>\n<li>同步：用户填写信息，提交（信息入库），触发短信发送接口，发送短信，页面反馈给用户</li>\n<li>异步：用户填写信息，提交（信息入库），页面反馈给用户，同时触发接口，发送短信</li>\n</ol>\n<p>消息队列的主要特点：解耦、削峰</p>\n<h3 id=\"消息队列的两种模式\"><a href=\"#消息队列的两种模式\" class=\"headerlink\" title=\"消息队列的两种模式\"></a>消息队列的两种模式</h3><ol>\n<li><p>点对点模式: 消费者主动拉取数据，消息收到后信息清除。消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息，消息被消费后Queue中不再有存储。。。。。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。<br> 消息不能复用，比如A生产消息，B消费消息，此时如果C也想消费A的消息，那么只能让A再开一个队列让C接受。<code>只是消息队列，不是消息的存储系统</code>（一对一）</p>\n</li>\n<li><p>发布订阅模式：消费者消费数据后不会清除消息。相当于消息生产者将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。发布到topic的消息会被所有订阅者消费。（一对多）</p>\n<ol>\n<li>队列主动推送</li>\n<li>消费者主动拉取</li>\n</ol>\n<ul>\n<li><p>不想要的消息？？</p>\n</li>\n<li><p>推送速度如何确定？</p>\n<p>而卡夫卡属于消费者拉取。所以卡夫卡内有个<code>长轮询</code>来不断地问topic内有没有消息。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基础架构\"><a href=\"#基础架构\" class=\"headerlink\" title=\"基础架构\"></a>基础架构</h2><p>生产者、消费者、kafka集群。(集群就是消息暂停的地方)</p>\n<ol>\n<li>集群中，分布式，多台服务器。服务器中的broker就是卡夫卡的进程。broker中还有组件：主题。主题将消息分类。partition提高卡夫卡的负载能力和并发度。有leader和follower，后者做数据冗余，提升安全性，且前后者不会出现在同一台服务器。生产者只会寻找leader。主题：分区+主副本。</li>\n<li>消费者，有消费者组，将多个消费者用一个组名。<code>一个分区只能被一个消费者组内的某一个消费者消费</code>。消费者组可以提高消费能力。并发度最好的时候就是消费者个数与分支数相等。</li>\n<li>zookeeper，集群要正常工作就要依赖zookeeper，要想多台装有卡夫卡的机器组成集群，只要他们所用的zookeeper是同一套集群就ok了。除了帮卡夫卡存贮信息外还存储消费到何处的位置信息。（0.9版本之前存才zk，之后存在kafka（存在磁盘，默认7天）。目的都一样：记住消费到的位置）</li>\n</ol>\n<h2 id=\"安装部署\"><a href=\"#安装部署\" class=\"headerlink\" title=\"安装部署\"></a>安装部署</h2>"},{"title":"lock","date":"2020-07-20T13:46:41.000Z","_content":"\n锁跟多线程紧密相关，有复杂与简单之分。\n\n<!--more-->\n\n# 分类\n\n![image.png](https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png)\n\n# 乐观锁|悲观锁\n\n所谓乐观锁、悲观锁可以类比地看作**JVM里的方法区**，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？\n\n- 悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，`synchronized`关键字和`Lock的实现类`都是悲观锁。\n- 乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过**无锁编程**实现的乐观锁，最常用的就是`CAS算法`，Java原子类中的递增操作就是通过**CAS自旋实现**的。\n\n根据他们的概念，可以发现**悲观锁适合写操作多的场景**，**乐观锁适合读操作多的场景**，这样利于性能的优化提升。\n\n```java\n// synchronized\npublic synchronized void testMehthod(){\n    // do something...\n}\n\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock();\npublic void modifyPublicResources()){\n    try{\n        lock.lock();\n        // do something...\n    }finally{\n        lock.unlock();\n    }\n}\n\n// 乐观锁\nprivate AtomicInteger ai = new AtomicInteger();\natomicInteger.incrementAndGet(); // 执行自增1\n```\n\n\n\n# Compare And Swap\n\nCAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的**原子类**就是通过这种算法实现了乐观锁。算法涉及到三个操作数：\n\n- 需要读写的内存值V （已存在的值）\n- 进行比较的值A\n- 要写入的新值B\n\n当`V=A`时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n## AtomicInteger\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    // 获取并操作内存的数据\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    // 存储value在AtomicInteger中的偏移量\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\t// 存储AtomicInteger的int值\n    private volatile int value;\n```\n\n```java\npublic final int getAndIncrement() {\n    return unsafe.getAndAddInt(this, valueOffset, 1);\n}\n```\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n```\n\n```java\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n\n一目了然了吧，最终的`compareAndSwapInt`是`native`，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：\n\n- 看到`do-while`了吧，循环时间长会造成较大的CPU开销。\n\n**note:** ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A\"\n\n# 自旋锁|适应性自旋锁\n\n涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference [here](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)\n\n# 公平锁|非公平锁\n\n简而言之，公平锁是好好排队的，非公平锁是插队来的。\n\n在类`ReentrantLock`中，有一个内部类`Sync`，他是继承`AbstractQueuedSnchronizer`的，对锁的添加、释放等操作大部分都是在`Sync`实现的，他又有`FairSync`和`NonfairSync`两个子类。`ReentrantLock`默认使用非公平锁。\n\n# 独享锁|共享锁\n\n别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的`synchronized`和并发包中的`Lock`。\n\n共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。\n\n独享锁和共享锁也是通过AQS来实现的。具体参考类`ReentrantReadWriteLock`。类中有`ReadLock`和`WriteLock`两把锁，","source":"_posts/lock.md","raw":"---\ntitle: lock\ndate: 2020-07-20 21:46:41\ncategories: Java\ntags: lock\n---\n\n锁跟多线程紧密相关，有复杂与简单之分。\n\n<!--more-->\n\n# 分类\n\n![image.png](https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png)\n\n# 乐观锁|悲观锁\n\n所谓乐观锁、悲观锁可以类比地看作**JVM里的方法区**，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？\n\n- 悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，`synchronized`关键字和`Lock的实现类`都是悲观锁。\n- 乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过**无锁编程**实现的乐观锁，最常用的就是`CAS算法`，Java原子类中的递增操作就是通过**CAS自旋实现**的。\n\n根据他们的概念，可以发现**悲观锁适合写操作多的场景**，**乐观锁适合读操作多的场景**，这样利于性能的优化提升。\n\n```java\n// synchronized\npublic synchronized void testMehthod(){\n    // do something...\n}\n\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock();\npublic void modifyPublicResources()){\n    try{\n        lock.lock();\n        // do something...\n    }finally{\n        lock.unlock();\n    }\n}\n\n// 乐观锁\nprivate AtomicInteger ai = new AtomicInteger();\natomicInteger.incrementAndGet(); // 执行自增1\n```\n\n\n\n# Compare And Swap\n\nCAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的**原子类**就是通过这种算法实现了乐观锁。算法涉及到三个操作数：\n\n- 需要读写的内存值V （已存在的值）\n- 进行比较的值A\n- 要写入的新值B\n\n当`V=A`时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n## AtomicInteger\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    // 获取并操作内存的数据\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    // 存储value在AtomicInteger中的偏移量\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\t// 存储AtomicInteger的int值\n    private volatile int value;\n```\n\n```java\npublic final int getAndIncrement() {\n    return unsafe.getAndAddInt(this, valueOffset, 1);\n}\n```\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n```\n\n```java\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n\n一目了然了吧，最终的`compareAndSwapInt`是`native`，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：\n\n- 看到`do-while`了吧，循环时间长会造成较大的CPU开销。\n\n**note:** ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A\"\n\n# 自旋锁|适应性自旋锁\n\n涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference [here](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)\n\n# 公平锁|非公平锁\n\n简而言之，公平锁是好好排队的，非公平锁是插队来的。\n\n在类`ReentrantLock`中，有一个内部类`Sync`，他是继承`AbstractQueuedSnchronizer`的，对锁的添加、释放等操作大部分都是在`Sync`实现的，他又有`FairSync`和`NonfairSync`两个子类。`ReentrantLock`默认使用非公平锁。\n\n# 独享锁|共享锁\n\n别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的`synchronized`和并发包中的`Lock`。\n\n共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。\n\n独享锁和共享锁也是通过AQS来实现的。具体参考类`ReentrantReadWriteLock`。类中有`ReadLock`和`WriteLock`两把锁，","slug":"lock","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7n001hw5ih9xrv26ea","content":"<p>锁跟多线程紧密相关，有复杂与简单之分。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><p><img src=\"https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png\" alt=\"image.png\"></p>\n<h1 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁|悲观锁\"></a>乐观锁|悲观锁</h1><p>所谓乐观锁、悲观锁可以类比地看作<strong>JVM里的方法区</strong>，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？</p>\n<ul>\n<li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，<code>synchronized</code>关键字和<code>Lock的实现类</code>都是悲观锁。</li>\n<li>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过<strong>无锁编程</strong>实现的乐观锁，最常用的就是<code>CAS算法</code>，Java原子类中的递增操作就是通过<strong>CAS自旋实现</strong>的。</li>\n</ul>\n<p>根据他们的概念，可以发现<strong>悲观锁适合写操作多的场景</strong>，<strong>乐观锁适合读操作多的场景</strong>，这样利于性能的优化提升。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">testMehthod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReentrantLock</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">modifyPublicResources</span><span class=\"params\">()</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 乐观锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> AtomicInteger ai = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">atomicInteger.incrementAndGet(); <span class=\"comment\">// 执行自增1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Compare-And-Swap\"><a href=\"#Compare-And-Swap\" class=\"headerlink\" title=\"Compare And Swap\"></a>Compare And Swap</h1><p>CAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的<strong>原子类</strong>就是通过这种算法实现了乐观锁。算法涉及到三个操作数：</p>\n<ul>\n<li>需要读写的内存值V （已存在的值）</li>\n<li>进行比较的值A</li>\n<li>要写入的新值B</li>\n</ul>\n<p>当<code>V=A</code>时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<h2 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取并操作内存的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"comment\">// 存储value在AtomicInteger中的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 存储AtomicInteger的int值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>一目了然了吧，最终的<code>compareAndSwapInt</code>是<code>native</code>，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：</p>\n<ul>\n<li>看到<code>do-while</code>了吧，循环时间长会造成较大的CPU开销。</li>\n</ul>\n<p><strong>note:</strong> ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A”</p>\n<h1 id=\"自旋锁-适应性自旋锁\"><a href=\"#自旋锁-适应性自旋锁\" class=\"headerlink\" title=\"自旋锁|适应性自旋锁\"></a>自旋锁|适应性自旋锁</h1><p>涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference <a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect\">here</a></p>\n<h1 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁|非公平锁\"></a>公平锁|非公平锁</h1><p>简而言之，公平锁是好好排队的，非公平锁是插队来的。</p>\n<p>在类<code>ReentrantLock</code>中，有一个内部类<code>Sync</code>，他是继承<code>AbstractQueuedSnchronizer</code>的，对锁的添加、释放等操作大部分都是在<code>Sync</code>实现的，他又有<code>FairSync</code>和<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁。</p>\n<h1 id=\"独享锁-共享锁\"><a href=\"#独享锁-共享锁\" class=\"headerlink\" title=\"独享锁|共享锁\"></a>独享锁|共享锁</h1><p>别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的<code>synchronized</code>和并发包中的<code>Lock</code>。</p>\n<p>共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。</p>\n<p>独享锁和共享锁也是通过AQS来实现的。具体参考类<code>ReentrantReadWriteLock</code>。类中有<code>ReadLock</code>和<code>WriteLock</code>两把锁，</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>锁跟多线程紧密相关，有复杂与简单之分。</p>","more":"<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><p><img src=\"https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png\" alt=\"image.png\"></p>\n<h1 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁|悲观锁\"></a>乐观锁|悲观锁</h1><p>所谓乐观锁、悲观锁可以类比地看作<strong>JVM里的方法区</strong>，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？</p>\n<ul>\n<li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，<code>synchronized</code>关键字和<code>Lock的实现类</code>都是悲观锁。</li>\n<li>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过<strong>无锁编程</strong>实现的乐观锁，最常用的就是<code>CAS算法</code>，Java原子类中的递增操作就是通过<strong>CAS自旋实现</strong>的。</li>\n</ul>\n<p>根据他们的概念，可以发现<strong>悲观锁适合写操作多的场景</strong>，<strong>乐观锁适合读操作多的场景</strong>，这样利于性能的优化提升。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">testMehthod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReentrantLock</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">modifyPublicResources</span><span class=\"params\">()</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 乐观锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> AtomicInteger ai = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">atomicInteger.incrementAndGet(); <span class=\"comment\">// 执行自增1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Compare-And-Swap\"><a href=\"#Compare-And-Swap\" class=\"headerlink\" title=\"Compare And Swap\"></a>Compare And Swap</h1><p>CAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的<strong>原子类</strong>就是通过这种算法实现了乐观锁。算法涉及到三个操作数：</p>\n<ul>\n<li>需要读写的内存值V （已存在的值）</li>\n<li>进行比较的值A</li>\n<li>要写入的新值B</li>\n</ul>\n<p>当<code>V=A</code>时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<h2 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取并操作内存的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"comment\">// 存储value在AtomicInteger中的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 存储AtomicInteger的int值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>一目了然了吧，最终的<code>compareAndSwapInt</code>是<code>native</code>，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：</p>\n<ul>\n<li>看到<code>do-while</code>了吧，循环时间长会造成较大的CPU开销。</li>\n</ul>\n<p><strong>note:</strong> ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A”</p>\n<h1 id=\"自旋锁-适应性自旋锁\"><a href=\"#自旋锁-适应性自旋锁\" class=\"headerlink\" title=\"自旋锁|适应性自旋锁\"></a>自旋锁|适应性自旋锁</h1><p>涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference <a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect\">here</a></p>\n<h1 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁|非公平锁\"></a>公平锁|非公平锁</h1><p>简而言之，公平锁是好好排队的，非公平锁是插队来的。</p>\n<p>在类<code>ReentrantLock</code>中，有一个内部类<code>Sync</code>，他是继承<code>AbstractQueuedSnchronizer</code>的，对锁的添加、释放等操作大部分都是在<code>Sync</code>实现的，他又有<code>FairSync</code>和<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁。</p>\n<h1 id=\"独享锁-共享锁\"><a href=\"#独享锁-共享锁\" class=\"headerlink\" title=\"独享锁|共享锁\"></a>独享锁|共享锁</h1><p>别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的<code>synchronized</code>和并发包中的<code>Lock</code>。</p>\n<p>共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。</p>\n<p>独享锁和共享锁也是通过AQS来实现的。具体参考类<code>ReentrantReadWriteLock</code>。类中有<code>ReadLock</code>和<code>WriteLock</code>两把锁，</p>"},{"title":"mybatis autoconfiguration","date":"2021-03-09T12:48:57.000Z","_content":"\n这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 来源\n\n如果还记得之前的分析就会知道，SpringBoot会从`META-INF`目录下找`spring.factories`文件，并从中找`EnableAutoConfiguration`对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n```\n\n一共就两个类，第一个是语言相关的，会检测是否有*thymeleaf*、*framemarker*等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个`MybatisAutoConfiguration`配置类。\n\n# 自动装配\n\n通过这个类我们要弄清楚他自动装配了啥。\n\n```java\n@Configuration\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class}) // 路径下存在这两个类的class时生效\n@ConditionalOnSingleCandidate(DataSource.class) // 单个数据源生效\n@EnableConfigurationProperties({MybatisProperties.class}) // 启用mybatis配置文件的属性\n@AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class}) // 这两个类后自动配置\npublic class MybatisAutoConfiguration implements InitializingBean {\n    // ...\n}\n```\n\n## sqlSessionFactory\n\n```java\n@Bean\n@ConditionalOnMissingBean // 缺少这个bean时创建他\npublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n    // ...\n}\n```\n\nsqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的`MapperProperties`，会根据用户配置的信息来修改facotry的相关属性。\n\n## sqlSessionTemplate\n\n```java\n@Bean\n@ConditionalOnMissingBean // 同sqlSessionFactory\npublic SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n    ExecutorType executorType = this.properties.getExecutorType();\n    return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n}\n```\n\n这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定`executorType`来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中`executorType`这个属性，他通常有三个选择：\n\n- SIMPLE：为每个语句的执行创建一个预处理语句，基操\n- REUSE：复用预处理语句\n- BATCH：批量执行所有更新语句\n\n## MapperScannerRegistrarNotFoundConfiguration\n\n```java\n@Configuration\n@Import({MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class}) // 导入\n@ConditionalOnMissingBean({MapperFactoryBean.class, MapperScannerConfigurer.class}) // 缺少这两个类时生效\npublic static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {\n    public MapperScannerRegistrarNotFoundConfiguration() {\n    }\n\n    public void afterPropertiesSet() {\n        MybatisAutoConfiguration.logger.debug(\"Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.\");\n    }\n}\n```\n\n这个类导入了一个内部类，并且会在`MapperFactoryBean`和`MapperScannerConfigure.class`缺少时生效，这个大家就很熟悉了，**通常没有写*@MapperScan*时的异常就是在这里产生的**：\n\n```java\npublic class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {\n    private Class<T> mapperInterface;\n    private boolean addToConfig = true;\n\n    public MapperFactoryBean() {\n    }\n\n    public MapperFactoryBean(Class<T> mapperInterface) {\n        this.mapperInterface = mapperInterface;\n    }\n\n    protected void checkDaoConfig() {\n        super.checkDaoConfig();\n        Assert.notNull(this.mapperInterface, \"Property 'mapperInterface' is required\");\n        Configuration configuration = this.getSqlSession().getConfiguration();\n        // 如果开启了“添加配置”并且接口没有被添加过的话\n        if (this.addToConfig && !configuration.hasMapper(this.mapperInterface)) {\n            try {\n                // 往mybatis的配置类中添加接口\n                configuration.addMapper(this.mapperInterface);\n            } catch (Exception var6) {\n                this.logger.error(\"Error while adding the mapper '\" + this.mapperInterface + \"' to configuration.\", var6);\n                throw new IllegalArgumentException(var6);\n            } finally {\n                ErrorContext.instance().reset();\n            }\n        }\n\n    }\n    // ...\n}\n\n```\n\n总结一下，这个自动配置类主要做了以下工作：\n\n1. 启用配置文件\n2. 缺少sqlSessionFactory时创建该bean，依赖数据源dataSource\n3. 缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory\n4. 没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper\n\n以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有`mapperRegister`的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。","source":"_posts/mybatis-autoconfiguration.md","raw":"---\ntitle: mybatis autoconfiguration\ndate: 2021-03-09 20:48:57\ncategories: framework\ntags: mybatis\n---\n\n这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 来源\n\n如果还记得之前的分析就会知道，SpringBoot会从`META-INF`目录下找`spring.factories`文件，并从中找`EnableAutoConfiguration`对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n```\n\n一共就两个类，第一个是语言相关的，会检测是否有*thymeleaf*、*framemarker*等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个`MybatisAutoConfiguration`配置类。\n\n# 自动装配\n\n通过这个类我们要弄清楚他自动装配了啥。\n\n```java\n@Configuration\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class}) // 路径下存在这两个类的class时生效\n@ConditionalOnSingleCandidate(DataSource.class) // 单个数据源生效\n@EnableConfigurationProperties({MybatisProperties.class}) // 启用mybatis配置文件的属性\n@AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class}) // 这两个类后自动配置\npublic class MybatisAutoConfiguration implements InitializingBean {\n    // ...\n}\n```\n\n## sqlSessionFactory\n\n```java\n@Bean\n@ConditionalOnMissingBean // 缺少这个bean时创建他\npublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n    // ...\n}\n```\n\nsqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的`MapperProperties`，会根据用户配置的信息来修改facotry的相关属性。\n\n## sqlSessionTemplate\n\n```java\n@Bean\n@ConditionalOnMissingBean // 同sqlSessionFactory\npublic SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n    ExecutorType executorType = this.properties.getExecutorType();\n    return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n}\n```\n\n这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定`executorType`来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中`executorType`这个属性，他通常有三个选择：\n\n- SIMPLE：为每个语句的执行创建一个预处理语句，基操\n- REUSE：复用预处理语句\n- BATCH：批量执行所有更新语句\n\n## MapperScannerRegistrarNotFoundConfiguration\n\n```java\n@Configuration\n@Import({MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class}) // 导入\n@ConditionalOnMissingBean({MapperFactoryBean.class, MapperScannerConfigurer.class}) // 缺少这两个类时生效\npublic static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {\n    public MapperScannerRegistrarNotFoundConfiguration() {\n    }\n\n    public void afterPropertiesSet() {\n        MybatisAutoConfiguration.logger.debug(\"Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.\");\n    }\n}\n```\n\n这个类导入了一个内部类，并且会在`MapperFactoryBean`和`MapperScannerConfigure.class`缺少时生效，这个大家就很熟悉了，**通常没有写*@MapperScan*时的异常就是在这里产生的**：\n\n```java\npublic class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {\n    private Class<T> mapperInterface;\n    private boolean addToConfig = true;\n\n    public MapperFactoryBean() {\n    }\n\n    public MapperFactoryBean(Class<T> mapperInterface) {\n        this.mapperInterface = mapperInterface;\n    }\n\n    protected void checkDaoConfig() {\n        super.checkDaoConfig();\n        Assert.notNull(this.mapperInterface, \"Property 'mapperInterface' is required\");\n        Configuration configuration = this.getSqlSession().getConfiguration();\n        // 如果开启了“添加配置”并且接口没有被添加过的话\n        if (this.addToConfig && !configuration.hasMapper(this.mapperInterface)) {\n            try {\n                // 往mybatis的配置类中添加接口\n                configuration.addMapper(this.mapperInterface);\n            } catch (Exception var6) {\n                this.logger.error(\"Error while adding the mapper '\" + this.mapperInterface + \"' to configuration.\", var6);\n                throw new IllegalArgumentException(var6);\n            } finally {\n                ErrorContext.instance().reset();\n            }\n        }\n\n    }\n    // ...\n}\n\n```\n\n总结一下，这个自动配置类主要做了以下工作：\n\n1. 启用配置文件\n2. 缺少sqlSessionFactory时创建该bean，依赖数据源dataSource\n3. 缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory\n4. 没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper\n\n以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有`mapperRegister`的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。","slug":"mybatis-autoconfiguration","published":1,"updated":"2021-03-22T14:15:53.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7p001lw5ih0n9t6rvg","content":"<p>这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。</p>\n<a id=\"more\"></a>\n\n<!-- toc -->\n\n<h1 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h1><p>如果还记得之前的分析就会知道，SpringBoot会从<code>META-INF</code>目录下找<code>spring.factories</code>文件，并从中找<code>EnableAutoConfiguration</code>对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Auto Configure</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"attr\">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span></span><br></pre></td></tr></table></figure>\n\n<p>一共就两个类，第一个是语言相关的，会检测是否有<em>thymeleaf</em>、<em>framemarker</em>等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个<code>MybatisAutoConfiguration</code>配置类。</p>\n<h1 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h1><p>通过这个类我们要弄清楚他自动装配了啥。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span> <span class=\"comment\">// 路径下存在这两个类的class时生效</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnSingleCandidate(DataSource.class)</span> <span class=\"comment\">// 单个数据源生效</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span> <span class=\"comment\">// 启用mybatis配置文件的属性</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span> <span class=\"comment\">// 这两个类后自动配置</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisAutoConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"sqlSessionFactory\"><a href=\"#sqlSessionFactory\" class=\"headerlink\" title=\"sqlSessionFactory\"></a>sqlSessionFactory</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 缺少这个bean时创建他</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">(DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的<code>MapperProperties</code>，会根据用户配置的信息来修改facotry的相关属性。</p>\n<h2 id=\"sqlSessionTemplate\"><a href=\"#sqlSessionTemplate\" class=\"headerlink\" title=\"sqlSessionTemplate\"></a>sqlSessionTemplate</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 同sqlSessionFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">sqlSessionTemplate</span><span class=\"params\">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorType executorType = <span class=\"keyword\">this</span>.properties.getExecutorType();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorType != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory, executorType) : <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定<code>executorType</code>来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中<code>executorType</code>这个属性，他通常有三个选择：</p>\n<ul>\n<li>SIMPLE：为每个语句的执行创建一个预处理语句，基操</li>\n<li>REUSE：复用预处理语句</li>\n<li>BATCH：批量执行所有更新语句</li>\n</ul>\n<h2 id=\"MapperScannerRegistrarNotFoundConfiguration\"><a href=\"#MapperScannerRegistrarNotFoundConfiguration\" class=\"headerlink\" title=\"MapperScannerRegistrarNotFoundConfiguration\"></a>MapperScannerRegistrarNotFoundConfiguration</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span> <span class=\"comment\">// 导入</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span> <span class=\"comment\">// 缺少这两个类时生效</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MybatisAutoConfiguration.logger.debug(<span class=\"string\">&quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类导入了一个内部类，并且会在<code>MapperFactoryBean</code>和<code>MapperScannerConfigure.class</code>缺少时生效，这个大家就很熟悉了，<strong>通常没有写*@MapperScan*时的异常就是在这里产生的</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperFactoryBean</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">SqlSessionDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> addToConfig = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mapperInterface = mapperInterface;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">checkDaoConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.checkDaoConfig();</span><br><span class=\"line\">        Assert.notNull(<span class=\"keyword\">this</span>.mapperInterface, <span class=\"string\">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class=\"line\">        Configuration configuration = <span class=\"keyword\">this</span>.getSqlSession().getConfiguration();</span><br><span class=\"line\">        <span class=\"comment\">// 如果开启了“添加配置”并且接口没有被添加过的话</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class=\"keyword\">this</span>.mapperInterface)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 往mybatis的配置类中添加接口</span></span><br><span class=\"line\">                configuration.addMapper(<span class=\"keyword\">this</span>.mapperInterface);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var6) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.logger.error(<span class=\"string\">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class=\"keyword\">this</span>.mapperInterface + <span class=\"string\">&quot;&#x27; to configuration.&quot;</span>, var6);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(var6);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                ErrorContext.instance().reset();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结一下，这个自动配置类主要做了以下工作：</p>\n<ol>\n<li>启用配置文件</li>\n<li>缺少sqlSessionFactory时创建该bean，依赖数据源dataSource</li>\n<li>缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory</li>\n<li>没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper</li>\n</ol>\n<p>以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有<code>mapperRegister</code>的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。</p>","more":"<!-- toc -->\n\n<h1 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h1><p>如果还记得之前的分析就会知道，SpringBoot会从<code>META-INF</code>目录下找<code>spring.factories</code>文件，并从中找<code>EnableAutoConfiguration</code>对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Auto Configure</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"attr\">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span></span><br></pre></td></tr></table></figure>\n\n<p>一共就两个类，第一个是语言相关的，会检测是否有<em>thymeleaf</em>、<em>framemarker</em>等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个<code>MybatisAutoConfiguration</code>配置类。</p>\n<h1 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h1><p>通过这个类我们要弄清楚他自动装配了啥。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span> <span class=\"comment\">// 路径下存在这两个类的class时生效</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnSingleCandidate(DataSource.class)</span> <span class=\"comment\">// 单个数据源生效</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span> <span class=\"comment\">// 启用mybatis配置文件的属性</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span> <span class=\"comment\">// 这两个类后自动配置</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisAutoConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"sqlSessionFactory\"><a href=\"#sqlSessionFactory\" class=\"headerlink\" title=\"sqlSessionFactory\"></a>sqlSessionFactory</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 缺少这个bean时创建他</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">(DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的<code>MapperProperties</code>，会根据用户配置的信息来修改facotry的相关属性。</p>\n<h2 id=\"sqlSessionTemplate\"><a href=\"#sqlSessionTemplate\" class=\"headerlink\" title=\"sqlSessionTemplate\"></a>sqlSessionTemplate</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 同sqlSessionFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">sqlSessionTemplate</span><span class=\"params\">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorType executorType = <span class=\"keyword\">this</span>.properties.getExecutorType();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorType != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory, executorType) : <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定<code>executorType</code>来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中<code>executorType</code>这个属性，他通常有三个选择：</p>\n<ul>\n<li>SIMPLE：为每个语句的执行创建一个预处理语句，基操</li>\n<li>REUSE：复用预处理语句</li>\n<li>BATCH：批量执行所有更新语句</li>\n</ul>\n<h2 id=\"MapperScannerRegistrarNotFoundConfiguration\"><a href=\"#MapperScannerRegistrarNotFoundConfiguration\" class=\"headerlink\" title=\"MapperScannerRegistrarNotFoundConfiguration\"></a>MapperScannerRegistrarNotFoundConfiguration</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span> <span class=\"comment\">// 导入</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span> <span class=\"comment\">// 缺少这两个类时生效</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MybatisAutoConfiguration.logger.debug(<span class=\"string\">&quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类导入了一个内部类，并且会在<code>MapperFactoryBean</code>和<code>MapperScannerConfigure.class</code>缺少时生效，这个大家就很熟悉了，<strong>通常没有写*@MapperScan*时的异常就是在这里产生的</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperFactoryBean</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">SqlSessionDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> addToConfig = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mapperInterface = mapperInterface;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">checkDaoConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.checkDaoConfig();</span><br><span class=\"line\">        Assert.notNull(<span class=\"keyword\">this</span>.mapperInterface, <span class=\"string\">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class=\"line\">        Configuration configuration = <span class=\"keyword\">this</span>.getSqlSession().getConfiguration();</span><br><span class=\"line\">        <span class=\"comment\">// 如果开启了“添加配置”并且接口没有被添加过的话</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class=\"keyword\">this</span>.mapperInterface)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 往mybatis的配置类中添加接口</span></span><br><span class=\"line\">                configuration.addMapper(<span class=\"keyword\">this</span>.mapperInterface);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var6) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.logger.error(<span class=\"string\">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class=\"keyword\">this</span>.mapperInterface + <span class=\"string\">&quot;&#x27; to configuration.&quot;</span>, var6);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(var6);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                ErrorContext.instance().reset();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结一下，这个自动配置类主要做了以下工作：</p>\n<ol>\n<li>启用配置文件</li>\n<li>缺少sqlSessionFactory时创建该bean，依赖数据源dataSource</li>\n<li>缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory</li>\n<li>没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper</li>\n</ol>\n<p>以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有<code>mapperRegister</code>的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。</p>"},{"title":"mybatis sql resolution","date":"2021-03-07T11:03:54.000Z","_content":"\n承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。\n\n<!-- more -->\n\n<!-- toc -->\n\n```java\npublic class Test {\n\n    // 模拟的pojo\n    static class User {\n        int age;\n        int name;\n    }\n\n    public static void main(String[] args) {\n        // 核心就在这\n        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class<?>[]{UserMapper.class}, new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                // 获取到注解\n                Select annotation = method.getAnnotation(Select.class);\n                // 构建入参的映射\n                Map<String, Object> map = buildMethodArgNameMap(method, args);\n\n                System.out.println(map.toString());\n                if (annotation != null) {\n                    String[] value = annotation.value();\n                    String s = parseSql(value[0], map);\n                    System.out.println(s);\n                }\n                return null;\n            }\n        });\n        userMapper.selectUesList(2);\n    }\n\n    // 解析sql\n    public static String parseSql(String sql, Map<String, Object> map) {\n        StringBuilder sb = new StringBuilder();\n        int length = sql.length();\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (c == '#') {\n                int nextIndex = i + 1;\n                char nextChar = sql.charAt(nextIndex);\n                if (nextChar != '{') {\n                    throw new RuntimeException(\"sql写法错误，应该是 { \");\n                }\n                StringBuilder argSb = new StringBuilder();\n                i = parseSqlArg(argSb, sql, nextIndex);\n                String argName = argSb.toString();\n                Object argValue = map.get(argName);\n                sb.append(argValue.toString());\n                continue;\n            }\n            sb.append(c);\n        }\n\n        // 返回解析后拼接过的sql\n        return sb.toString();\n    }\n\n    /**\n     * 这里应该是解析出{}中的的东西\n     */\n    private static int parseSqlArg(StringBuilder argSb, String sql, int nextIndex) {\n        for (int i = nextIndex + 1; i < sql.length(); i++) {\n            char c = sql.charAt(i);\n            if (c != '}') {\n                argSb.append(c);\n            } else {\n                return i;\n            }\n        }\n        throw new RuntimeException(\"sql写法错误，应该是 } \");\n    }\n\n    /**\n     * 解析传入的参数\n     *\n     * @param method method\n     * @param args   参数\n     * @return 解析后的参数\n     */\n    public static Map<String, Object> buildMethodArgNameMap(Method method, Object[] args) {\n        Map<String, Object> map = new HashMap<>(6);\n        // 方法的入参，例如：Integer id, args是实际的入参值，如 6\n        Parameter[] parameters = method.getParameters();\n        for (int i = 0; i < parameters.length; i++) {\n            map.put(parameters[i].getName(), args[i]);\n        }\n        return map;\n    }\n}\n\n\ninterface UserMapper {\n\n    @Select(\"select * from User where id = #{id}\")\n    List<Test.User> selectUesList(Integer id);\n}\t\n```\n\n以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：![mybatis_structure.jpg](https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg)\n\n我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用`#{}`括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。","source":"_posts/mybatis-sql-resolution.md","raw":"---\ntitle: mybatis sql resolution\ndate: 2021-03-07 19:03:54\ncategories: framework\ntags: mybatis\n---\n\n承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。\n\n<!-- more -->\n\n<!-- toc -->\n\n```java\npublic class Test {\n\n    // 模拟的pojo\n    static class User {\n        int age;\n        int name;\n    }\n\n    public static void main(String[] args) {\n        // 核心就在这\n        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class<?>[]{UserMapper.class}, new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                // 获取到注解\n                Select annotation = method.getAnnotation(Select.class);\n                // 构建入参的映射\n                Map<String, Object> map = buildMethodArgNameMap(method, args);\n\n                System.out.println(map.toString());\n                if (annotation != null) {\n                    String[] value = annotation.value();\n                    String s = parseSql(value[0], map);\n                    System.out.println(s);\n                }\n                return null;\n            }\n        });\n        userMapper.selectUesList(2);\n    }\n\n    // 解析sql\n    public static String parseSql(String sql, Map<String, Object> map) {\n        StringBuilder sb = new StringBuilder();\n        int length = sql.length();\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (c == '#') {\n                int nextIndex = i + 1;\n                char nextChar = sql.charAt(nextIndex);\n                if (nextChar != '{') {\n                    throw new RuntimeException(\"sql写法错误，应该是 { \");\n                }\n                StringBuilder argSb = new StringBuilder();\n                i = parseSqlArg(argSb, sql, nextIndex);\n                String argName = argSb.toString();\n                Object argValue = map.get(argName);\n                sb.append(argValue.toString());\n                continue;\n            }\n            sb.append(c);\n        }\n\n        // 返回解析后拼接过的sql\n        return sb.toString();\n    }\n\n    /**\n     * 这里应该是解析出{}中的的东西\n     */\n    private static int parseSqlArg(StringBuilder argSb, String sql, int nextIndex) {\n        for (int i = nextIndex + 1; i < sql.length(); i++) {\n            char c = sql.charAt(i);\n            if (c != '}') {\n                argSb.append(c);\n            } else {\n                return i;\n            }\n        }\n        throw new RuntimeException(\"sql写法错误，应该是 } \");\n    }\n\n    /**\n     * 解析传入的参数\n     *\n     * @param method method\n     * @param args   参数\n     * @return 解析后的参数\n     */\n    public static Map<String, Object> buildMethodArgNameMap(Method method, Object[] args) {\n        Map<String, Object> map = new HashMap<>(6);\n        // 方法的入参，例如：Integer id, args是实际的入参值，如 6\n        Parameter[] parameters = method.getParameters();\n        for (int i = 0; i < parameters.length; i++) {\n            map.put(parameters[i].getName(), args[i]);\n        }\n        return map;\n    }\n}\n\n\ninterface UserMapper {\n\n    @Select(\"select * from User where id = #{id}\")\n    List<Test.User> selectUesList(Integer id);\n}\t\n```\n\n以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：![mybatis_structure.jpg](https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg)\n\n我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用`#{}`括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。","slug":"mybatis-sql-resolution","published":1,"updated":"2021-03-23T15:15:34.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7t001nw5ihe0yj0268","content":"<p>承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。</p>\n<a id=\"more\"></a>\n\n<!-- toc -->\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟的pojo</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 核心就在这</span></span><br><span class=\"line\">        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;UserMapper.class&#125;, <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取到注解</span></span><br><span class=\"line\">                Select annotation = method.getAnnotation(Select.class);</span><br><span class=\"line\">                <span class=\"comment\">// 构建入参的映射</span></span><br><span class=\"line\">                Map&lt;String, Object&gt; map = buildMethodArgNameMap(method, args);</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(map.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String[] value = annotation.value();</span><br><span class=\"line\">                    String s = parseSql(value[<span class=\"number\">0</span>], map);</span><br><span class=\"line\">                    System.out.println(s);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        userMapper.selectUesList(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析sql</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseSql</span><span class=\"params\">(String sql, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = sql.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nextIndex = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> nextChar = sql.charAt(nextIndex);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextChar != <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#123; &quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                StringBuilder argSb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                i = parseSqlArg(argSb, sql, nextIndex);</span><br><span class=\"line\">                String argName = argSb.toString();</span><br><span class=\"line\">                Object argValue = map.get(argName);</span><br><span class=\"line\">                sb.append(argValue.toString());</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sb.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回解析后拼接过的sql</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里应该是解析出&#123;&#125;中的的东西</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parseSqlArg</span><span class=\"params\">(StringBuilder argSb, String sql, <span class=\"keyword\">int</span> nextIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex + <span class=\"number\">1</span>; i &lt; sql.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"string\">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class=\"line\">                argSb.append(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#125; &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解析传入的参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method method</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 解析后的参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, Object&gt; <span class=\"title\">buildMethodArgNameMap</span><span class=\"params\">(Method method, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 方法的入参，例如：Integer id, args是实际的入参值，如 6</span></span><br><span class=\"line\">        Parameter[] parameters = method.getParameters();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class=\"line\">            map.put(parameters[i].getName(), args[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Select(&quot;select * from User where id = #&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    List&lt;Test.User&gt; selectUesList(Integer id);</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：<img src=\"https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg\" alt=\"mybatis_structure.jpg\"></p>\n<p>我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用<code>#&#123;&#125;</code>括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。</p>","more":"<!-- toc -->\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟的pojo</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 核心就在这</span></span><br><span class=\"line\">        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;UserMapper.class&#125;, <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取到注解</span></span><br><span class=\"line\">                Select annotation = method.getAnnotation(Select.class);</span><br><span class=\"line\">                <span class=\"comment\">// 构建入参的映射</span></span><br><span class=\"line\">                Map&lt;String, Object&gt; map = buildMethodArgNameMap(method, args);</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(map.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String[] value = annotation.value();</span><br><span class=\"line\">                    String s = parseSql(value[<span class=\"number\">0</span>], map);</span><br><span class=\"line\">                    System.out.println(s);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        userMapper.selectUesList(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析sql</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseSql</span><span class=\"params\">(String sql, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = sql.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nextIndex = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> nextChar = sql.charAt(nextIndex);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextChar != <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#123; &quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                StringBuilder argSb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                i = parseSqlArg(argSb, sql, nextIndex);</span><br><span class=\"line\">                String argName = argSb.toString();</span><br><span class=\"line\">                Object argValue = map.get(argName);</span><br><span class=\"line\">                sb.append(argValue.toString());</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sb.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回解析后拼接过的sql</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里应该是解析出&#123;&#125;中的的东西</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parseSqlArg</span><span class=\"params\">(StringBuilder argSb, String sql, <span class=\"keyword\">int</span> nextIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex + <span class=\"number\">1</span>; i &lt; sql.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"string\">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class=\"line\">                argSb.append(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#125; &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解析传入的参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method method</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 解析后的参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, Object&gt; <span class=\"title\">buildMethodArgNameMap</span><span class=\"params\">(Method method, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 方法的入参，例如：Integer id, args是实际的入参值，如 6</span></span><br><span class=\"line\">        Parameter[] parameters = method.getParameters();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class=\"line\">            map.put(parameters[i].getName(), args[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Select(&quot;select * from User where id = #&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    List&lt;Test.User&gt; selectUesList(Integer id);</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：<img src=\"https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg\" alt=\"mybatis_structure.jpg\"></p>\n<p>我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用<code>#&#123;&#125;</code>括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。</p>"},{"title":"mybatis_preview","date":"2020-08-05T14:21:19.000Z","_content":"\nMybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。\n\n<!--more-->\n\n# 流程\n\n```flow\nstart=>start: start\nconfig=>operation: mybatis-config.xml\nbuild=>operation: SqlSessionFactoryBuilder\nfactory=>operation: SqlSessionFactory\nsession=>parallel: SqlSession\nmapper=>operation: Sql Mapper\nend=>end: end\n\nstart->config->build->factory->session\nsession(path1,)->end\nsession(path2,right)->mapper->end\n```\n\n对于`SqlSessionFactoryBuilder`来说，作用是创建`SqlSessionFactory`，一旦创建完工厂就没用了，所以是作为**局部变量**；而对于`SqlSessionFactory`，可以把它看作*连接池*，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建`SqlSession` 。创建`SqlSession`后用来链接数据库，每个session被看作是请求数据库，他是**线程不安全**的，每个线程都应有自己的session，不共享，所以最佳作用域是**方法域**，即每次与数据库交互都创建一个`SqlSession`，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。\n\n## 属性名与数据库表字段名\n\n当pojo中的实例变量与数据库字段中不一致时，可以使用`resultMap`来解决，即**结果集映射**。\n\n也常用`resultType`，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来`resultMap`时可以去掉`resultType`属性。\n\n## 日志工厂\n\nmybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！\n\n```xml\n<settings>\n\t<setting name=\"logImpl\" value=\"log4j\"/>\n</settings>\n```\n\n## 分页\n\nmybatis支持分页，有`limit`和`rowBounts`两个方法。区别是前者在sql中实现，后者面向对象。\n\n```sql\nselect * from USER limit #{index},#{size}\n```\n\n# 缓存\n\n默认定义了两级缓存：一级缓存、二级缓存\n\n## 一级缓存\n\n默认开启，在session的`close`之前都有效，如果是查询相同的数据，直接在缓存中拿。\n\n## 二级缓存\n\n需要手动开启和配置，基于`namespace`级别，有`Cache`接口来自定义实现。\n","source":"_posts/mybatis_preview.md","raw":"---\ntitle: mybatis_preview\ndate: 2020-08-05 22:21:19\ncategories: framework\ntags: mybatis\n---\n\nMybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。\n\n<!--more-->\n\n# 流程\n\n```flow\nstart=>start: start\nconfig=>operation: mybatis-config.xml\nbuild=>operation: SqlSessionFactoryBuilder\nfactory=>operation: SqlSessionFactory\nsession=>parallel: SqlSession\nmapper=>operation: Sql Mapper\nend=>end: end\n\nstart->config->build->factory->session\nsession(path1,)->end\nsession(path2,right)->mapper->end\n```\n\n对于`SqlSessionFactoryBuilder`来说，作用是创建`SqlSessionFactory`，一旦创建完工厂就没用了，所以是作为**局部变量**；而对于`SqlSessionFactory`，可以把它看作*连接池*，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建`SqlSession` 。创建`SqlSession`后用来链接数据库，每个session被看作是请求数据库，他是**线程不安全**的，每个线程都应有自己的session，不共享，所以最佳作用域是**方法域**，即每次与数据库交互都创建一个`SqlSession`，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。\n\n## 属性名与数据库表字段名\n\n当pojo中的实例变量与数据库字段中不一致时，可以使用`resultMap`来解决，即**结果集映射**。\n\n也常用`resultType`，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来`resultMap`时可以去掉`resultType`属性。\n\n## 日志工厂\n\nmybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！\n\n```xml\n<settings>\n\t<setting name=\"logImpl\" value=\"log4j\"/>\n</settings>\n```\n\n## 分页\n\nmybatis支持分页，有`limit`和`rowBounts`两个方法。区别是前者在sql中实现，后者面向对象。\n\n```sql\nselect * from USER limit #{index},#{size}\n```\n\n# 缓存\n\n默认定义了两级缓存：一级缓存、二级缓存\n\n## 一级缓存\n\n默认开启，在session的`close`之前都有效，如果是查询相同的数据，直接在缓存中拿。\n\n## 二级缓存\n\n需要手动开启和配置，基于`namespace`级别，有`Cache`接口来自定义实现。\n","slug":"mybatis_preview","published":1,"updated":"2021-03-07T11:04:27.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7v001pw5ihb0ns40jx","content":"<p>Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">config&#x3D;&gt;operation: mybatis-config.xml</span><br><span class=\"line\">build&#x3D;&gt;operation: SqlSessionFactoryBuilder</span><br><span class=\"line\">factory&#x3D;&gt;operation: SqlSessionFactory</span><br><span class=\"line\">session&#x3D;&gt;parallel: SqlSession</span><br><span class=\"line\">mapper&#x3D;&gt;operation: Sql Mapper</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;config-&gt;build-&gt;factory-&gt;session</span><br><span class=\"line\">session(path1,)-&gt;end</span><br><span class=\"line\">session(path2,right)-&gt;mapper-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>SqlSessionFactoryBuilder</code>来说，作用是创建<code>SqlSessionFactory</code>，一旦创建完工厂就没用了，所以是作为<strong>局部变量</strong>；而对于<code>SqlSessionFactory</code>，可以把它看作<em>连接池</em>，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建<code>SqlSession</code> 。创建<code>SqlSession</code>后用来链接数据库，每个session被看作是请求数据库，他是<strong>线程不安全</strong>的，每个线程都应有自己的session，不共享，所以最佳作用域是<strong>方法域</strong>，即每次与数据库交互都创建一个<code>SqlSession</code>，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。</p>\n<h2 id=\"属性名与数据库表字段名\"><a href=\"#属性名与数据库表字段名\" class=\"headerlink\" title=\"属性名与数据库表字段名\"></a>属性名与数据库表字段名</h2><p>当pojo中的实例变量与数据库字段中不一致时，可以使用<code>resultMap</code>来解决，即<strong>结果集映射</strong>。</p>\n<p>也常用<code>resultType</code>，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来<code>resultMap</code>时可以去掉<code>resultType</code>属性。</p>\n<h2 id=\"日志工厂\"><a href=\"#日志工厂\" class=\"headerlink\" title=\"日志工厂\"></a>日志工厂</h2><p>mybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logImpl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;log4j&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h2><p>mybatis支持分页，有<code>limit</code>和<code>rowBounts</code>两个方法。区别是前者在sql中实现，后者面向对象。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">USER</span> <span class=\"keyword\">limit</span> <span class=\"comment\">#&#123;index&#125;,#&#123;size&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><p>默认定义了两级缓存：一级缓存、二级缓存</p>\n<h2 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h2><p>默认开启，在session的<code>close</code>之前都有效，如果是查询相同的数据，直接在缓存中拿。</p>\n<h2 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h2><p>需要手动开启和配置，基于<code>namespace</code>级别，有<code>Cache</code>接口来自定义实现。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。</p>","more":"<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">config&#x3D;&gt;operation: mybatis-config.xml</span><br><span class=\"line\">build&#x3D;&gt;operation: SqlSessionFactoryBuilder</span><br><span class=\"line\">factory&#x3D;&gt;operation: SqlSessionFactory</span><br><span class=\"line\">session&#x3D;&gt;parallel: SqlSession</span><br><span class=\"line\">mapper&#x3D;&gt;operation: Sql Mapper</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;config-&gt;build-&gt;factory-&gt;session</span><br><span class=\"line\">session(path1,)-&gt;end</span><br><span class=\"line\">session(path2,right)-&gt;mapper-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>SqlSessionFactoryBuilder</code>来说，作用是创建<code>SqlSessionFactory</code>，一旦创建完工厂就没用了，所以是作为<strong>局部变量</strong>；而对于<code>SqlSessionFactory</code>，可以把它看作<em>连接池</em>，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建<code>SqlSession</code> 。创建<code>SqlSession</code>后用来链接数据库，每个session被看作是请求数据库，他是<strong>线程不安全</strong>的，每个线程都应有自己的session，不共享，所以最佳作用域是<strong>方法域</strong>，即每次与数据库交互都创建一个<code>SqlSession</code>，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。</p>\n<h2 id=\"属性名与数据库表字段名\"><a href=\"#属性名与数据库表字段名\" class=\"headerlink\" title=\"属性名与数据库表字段名\"></a>属性名与数据库表字段名</h2><p>当pojo中的实例变量与数据库字段中不一致时，可以使用<code>resultMap</code>来解决，即<strong>结果集映射</strong>。</p>\n<p>也常用<code>resultType</code>，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来<code>resultMap</code>时可以去掉<code>resultType</code>属性。</p>\n<h2 id=\"日志工厂\"><a href=\"#日志工厂\" class=\"headerlink\" title=\"日志工厂\"></a>日志工厂</h2><p>mybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logImpl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;log4j&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h2><p>mybatis支持分页，有<code>limit</code>和<code>rowBounts</code>两个方法。区别是前者在sql中实现，后者面向对象。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">USER</span> <span class=\"keyword\">limit</span> <span class=\"comment\">#&#123;index&#125;,#&#123;size&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><p>默认定义了两级缓存：一级缓存、二级缓存</p>\n<h2 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h2><p>默认开启，在session的<code>close</code>之前都有效，如果是查询相同的数据，直接在缓存中拿。</p>\n<h2 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h2><p>需要手动开启和配置，基于<code>namespace</code>级别，有<code>Cache</code>接口来自定义实现。</p>"},{"title":"nginx","date":"2019-11-02T14:53:32.000Z","_content":"# NIGNX\n\n*Nginx* (engine x) 是一个高性能的HTTP和**反向代理**web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n\n它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。\n\n特点：\n\n- 反向代理\n- 负载均衡\n- 动静分离\n- 高可用\n\n\n\n## 反向代理\n\n客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。\n\n## 正向代理\n\n如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）\n\n正向访问需要在浏览器配置代理服务器。\n\n\n\n## 负载均衡\n\n单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。\n\n\n\n## 动静分离\n\n为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。\n\n静态资源：html, css, js\n\n动态资源：jsp, servlet\n\n## 操作\n\n### 常用命令\n\n前提条件：进入nginx目录\n\n/usr/localnginx/sbin\n\n- 查看nginx版本号\n- 启动\n- 关闭\n- 重新加载nginx\n\n[referenct](https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng)\n\n# 配置\n\n1. 配置EPEL源\n\n   ```bash\n   sudo yum install -y epel-release\n   sudo yum -y update\n   ```\n\n2. 安装nginx\n\n   ```bash\n   sudo yum instll -y nginx\n   ```\n\n   安装成功后：\n\n   `默认网站目录`：_/usr/share/nginx/html_\n\n   `默认的配置文件为`：_/etc/nginx/nginx.conf_\n\n   `自定义配置文件目录为`：_/etc/nginx/conf.d/_\n\n3. 开启端口80和443\n\n   如果关闭了防火墙，直接略过。\n\n   ```bash\n   sudo firewall-cmd --permanent --zone=public --add-service=http\n   sudo firewall-cmd --permanent --zone=public --add-service=https\n   sudo firewall-cmd --reload\n   ```\n\n4. 命令\n\n   - 启动\n\n     ```bash\n     systemctl start nginx\n     ```\n\n   - 停止\n\n     ```bash\n     systemctl stop nginx\n     ```\n\n   - 重启\n\n     ```bash\n     systemctl restart nginx\n     ```\n\n   - 查看状态\n\n     ```bash\n     systemctl status nginx\n     ```\n\n   - 启用开机启动\n\n     ```bash\n     systemctl enable nginx\n     ```\n\n     测试的时候，直接`nginx`命令即可，方便调试，调试时使用：\n\n     ```bash\n     nginx -t\n     ```\n\n     ```bash\n     nginx -s reload\n     ```\n\n     \n\n   - 禁止开机启动\n\n     ```bash\n     systemctl disbale nginx\n     ```\n\n5. https\n\n   1. 关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。\n\n   3. 拷贝证书至nginx\n   \n      domain为个人域名。\n   \n      ```bash\n   mkdir -p /etc/nginx/ssl\n      \n   acme.sh --install-cert -d domain \\\n      --key-file       /etc/nginx/ssl/domain.key  \\\n      --fullchain-file /etc/nginx/ssl/domain.cer \\\n      --reloadcmd     \"service nginx force-reload\"\n      ```\n   \n6. 配置nginx\n\n   删除**/etc/nginx/nginx.conf**中的server部分代码\n\n   ```markdown\n   server{\n   ...\n   }\n   ```\n\n   在**/etc/nginx/conf.d**创建自定义配置文件夹**default.conf**\n\n   ```properties\n   server {\n       listen 80;\n       listen 443 ssl;\n       server_name  domain www.domain;\n       location / {\n            root /usr/share/nginx/html;\n            index  index.html index.htm;\n        }\n   \n       ssl_certificate /etc/nginx/ssl/domain.crt;\n       ssl_certificate_key /etc/nginx/ssl/domain.key;\n       ssl_session_timeout  5m;\n       ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n       ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;\n       ssl_prefer_server_ciphers  on;\n   \n       error_page 497  https://$host$uri?$args;\n   }\n   ```\n   \n\n   \n\n   \n","source":"_posts/nginx.md","raw":"---\ntitle: nginx\ndate: 2019-11-02 22:53:32\ncategories: Network\ntags: network\n---\n# NIGNX\n\n*Nginx* (engine x) 是一个高性能的HTTP和**反向代理**web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n\n它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。\n\n特点：\n\n- 反向代理\n- 负载均衡\n- 动静分离\n- 高可用\n\n\n\n## 反向代理\n\n客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。\n\n## 正向代理\n\n如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）\n\n正向访问需要在浏览器配置代理服务器。\n\n\n\n## 负载均衡\n\n单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。\n\n\n\n## 动静分离\n\n为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。\n\n静态资源：html, css, js\n\n动态资源：jsp, servlet\n\n## 操作\n\n### 常用命令\n\n前提条件：进入nginx目录\n\n/usr/localnginx/sbin\n\n- 查看nginx版本号\n- 启动\n- 关闭\n- 重新加载nginx\n\n[referenct](https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng)\n\n# 配置\n\n1. 配置EPEL源\n\n   ```bash\n   sudo yum install -y epel-release\n   sudo yum -y update\n   ```\n\n2. 安装nginx\n\n   ```bash\n   sudo yum instll -y nginx\n   ```\n\n   安装成功后：\n\n   `默认网站目录`：_/usr/share/nginx/html_\n\n   `默认的配置文件为`：_/etc/nginx/nginx.conf_\n\n   `自定义配置文件目录为`：_/etc/nginx/conf.d/_\n\n3. 开启端口80和443\n\n   如果关闭了防火墙，直接略过。\n\n   ```bash\n   sudo firewall-cmd --permanent --zone=public --add-service=http\n   sudo firewall-cmd --permanent --zone=public --add-service=https\n   sudo firewall-cmd --reload\n   ```\n\n4. 命令\n\n   - 启动\n\n     ```bash\n     systemctl start nginx\n     ```\n\n   - 停止\n\n     ```bash\n     systemctl stop nginx\n     ```\n\n   - 重启\n\n     ```bash\n     systemctl restart nginx\n     ```\n\n   - 查看状态\n\n     ```bash\n     systemctl status nginx\n     ```\n\n   - 启用开机启动\n\n     ```bash\n     systemctl enable nginx\n     ```\n\n     测试的时候，直接`nginx`命令即可，方便调试，调试时使用：\n\n     ```bash\n     nginx -t\n     ```\n\n     ```bash\n     nginx -s reload\n     ```\n\n     \n\n   - 禁止开机启动\n\n     ```bash\n     systemctl disbale nginx\n     ```\n\n5. https\n\n   1. 关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。\n\n   3. 拷贝证书至nginx\n   \n      domain为个人域名。\n   \n      ```bash\n   mkdir -p /etc/nginx/ssl\n      \n   acme.sh --install-cert -d domain \\\n      --key-file       /etc/nginx/ssl/domain.key  \\\n      --fullchain-file /etc/nginx/ssl/domain.cer \\\n      --reloadcmd     \"service nginx force-reload\"\n      ```\n   \n6. 配置nginx\n\n   删除**/etc/nginx/nginx.conf**中的server部分代码\n\n   ```markdown\n   server{\n   ...\n   }\n   ```\n\n   在**/etc/nginx/conf.d**创建自定义配置文件夹**default.conf**\n\n   ```properties\n   server {\n       listen 80;\n       listen 443 ssl;\n       server_name  domain www.domain;\n       location / {\n            root /usr/share/nginx/html;\n            index  index.html index.htm;\n        }\n   \n       ssl_certificate /etc/nginx/ssl/domain.crt;\n       ssl_certificate_key /etc/nginx/ssl/domain.key;\n       ssl_session_timeout  5m;\n       ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n       ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;\n       ssl_prefer_server_ciphers  on;\n   \n       error_page 497  https://$host$uri?$args;\n   }\n   ```\n   \n\n   \n\n   \n","slug":"nginx","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q7z001tw5ih51vqajrg","content":"<h1 id=\"NIGNX\"><a href=\"#NIGNX\" class=\"headerlink\" title=\"NIGNX\"></a>NIGNX</h1><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和<strong>反向代理</strong>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>\n<p>它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p>\n<p>特点：</p>\n<ul>\n<li>反向代理</li>\n<li>负载均衡</li>\n<li>动静分离</li>\n<li>高可用</li>\n</ul>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）</p>\n<p>正向访问需要在浏览器配置代理服务器。</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。</p>\n<p>静态资源：html, css, js</p>\n<p>动态资源：jsp, servlet</p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>前提条件：进入nginx目录</p>\n<p>/usr/localnginx/sbin</p>\n<ul>\n<li>查看nginx版本号</li>\n<li>启动</li>\n<li>关闭</li>\n<li>重新加载nginx</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng\">referenct</a></p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><ol>\n<li><p>配置EPEL源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y epel-release</span><br><span class=\"line\">sudo yum -y update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装nginx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum instll -y nginx</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后：</p>\n<p><code>默认网站目录</code>：<em>/usr/share/nginx/html</em></p>\n<p><code>默认的配置文件为</code>：<em>/etc/nginx/nginx.conf</em></p>\n<p><code>自定义配置文件目录为</code>：<em>/etc/nginx/conf.d/</em></p>\n</li>\n<li><p>开启端口80和443</p>\n<p>如果关闭了防火墙，直接略过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启用开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nginx</span><br></pre></td></tr></table></figure>\n\n<p>测试的时候，直接<code>nginx</code>命令即可，方便调试，调试时使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>禁止开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl disbale nginx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>https</p>\n<ol>\n<li><p>关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。</p>\n</li>\n<li><p>拷贝证书至nginx</p>\n<p>domain为个人域名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /etc/nginx/ssl</span><br><span class=\"line\">   </span><br><span class=\"line\">acme.sh --install-cert -d domain \\</span><br><span class=\"line\">   --key-file       /etc/nginx/ssl/domain.key  \\</span><br><span class=\"line\">   --fullchain-file /etc/nginx/ssl/domain.cer \\</span><br><span class=\"line\">   --reloadcmd     <span class=\"string\">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>配置nginx</p>\n<p>删除**/etc/nginx/nginx.conf**中的server部分代码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在**/etc/nginx/conf.d<strong>创建自定义配置文件夹</strong>default.conf**</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">80;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">443 ssl;</span></span><br><span class=\"line\">    <span class=\"attr\">server_name</span>  <span class=\"string\">domain www.domain;</span></span><br><span class=\"line\">    <span class=\"attr\">location</span> <span class=\"string\">/ &#123;</span></span><br><span class=\"line\">         <span class=\"attr\">root</span> <span class=\"string\">/usr/share/nginx/html;</span></span><br><span class=\"line\">         <span class=\"attr\">index</span>  <span class=\"string\">index.html index.htm;</span></span><br><span class=\"line\">     <span class=\"attr\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate</span> <span class=\"string\">/etc/nginx/ssl/domain.crt;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate_key</span> <span class=\"string\">/etc/nginx/ssl/domain.key;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_session_timeout</span>  <span class=\"string\">5m;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_protocols</span> <span class=\"string\">TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_ciphers</span> <span class=\"string\">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_prefer_server_ciphers</span>  <span class=\"string\">on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">error_page</span> <span class=\"string\">497  https://$host$uri?$args;</span></span><br><span class=\"line\"><span class=\"attr\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n</li>\n</ol>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<h1 id=\"NIGNX\"><a href=\"#NIGNX\" class=\"headerlink\" title=\"NIGNX\"></a>NIGNX</h1><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和<strong>反向代理</strong>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>\n<p>它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p>\n<p>特点：</p>\n<ul>\n<li>反向代理</li>\n<li>负载均衡</li>\n<li>动静分离</li>\n<li>高可用</li>\n</ul>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）</p>\n<p>正向访问需要在浏览器配置代理服务器。</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。</p>\n<p>静态资源：html, css, js</p>\n<p>动态资源：jsp, servlet</p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>前提条件：进入nginx目录</p>\n<p>/usr/localnginx/sbin</p>\n<ul>\n<li>查看nginx版本号</li>\n<li>启动</li>\n<li>关闭</li>\n<li>重新加载nginx</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng\">referenct</a></p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><ol>\n<li><p>配置EPEL源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y epel-release</span><br><span class=\"line\">sudo yum -y update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装nginx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum instll -y nginx</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后：</p>\n<p><code>默认网站目录</code>：<em>/usr/share/nginx/html</em></p>\n<p><code>默认的配置文件为</code>：<em>/etc/nginx/nginx.conf</em></p>\n<p><code>自定义配置文件目录为</code>：<em>/etc/nginx/conf.d/</em></p>\n</li>\n<li><p>开启端口80和443</p>\n<p>如果关闭了防火墙，直接略过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启用开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nginx</span><br></pre></td></tr></table></figure>\n\n<p>测试的时候，直接<code>nginx</code>命令即可，方便调试，调试时使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>禁止开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl disbale nginx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>https</p>\n<ol>\n<li><p>关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。</p>\n</li>\n<li><p>拷贝证书至nginx</p>\n<p>domain为个人域名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /etc/nginx/ssl</span><br><span class=\"line\">   </span><br><span class=\"line\">acme.sh --install-cert -d domain \\</span><br><span class=\"line\">   --key-file       /etc/nginx/ssl/domain.key  \\</span><br><span class=\"line\">   --fullchain-file /etc/nginx/ssl/domain.cer \\</span><br><span class=\"line\">   --reloadcmd     <span class=\"string\">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>配置nginx</p>\n<p>删除**/etc/nginx/nginx.conf**中的server部分代码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在**/etc/nginx/conf.d<strong>创建自定义配置文件夹</strong>default.conf**</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">80;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">443 ssl;</span></span><br><span class=\"line\">    <span class=\"attr\">server_name</span>  <span class=\"string\">domain www.domain;</span></span><br><span class=\"line\">    <span class=\"attr\">location</span> <span class=\"string\">/ &#123;</span></span><br><span class=\"line\">         <span class=\"attr\">root</span> <span class=\"string\">/usr/share/nginx/html;</span></span><br><span class=\"line\">         <span class=\"attr\">index</span>  <span class=\"string\">index.html index.htm;</span></span><br><span class=\"line\">     <span class=\"attr\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate</span> <span class=\"string\">/etc/nginx/ssl/domain.crt;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate_key</span> <span class=\"string\">/etc/nginx/ssl/domain.key;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_session_timeout</span>  <span class=\"string\">5m;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_protocols</span> <span class=\"string\">TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_ciphers</span> <span class=\"string\">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_prefer_server_ciphers</span>  <span class=\"string\">on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">error_page</span> <span class=\"string\">497  https://$host$uri?$args;</span></span><br><span class=\"line\"><span class=\"attr\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n</li>\n</ol>\n"},{"title":"observer","date":"2020-06-12T09:12:38.000Z","_content":"\n观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？\n\n<!--more-->\n\n一个好的设计模式能拯救一堆代码。\n\n# 场景\n\n设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。\n\n```java\npublic class WeatherData(){\n    getTemperature(){};\n    getHumidity(){};\n    \n    /**\n    * 一旦气象更新，此方法会被调用。\n    */\n    measuremetnsChanged(){\n        // our codes go here\n    };\n}\n```\n\n如果直接在`measuremetnsChanged`这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。\n\n```java\npublic void measuremetnsChanged(){\n    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    ......\n}\n```\n\n# 观察者模式\n\n先看看我们平时是怎么浏览微信订阅号消息：\n\n首先整个流程应该有两个参与者\n\n- 订阅号运营者\n- 订阅者\n\n订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。\n\n那么观察者模式也类似：\n\n> 订阅号运营者+订阅者=观察者模式\n\n不一样的是名称，订阅号运营者改为“subject\"（主题），订阅者改为”observer\"（观察者）。\n\n由于一个主题可以被多个观察者订阅，所以，它实现了对象之间**一对多**；同时，这种对象设计也让主题和观察者之间**松耦合**.\n\n对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。\n\n## 实现\n\n![Screenshot from 2020-06-12 18-03-04.png](https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png)\n\n我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。\n\n```java\npublic CurrentConditionsDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    weatherData.registerObserver(this);\n}\n```\n\n以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。\n\n完整代码参考：[项目传送门](https://github.com/Sebastian-Getts/designPatternsPractice)\n\n## 原理\n\n虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。\n\n# 应用\n\n观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。","source":"_posts/observer.md","raw":"---\ntitle: observer\ndate: 2020-06-12 17:12:38\ncategories: DesignPatterns\ntags: design_patterns\n---\n\n观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？\n\n<!--more-->\n\n一个好的设计模式能拯救一堆代码。\n\n# 场景\n\n设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。\n\n```java\npublic class WeatherData(){\n    getTemperature(){};\n    getHumidity(){};\n    \n    /**\n    * 一旦气象更新，此方法会被调用。\n    */\n    measuremetnsChanged(){\n        // our codes go here\n    };\n}\n```\n\n如果直接在`measuremetnsChanged`这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。\n\n```java\npublic void measuremetnsChanged(){\n    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    ......\n}\n```\n\n# 观察者模式\n\n先看看我们平时是怎么浏览微信订阅号消息：\n\n首先整个流程应该有两个参与者\n\n- 订阅号运营者\n- 订阅者\n\n订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。\n\n那么观察者模式也类似：\n\n> 订阅号运营者+订阅者=观察者模式\n\n不一样的是名称，订阅号运营者改为“subject\"（主题），订阅者改为”observer\"（观察者）。\n\n由于一个主题可以被多个观察者订阅，所以，它实现了对象之间**一对多**；同时，这种对象设计也让主题和观察者之间**松耦合**.\n\n对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。\n\n## 实现\n\n![Screenshot from 2020-06-12 18-03-04.png](https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png)\n\n我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。\n\n```java\npublic CurrentConditionsDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    weatherData.registerObserver(this);\n}\n```\n\n以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。\n\n完整代码参考：[项目传送门](https://github.com/Sebastian-Getts/designPatternsPractice)\n\n## 原理\n\n虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。\n\n# 应用\n\n观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。","slug":"observer","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q82001ww5ih4e46g5xd","content":"<p>观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？</p>\n<a id=\"more\"></a>\n\n<p>一个好的设计模式能拯救一堆代码。</p>\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">WeatherData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    getTemperature()&#123;&#125;;</span><br><span class=\"line\">    getHumidity()&#123;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 一旦气象更新，此方法会被调用。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    measuremetnsChanged()&#123;</span><br><span class=\"line\">        <span class=\"comment\">// our codes go here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果直接在<code>measuremetnsChanged</code>这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measuremetnsChanged</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>先看看我们平时是怎么浏览微信订阅号消息：</p>\n<p>首先整个流程应该有两个参与者</p>\n<ul>\n<li>订阅号运营者</li>\n<li>订阅者</li>\n</ul>\n<p>订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。</p>\n<p>那么观察者模式也类似：</p>\n<blockquote>\n<p>订阅号运营者+订阅者=观察者模式</p>\n</blockquote>\n<p>不一样的是名称，订阅号运营者改为“subject”（主题），订阅者改为”observer”（观察者）。</p>\n<p>由于一个主题可以被多个观察者订阅，所以，它实现了对象之间<strong>一对多</strong>；同时，这种对象设计也让主题和观察者之间<strong>松耦合</strong>.</p>\n<p>对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><img src=\"https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png\" alt=\"Screenshot from 2020-06-12 18-03-04.png\"></p>\n<p>我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Subject weatherData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weatherData = weatherData;</span><br><span class=\"line\">    weatherData.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。</p>\n<p>完整代码参考：<a href=\"https://github.com/Sebastian-Getts/designPatternsPractice\">项目传送门</a></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？</p>","more":"<p>一个好的设计模式能拯救一堆代码。</p>\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">WeatherData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    getTemperature()&#123;&#125;;</span><br><span class=\"line\">    getHumidity()&#123;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 一旦气象更新，此方法会被调用。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    measuremetnsChanged()&#123;</span><br><span class=\"line\">        <span class=\"comment\">// our codes go here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果直接在<code>measuremetnsChanged</code>这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measuremetnsChanged</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>先看看我们平时是怎么浏览微信订阅号消息：</p>\n<p>首先整个流程应该有两个参与者</p>\n<ul>\n<li>订阅号运营者</li>\n<li>订阅者</li>\n</ul>\n<p>订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。</p>\n<p>那么观察者模式也类似：</p>\n<blockquote>\n<p>订阅号运营者+订阅者=观察者模式</p>\n</blockquote>\n<p>不一样的是名称，订阅号运营者改为“subject”（主题），订阅者改为”observer”（观察者）。</p>\n<p>由于一个主题可以被多个观察者订阅，所以，它实现了对象之间<strong>一对多</strong>；同时，这种对象设计也让主题和观察者之间<strong>松耦合</strong>.</p>\n<p>对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><img src=\"https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png\" alt=\"Screenshot from 2020-06-12 18-03-04.png\"></p>\n<p>我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Subject weatherData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weatherData = weatherData;</span><br><span class=\"line\">    weatherData.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。</p>\n<p>完整代码参考：<a href=\"https://github.com/Sebastian-Getts/designPatternsPractice\">项目传送门</a></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。</p>"},{"title":"redis","date":"2020-06-09T13:54:01.000Z","_content":"\n常用redis，深入了解redis的性能和瓶颈。[reference](https://github.com/antirez/redis)\n\n<!--more-->\n\n# 介绍\n\nredis: **内存**中的数据结构存储系统，可以用作**数据库**、**缓存**和**消息中间件**，nosql的一种。\n\n## nosql\n\n关系型数据库不够用，出来了nosql。。。\n\n1. 一开始单体应用，小用户量能承受。但是当体量变大时：\n   - 数据量大\n   - 数据的索引大\n   - 访问量大\n2. 读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层**memcache**缓存\n3. 集群（水平拆分）：上面的读写分离copy多份。\n\nmysql早些年使用的是MyISAM引擎，特性是**表锁**（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了**行锁**。\n\n不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。\n\n### 特点\n\n1. 易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。\n2. 大数据量也高性能（写8万次/秒，读11万次/秒）\n3. 多样型，不需要事先设计数据库\n4. 没有固定的查询语言；最终一致性\n5. 键值对存储，列存储，文档存储，图形存储库（社交）\n6. 高性能、高可用、高可扩\n7. CAP、BASE，异地多活\n8. 多样、实时、并发（Volume, Variety, Veiocity）\n\n与关系型一起使用。\n\n商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）\n\n商品的基本信息（价格、商家、名称）：MySQL\n\n图片：FastDFS, GFS, HDFS, OSS...\n\n商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）\n\n==没有什么不是加以层解决不了的==： 统一服务层。\n\n### 文档型数据库\n\nMongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。\n\n### KV键值对\n\nRedis，Tair\n\n### 列存储数据库\n\nHBase（大数据）\n\n分布式文件系统\n\n### 图\n\n类似知识图谱，不是存储图形。主要用于存储社交网络。\n\nNeo4j，InfoGrid。\n\n# Redis\n\nRemote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。\n\n- 内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）\n- 计时器、计数器（浏览量）\n\n## 测试\n\n安装后自带的测试工具\n\n```bash\nredis-benchmark -h localhost -p 6379 -100 -n 100000\n```\n\n## 基础\n\n默认16个数据库且使用的是第0个。 \n\n### GEOSPATIAL\n\n地理位置，不仅仅是GET、SET！根据经纬度获取距离。\n\n## springboot集成\n\n版本<2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。\n\n版本>2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。\n\n## rdb\n\n为什么会有这个rdb？\n\nredis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。\n\n```flow\nstart=>start: start\nend=>end: end\ncondition=>condition: 触发rdb\nrdbfile=>inputoutput: dump.rdb\noperation=>operation: go on dealing with\n\nstart->condition\ncondition(yes)->rdbfile->end\ncondition(no)->operation->end\n```\n\n#### 触发机制\n\n1. save的规则\n2. 执行flushall\n3. 退出redis\n\n产生备份，会自动生成一个dump.rdb\n\n#### 用rdb恢复\n\n```bash\nconfig get dir\n```\n\n#### 优点：\n\n1. 适合大数据\n2. 对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）\n\n#### 缺点：\n\n1. 需要一定的时间间隔进程操作\n2. fork进程的时候会占用一定的内容空间\n\n## AOF\n\nAppend Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。\n\n- 大数据的情况下效率会比较低。\n- 默认是不开启的。\n\n开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。\n\n修复aof文件 `redis-check-aof --fix`\n\n### 优点：\n\n1. 每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据\n2. 从不同步效率最高\n\n### 缺点：\n\n1. 相对于数据文件，aof远大于rdb，修复的速度比rdb慢\n2. 默认是rdb，效率自然高于aof。\n\n**与rdb混合使用**\n\n## 主从复制\n\n将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。\n\n作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石\n\nreids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。\n\n默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。\n\n### 环境配置\n\n```shell\ninfo replication # 查看当前库的信息\n```\n\n一般情况下只用配置从机即可。\n\n```shell\nSLAVEOF ip:port # ip:port为主机\n```\n\n上面的是命令配置，只是暂时的。**实际生产应该修改配置文件**，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。\n\n#### 如果主机宕机了呢？\n\n默认情况下，主机挂了以后，用`info replication`查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。\n\n更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。\n\n- 全量复制 master将整个数据传送到slaver\n- 增量复制\n\n只要重新链接master，一次全量复制将被自动执行\n\n### 哨兵模式\n\nSentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。\n\n哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）\n\n#### 优点\n\n1. 集群\n2. 主从切换\n\n#### 缺点\n\n1. 不方便在线扩容，一旦到达上线。\n2. 配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。\n\n## redis异常处理\n\n### 缓存穿透（一直查询不到）\n\n```flow\nstart=>start: request\nend=>end: response\ncondition=>condition: redis缓存中是否存在\nop1=>operation: select in mysql\nstart->condition\ncondition(yes)->end\ncondition(no)->op1->end\n```\n\n如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。\n\n#### 布隆过滤器\n\n它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力\n\n#### 缓存空对象\n\n### 缓存击穿（量太大，缓存过期）\n\n活力集中在一个点（一个热评的点，如微博）。\n\n#### 加互斥锁\n\n#### 设置热点数据永不过期\n\n### 缓存雪崩\n\n在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。\n\n#### redis高可用\n\n#### 限流降级\n\n#### 数据预热\n\n正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。\n\n","source":"_posts/redis.md","raw":"---\ntitle: redis\ndate: 2020-06-09 21:54:01\ncategories: DB\ntags: \n- redis\n- nosql\n---\n\n常用redis，深入了解redis的性能和瓶颈。[reference](https://github.com/antirez/redis)\n\n<!--more-->\n\n# 介绍\n\nredis: **内存**中的数据结构存储系统，可以用作**数据库**、**缓存**和**消息中间件**，nosql的一种。\n\n## nosql\n\n关系型数据库不够用，出来了nosql。。。\n\n1. 一开始单体应用，小用户量能承受。但是当体量变大时：\n   - 数据量大\n   - 数据的索引大\n   - 访问量大\n2. 读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层**memcache**缓存\n3. 集群（水平拆分）：上面的读写分离copy多份。\n\nmysql早些年使用的是MyISAM引擎，特性是**表锁**（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了**行锁**。\n\n不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。\n\n### 特点\n\n1. 易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。\n2. 大数据量也高性能（写8万次/秒，读11万次/秒）\n3. 多样型，不需要事先设计数据库\n4. 没有固定的查询语言；最终一致性\n5. 键值对存储，列存储，文档存储，图形存储库（社交）\n6. 高性能、高可用、高可扩\n7. CAP、BASE，异地多活\n8. 多样、实时、并发（Volume, Variety, Veiocity）\n\n与关系型一起使用。\n\n商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）\n\n商品的基本信息（价格、商家、名称）：MySQL\n\n图片：FastDFS, GFS, HDFS, OSS...\n\n商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）\n\n==没有什么不是加以层解决不了的==： 统一服务层。\n\n### 文档型数据库\n\nMongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。\n\n### KV键值对\n\nRedis，Tair\n\n### 列存储数据库\n\nHBase（大数据）\n\n分布式文件系统\n\n### 图\n\n类似知识图谱，不是存储图形。主要用于存储社交网络。\n\nNeo4j，InfoGrid。\n\n# Redis\n\nRemote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。\n\n- 内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）\n- 计时器、计数器（浏览量）\n\n## 测试\n\n安装后自带的测试工具\n\n```bash\nredis-benchmark -h localhost -p 6379 -100 -n 100000\n```\n\n## 基础\n\n默认16个数据库且使用的是第0个。 \n\n### GEOSPATIAL\n\n地理位置，不仅仅是GET、SET！根据经纬度获取距离。\n\n## springboot集成\n\n版本<2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。\n\n版本>2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。\n\n## rdb\n\n为什么会有这个rdb？\n\nredis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。\n\n```flow\nstart=>start: start\nend=>end: end\ncondition=>condition: 触发rdb\nrdbfile=>inputoutput: dump.rdb\noperation=>operation: go on dealing with\n\nstart->condition\ncondition(yes)->rdbfile->end\ncondition(no)->operation->end\n```\n\n#### 触发机制\n\n1. save的规则\n2. 执行flushall\n3. 退出redis\n\n产生备份，会自动生成一个dump.rdb\n\n#### 用rdb恢复\n\n```bash\nconfig get dir\n```\n\n#### 优点：\n\n1. 适合大数据\n2. 对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）\n\n#### 缺点：\n\n1. 需要一定的时间间隔进程操作\n2. fork进程的时候会占用一定的内容空间\n\n## AOF\n\nAppend Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。\n\n- 大数据的情况下效率会比较低。\n- 默认是不开启的。\n\n开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。\n\n修复aof文件 `redis-check-aof --fix`\n\n### 优点：\n\n1. 每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据\n2. 从不同步效率最高\n\n### 缺点：\n\n1. 相对于数据文件，aof远大于rdb，修复的速度比rdb慢\n2. 默认是rdb，效率自然高于aof。\n\n**与rdb混合使用**\n\n## 主从复制\n\n将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。\n\n作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石\n\nreids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。\n\n默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。\n\n### 环境配置\n\n```shell\ninfo replication # 查看当前库的信息\n```\n\n一般情况下只用配置从机即可。\n\n```shell\nSLAVEOF ip:port # ip:port为主机\n```\n\n上面的是命令配置，只是暂时的。**实际生产应该修改配置文件**，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。\n\n#### 如果主机宕机了呢？\n\n默认情况下，主机挂了以后，用`info replication`查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。\n\n更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。\n\n- 全量复制 master将整个数据传送到slaver\n- 增量复制\n\n只要重新链接master，一次全量复制将被自动执行\n\n### 哨兵模式\n\nSentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。\n\n哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）\n\n#### 优点\n\n1. 集群\n2. 主从切换\n\n#### 缺点\n\n1. 不方便在线扩容，一旦到达上线。\n2. 配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。\n\n## redis异常处理\n\n### 缓存穿透（一直查询不到）\n\n```flow\nstart=>start: request\nend=>end: response\ncondition=>condition: redis缓存中是否存在\nop1=>operation: select in mysql\nstart->condition\ncondition(yes)->end\ncondition(no)->op1->end\n```\n\n如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。\n\n#### 布隆过滤器\n\n它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力\n\n#### 缓存空对象\n\n### 缓存击穿（量太大，缓存过期）\n\n活力集中在一个点（一个热评的点，如微博）。\n\n#### 加互斥锁\n\n#### 设置热点数据永不过期\n\n### 缓存雪崩\n\n在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。\n\n#### redis高可用\n\n#### 限流降级\n\n#### 数据预热\n\n正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。\n\n","slug":"redis","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q840020w5ihbhmmer5d","content":"<p>常用redis，深入了解redis的性能和瓶颈。<a href=\"https://github.com/antirez/redis\">reference</a></p>\n<a id=\"more\"></a>\n\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>redis: <strong>内存</strong>中的数据结构存储系统，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>，nosql的一种。</p>\n<h2 id=\"nosql\"><a href=\"#nosql\" class=\"headerlink\" title=\"nosql\"></a>nosql</h2><p>关系型数据库不够用，出来了nosql。。。</p>\n<ol>\n<li>一开始单体应用，小用户量能承受。但是当体量变大时：<ul>\n<li>数据量大</li>\n<li>数据的索引大</li>\n<li>访问量大</li>\n</ul>\n</li>\n<li>读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层<strong>memcache</strong>缓存</li>\n<li>集群（水平拆分）：上面的读写分离copy多份。</li>\n</ol>\n<p>mysql早些年使用的是MyISAM引擎，特性是<strong>表锁</strong>（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了<strong>行锁</strong>。</p>\n<p>不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。</li>\n<li>大数据量也高性能（写8万次/秒，读11万次/秒）</li>\n<li>多样型，不需要事先设计数据库</li>\n<li>没有固定的查询语言；最终一致性</li>\n<li>键值对存储，列存储，文档存储，图形存储库（社交）</li>\n<li>高性能、高可用、高可扩</li>\n<li>CAP、BASE，异地多活</li>\n<li>多样、实时、并发（Volume, Variety, Veiocity）</li>\n</ol>\n<p>与关系型一起使用。</p>\n<p>商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）</p>\n<p>商品的基本信息（价格、商家、名称）：MySQL</p>\n<p>图片：FastDFS, GFS, HDFS, OSS…</p>\n<p>商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）</p>\n<p>==没有什么不是加以层解决不了的==： 统一服务层。</p>\n<h3 id=\"文档型数据库\"><a href=\"#文档型数据库\" class=\"headerlink\" title=\"文档型数据库\"></a>文档型数据库</h3><p>MongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。</p>\n<h3 id=\"KV键值对\"><a href=\"#KV键值对\" class=\"headerlink\" title=\"KV键值对\"></a>KV键值对</h3><p>Redis，Tair</p>\n<h3 id=\"列存储数据库\"><a href=\"#列存储数据库\" class=\"headerlink\" title=\"列存储数据库\"></a>列存储数据库</h3><p>HBase（大数据）</p>\n<p>分布式文件系统</p>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>类似知识图谱，不是存储图形。主要用于存储社交网络。</p>\n<p>Neo4j，InfoGrid。</p>\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><p>Remote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。</p>\n<ul>\n<li>内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）</li>\n<li>计时器、计数器（浏览量）</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>安装后自带的测试工具</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-benchmark -h localhost -p 6379 -100 -n 100000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>默认16个数据库且使用的是第0个。 </p>\n<h3 id=\"GEOSPATIAL\"><a href=\"#GEOSPATIAL\" class=\"headerlink\" title=\"GEOSPATIAL\"></a>GEOSPATIAL</h3><p>地理位置，不仅仅是GET、SET！根据经纬度获取距离。</p>\n<h2 id=\"springboot集成\"><a href=\"#springboot集成\" class=\"headerlink\" title=\"springboot集成\"></a>springboot集成</h2><p>版本&lt;2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。</p>\n<p>版本&gt;2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p>\n<h2 id=\"rdb\"><a href=\"#rdb\" class=\"headerlink\" title=\"rdb\"></a>rdb</h2><p>为什么会有这个rdb？</p>\n<p>redis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\">condition&#x3D;&gt;condition: 触发rdb</span><br><span class=\"line\">rdbfile&#x3D;&gt;inputoutput: dump.rdb</span><br><span class=\"line\">operation&#x3D;&gt;operation: go on dealing with</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;rdbfile-&gt;end</span><br><span class=\"line\">condition(no)-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"触发机制\"><a href=\"#触发机制\" class=\"headerlink\" title=\"触发机制\"></a>触发机制</h4><ol>\n<li>save的规则</li>\n<li>执行flushall</li>\n<li>退出redis</li>\n</ol>\n<p>产生备份，会自动生成一个dump.rdb</p>\n<h4 id=\"用rdb恢复\"><a href=\"#用rdb恢复\" class=\"headerlink\" title=\"用rdb恢复\"></a>用rdb恢复</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config get dir</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li>适合大数据</li>\n<li>对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li>需要一定的时间间隔进程操作</li>\n<li>fork进程的时候会占用一定的内容空间</li>\n</ol>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2><p>Append Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。</p>\n<ul>\n<li>大数据的情况下效率会比较低。</li>\n<li>默认是不开启的。</li>\n</ul>\n<p>开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。</p>\n<p>修复aof文件 <code>redis-check-aof --fix</code></p>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据</li>\n<li>从不同步效率最高</li>\n</ol>\n<h3 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>相对于数据文件，aof远大于rdb，修复的速度比rdb慢</li>\n<li>默认是rdb，效率自然高于aof。</li>\n</ol>\n<p><strong>与rdb混合使用</strong></p>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。</p>\n<p>作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石</p>\n<p>reids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。</p>\n<p>默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。</p>\n<h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info replication # 查看当前库的信息</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下只用配置从机即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SLAVEOF ip:port # ip:port为主机</span><br></pre></td></tr></table></figure>\n\n<p>上面的是命令配置，只是暂时的。<strong>实际生产应该修改配置文件</strong>，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。</p>\n<h4 id=\"如果主机宕机了呢？\"><a href=\"#如果主机宕机了呢？\" class=\"headerlink\" title=\"如果主机宕机了呢？\"></a>如果主机宕机了呢？</h4><p>默认情况下，主机挂了以后，用<code>info replication</code>查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。</p>\n<p>更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。</p>\n<ul>\n<li>全量复制 master将整个数据传送到slaver</li>\n<li>增量复制</li>\n</ul>\n<p>只要重新链接master，一次全量复制将被自动执行</p>\n<h3 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h3><p>Sentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p>\n<p>哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>集群</li>\n<li>主从切换</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>不方便在线扩容，一旦到达上线。</li>\n<li>配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。</li>\n</ol>\n<h2 id=\"redis异常处理\"><a href=\"#redis异常处理\" class=\"headerlink\" title=\"redis异常处理\"></a>redis异常处理</h2><h3 id=\"缓存穿透（一直查询不到）\"><a href=\"#缓存穿透（一直查询不到）\" class=\"headerlink\" title=\"缓存穿透（一直查询不到）\"></a>缓存穿透（一直查询不到）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: request</span><br><span class=\"line\">end&#x3D;&gt;end: response</span><br><span class=\"line\">condition&#x3D;&gt;condition: redis缓存中是否存在</span><br><span class=\"line\">op1&#x3D;&gt;operation: select in mysql</span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;end</span><br><span class=\"line\">condition(no)-&gt;op1-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。</p>\n<h4 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h4><p>它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力</p>\n<h4 id=\"缓存空对象\"><a href=\"#缓存空对象\" class=\"headerlink\" title=\"缓存空对象\"></a>缓存空对象</h4><h3 id=\"缓存击穿（量太大，缓存过期）\"><a href=\"#缓存击穿（量太大，缓存过期）\" class=\"headerlink\" title=\"缓存击穿（量太大，缓存过期）\"></a>缓存击穿（量太大，缓存过期）</h3><p>活力集中在一个点（一个热评的点，如微博）。</p>\n<h4 id=\"加互斥锁\"><a href=\"#加互斥锁\" class=\"headerlink\" title=\"加互斥锁\"></a>加互斥锁</h4><h4 id=\"设置热点数据永不过期\"><a href=\"#设置热点数据永不过期\" class=\"headerlink\" title=\"设置热点数据永不过期\"></a>设置热点数据永不过期</h4><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。</p>\n<h4 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h4><h4 id=\"限流降级\"><a href=\"#限流降级\" class=\"headerlink\" title=\"限流降级\"></a>限流降级</h4><h4 id=\"数据预热\"><a href=\"#数据预热\" class=\"headerlink\" title=\"数据预热\"></a>数据预热</h4><p>正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>常用redis，深入了解redis的性能和瓶颈。<a href=\"https://github.com/antirez/redis\">reference</a></p>","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>redis: <strong>内存</strong>中的数据结构存储系统，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>，nosql的一种。</p>\n<h2 id=\"nosql\"><a href=\"#nosql\" class=\"headerlink\" title=\"nosql\"></a>nosql</h2><p>关系型数据库不够用，出来了nosql。。。</p>\n<ol>\n<li>一开始单体应用，小用户量能承受。但是当体量变大时：<ul>\n<li>数据量大</li>\n<li>数据的索引大</li>\n<li>访问量大</li>\n</ul>\n</li>\n<li>读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层<strong>memcache</strong>缓存</li>\n<li>集群（水平拆分）：上面的读写分离copy多份。</li>\n</ol>\n<p>mysql早些年使用的是MyISAM引擎，特性是<strong>表锁</strong>（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了<strong>行锁</strong>。</p>\n<p>不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。</li>\n<li>大数据量也高性能（写8万次/秒，读11万次/秒）</li>\n<li>多样型，不需要事先设计数据库</li>\n<li>没有固定的查询语言；最终一致性</li>\n<li>键值对存储，列存储，文档存储，图形存储库（社交）</li>\n<li>高性能、高可用、高可扩</li>\n<li>CAP、BASE，异地多活</li>\n<li>多样、实时、并发（Volume, Variety, Veiocity）</li>\n</ol>\n<p>与关系型一起使用。</p>\n<p>商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）</p>\n<p>商品的基本信息（价格、商家、名称）：MySQL</p>\n<p>图片：FastDFS, GFS, HDFS, OSS…</p>\n<p>商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）</p>\n<p>==没有什么不是加以层解决不了的==： 统一服务层。</p>\n<h3 id=\"文档型数据库\"><a href=\"#文档型数据库\" class=\"headerlink\" title=\"文档型数据库\"></a>文档型数据库</h3><p>MongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。</p>\n<h3 id=\"KV键值对\"><a href=\"#KV键值对\" class=\"headerlink\" title=\"KV键值对\"></a>KV键值对</h3><p>Redis，Tair</p>\n<h3 id=\"列存储数据库\"><a href=\"#列存储数据库\" class=\"headerlink\" title=\"列存储数据库\"></a>列存储数据库</h3><p>HBase（大数据）</p>\n<p>分布式文件系统</p>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>类似知识图谱，不是存储图形。主要用于存储社交网络。</p>\n<p>Neo4j，InfoGrid。</p>\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><p>Remote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。</p>\n<ul>\n<li>内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）</li>\n<li>计时器、计数器（浏览量）</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>安装后自带的测试工具</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-benchmark -h localhost -p 6379 -100 -n 100000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>默认16个数据库且使用的是第0个。 </p>\n<h3 id=\"GEOSPATIAL\"><a href=\"#GEOSPATIAL\" class=\"headerlink\" title=\"GEOSPATIAL\"></a>GEOSPATIAL</h3><p>地理位置，不仅仅是GET、SET！根据经纬度获取距离。</p>\n<h2 id=\"springboot集成\"><a href=\"#springboot集成\" class=\"headerlink\" title=\"springboot集成\"></a>springboot集成</h2><p>版本&lt;2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。</p>\n<p>版本&gt;2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p>\n<h2 id=\"rdb\"><a href=\"#rdb\" class=\"headerlink\" title=\"rdb\"></a>rdb</h2><p>为什么会有这个rdb？</p>\n<p>redis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\">condition&#x3D;&gt;condition: 触发rdb</span><br><span class=\"line\">rdbfile&#x3D;&gt;inputoutput: dump.rdb</span><br><span class=\"line\">operation&#x3D;&gt;operation: go on dealing with</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;rdbfile-&gt;end</span><br><span class=\"line\">condition(no)-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"触发机制\"><a href=\"#触发机制\" class=\"headerlink\" title=\"触发机制\"></a>触发机制</h4><ol>\n<li>save的规则</li>\n<li>执行flushall</li>\n<li>退出redis</li>\n</ol>\n<p>产生备份，会自动生成一个dump.rdb</p>\n<h4 id=\"用rdb恢复\"><a href=\"#用rdb恢复\" class=\"headerlink\" title=\"用rdb恢复\"></a>用rdb恢复</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config get dir</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li>适合大数据</li>\n<li>对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li>需要一定的时间间隔进程操作</li>\n<li>fork进程的时候会占用一定的内容空间</li>\n</ol>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2><p>Append Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。</p>\n<ul>\n<li>大数据的情况下效率会比较低。</li>\n<li>默认是不开启的。</li>\n</ul>\n<p>开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。</p>\n<p>修复aof文件 <code>redis-check-aof --fix</code></p>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据</li>\n<li>从不同步效率最高</li>\n</ol>\n<h3 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>相对于数据文件，aof远大于rdb，修复的速度比rdb慢</li>\n<li>默认是rdb，效率自然高于aof。</li>\n</ol>\n<p><strong>与rdb混合使用</strong></p>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。</p>\n<p>作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石</p>\n<p>reids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。</p>\n<p>默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。</p>\n<h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info replication # 查看当前库的信息</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下只用配置从机即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SLAVEOF ip:port # ip:port为主机</span><br></pre></td></tr></table></figure>\n\n<p>上面的是命令配置，只是暂时的。<strong>实际生产应该修改配置文件</strong>，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。</p>\n<h4 id=\"如果主机宕机了呢？\"><a href=\"#如果主机宕机了呢？\" class=\"headerlink\" title=\"如果主机宕机了呢？\"></a>如果主机宕机了呢？</h4><p>默认情况下，主机挂了以后，用<code>info replication</code>查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。</p>\n<p>更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。</p>\n<ul>\n<li>全量复制 master将整个数据传送到slaver</li>\n<li>增量复制</li>\n</ul>\n<p>只要重新链接master，一次全量复制将被自动执行</p>\n<h3 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h3><p>Sentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p>\n<p>哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>集群</li>\n<li>主从切换</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>不方便在线扩容，一旦到达上线。</li>\n<li>配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。</li>\n</ol>\n<h2 id=\"redis异常处理\"><a href=\"#redis异常处理\" class=\"headerlink\" title=\"redis异常处理\"></a>redis异常处理</h2><h3 id=\"缓存穿透（一直查询不到）\"><a href=\"#缓存穿透（一直查询不到）\" class=\"headerlink\" title=\"缓存穿透（一直查询不到）\"></a>缓存穿透（一直查询不到）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: request</span><br><span class=\"line\">end&#x3D;&gt;end: response</span><br><span class=\"line\">condition&#x3D;&gt;condition: redis缓存中是否存在</span><br><span class=\"line\">op1&#x3D;&gt;operation: select in mysql</span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;end</span><br><span class=\"line\">condition(no)-&gt;op1-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。</p>\n<h4 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h4><p>它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力</p>\n<h4 id=\"缓存空对象\"><a href=\"#缓存空对象\" class=\"headerlink\" title=\"缓存空对象\"></a>缓存空对象</h4><h3 id=\"缓存击穿（量太大，缓存过期）\"><a href=\"#缓存击穿（量太大，缓存过期）\" class=\"headerlink\" title=\"缓存击穿（量太大，缓存过期）\"></a>缓存击穿（量太大，缓存过期）</h3><p>活力集中在一个点（一个热评的点，如微博）。</p>\n<h4 id=\"加互斥锁\"><a href=\"#加互斥锁\" class=\"headerlink\" title=\"加互斥锁\"></a>加互斥锁</h4><h4 id=\"设置热点数据永不过期\"><a href=\"#设置热点数据永不过期\" class=\"headerlink\" title=\"设置热点数据永不过期\"></a>设置热点数据永不过期</h4><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。</p>\n<h4 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h4><h4 id=\"限流降级\"><a href=\"#限流降级\" class=\"headerlink\" title=\"限流降级\"></a>限流降级</h4><h4 id=\"数据预热\"><a href=\"#数据预热\" class=\"headerlink\" title=\"数据预热\"></a>数据预热</h4><p>正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。</p>"},{"title":"Springboot-servlet","date":"2021-02-28T14:01:17.000Z","_content":"\n这篇探究SpringBoot的内置servlet容器。\n\n<!-- more -->\n\n<!-- toc -->\n\n自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。\n\n# 入口\n\n之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫`onRefresh()`的方法，用到了**模板方法**，让子类复写来完成特定工作的，之前也提到过，在类`SpringApplication`初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被`ServletWebServerApplicationContext`重写：\n\n```java\n@Override\nprotected void onRefresh() {\n    super.onRefresh();\n    try {\n        // 创建web服务器！\n        createWebServer();\n    }\n    catch (Throwable ex) {\n        throw new ApplicationContextException(\"Unable to start web server\", ex);\n    }\n}\n```\n\n\n\n# 创建服务\n\n入口找到后，接下来我们分析他是如何创建的：\n\n```java\nprivate void createWebServer() {\n    // volatile标志的引用\n    WebServer webServer = this.webServer;\n    // 从抽象类（父类）中获取servlet容器\n    ServletContext servletContext = getServletContext();\n    // 判断获取到的容器是否为null\n    if (webServer == null && servletContext == null) {\n        // 为null就从web服务器工厂建一个\n        ServletWebServerFactory factory = getWebServerFactory();\n        // 从这里获取到web服务器！入参还有初始化器！\n        this.webServer = factory.getWebServer(getSelfInitializer());\n        getBeanFactory().registerSingleton(\"webServerGracefulShutdown\",\n                                           new WebServerGracefulShutdownLifecycle(this.webServer));\n        getBeanFactory().registerSingleton(\"webServerStartStop\",\n                                           new WebServerStartStopLifecycle(this, this.webServer));\n    }\n    // 不为null就启动它\n    else if (servletContext != null) {\n        try {\n            getSelfInitializer().onStartup(servletContext);\n        }\n        catch (ServletException ex) {\n            throw new ApplicationContextException(\"Cannot initialize servlet context\", ex);\n        }\n    }\n    initPropertySources();\n}\n```\n\n## getWebServerFactory\n\n工厂哪里来？回顾之前的就可以猜到，SPI！\n\n```java\nprotected ServletWebServerFactory getWebServerFactory() {\n    // Use bean names so that we don't consider the hierarchy\n    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);\n    if (beanNames.length == 0) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to missing \"\n                                              + \"ServletWebServerFactory bean.\");\n    }\n    if (beanNames.length > 1) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to multiple \"\n                                              + \"ServletWebServerFactory beans : \" + StringUtils.arrayToCommaDelimitedString(beanNames));\n    }\n    return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);\n}\n```\n\n## getSelfInitializer\n\n看看如何获取到初始化器：\n\n```java\nprivate org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {\n    return this::selfInitialize;\n}\n```\n\n这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。\n\n# getWebServer\n\n```java\npublic WebServer getWebServer(ServletContextInitializer... initializers) {\n    if (this.disableMBeanRegistry) {\n        Registry.disableRegistry();\n    }\n    // 创建tomcat实例\n    Tomcat tomcat = new Tomcat();\n    File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");\n    // 设置属性\n    tomcat.setBaseDir(baseDir.getAbsolutePath());\n    Connector connector = new Connector(this.protocol);\n    connector.setThrowOnFailure(true);\n    tomcat.getService().addConnector(connector);\n    customizeConnector(connector);\n    tomcat.setConnector(connector);\n    tomcat.getHost().setAutoDeploy(false);\n    configureEngine(tomcat.getEngine());\n    for (Connector additionalConnector : this.additionalTomcatConnectors) {\n        tomcat.getService().addConnector(additionalConnector);\n    }\n    // 准备\n    prepareContext(tomcat.getHost(), initializers);\n    // 获取\n    return getTomcatWebServer(tomcat);\n}\n```\n\n我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:\n\n```java\nprotected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {\n    // 继续调用有有参方法\n    return new TomcatWebServer(tomcat, getPort() >= 0, getShutdown());\n}\n```\n\n```java\npublic TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) {\n    Assert.notNull(tomcat, \"Tomcat Server must not be null\");\n    this.tomcat = tomcat;\n    this.autoStart = autoStart;\n    this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(tomcat) : null;\n    // 初始化\n    initialize();\n}\n\nprivate void initialize() throws WebServerException {\n    logger.info(\"Tomcat initialized with port(s): \" + getPortsDescription(false));\n    synchronized (this.monitor) {\n        try {\n            addInstanceIdToEngineName();\n\n            Context context = findContext();\n            context.addLifecycleListener((event) -> {\n                if (context.equals(event.getSource()) && Lifecycle.START_EVENT.equals(event.getType())) {\n                    // Remove service connectors so that protocol binding doesn't\n                    // happen when the service is started.\n                    removeServiceConnectors();\n                }\n            });\n\n            // Start the server to trigger initialization listeners\n            this.tomcat.start();\n\n            // We can re-throw failure exception directly in the main thread\n            rethrowDeferredStartupExceptions();\n\n            try {\n                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());\n            }\n            catch (NamingException ex) {\n                // Naming is not enabled. Continue\n            }\n\n            // Unlike Jetty, all Tomcat threads are daemon threads. We create a\n            // blocking non-daemon to stop immediate shutdown\n            startDaemonAwaitThread();\n        }\n        catch (Exception ex) {\n            stopSilently();\n            destroySilently();\n            throw new WebServerException(\"Unable to start embedded Tomcat\", ex);\n        }\n    }\n}\n```\n\n在上面的初始化的方法中，我们找到了启动的地方。","source":"_posts/springboot-servlet.md","raw":"---\ntitle: Springboot-servlet\ndate: 2021-02-28 22:01:17\ncategories: springboot\ntags: source\n---\n\n这篇探究SpringBoot的内置servlet容器。\n\n<!-- more -->\n\n<!-- toc -->\n\n自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。\n\n# 入口\n\n之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫`onRefresh()`的方法，用到了**模板方法**，让子类复写来完成特定工作的，之前也提到过，在类`SpringApplication`初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被`ServletWebServerApplicationContext`重写：\n\n```java\n@Override\nprotected void onRefresh() {\n    super.onRefresh();\n    try {\n        // 创建web服务器！\n        createWebServer();\n    }\n    catch (Throwable ex) {\n        throw new ApplicationContextException(\"Unable to start web server\", ex);\n    }\n}\n```\n\n\n\n# 创建服务\n\n入口找到后，接下来我们分析他是如何创建的：\n\n```java\nprivate void createWebServer() {\n    // volatile标志的引用\n    WebServer webServer = this.webServer;\n    // 从抽象类（父类）中获取servlet容器\n    ServletContext servletContext = getServletContext();\n    // 判断获取到的容器是否为null\n    if (webServer == null && servletContext == null) {\n        // 为null就从web服务器工厂建一个\n        ServletWebServerFactory factory = getWebServerFactory();\n        // 从这里获取到web服务器！入参还有初始化器！\n        this.webServer = factory.getWebServer(getSelfInitializer());\n        getBeanFactory().registerSingleton(\"webServerGracefulShutdown\",\n                                           new WebServerGracefulShutdownLifecycle(this.webServer));\n        getBeanFactory().registerSingleton(\"webServerStartStop\",\n                                           new WebServerStartStopLifecycle(this, this.webServer));\n    }\n    // 不为null就启动它\n    else if (servletContext != null) {\n        try {\n            getSelfInitializer().onStartup(servletContext);\n        }\n        catch (ServletException ex) {\n            throw new ApplicationContextException(\"Cannot initialize servlet context\", ex);\n        }\n    }\n    initPropertySources();\n}\n```\n\n## getWebServerFactory\n\n工厂哪里来？回顾之前的就可以猜到，SPI！\n\n```java\nprotected ServletWebServerFactory getWebServerFactory() {\n    // Use bean names so that we don't consider the hierarchy\n    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);\n    if (beanNames.length == 0) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to missing \"\n                                              + \"ServletWebServerFactory bean.\");\n    }\n    if (beanNames.length > 1) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to multiple \"\n                                              + \"ServletWebServerFactory beans : \" + StringUtils.arrayToCommaDelimitedString(beanNames));\n    }\n    return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);\n}\n```\n\n## getSelfInitializer\n\n看看如何获取到初始化器：\n\n```java\nprivate org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {\n    return this::selfInitialize;\n}\n```\n\n这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。\n\n# getWebServer\n\n```java\npublic WebServer getWebServer(ServletContextInitializer... initializers) {\n    if (this.disableMBeanRegistry) {\n        Registry.disableRegistry();\n    }\n    // 创建tomcat实例\n    Tomcat tomcat = new Tomcat();\n    File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");\n    // 设置属性\n    tomcat.setBaseDir(baseDir.getAbsolutePath());\n    Connector connector = new Connector(this.protocol);\n    connector.setThrowOnFailure(true);\n    tomcat.getService().addConnector(connector);\n    customizeConnector(connector);\n    tomcat.setConnector(connector);\n    tomcat.getHost().setAutoDeploy(false);\n    configureEngine(tomcat.getEngine());\n    for (Connector additionalConnector : this.additionalTomcatConnectors) {\n        tomcat.getService().addConnector(additionalConnector);\n    }\n    // 准备\n    prepareContext(tomcat.getHost(), initializers);\n    // 获取\n    return getTomcatWebServer(tomcat);\n}\n```\n\n我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:\n\n```java\nprotected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {\n    // 继续调用有有参方法\n    return new TomcatWebServer(tomcat, getPort() >= 0, getShutdown());\n}\n```\n\n```java\npublic TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) {\n    Assert.notNull(tomcat, \"Tomcat Server must not be null\");\n    this.tomcat = tomcat;\n    this.autoStart = autoStart;\n    this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(tomcat) : null;\n    // 初始化\n    initialize();\n}\n\nprivate void initialize() throws WebServerException {\n    logger.info(\"Tomcat initialized with port(s): \" + getPortsDescription(false));\n    synchronized (this.monitor) {\n        try {\n            addInstanceIdToEngineName();\n\n            Context context = findContext();\n            context.addLifecycleListener((event) -> {\n                if (context.equals(event.getSource()) && Lifecycle.START_EVENT.equals(event.getType())) {\n                    // Remove service connectors so that protocol binding doesn't\n                    // happen when the service is started.\n                    removeServiceConnectors();\n                }\n            });\n\n            // Start the server to trigger initialization listeners\n            this.tomcat.start();\n\n            // We can re-throw failure exception directly in the main thread\n            rethrowDeferredStartupExceptions();\n\n            try {\n                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());\n            }\n            catch (NamingException ex) {\n                // Naming is not enabled. Continue\n            }\n\n            // Unlike Jetty, all Tomcat threads are daemon threads. We create a\n            // blocking non-daemon to stop immediate shutdown\n            startDaemonAwaitThread();\n        }\n        catch (Exception ex) {\n            stopSilently();\n            destroySilently();\n            throw new WebServerException(\"Unable to start embedded Tomcat\", ex);\n        }\n    }\n}\n```\n\n在上面的初始化的方法中，我们找到了启动的地方。","slug":"springboot-servlet","published":1,"updated":"2021-03-02T15:48:34.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q870024w5ihg38x2fc4","content":"<p>这篇探究SpringBoot的内置servlet容器。</p>\n<a id=\"more\"></a>\n\n<!-- toc -->\n\n<p>自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。</p>\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫<code>onRefresh()</code>的方法，用到了<strong>模板方法</strong>，让子类复写来完成特定工作的，之前也提到过，在类<code>SpringApplication</code>初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被<code>ServletWebServerApplicationContext</code>重写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRefresh();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建web服务器！</span></span><br><span class=\"line\">        createWebServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"创建服务\"><a href=\"#创建服务\" class=\"headerlink\" title=\"创建服务\"></a>创建服务</h1><p>入口找到后，接下来我们分析他是如何创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createWebServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// volatile标志的引用</span></span><br><span class=\"line\">    WebServer webServer = <span class=\"keyword\">this</span>.webServer;</span><br><span class=\"line\">    <span class=\"comment\">// 从抽象类（父类）中获取servlet容器</span></span><br><span class=\"line\">    ServletContext servletContext = getServletContext();</span><br><span class=\"line\">    <span class=\"comment\">// 判断获取到的容器是否为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (webServer == <span class=\"keyword\">null</span> &amp;&amp; servletContext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为null就从web服务器工厂建一个</span></span><br><span class=\"line\">        ServletWebServerFactory factory = getWebServerFactory();</span><br><span class=\"line\">        <span class=\"comment\">// 从这里获取到web服务器！入参还有初始化器！</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerGracefulShutdownLifecycle(<span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerStartStop&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerStartStopLifecycle(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为null就启动它</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (servletContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            getSelfInitializer().onStartup(servletContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initPropertySources();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getWebServerFactory\"><a href=\"#getWebServerFactory\" class=\"headerlink\" title=\"getWebServerFactory\"></a>getWebServerFactory</h2><p>工厂哪里来？回顾之前的就可以猜到，SPI！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ServletWebServerFactory <span class=\"title\">getWebServerFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use bean names so that we don&#x27;t consider the hierarchy</span></span><br><span class=\"line\">    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory bean.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory beans : &quot;</span> + StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getBeanFactory().getBean(beanNames[<span class=\"number\">0</span>], ServletWebServerFactory.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getSelfInitializer\"><a href=\"#getSelfInitializer\" class=\"headerlink\" title=\"getSelfInitializer\"></a>getSelfInitializer</h2><p>看看如何获取到初始化器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> org.springframework.boot.web.servlet.<span class=\"function\">ServletContextInitializer <span class=\"title\">getSelfInitializer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>::selfInitialize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。</p>\n<h1 id=\"getWebServer\"><a href=\"#getWebServer\" class=\"headerlink\" title=\"getWebServer\"></a>getWebServer</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebServer <span class=\"title\">getWebServer</span><span class=\"params\">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.disableMBeanRegistry) &#123;</span><br><span class=\"line\">        Registry.disableRegistry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建tomcat实例</span></span><br><span class=\"line\">    Tomcat tomcat = <span class=\"keyword\">new</span> Tomcat();</span><br><span class=\"line\">    File baseDir = (<span class=\"keyword\">this</span>.baseDirectory != <span class=\"keyword\">null</span>) ? <span class=\"keyword\">this</span>.baseDirectory : createTempDir(<span class=\"string\">&quot;tomcat&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class=\"line\">    Connector connector = <span class=\"keyword\">new</span> Connector(<span class=\"keyword\">this</span>.protocol);</span><br><span class=\"line\">    connector.setThrowOnFailure(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    tomcat.getService().addConnector(connector);</span><br><span class=\"line\">    customizeConnector(connector);</span><br><span class=\"line\">    tomcat.setConnector(connector);</span><br><span class=\"line\">    tomcat.getHost().setAutoDeploy(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    configureEngine(tomcat.getEngine());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Connector additionalConnector : <span class=\"keyword\">this</span>.additionalTomcatConnectors) &#123;</span><br><span class=\"line\">        tomcat.getService().addConnector(additionalConnector);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 准备</span></span><br><span class=\"line\">    prepareContext(tomcat.getHost(), initializers);</span><br><span class=\"line\">    <span class=\"comment\">// 获取</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTomcatWebServer(tomcat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> TomcatWebServer <span class=\"title\">getTomcatWebServer</span><span class=\"params\">(Tomcat tomcat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 继续调用有有参方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class=\"number\">0</span>, getShutdown());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TomcatWebServer</span><span class=\"params\">(Tomcat tomcat, <span class=\"keyword\">boolean</span> autoStart, Shutdown shutdown)</span> </span>&#123;</span><br><span class=\"line\">    Assert.notNull(tomcat, <span class=\"string\">&quot;Tomcat Server must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tomcat = tomcat;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.autoStart = autoStart;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? <span class=\"keyword\">new</span> GracefulShutdown(tomcat) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> WebServerException </span>&#123;</span><br><span class=\"line\">    logger.info(<span class=\"string\">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class=\"keyword\">false</span>));</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.monitor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            addInstanceIdToEngineName();</span><br><span class=\"line\"></span><br><span class=\"line\">            Context context = findContext();</span><br><span class=\"line\">            context.addLifecycleListener((event) -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class=\"line\">                    <span class=\"comment\">// happen when the service is started.</span></span><br><span class=\"line\">                    removeServiceConnectors();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start the server to trigger initialization listeners</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tomcat.start();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// We can re-throw failure exception directly in the main thread</span></span><br><span class=\"line\">            rethrowDeferredStartupExceptions();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (NamingException ex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Naming is not enabled. Continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class=\"line\">            <span class=\"comment\">// blocking non-daemon to stop immediate shutdown</span></span><br><span class=\"line\">            startDaemonAwaitThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            stopSilently();</span><br><span class=\"line\">            destroySilently();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> WebServerException(<span class=\"string\">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的初始化的方法中，我们找到了启动的地方。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇探究SpringBoot的内置servlet容器。</p>","more":"<!-- toc -->\n\n<p>自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。</p>\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫<code>onRefresh()</code>的方法，用到了<strong>模板方法</strong>，让子类复写来完成特定工作的，之前也提到过，在类<code>SpringApplication</code>初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被<code>ServletWebServerApplicationContext</code>重写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRefresh();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建web服务器！</span></span><br><span class=\"line\">        createWebServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"创建服务\"><a href=\"#创建服务\" class=\"headerlink\" title=\"创建服务\"></a>创建服务</h1><p>入口找到后，接下来我们分析他是如何创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createWebServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// volatile标志的引用</span></span><br><span class=\"line\">    WebServer webServer = <span class=\"keyword\">this</span>.webServer;</span><br><span class=\"line\">    <span class=\"comment\">// 从抽象类（父类）中获取servlet容器</span></span><br><span class=\"line\">    ServletContext servletContext = getServletContext();</span><br><span class=\"line\">    <span class=\"comment\">// 判断获取到的容器是否为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (webServer == <span class=\"keyword\">null</span> &amp;&amp; servletContext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为null就从web服务器工厂建一个</span></span><br><span class=\"line\">        ServletWebServerFactory factory = getWebServerFactory();</span><br><span class=\"line\">        <span class=\"comment\">// 从这里获取到web服务器！入参还有初始化器！</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerGracefulShutdownLifecycle(<span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerStartStop&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerStartStopLifecycle(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为null就启动它</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (servletContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            getSelfInitializer().onStartup(servletContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initPropertySources();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getWebServerFactory\"><a href=\"#getWebServerFactory\" class=\"headerlink\" title=\"getWebServerFactory\"></a>getWebServerFactory</h2><p>工厂哪里来？回顾之前的就可以猜到，SPI！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ServletWebServerFactory <span class=\"title\">getWebServerFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use bean names so that we don&#x27;t consider the hierarchy</span></span><br><span class=\"line\">    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory bean.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory beans : &quot;</span> + StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getBeanFactory().getBean(beanNames[<span class=\"number\">0</span>], ServletWebServerFactory.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getSelfInitializer\"><a href=\"#getSelfInitializer\" class=\"headerlink\" title=\"getSelfInitializer\"></a>getSelfInitializer</h2><p>看看如何获取到初始化器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> org.springframework.boot.web.servlet.<span class=\"function\">ServletContextInitializer <span class=\"title\">getSelfInitializer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>::selfInitialize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。</p>\n<h1 id=\"getWebServer\"><a href=\"#getWebServer\" class=\"headerlink\" title=\"getWebServer\"></a>getWebServer</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebServer <span class=\"title\">getWebServer</span><span class=\"params\">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.disableMBeanRegistry) &#123;</span><br><span class=\"line\">        Registry.disableRegistry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建tomcat实例</span></span><br><span class=\"line\">    Tomcat tomcat = <span class=\"keyword\">new</span> Tomcat();</span><br><span class=\"line\">    File baseDir = (<span class=\"keyword\">this</span>.baseDirectory != <span class=\"keyword\">null</span>) ? <span class=\"keyword\">this</span>.baseDirectory : createTempDir(<span class=\"string\">&quot;tomcat&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class=\"line\">    Connector connector = <span class=\"keyword\">new</span> Connector(<span class=\"keyword\">this</span>.protocol);</span><br><span class=\"line\">    connector.setThrowOnFailure(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    tomcat.getService().addConnector(connector);</span><br><span class=\"line\">    customizeConnector(connector);</span><br><span class=\"line\">    tomcat.setConnector(connector);</span><br><span class=\"line\">    tomcat.getHost().setAutoDeploy(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    configureEngine(tomcat.getEngine());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Connector additionalConnector : <span class=\"keyword\">this</span>.additionalTomcatConnectors) &#123;</span><br><span class=\"line\">        tomcat.getService().addConnector(additionalConnector);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 准备</span></span><br><span class=\"line\">    prepareContext(tomcat.getHost(), initializers);</span><br><span class=\"line\">    <span class=\"comment\">// 获取</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTomcatWebServer(tomcat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> TomcatWebServer <span class=\"title\">getTomcatWebServer</span><span class=\"params\">(Tomcat tomcat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 继续调用有有参方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class=\"number\">0</span>, getShutdown());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TomcatWebServer</span><span class=\"params\">(Tomcat tomcat, <span class=\"keyword\">boolean</span> autoStart, Shutdown shutdown)</span> </span>&#123;</span><br><span class=\"line\">    Assert.notNull(tomcat, <span class=\"string\">&quot;Tomcat Server must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tomcat = tomcat;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.autoStart = autoStart;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? <span class=\"keyword\">new</span> GracefulShutdown(tomcat) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> WebServerException </span>&#123;</span><br><span class=\"line\">    logger.info(<span class=\"string\">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class=\"keyword\">false</span>));</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.monitor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            addInstanceIdToEngineName();</span><br><span class=\"line\"></span><br><span class=\"line\">            Context context = findContext();</span><br><span class=\"line\">            context.addLifecycleListener((event) -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class=\"line\">                    <span class=\"comment\">// happen when the service is started.</span></span><br><span class=\"line\">                    removeServiceConnectors();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start the server to trigger initialization listeners</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tomcat.start();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// We can re-throw failure exception directly in the main thread</span></span><br><span class=\"line\">            rethrowDeferredStartupExceptions();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (NamingException ex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Naming is not enabled. Continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class=\"line\">            <span class=\"comment\">// blocking non-daemon to stop immediate shutdown</span></span><br><span class=\"line\">            startDaemonAwaitThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            stopSilently();</span><br><span class=\"line\">            destroySilently();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> WebServerException(<span class=\"string\">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的初始化的方法中，我们找到了启动的地方。</p>"},{"title":"subarray","date":"2021-02-27T05:45:38.000Z","_content":"\n这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的`map` + `preSum`，双指针的思路是很容易理解的，后者需要绕个弯。\n\n<!-- more -->\n\n<!--toc-->\n\n# [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\n\nGiven an array of integers `nums` and an integer `k`, return *the total number of continuous subarrays whose sum equals to `k`*.\n\n以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：\n\n```java\npublic int subarraySum(int[] nums, int k){\n    int res = 0;\n    for(int lo = 0, hi = 0, sum = 0; hi < nums.length; hi++){\n        sum += nums[i];\n        whlie(lo < nums.length && sum > k){\n            sum -= nums[lo++];\n        }\n        if(sum == k) res++;\n    }\n    \n    return res;\n}\n```\n\n如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的**Constraints**：\n\n- `1 <= nums.length <= 2 * 104`\n- `-1000 <= nums[i] <= 1000`\n- `-107 <= k <= 107`\n\n注意到了么，给的入参中数字是可以为负数的，在代码中`sum-= nums[lo++]`是无效的，如果入参都是正数，双指针就是OK的。\n\n## map + preSum\n\n​\t\t与双指针不同的是，这种解法用到了额外的数据结构`map`，在这里关于映射表的用法也有多种。另外一个`preSum`很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：\n\n有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么`P5 - P2`是12，正是子串\\[2, 3\\]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：`Px - Py = target (x > y)`，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：`Px - target = Py`，然后统计有多少个符合的子数组即可，这样我们的map可以定义为*Map\\<Integer, Integer\\>*，用来保存*当前的数组和*和*数组和的个数*。\n\n```java\npublic int subarraySum(int[] nums, int k){\n    if(nums.length == 0) return 0;\n    Map<Integer, Integer> map new HashMap<>();\n    int sum = 0, result = 0;\n    for(int cur : nums){\n        sum += cur; // preSum\n        if(sum == k) result++; //也可以提前在map中放入 map.put(0, 1)\n        result += map.getOrDefault(sum - k, 0);\n        map.put(sum, map.getOrDefault(sum, 0) + 1);\n    }\n    \n    return result;\n}\n```\n\n通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：`sum(i, j) = sum(0, j) - sum(0, i)`。\n\n# [Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero)\n\nYou are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn *the **minimum number** of operations to reduce* `x` *to **exactly*** `0` *if it's possible**, otherwise, return* `-1`.\n\n**Constraints:**\n\n- `1 <= nums.length <= 105`\n- `1 <= nums[i] <= 104`\n- `1 <= x <= 109`\n\n​\t\t以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。\n\n由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：\n\n```java\npublic int minOperations(int[] nums, int x){\n    int target = Arrays.stream(nums).sum() - x;\n    int size = -1, n = nums.length;\n    for(int lo = 0, hi = 0, sum = 0; hi < n; hi++){\n        sum += nums[hi];\n        while(lo < n && sum > target){\n            sum -= nums[lo++];\n        }\n        if(sum == target) size = Math.max(size, hi - lo + 1);\n    }\n    return size < 0 ? -1 : n - size;\n}\n```\n\n也能使用前缀和：\n\n```java\npublic int minOperations(int[] nums, int x) {\n    int target = Arrays.stream(nums).sum() - x;\n    if(target == 0) return nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);// 长度，下面是 i - map.value\n    int sum = 0, res = 0;\n    for(int i=0; i<nums.length; i++){\n        int num = nums[i];\n        sum += num;\n        if(map.containsKey(sum - target)){\n            res = Math.max(res, i - map.get(sum - target));\n        }\n        map.put(sum, i);\n    }\n\n    return res == 0 ? -1 : nums.length - res;\n}\n```\n\n","source":"_posts/subarray.md","raw":"---\ntitle: subarray\ndate: 2021-02-27 13:45:38\ncategories: Leetcode\ntags: \n- double poiters\n- map+preSum\n---\n\n这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的`map` + `preSum`，双指针的思路是很容易理解的，后者需要绕个弯。\n\n<!-- more -->\n\n<!--toc-->\n\n# [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\n\nGiven an array of integers `nums` and an integer `k`, return *the total number of continuous subarrays whose sum equals to `k`*.\n\n以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：\n\n```java\npublic int subarraySum(int[] nums, int k){\n    int res = 0;\n    for(int lo = 0, hi = 0, sum = 0; hi < nums.length; hi++){\n        sum += nums[i];\n        whlie(lo < nums.length && sum > k){\n            sum -= nums[lo++];\n        }\n        if(sum == k) res++;\n    }\n    \n    return res;\n}\n```\n\n如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的**Constraints**：\n\n- `1 <= nums.length <= 2 * 104`\n- `-1000 <= nums[i] <= 1000`\n- `-107 <= k <= 107`\n\n注意到了么，给的入参中数字是可以为负数的，在代码中`sum-= nums[lo++]`是无效的，如果入参都是正数，双指针就是OK的。\n\n## map + preSum\n\n​\t\t与双指针不同的是，这种解法用到了额外的数据结构`map`，在这里关于映射表的用法也有多种。另外一个`preSum`很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：\n\n有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么`P5 - P2`是12，正是子串\\[2, 3\\]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：`Px - Py = target (x > y)`，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：`Px - target = Py`，然后统计有多少个符合的子数组即可，这样我们的map可以定义为*Map\\<Integer, Integer\\>*，用来保存*当前的数组和*和*数组和的个数*。\n\n```java\npublic int subarraySum(int[] nums, int k){\n    if(nums.length == 0) return 0;\n    Map<Integer, Integer> map new HashMap<>();\n    int sum = 0, result = 0;\n    for(int cur : nums){\n        sum += cur; // preSum\n        if(sum == k) result++; //也可以提前在map中放入 map.put(0, 1)\n        result += map.getOrDefault(sum - k, 0);\n        map.put(sum, map.getOrDefault(sum, 0) + 1);\n    }\n    \n    return result;\n}\n```\n\n通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：`sum(i, j) = sum(0, j) - sum(0, i)`。\n\n# [Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero)\n\nYou are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn *the **minimum number** of operations to reduce* `x` *to **exactly*** `0` *if it's possible**, otherwise, return* `-1`.\n\n**Constraints:**\n\n- `1 <= nums.length <= 105`\n- `1 <= nums[i] <= 104`\n- `1 <= x <= 109`\n\n​\t\t以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。\n\n由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：\n\n```java\npublic int minOperations(int[] nums, int x){\n    int target = Arrays.stream(nums).sum() - x;\n    int size = -1, n = nums.length;\n    for(int lo = 0, hi = 0, sum = 0; hi < n; hi++){\n        sum += nums[hi];\n        while(lo < n && sum > target){\n            sum -= nums[lo++];\n        }\n        if(sum == target) size = Math.max(size, hi - lo + 1);\n    }\n    return size < 0 ? -1 : n - size;\n}\n```\n\n也能使用前缀和：\n\n```java\npublic int minOperations(int[] nums, int x) {\n    int target = Arrays.stream(nums).sum() - x;\n    if(target == 0) return nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);// 长度，下面是 i - map.value\n    int sum = 0, res = 0;\n    for(int i=0; i<nums.length; i++){\n        int num = nums[i];\n        sum += num;\n        if(map.containsKey(sum - target)){\n            res = Math.max(res, i - map.get(sum - target));\n        }\n        map.put(sum, i);\n    }\n\n    return res == 0 ? -1 : nums.length - res;\n}\n```\n\n","slug":"subarray","published":1,"updated":"2021-02-27T07:35:51.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q890028w5ihdly0flea","content":"<p>这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的<code>map</code> + <code>preSum</code>，双指针的思路是很容易理解的，后者需要绕个弯。</p>\n<a id=\"more\"></a>\n\n<!--toc-->\n\n<h1 id=\"Subarray-Sum-Equals-K\"><a href=\"#Subarray-Sum-Equals-K\" class=\"headerlink\" title=\"Subarray Sum Equals K\"></a><a href=\"https://leetcode.com/problems/subarray-sum-equals-k/\">Subarray Sum Equals K</a></h1><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.</p>\n<p>以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; nums.length; hi++)&#123;</span><br><span class=\"line\">        sum += nums[i];</span><br><span class=\"line\">        whlie(lo &lt; nums.length &amp;&amp; sum &gt; k)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) res++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的<strong>Constraints</strong>：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>\n<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n<li><code>-107 &lt;= k &lt;= 107</code></li>\n</ul>\n<p>注意到了么，给的入参中数字是可以为负数的，在代码中<code>sum-= nums[lo++]</code>是无效的，如果入参都是正数，双指针就是OK的。</p>\n<h2 id=\"map-preSum\"><a href=\"#map-preSum\" class=\"headerlink\" title=\"map + preSum\"></a>map + preSum</h2><p>​        与双指针不同的是，这种解法用到了额外的数据结构<code>map</code>，在这里关于映射表的用法也有多种。另外一个<code>preSum</code>很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：</p>\n<p>有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么<code>P5 - P2</code>是12，正是子串[2, 3]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：<code>Px - Py = target (x &gt; y)</code>，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：<code>Px - target = Py</code>，然后统计有多少个符合的子数组即可，这样我们的map可以定义为<em>Map&lt;Integer, Integer&gt;<em>，用来保存</em>当前的数组和</em>和<em>数组和的个数</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cur : nums)&#123;</span><br><span class=\"line\">        sum += cur; <span class=\"comment\">// preSum</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) result++; <span class=\"comment\">//也可以提前在map中放入 map.put(0, 1)</span></span><br><span class=\"line\">        result += map.getOrDefault(sum - k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        map.put(sum, map.getOrDefault(sum, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：<code>sum(i, j) = sum(0, j) - sum(0, i)</code>。</p>\n<h1 id=\"Minimum-Operations-to-Reduce-X-to-Zero\"><a href=\"#Minimum-Operations-to-Reduce-X-to-Zero\" class=\"headerlink\" title=\"Minimum Operations to Reduce X to Zero\"></a><a href=\"https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero\">Minimum Operations to Reduce X to Zero</a></h1><p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>\n<p>Return <em>the <strong>minimum number</strong> of operations to reduce</em> <code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it’s possible**, otherwise, return</em> <code>-1</code>.</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>1 &lt;= x &lt;= 109</code></li>\n</ul>\n<p>​        以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。</p>\n<p>由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = -<span class=\"number\">1</span>, n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; n; hi++)&#123;</span><br><span class=\"line\">        sum += nums[hi];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt; n &amp;&amp; sum &gt; target)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == target) size = Math.max(size, hi - lo + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size &lt; <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : n - size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也能使用前缀和：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, -<span class=\"number\">1</span>);<span class=\"comment\">// 长度，下面是 i - map.value</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = nums[i];</span><br><span class=\"line\">        sum += num;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.containsKey(sum - target))&#123;</span><br><span class=\"line\">            res = Math.max(res, i - map.get(sum - target));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.put(sum, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : nums.length - res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的<code>map</code> + <code>preSum</code>，双指针的思路是很容易理解的，后者需要绕个弯。</p>","more":"<!--toc-->\n\n<h1 id=\"Subarray-Sum-Equals-K\"><a href=\"#Subarray-Sum-Equals-K\" class=\"headerlink\" title=\"Subarray Sum Equals K\"></a><a href=\"https://leetcode.com/problems/subarray-sum-equals-k/\">Subarray Sum Equals K</a></h1><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.</p>\n<p>以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; nums.length; hi++)&#123;</span><br><span class=\"line\">        sum += nums[i];</span><br><span class=\"line\">        whlie(lo &lt; nums.length &amp;&amp; sum &gt; k)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) res++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的<strong>Constraints</strong>：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>\n<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n<li><code>-107 &lt;= k &lt;= 107</code></li>\n</ul>\n<p>注意到了么，给的入参中数字是可以为负数的，在代码中<code>sum-= nums[lo++]</code>是无效的，如果入参都是正数，双指针就是OK的。</p>\n<h2 id=\"map-preSum\"><a href=\"#map-preSum\" class=\"headerlink\" title=\"map + preSum\"></a>map + preSum</h2><p>​        与双指针不同的是，这种解法用到了额外的数据结构<code>map</code>，在这里关于映射表的用法也有多种。另外一个<code>preSum</code>很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：</p>\n<p>有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么<code>P5 - P2</code>是12，正是子串[2, 3]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：<code>Px - Py = target (x &gt; y)</code>，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：<code>Px - target = Py</code>，然后统计有多少个符合的子数组即可，这样我们的map可以定义为<em>Map&lt;Integer, Integer&gt;<em>，用来保存</em>当前的数组和</em>和<em>数组和的个数</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cur : nums)&#123;</span><br><span class=\"line\">        sum += cur; <span class=\"comment\">// preSum</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) result++; <span class=\"comment\">//也可以提前在map中放入 map.put(0, 1)</span></span><br><span class=\"line\">        result += map.getOrDefault(sum - k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        map.put(sum, map.getOrDefault(sum, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：<code>sum(i, j) = sum(0, j) - sum(0, i)</code>。</p>\n<h1 id=\"Minimum-Operations-to-Reduce-X-to-Zero\"><a href=\"#Minimum-Operations-to-Reduce-X-to-Zero\" class=\"headerlink\" title=\"Minimum Operations to Reduce X to Zero\"></a><a href=\"https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero\">Minimum Operations to Reduce X to Zero</a></h1><p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>\n<p>Return <em>the <strong>minimum number</strong> of operations to reduce</em> <code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it’s possible**, otherwise, return</em> <code>-1</code>.</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>1 &lt;= x &lt;= 109</code></li>\n</ul>\n<p>​        以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。</p>\n<p>由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = -<span class=\"number\">1</span>, n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; n; hi++)&#123;</span><br><span class=\"line\">        sum += nums[hi];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt; n &amp;&amp; sum &gt; target)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == target) size = Math.max(size, hi - lo + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size &lt; <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : n - size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也能使用前缀和：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, -<span class=\"number\">1</span>);<span class=\"comment\">// 长度，下面是 i - map.value</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = nums[i];</span><br><span class=\"line\">        sum += num;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.containsKey(sum - target))&#123;</span><br><span class=\"line\">            res = Math.max(res, i - map.get(sum - target));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.put(sum, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : nums.length - res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"uml","date":"2020-01-12T15:14:16.000Z","_content":"\nThe **Unified Modeling Language(UML)** is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.\n\n<!-- more -->\n\n# 序\n\n主要说说UML中的关系(Class Relationships)\n\n[reference1](https://www.visual-paradigm.com/cn/guide/), [reference2](https://support.typora.io/Draw-Diagrams-With-Markdown/)\n\n## Class Relationships\n\nA class may be involved in one or more relationships with other classes.\n\n## Inheritance(or Generalization)\n\n- Represents an \"is-a\" relationship\n- An abstract class name is shown *in italics*\n- SubClass1 and SubClass2 are specializations of Super Class\n- **A solid line with a hollow arrowhead that point <u>from the child to the parent class</u>**\n\n```mermaid\nclassDiagram\nClass <|-- SubClass1\nClass <|-- SubClass2 \n```\n\n\n\n---\n\n## Simple Association\n\n- A structural link between two peer classes\n- There is an association between Class1 and Class2\n- **A solid line connecting two classes**\n\n```mermaid\nclassDiagram\nClass1 .. Class2\n```\n\n\n\n---\n\n## Aggregation\n\nA special type of association. It represents a \"part of\" relationship.\n\n- Class2 is part of Class1.\n- Many instances(denoted by the *) of Class2 can be associated with Class1\n- Objects of Class1 and Class2 have separate lifetimes\n- **A solid line with an unfilled diamond at the association end connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 o-- Class2\n```\n\n---\n\n## Composition\n\nA special type of aggregation **where parts are destroyed when the whole is destroyed.**\n\n- Objects of Class2 live and die with Class1\n- Class2 cannot stand by itself\n- **A solid line with a filled diamond at the association connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 *-- Class2\n```\n\n---\n\n## Dependency\n\n- Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)\n- Class1 depends on Class2\n- A dashed line with an open arrow\n\n```mermaid\nclassDiagram\nClass1 ..> Class2\n```\n\n\n\n","source":"_posts/uml.md","raw":"---\ntitle: uml\ndate: 2020-01-12 23:14:16\ncategories: Utils\ntags: utils\n---\n\nThe **Unified Modeling Language(UML)** is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.\n\n<!-- more -->\n\n# 序\n\n主要说说UML中的关系(Class Relationships)\n\n[reference1](https://www.visual-paradigm.com/cn/guide/), [reference2](https://support.typora.io/Draw-Diagrams-With-Markdown/)\n\n## Class Relationships\n\nA class may be involved in one or more relationships with other classes.\n\n## Inheritance(or Generalization)\n\n- Represents an \"is-a\" relationship\n- An abstract class name is shown *in italics*\n- SubClass1 and SubClass2 are specializations of Super Class\n- **A solid line with a hollow arrowhead that point <u>from the child to the parent class</u>**\n\n```mermaid\nclassDiagram\nClass <|-- SubClass1\nClass <|-- SubClass2 \n```\n\n\n\n---\n\n## Simple Association\n\n- A structural link between two peer classes\n- There is an association between Class1 and Class2\n- **A solid line connecting two classes**\n\n```mermaid\nclassDiagram\nClass1 .. Class2\n```\n\n\n\n---\n\n## Aggregation\n\nA special type of association. It represents a \"part of\" relationship.\n\n- Class2 is part of Class1.\n- Many instances(denoted by the *) of Class2 can be associated with Class1\n- Objects of Class1 and Class2 have separate lifetimes\n- **A solid line with an unfilled diamond at the association end connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 o-- Class2\n```\n\n---\n\n## Composition\n\nA special type of aggregation **where parts are destroyed when the whole is destroyed.**\n\n- Objects of Class2 live and die with Class1\n- Class2 cannot stand by itself\n- **A solid line with a filled diamond at the association connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 *-- Class2\n```\n\n---\n\n## Dependency\n\n- Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)\n- Class1 depends on Class2\n- A dashed line with an open arrow\n\n```mermaid\nclassDiagram\nClass1 ..> Class2\n```\n\n\n\n","slug":"uml","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q8a002aw5ihd43v2r8d","content":"<p>The <strong>Unified Modeling Language(UML)</strong> is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.</p>\n<a id=\"more\"></a>\n\n<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>主要说说UML中的关系(Class Relationships)</p>\n<p><a href=\"https://www.visual-paradigm.com/cn/guide/\">reference1</a>, <a href=\"https://support.typora.io/Draw-Diagrams-With-Markdown/\">reference2</a></p>\n<h2 id=\"Class-Relationships\"><a href=\"#Class-Relationships\" class=\"headerlink\" title=\"Class Relationships\"></a>Class Relationships</h2><p>A class may be involved in one or more relationships with other classes.</p>\n<h2 id=\"Inheritance-or-Generalization\"><a href=\"#Inheritance-or-Generalization\" class=\"headerlink\" title=\"Inheritance(or Generalization)\"></a>Inheritance(or Generalization)</h2><ul>\n<li>Represents an “is-a” relationship</li>\n<li>An abstract class name is shown <em>in italics</em></li>\n<li>SubClass1 and SubClass2 are specializations of Super Class</li>\n<li><strong>A solid line with a hollow arrowhead that point <u>from the child to the parent class</u></strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class &lt;|-- SubClass1</span><br><span class=\"line\">Class &lt;|-- SubClass2 </span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Simple-Association\"><a href=\"#Simple-Association\" class=\"headerlink\" title=\"Simple Association\"></a>Simple Association</h2><ul>\n<li>A structural link between two peer classes</li>\n<li>There is an association between Class1 and Class2</li>\n<li><strong>A solid line connecting two classes</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 .. Class2</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Aggregation\"><a href=\"#Aggregation\" class=\"headerlink\" title=\"Aggregation\"></a>Aggregation</h2><p>A special type of association. It represents a “part of” relationship.</p>\n<ul>\n<li>Class2 is part of Class1.</li>\n<li>Many instances(denoted by the *) of Class2 can be associated with Class1</li>\n<li>Objects of Class1 and Class2 have separate lifetimes</li>\n<li><strong>A solid line with an unfilled diamond at the association end connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 o-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Composition\"><a href=\"#Composition\" class=\"headerlink\" title=\"Composition\"></a>Composition</h2><p>A special type of aggregation <strong>where parts are destroyed when the whole is destroyed.</strong></p>\n<ul>\n<li>Objects of Class2 live and die with Class1</li>\n<li>Class2 cannot stand by itself</li>\n<li><strong>A solid line with a filled diamond at the association connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 *-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Dependency\"><a href=\"#Dependency\" class=\"headerlink\" title=\"Dependency\"></a>Dependency</h2><ul>\n<li>Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)</li>\n<li>Class1 depends on Class2</li>\n<li>A dashed line with an open arrow</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 ..&gt; Class2</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>The <strong>Unified Modeling Language(UML)</strong> is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.</p>","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>主要说说UML中的关系(Class Relationships)</p>\n<p><a href=\"https://www.visual-paradigm.com/cn/guide/\">reference1</a>, <a href=\"https://support.typora.io/Draw-Diagrams-With-Markdown/\">reference2</a></p>\n<h2 id=\"Class-Relationships\"><a href=\"#Class-Relationships\" class=\"headerlink\" title=\"Class Relationships\"></a>Class Relationships</h2><p>A class may be involved in one or more relationships with other classes.</p>\n<h2 id=\"Inheritance-or-Generalization\"><a href=\"#Inheritance-or-Generalization\" class=\"headerlink\" title=\"Inheritance(or Generalization)\"></a>Inheritance(or Generalization)</h2><ul>\n<li>Represents an “is-a” relationship</li>\n<li>An abstract class name is shown <em>in italics</em></li>\n<li>SubClass1 and SubClass2 are specializations of Super Class</li>\n<li><strong>A solid line with a hollow arrowhead that point <u>from the child to the parent class</u></strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class &lt;|-- SubClass1</span><br><span class=\"line\">Class &lt;|-- SubClass2 </span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Simple-Association\"><a href=\"#Simple-Association\" class=\"headerlink\" title=\"Simple Association\"></a>Simple Association</h2><ul>\n<li>A structural link between two peer classes</li>\n<li>There is an association between Class1 and Class2</li>\n<li><strong>A solid line connecting two classes</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 .. Class2</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Aggregation\"><a href=\"#Aggregation\" class=\"headerlink\" title=\"Aggregation\"></a>Aggregation</h2><p>A special type of association. It represents a “part of” relationship.</p>\n<ul>\n<li>Class2 is part of Class1.</li>\n<li>Many instances(denoted by the *) of Class2 can be associated with Class1</li>\n<li>Objects of Class1 and Class2 have separate lifetimes</li>\n<li><strong>A solid line with an unfilled diamond at the association end connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 o-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Composition\"><a href=\"#Composition\" class=\"headerlink\" title=\"Composition\"></a>Composition</h2><p>A special type of aggregation <strong>where parts are destroyed when the whole is destroyed.</strong></p>\n<ul>\n<li>Objects of Class2 live and die with Class1</li>\n<li>Class2 cannot stand by itself</li>\n<li><strong>A solid line with a filled diamond at the association connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 *-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Dependency\"><a href=\"#Dependency\" class=\"headerlink\" title=\"Dependency\"></a>Dependency</h2><ul>\n<li>Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)</li>\n<li>Class1 depends on Class2</li>\n<li>A dashed line with an open arrow</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 ..&gt; Class2</span><br></pre></td></tr></table></figure>"},{"title":"volatile","date":"2020-07-20T13:23:51.000Z","_content":"\n这个关键字用于将Java变量标记为`being stored in main memory`，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。\n\n<!--more-->\n\n# Visibility problems\n\n主要是多线程中的问题。线程在操作`非volatile`的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。\n\n那么问题来了，对于`非volatile`的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器\n\n```java\npublic class ShareObject{\n    public int counter = 0;\n}\n```\n\n假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。\n\n如果counter不声明为`volatile`，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，**一个线程的更新对其他线程是不可见的**。\n\n# Visibility Guarantee\n\n关键字`volatile`的设定就是解决上面提到的可见性问题。通过声明counter变量为`volatile`的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字`volatile`的例子：\n\n```java\npublic class ShareObject{\n    // 由于声明为volatile，因此更改变量对于其他线程的是可见的\n    public volatile int counter = 0 ;\n}\n```\n\n但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为`volatile`是不够的。\n\n## Full Visibility Guarantee\n\n实际上，关键字`volatile`的可见保证性超越了`volatile`变量本身。有点绕吧，可见保证性如下：\n\n- 如果线程A更改了`volatile`变量，并且线程B随后读取了它，则在写入`volatile`变量之前线程A可见的所有变量在线程B读取`volatile`变量后也将可见。\n\n- 如果线程A读取了一个`volatile`变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。\n\n看个代码例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    // 更改了三个变量，只有days是volatile的\n    public void update(int years, int months, int days){\n        this.years = year;\n        this.months = months;\n        this.days = days;    \n    }\n}\n```\n\n”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n\n    public int totalDays(){\n        int total = this.days;\n        total += months * 30;\n        total += years * 365;\n        return total;   \n    }\n\n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n着重观察*totalDays()*，他一开始会将`days`的值赋给变量`total` ,由于`days`的类型是`volatile`，所以，读取`days`的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了`volatile`他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为`volatile`，读取时必须**最后**读取带有`volatile`属性的值）。\n\n# Instruction Reordering\n\n指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：\n\n```java\nint a = 1;\nint b = 2;\na++;\nb++;\n```\n\n这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：\n\n```java\nint a  = 1;\na++;\nint b = 2;\nb++\n```\n\n然而，当变量属于`volatile`时，指令排序就需要小心了，看看下面的例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n如果JVM重排指令，像下面这样：\n\n```java\n    public void update(int years, int months, int days){\n        // 这里将days赋值动作放到了第一位\n        this.days = days;\n        this.years = years;\n        this.months = months;\n    }\n```\n\n当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。\n\n## Volatile Happens-Before Guarantee\n\n`volatile`关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。\n\n- 如果读/写其他变量出现在写`volatile变量`之前，那么就不能重排为出现在它之后。当然返回过是允许的。\n- 如果读/写其他变量出现在读`volatile变量`之后，那么就不能重排为出现在它之前。\n\n# Volatile is Not Always Enough\n\n很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证`原子性`的操作了，如**syncronized**或者比并发包下的`lock`了。\n","source":"_posts/volatile.md","raw":"---\ntitle: volatile\ndate: 2020-07-20 21:23:51\ncategories: Java\ntags: lock\n---\n\n这个关键字用于将Java变量标记为`being stored in main memory`，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。\n\n<!--more-->\n\n# Visibility problems\n\n主要是多线程中的问题。线程在操作`非volatile`的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。\n\n那么问题来了，对于`非volatile`的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器\n\n```java\npublic class ShareObject{\n    public int counter = 0;\n}\n```\n\n假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。\n\n如果counter不声明为`volatile`，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，**一个线程的更新对其他线程是不可见的**。\n\n# Visibility Guarantee\n\n关键字`volatile`的设定就是解决上面提到的可见性问题。通过声明counter变量为`volatile`的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字`volatile`的例子：\n\n```java\npublic class ShareObject{\n    // 由于声明为volatile，因此更改变量对于其他线程的是可见的\n    public volatile int counter = 0 ;\n}\n```\n\n但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为`volatile`是不够的。\n\n## Full Visibility Guarantee\n\n实际上，关键字`volatile`的可见保证性超越了`volatile`变量本身。有点绕吧，可见保证性如下：\n\n- 如果线程A更改了`volatile`变量，并且线程B随后读取了它，则在写入`volatile`变量之前线程A可见的所有变量在线程B读取`volatile`变量后也将可见。\n\n- 如果线程A读取了一个`volatile`变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。\n\n看个代码例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    // 更改了三个变量，只有days是volatile的\n    public void update(int years, int months, int days){\n        this.years = year;\n        this.months = months;\n        this.days = days;    \n    }\n}\n```\n\n”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n\n    public int totalDays(){\n        int total = this.days;\n        total += months * 30;\n        total += years * 365;\n        return total;   \n    }\n\n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n着重观察*totalDays()*，他一开始会将`days`的值赋给变量`total` ,由于`days`的类型是`volatile`，所以，读取`days`的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了`volatile`他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为`volatile`，读取时必须**最后**读取带有`volatile`属性的值）。\n\n# Instruction Reordering\n\n指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：\n\n```java\nint a = 1;\nint b = 2;\na++;\nb++;\n```\n\n这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：\n\n```java\nint a  = 1;\na++;\nint b = 2;\nb++\n```\n\n然而，当变量属于`volatile`时，指令排序就需要小心了，看看下面的例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n如果JVM重排指令，像下面这样：\n\n```java\n    public void update(int years, int months, int days){\n        // 这里将days赋值动作放到了第一位\n        this.days = days;\n        this.years = years;\n        this.months = months;\n    }\n```\n\n当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。\n\n## Volatile Happens-Before Guarantee\n\n`volatile`关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。\n\n- 如果读/写其他变量出现在写`volatile变量`之前，那么就不能重排为出现在它之后。当然返回过是允许的。\n- 如果读/写其他变量出现在读`volatile变量`之后，那么就不能重排为出现在它之前。\n\n# Volatile is Not Always Enough\n\n很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证`原子性`的操作了，如**syncronized**或者比并发包下的`lock`了。\n","slug":"volatile","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q8c002fw5ihend92pom","content":"<p>这个关键字用于将Java变量标记为<code>being stored in main memory</code>，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"Visibility-problems\"><a href=\"#Visibility-problems\" class=\"headerlink\" title=\"Visibility problems\"></a>Visibility problems</h1><p>主要是多线程中的问题。线程在操作<code>非volatile</code>的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。</p>\n<p>那么问题来了，对于<code>非volatile</code>的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。</p>\n<p>如果counter不声明为<code>volatile</code>，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，<strong>一个线程的更新对其他线程是不可见的</strong>。</p>\n<h1 id=\"Visibility-Guarantee\"><a href=\"#Visibility-Guarantee\" class=\"headerlink\" title=\"Visibility Guarantee\"></a>Visibility Guarantee</h1><p>关键字<code>volatile</code>的设定就是解决上面提到的可见性问题。通过声明counter变量为<code>volatile</code>的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字<code>volatile</code>的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由于声明为volatile，因此更改变量对于其他线程的是可见的</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为<code>volatile</code>是不够的。</p>\n<h2 id=\"Full-Visibility-Guarantee\"><a href=\"#Full-Visibility-Guarantee\" class=\"headerlink\" title=\"Full Visibility Guarantee\"></a>Full Visibility Guarantee</h2><p>实际上，关键字<code>volatile</code>的可见保证性超越了<code>volatile</code>变量本身。有点绕吧，可见保证性如下：</p>\n<ul>\n<li><p>如果线程A更改了<code>volatile</code>变量，并且线程B随后读取了它，则在写入<code>volatile</code>变量之前线程A可见的所有变量在线程B读取<code>volatile</code>变量后也将可见。</p>\n</li>\n<li><p>如果线程A读取了一个<code>volatile</code>变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。</p>\n</li>\n</ul>\n<p>看个代码例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 更改了三个变量，只有days是volatile的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = year;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">totalDays</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"keyword\">this</span>.days;</span><br><span class=\"line\">        total += months * <span class=\"number\">30</span>;</span><br><span class=\"line\">        total += years * <span class=\"number\">365</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>着重观察<em>totalDays()<em>，他一开始会将<code>days</code>的值赋给变量<code>total</code> ,由于<code>days</code>的类型是<code>volatile</code>，所以，读取<code>days</code>的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了<code>volatile</code>他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为<code>volatile</code>，读取时必须</em></em>最后**读取带有<code>volatile</code>属性的值）。</p>\n<h1 id=\"Instruction-Reordering\"><a href=\"#Instruction-Reordering\" class=\"headerlink\" title=\"Instruction Reordering\"></a>Instruction Reordering</h1><p>指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b++;</span><br></pre></td></tr></table></figure>\n\n<p>这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a  = <span class=\"number\">1</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">b++</span><br></pre></td></tr></table></figure>\n\n<p>然而，当变量属于<code>volatile</code>时，指令排序就需要小心了，看看下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果JVM重排指令，像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里将days赋值动作放到了第一位</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。</p>\n<h2 id=\"Volatile-Happens-Before-Guarantee\"><a href=\"#Volatile-Happens-Before-Guarantee\" class=\"headerlink\" title=\"Volatile Happens-Before Guarantee\"></a>Volatile Happens-Before Guarantee</h2><p><code>volatile</code>关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。</p>\n<ul>\n<li>如果读/写其他变量出现在写<code>volatile变量</code>之前，那么就不能重排为出现在它之后。当然返回过是允许的。</li>\n<li>如果读/写其他变量出现在读<code>volatile变量</code>之后，那么就不能重排为出现在它之前。</li>\n</ul>\n<h1 id=\"Volatile-is-Not-Always-Enough\"><a href=\"#Volatile-is-Not-Always-Enough\" class=\"headerlink\" title=\"Volatile is Not Always Enough\"></a>Volatile is Not Always Enough</h1><p>很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证<code>原子性</code>的操作了，如<strong>syncronized</strong>或者比并发包下的<code>lock</code>了。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这个关键字用于将Java变量标记为<code>being stored in main memory</code>，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。</p>","more":"<h1 id=\"Visibility-problems\"><a href=\"#Visibility-problems\" class=\"headerlink\" title=\"Visibility problems\"></a>Visibility problems</h1><p>主要是多线程中的问题。线程在操作<code>非volatile</code>的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。</p>\n<p>那么问题来了，对于<code>非volatile</code>的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。</p>\n<p>如果counter不声明为<code>volatile</code>，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，<strong>一个线程的更新对其他线程是不可见的</strong>。</p>\n<h1 id=\"Visibility-Guarantee\"><a href=\"#Visibility-Guarantee\" class=\"headerlink\" title=\"Visibility Guarantee\"></a>Visibility Guarantee</h1><p>关键字<code>volatile</code>的设定就是解决上面提到的可见性问题。通过声明counter变量为<code>volatile</code>的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字<code>volatile</code>的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由于声明为volatile，因此更改变量对于其他线程的是可见的</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为<code>volatile</code>是不够的。</p>\n<h2 id=\"Full-Visibility-Guarantee\"><a href=\"#Full-Visibility-Guarantee\" class=\"headerlink\" title=\"Full Visibility Guarantee\"></a>Full Visibility Guarantee</h2><p>实际上，关键字<code>volatile</code>的可见保证性超越了<code>volatile</code>变量本身。有点绕吧，可见保证性如下：</p>\n<ul>\n<li><p>如果线程A更改了<code>volatile</code>变量，并且线程B随后读取了它，则在写入<code>volatile</code>变量之前线程A可见的所有变量在线程B读取<code>volatile</code>变量后也将可见。</p>\n</li>\n<li><p>如果线程A读取了一个<code>volatile</code>变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。</p>\n</li>\n</ul>\n<p>看个代码例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 更改了三个变量，只有days是volatile的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = year;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">totalDays</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"keyword\">this</span>.days;</span><br><span class=\"line\">        total += months * <span class=\"number\">30</span>;</span><br><span class=\"line\">        total += years * <span class=\"number\">365</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>着重观察<em>totalDays()<em>，他一开始会将<code>days</code>的值赋给变量<code>total</code> ,由于<code>days</code>的类型是<code>volatile</code>，所以，读取<code>days</code>的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了<code>volatile</code>他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为<code>volatile</code>，读取时必须</em></em>最后**读取带有<code>volatile</code>属性的值）。</p>\n<h1 id=\"Instruction-Reordering\"><a href=\"#Instruction-Reordering\" class=\"headerlink\" title=\"Instruction Reordering\"></a>Instruction Reordering</h1><p>指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b++;</span><br></pre></td></tr></table></figure>\n\n<p>这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a  = <span class=\"number\">1</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">b++</span><br></pre></td></tr></table></figure>\n\n<p>然而，当变量属于<code>volatile</code>时，指令排序就需要小心了，看看下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果JVM重排指令，像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里将days赋值动作放到了第一位</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。</p>\n<h2 id=\"Volatile-Happens-Before-Guarantee\"><a href=\"#Volatile-Happens-Before-Guarantee\" class=\"headerlink\" title=\"Volatile Happens-Before Guarantee\"></a>Volatile Happens-Before Guarantee</h2><p><code>volatile</code>关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。</p>\n<ul>\n<li>如果读/写其他变量出现在写<code>volatile变量</code>之前，那么就不能重排为出现在它之后。当然返回过是允许的。</li>\n<li>如果读/写其他变量出现在读<code>volatile变量</code>之后，那么就不能重排为出现在它之前。</li>\n</ul>\n<h1 id=\"Volatile-is-Not-Always-Enough\"><a href=\"#Volatile-is-Not-Always-Enough\" class=\"headerlink\" title=\"Volatile is Not Always Enough\"></a>Volatile is Not Always Enough</h1><p>很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证<code>原子性</code>的操作了，如<strong>syncronized</strong>或者比并发包下的<code>lock</code>了。</p>"},{"title":"jvm concurrency","date":"2021-03-23T15:32:31.000Z","_content":"","source":"_posts/jvm-concurrency.md","raw":"---\ntitle: jvm concurrency\ndate: 2021-03-23 23:32:31\ntags:\n---\n","slug":"jvm-concurrency","published":1,"updated":"2021-03-23T15:32:31.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q8d002hw5ihecp5hxja","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"jvm classloader","date":"2021-03-23T15:32:02.000Z","_content":"\n类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。\n\n<!-- more -->\n\n<!-- toc -->\n\n# class\n\n提类加载器之前有必要说说他要加载的东西——class。\n\n\n\n# classLoader\n\n\n\n# 实践","source":"_posts/jvm-classloader.md","raw":"---\ntitle: jvm classloader\ndate: 2021-03-23 23:32:02\ncategories: JVM\ntags: classloader\n---\n\n类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。\n\n<!-- more -->\n\n<!-- toc -->\n\n# class\n\n提类加载器之前有必要说说他要加载的东西——class。\n\n\n\n# classLoader\n\n\n\n# 实践","slug":"jvm-classloader","published":1,"updated":"2021-03-23T16:08:43.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q8e002kw5ih3cavee9c","content":"<p>类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。</p>\n<a id=\"more\"></a>\n\n<!-- toc -->\n\n<h1 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h1><p>提类加载器之前有必要说说他要加载的东西——class。</p>\n<h1 id=\"classLoader\"><a href=\"#classLoader\" class=\"headerlink\" title=\"classLoader\"></a>classLoader</h1><h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1>","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。</p>","more":"<!-- toc -->\n\n<h1 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h1><p>提类加载器之前有必要说说他要加载的东西——class。</p>\n<h1 id=\"classLoader\"><a href=\"#classLoader\" class=\"headerlink\" title=\"classLoader\"></a>classLoader</h1><h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1>"},{"title":"jvm memory-manage","date":"2021-03-23T15:38:15.000Z","_content":"\n温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 布局\n\n在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是**运行时数据区**。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。\n\n​\t\t普通的对象如何产生？在java代码层面我们通过关键字**new**来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放**new**的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。\n\n​\t\tjvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：**对象头，实例数据，对齐填充**。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。\n\n## 对象头\n\n拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。\n\n”打标记“这词儿我取的口语化，官方叫做*Mark Word*，用来存储自身的*运行时数据*，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。\n\n另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是**指针**。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用**句柄**。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：\n\n> reference -> 句柄 ->实例数据、类型数据\n\n其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。\n\n# 开辟\n\n上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。\n\n重点来了，虚拟机，开辟区域。\n\n真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做**指针碰撞（Bump the Pointer）**与**空闲链表（Free List）**。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁**CAS+失败重试**，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是**本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）**。\n\n# 回收\n\n​\t\t关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。\n\n如何确定对象该不该被回收，\n\n历史垃圾回收器，\n\nG1，新的分区方式，打破传统","source":"_posts/jvm-memory-manage.md","raw":"---\ntitle: jvm memory-manage\ndate: 2021-03-23 23:38:15\ncategories: JVM\ntags: memory\n---\n\n温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 布局\n\n在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是**运行时数据区**。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。\n\n​\t\t普通的对象如何产生？在java代码层面我们通过关键字**new**来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放**new**的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。\n\n​\t\tjvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：**对象头，实例数据，对齐填充**。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。\n\n## 对象头\n\n拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。\n\n”打标记“这词儿我取的口语化，官方叫做*Mark Word*，用来存储自身的*运行时数据*，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。\n\n另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是**指针**。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用**句柄**。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：\n\n> reference -> 句柄 ->实例数据、类型数据\n\n其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。\n\n# 开辟\n\n上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。\n\n重点来了，虚拟机，开辟区域。\n\n真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做**指针碰撞（Bump the Pointer）**与**空闲链表（Free List）**。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁**CAS+失败重试**，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是**本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）**。\n\n# 回收\n\n​\t\t关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。\n\n如何确定对象该不该被回收，\n\n历史垃圾回收器，\n\nG1，新的分区方式，打破传统","slug":"jvm-memory-manage","published":1,"updated":"2021-03-25T16:12:00.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q8f002nw5ih51ws5ehk","content":"<p>温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。</p>\n<a id=\"more\"></a>\n\n<!-- toc -->\n\n<h1 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h1><p>在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是<strong>运行时数据区</strong>。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。</p>\n<p>​        普通的对象如何产生？在java代码层面我们通过关键字<strong>new</strong>来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放<strong>new</strong>的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。</p>\n<p>​        jvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：<strong>对象头，实例数据，对齐填充</strong>。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。</p>\n<h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。</p>\n<p>”打标记“这词儿我取的口语化，官方叫做<em>Mark Word</em>，用来存储自身的<em>运行时数据</em>，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。</p>\n<p>另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是<strong>指针</strong>。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用<strong>句柄</strong>。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：</p>\n<blockquote>\n<p>reference -&gt; 句柄 -&gt;实例数据、类型数据</p>\n</blockquote>\n<p>其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。</p>\n<h1 id=\"开辟\"><a href=\"#开辟\" class=\"headerlink\" title=\"开辟\"></a>开辟</h1><p>上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。</p>\n<p>重点来了，虚拟机，开辟区域。</p>\n<p>真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做<strong>指针碰撞（Bump the Pointer）</strong>与<strong>空闲链表（Free List）</strong>。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁<strong>CAS+失败重试</strong>，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是<strong>本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）</strong>。</p>\n<h1 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h1><p>​        关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。</p>\n<p>如何确定对象该不该被回收，</p>\n<p>历史垃圾回收器，</p>\n<p>G1，新的分区方式，打破传统</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。</p>","more":"<!-- toc -->\n\n<h1 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h1><p>在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是<strong>运行时数据区</strong>。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。</p>\n<p>​        普通的对象如何产生？在java代码层面我们通过关键字<strong>new</strong>来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放<strong>new</strong>的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。</p>\n<p>​        jvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：<strong>对象头，实例数据，对齐填充</strong>。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。</p>\n<h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。</p>\n<p>”打标记“这词儿我取的口语化，官方叫做<em>Mark Word</em>，用来存储自身的<em>运行时数据</em>，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。</p>\n<p>另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是<strong>指针</strong>。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用<strong>句柄</strong>。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：</p>\n<blockquote>\n<p>reference -&gt; 句柄 -&gt;实例数据、类型数据</p>\n</blockquote>\n<p>其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。</p>\n<h1 id=\"开辟\"><a href=\"#开辟\" class=\"headerlink\" title=\"开辟\"></a>开辟</h1><p>上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。</p>\n<p>重点来了，虚拟机，开辟区域。</p>\n<p>真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做<strong>指针碰撞（Bump the Pointer）</strong>与<strong>空闲链表（Free List）</strong>。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁<strong>CAS+失败重试</strong>，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是<strong>本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）</strong>。</p>\n<h1 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h1><p>​        关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。</p>\n<p>如何确定对象该不该被回收，</p>\n<p>历史垃圾回收器，</p>\n<p>G1，新的分区方式，打破传统</p>"},{"title":"SpringBoot startup","date":"2021-02-15T05:18:14.000Z","_content":"\n出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。\n\n<!--more-->\n\n​\t\t使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。\n\n<!--toc-->\n\n# 启动\n\n```java\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n```\n\n这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：\n\n- @SpringBootApplication\n- 调用类SpringApplication的静态方法run，传入启动类的class以及main的args\n\n所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事\n\n- 实例化SpringApplication\n- 调用实例方法run\n\n接下来我们先从实例化看起。\n\n# 实例化\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    // 初始化资源加载器，这里是null\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    // 启动类的class\n    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n    // 判断应用程序的类型\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    // 设置初始化器\n    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    // 设置监听器\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    // 判断启动类\n    this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。\n\n## 应用程序类型\n\n虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。\n\n如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。\n\n```java\nprivate static final String WEBMVC_INDICATOR_CLASS = \"org.springframework.web.servlet.DispatcherServlet\";\n\n\tprivate static final String WEBFLUX_INDICATOR_CLASS = \"org.springframework.web.reactive.DispatcherHandler\";\n\n\tprivate static final String JERSEY_INDICATOR_CLASS = \"org.glassfish.jersey.servlet.ServletContainer\";\n\nstatic WebApplicationType deduceFromClasspath() {\n    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\n        && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\n        return WebApplicationType.REACTIVE;\n    }\n    for (String className : SERVLET_INDICATOR_CLASSES) {\n        if (!ClassUtils.isPresent(className, null)) {\n            return WebApplicationType.NONE;\n        }\n    }\n    return WebApplicationType.SERVLET;\n}\n```\n\n## SPI\n\n在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。\n\n```java\npublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n```\n\nSpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是`ApplicaitonListener`的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。\n\n## 监听器\n\n```properties\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\\norg.springframework.boot.context.logging.LoggingApplicationListener,\\\norg.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener\n```\n\n这里列出一部分的*spring.facories*中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如`ClearCachesApplicationListener`，清除缓存。\n\n这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。\n\n## 初始化器\n\n初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借`ApplicationContextInitializer`）找对应的全类名\n\n```properties\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\\norg.springframework.boot.context.ContextIdApplicationContextInitializer,\\\norg.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\\norg.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\\norg.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ\n```\n\n我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。\n\n# Run\n\n实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。\n\n```java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n    configureHeadlessProperty();\n    // 获取listeners，是listener的持有者\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        // 准备环境\n        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n        configureIgnoreBeanInfo(environment);\n        Banner printedBanner = printBanner(environment);\n        // 创建上下文\n        context = createApplicationContext();\n        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n                                                         new Class[] { ConfigurableApplicationContext.class }, context);\n        // 准备上下文，初始化\n        prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        // 刷新上下文\n        refreshContext(context);\n        afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        callRunners(context, applicationArguments);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, listeners);\n        throw new IllegalStateException(ex);\n    }\n\n    try {\n        listeners.running(context);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, null);\n        throw new IllegalStateException(ex);\n    }\n    return context;\n}\n```\n\n这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。\n\n## RunListeners\n\n通过名字可以看出，`SpringApplicaitonRunListeners`掌握着各种listener，但是不是那么的直接。\n\n```java\nprivate SpringApplicationRunListeners getRunListeners(String[] args) {\n    Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };\n    return new SpringApplicationRunListeners(logger,\n                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n}\n```\n\n可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，`EventPublishingRunListener`。也就是说`SpringApplicationRunListeners`持有类`EventPublishingRunListener`，run方法中的所有listeners的方法内部都是调用`EventPublishingRunListenr`的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？\n\n在`EventPublishingRunListener`的内部持有两个重要的对象，一个广播器`SimpleApplicationEventMulticaster`，例如：\n\n```java\n@Override\npublic void starting() {\n    this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));\n}\n```\n\n开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数`this.application`，这是持有的另一个重要的对象：`SpringApplication`。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将`SpringApplication`传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。\n\n## createApplicationContext\n\n```java\n\tpublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n\t\t\t+ \"annotation.AnnotationConfigApplicationContext\";\n\n\tpublic static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = \"org.springframework.boot.\"\n\t\t\t+ \"web.servlet.context.AnnotationConfigServletWebServerApplicationContext\";\n\n\tpublic static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = \"org.springframework.\"\n\t\t\t+ \"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\";\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n    Class<?> contextClass = this.applicationContextClass;\n    if (contextClass == null) {\n        try {\n            switch (this.webApplicationType) {\n                case SERVLET:\n                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);\n                    break;\n                case REACTIVE:\n                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n                    break;\n                default:\n                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);\n            }\n        }\n        catch (ClassNotFoundException ex) {\n            throw new IllegalStateException(\n                \"Unable create a default ApplicationContext, please specify an ApplicationContextClass\", ex);\n        }\n    }\n    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n```\n\n之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。\n\n## prepareContext\n\n创建完上下文，我们再来看刷新前的准备工作。\n\n```java\nprivate void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,\n                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n    context.setEnvironment(environment);\n    // 后置处理上下文\n    postProcessApplicationContext(context);\n    // 初始化上下文\n    applyInitializers(context);\n    listeners.contextPrepared(context);\n    if (this.logStartupInfo) {\n        logStartupInfo(context.getParent() == null);\n        logStartupProfileInfo(context);\n    }\n    // Add boot specific singleton beans\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n    if (printedBanner != null) {\n        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n    }\n    if (beanFactory instanceof DefaultListableBeanFactory) {\n        ((DefaultListableBeanFactory) beanFactory)\n        .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n    if (this.lazyInitialization) {\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    }\n    // Load the sources\n    Set<Object> sources = getAllSources();\n    Assert.notEmpty(sources, \"Sources must not be empty\");\n    // 创建BeanDefinitionLoader\n    load(context, sources.toArray(new Object[0]));\n    listeners.contextLoaded(context);\n}\n```\n\n准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了*contextPrepared*和*contextLoaded*。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。\n\n### contextPrepared\n\n这个阶段主要做两件事：后置处理，初始化。我们一件一件看。\n\n#### postProcess\n\n```java\nprotected void postProcessApplicationContext(ConfigurableApplicationContext context) {\n    if (this.beanNameGenerator != null) {\n        // 为bean命名\n        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,\n                                                   this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        if (context instanceof GenericApplicationContext) {\n            ((GenericApplicationContext) context).setResourceLoader(this.resourceLoader);\n        }\n        if (context instanceof DefaultResourceLoader) {\n            ((DefaultResourceLoader) context).setClassLoader(this.resourceLoader.getClassLoader());\n        }\n    }\n    if (this.addConversionService) {\n        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());\n    }\n}\n```\n\n这里主要为上下文装配工厂的`beanNameGenerator`、资源加载器和类加载器。\n\n#### applyInitializers\n\n```java\nprotected void applyInitializers(ConfigurableApplicationContext context) {\n    for (ApplicationContextInitializer initializer : getInitializers()) {\n        Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),\n                                                                        ApplicationContextInitializer.class);\n        Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n        initializer.initialize(context);\n    }\n}\n```\n\n之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。\n\n### contextLoaded\n\n这里主要是创建`BeanDefinitionLoader`，用来后续从xml、javaConfig中加载bean。\n\n```java\nprotected void load(ApplicationContext context, Object[] sources) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Loading source \" + StringUtils.arrayToCommaDelimitedString(sources));\n    }\n    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);\n    if (this.beanNameGenerator != null) {\n        loader.setBeanNameGenerator(this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        loader.setResourceLoader(this.resourceLoader);\n    }\n    if (this.environment != null) {\n        loader.setEnvironment(this.environment);\n    }\n    loader.load();\n}\n```\n\n\n\n# 总结\n\n我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：\n\n- 根据应用程序的类型创建对应的上下文\n- 初始化器配置上下文\n- 监听机制响应对应的事件","source":"_posts/SpringBoot-startup.md","raw":"---\ntitle: SpringBoot startup\ndate: 2021-02-15 13:18:14\ncategories: springboot\ntags: source\n---\n\n出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。\n\n<!--more-->\n\n​\t\t使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。\n\n<!--toc-->\n\n# 启动\n\n```java\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n```\n\n这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：\n\n- @SpringBootApplication\n- 调用类SpringApplication的静态方法run，传入启动类的class以及main的args\n\n所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事\n\n- 实例化SpringApplication\n- 调用实例方法run\n\n接下来我们先从实例化看起。\n\n# 实例化\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    // 初始化资源加载器，这里是null\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    // 启动类的class\n    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n    // 判断应用程序的类型\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    // 设置初始化器\n    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    // 设置监听器\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    // 判断启动类\n    this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。\n\n## 应用程序类型\n\n虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。\n\n如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。\n\n```java\nprivate static final String WEBMVC_INDICATOR_CLASS = \"org.springframework.web.servlet.DispatcherServlet\";\n\n\tprivate static final String WEBFLUX_INDICATOR_CLASS = \"org.springframework.web.reactive.DispatcherHandler\";\n\n\tprivate static final String JERSEY_INDICATOR_CLASS = \"org.glassfish.jersey.servlet.ServletContainer\";\n\nstatic WebApplicationType deduceFromClasspath() {\n    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\n        && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\n        return WebApplicationType.REACTIVE;\n    }\n    for (String className : SERVLET_INDICATOR_CLASSES) {\n        if (!ClassUtils.isPresent(className, null)) {\n            return WebApplicationType.NONE;\n        }\n    }\n    return WebApplicationType.SERVLET;\n}\n```\n\n## SPI\n\n在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。\n\n```java\npublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n```\n\nSpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是`ApplicaitonListener`的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。\n\n## 监听器\n\n```properties\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\\norg.springframework.boot.context.logging.LoggingApplicationListener,\\\norg.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener\n```\n\n这里列出一部分的*spring.facories*中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如`ClearCachesApplicationListener`，清除缓存。\n\n这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。\n\n## 初始化器\n\n初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借`ApplicationContextInitializer`）找对应的全类名\n\n```properties\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\\norg.springframework.boot.context.ContextIdApplicationContextInitializer,\\\norg.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\\norg.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\\norg.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ\n```\n\n我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。\n\n# Run\n\n实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。\n\n```java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n    configureHeadlessProperty();\n    // 获取listeners，是listener的持有者\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        // 准备环境\n        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n        configureIgnoreBeanInfo(environment);\n        Banner printedBanner = printBanner(environment);\n        // 创建上下文\n        context = createApplicationContext();\n        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n                                                         new Class[] { ConfigurableApplicationContext.class }, context);\n        // 准备上下文，初始化\n        prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        // 刷新上下文\n        refreshContext(context);\n        afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        callRunners(context, applicationArguments);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, listeners);\n        throw new IllegalStateException(ex);\n    }\n\n    try {\n        listeners.running(context);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, null);\n        throw new IllegalStateException(ex);\n    }\n    return context;\n}\n```\n\n这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。\n\n## RunListeners\n\n通过名字可以看出，`SpringApplicaitonRunListeners`掌握着各种listener，但是不是那么的直接。\n\n```java\nprivate SpringApplicationRunListeners getRunListeners(String[] args) {\n    Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };\n    return new SpringApplicationRunListeners(logger,\n                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n}\n```\n\n可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，`EventPublishingRunListener`。也就是说`SpringApplicationRunListeners`持有类`EventPublishingRunListener`，run方法中的所有listeners的方法内部都是调用`EventPublishingRunListenr`的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？\n\n在`EventPublishingRunListener`的内部持有两个重要的对象，一个广播器`SimpleApplicationEventMulticaster`，例如：\n\n```java\n@Override\npublic void starting() {\n    this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));\n}\n```\n\n开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数`this.application`，这是持有的另一个重要的对象：`SpringApplication`。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将`SpringApplication`传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。\n\n## createApplicationContext\n\n```java\n\tpublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n\t\t\t+ \"annotation.AnnotationConfigApplicationContext\";\n\n\tpublic static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = \"org.springframework.boot.\"\n\t\t\t+ \"web.servlet.context.AnnotationConfigServletWebServerApplicationContext\";\n\n\tpublic static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = \"org.springframework.\"\n\t\t\t+ \"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\";\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n    Class<?> contextClass = this.applicationContextClass;\n    if (contextClass == null) {\n        try {\n            switch (this.webApplicationType) {\n                case SERVLET:\n                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);\n                    break;\n                case REACTIVE:\n                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n                    break;\n                default:\n                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);\n            }\n        }\n        catch (ClassNotFoundException ex) {\n            throw new IllegalStateException(\n                \"Unable create a default ApplicationContext, please specify an ApplicationContextClass\", ex);\n        }\n    }\n    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n```\n\n之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。\n\n## prepareContext\n\n创建完上下文，我们再来看刷新前的准备工作。\n\n```java\nprivate void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,\n                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n    context.setEnvironment(environment);\n    // 后置处理上下文\n    postProcessApplicationContext(context);\n    // 初始化上下文\n    applyInitializers(context);\n    listeners.contextPrepared(context);\n    if (this.logStartupInfo) {\n        logStartupInfo(context.getParent() == null);\n        logStartupProfileInfo(context);\n    }\n    // Add boot specific singleton beans\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n    if (printedBanner != null) {\n        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n    }\n    if (beanFactory instanceof DefaultListableBeanFactory) {\n        ((DefaultListableBeanFactory) beanFactory)\n        .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n    if (this.lazyInitialization) {\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    }\n    // Load the sources\n    Set<Object> sources = getAllSources();\n    Assert.notEmpty(sources, \"Sources must not be empty\");\n    // 创建BeanDefinitionLoader\n    load(context, sources.toArray(new Object[0]));\n    listeners.contextLoaded(context);\n}\n```\n\n准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了*contextPrepared*和*contextLoaded*。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。\n\n### contextPrepared\n\n这个阶段主要做两件事：后置处理，初始化。我们一件一件看。\n\n#### postProcess\n\n```java\nprotected void postProcessApplicationContext(ConfigurableApplicationContext context) {\n    if (this.beanNameGenerator != null) {\n        // 为bean命名\n        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,\n                                                   this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        if (context instanceof GenericApplicationContext) {\n            ((GenericApplicationContext) context).setResourceLoader(this.resourceLoader);\n        }\n        if (context instanceof DefaultResourceLoader) {\n            ((DefaultResourceLoader) context).setClassLoader(this.resourceLoader.getClassLoader());\n        }\n    }\n    if (this.addConversionService) {\n        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());\n    }\n}\n```\n\n这里主要为上下文装配工厂的`beanNameGenerator`、资源加载器和类加载器。\n\n#### applyInitializers\n\n```java\nprotected void applyInitializers(ConfigurableApplicationContext context) {\n    for (ApplicationContextInitializer initializer : getInitializers()) {\n        Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),\n                                                                        ApplicationContextInitializer.class);\n        Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n        initializer.initialize(context);\n    }\n}\n```\n\n之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。\n\n### contextLoaded\n\n这里主要是创建`BeanDefinitionLoader`，用来后续从xml、javaConfig中加载bean。\n\n```java\nprotected void load(ApplicationContext context, Object[] sources) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Loading source \" + StringUtils.arrayToCommaDelimitedString(sources));\n    }\n    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);\n    if (this.beanNameGenerator != null) {\n        loader.setBeanNameGenerator(this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        loader.setResourceLoader(this.resourceLoader);\n    }\n    if (this.environment != null) {\n        loader.setEnvironment(this.environment);\n    }\n    loader.load();\n}\n```\n\n\n\n# 总结\n\n我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：\n\n- 根据应用程序的类型创建对应的上下文\n- 初始化器配置上下文\n- 监听机制响应对应的事件","slug":"SpringBoot-startup","published":1,"updated":"2021-02-17T04:26:57.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q920040w5ih87kh5m6w","content":"<p>出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。</p>\n<a id=\"more\"></a>\n\n<p>​        使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。</p>\n<!--toc-->\n\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MyApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：</p>\n<ul>\n<li>@SpringBootApplication</li>\n<li>调用类SpringApplication的静态方法run，传入启动类的class以及main的args</li>\n</ul>\n<p>所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事</p>\n<ul>\n<li>实例化SpringApplication</li>\n<li>调用实例方法run</li>\n</ul>\n<p>接下来我们先从实例化看起。</p>\n<h1 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringApplication</span><span class=\"params\">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化资源加载器，这里是null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resourceLoader = resourceLoader;</span><br><span class=\"line\">    Assert.notNull(primarySources, <span class=\"string\">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 启动类的class</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.primarySources = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class=\"line\">    <span class=\"comment\">// 判断应用程序的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化器</span></span><br><span class=\"line\">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class=\"line\">    <span class=\"comment\">// 设置监听器</span></span><br><span class=\"line\">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class=\"line\">    <span class=\"comment\">// 判断启动类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。</p>\n<h2 id=\"应用程序类型\"><a href=\"#应用程序类型\" class=\"headerlink\" title=\"应用程序类型\"></a>应用程序类型</h2><p>虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。</p>\n<p>如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBMVC_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBFLUX_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String JERSEY_INDICATOR_CLASS = <span class=\"string\">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> WebApplicationType <span class=\"title\">deduceFromClasspath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class=\"keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> WebApplicationType.REACTIVE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ClassUtils.isPresent(className, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> WebApplicationType.NONE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebApplicationType.SERVLET;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h2><p>在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String FACTORIES_RESOURCE_LOCATION = <span class=\"string\">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>SpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是<code>ApplicaitonListener</code>的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。</p>\n<h2 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationListener</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.ClearCachesApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.builder.ParentContextCloserApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.context.FileEncodingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.AnsiOutputApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.ConfigFileApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.LoggingApplicationListener,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span></span><br></pre></td></tr></table></figure>\n\n<p>这里列出一部分的<em>spring.facories</em>中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如<code>ClearCachesApplicationListener</code>，清除缓存。</p>\n<p>这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。</p>\n<h2 id=\"初始化器\"><a href=\"#初始化器\" class=\"headerlink\" title=\"初始化器\"></a>初始化器</h2><p>初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借<code>ApplicationContextInitializer</code>）找对应的全类名</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationContextInitializer</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.ContextIdApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。</p>\n<h1 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h1><p>实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">    StopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</span><br><span class=\"line\">    stopWatch.start();</span><br><span class=\"line\">    ConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    configureHeadlessProperty();</span><br><span class=\"line\">    <span class=\"comment\">// 获取listeners，是listener的持有者</span></span><br><span class=\"line\">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class=\"line\">    listeners.starting();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(args);</span><br><span class=\"line\">        <span class=\"comment\">// 准备环境</span></span><br><span class=\"line\">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">        configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">        Banner printedBanner = printBanner(environment);</span><br><span class=\"line\">        <span class=\"comment\">// 创建上下文</span></span><br><span class=\"line\">        context = createApplicationContext();</span><br><span class=\"line\">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">                                                         <span class=\"keyword\">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">        <span class=\"comment\">// 准备上下文，初始化</span></span><br><span class=\"line\">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">        <span class=\"comment\">// 刷新上下文</span></span><br><span class=\"line\">        refreshContext(context);</span><br><span class=\"line\">        afterRefresh(context, applicationArguments);</span><br><span class=\"line\">        stopWatch.stop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listeners.started(context);</span><br><span class=\"line\">        callRunners(context, applicationArguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        listeners.running(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。</p>\n<h2 id=\"RunListeners\"><a href=\"#RunListeners\" class=\"headerlink\" title=\"RunListeners\"></a>RunListeners</h2><p>通过名字可以看出，<code>SpringApplicaitonRunListeners</code>掌握着各种listener，但是不是那么的直接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SpringApplicationRunListeners <span class=\"title\">getRunListeners</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] types = <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplicationRunListeners(logger,</span><br><span class=\"line\">                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class=\"keyword\">this</span>, args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，<code>EventPublishingRunListener</code>。也就是说<code>SpringApplicationRunListeners</code>持有类<code>EventPublishingRunListener</code>，run方法中的所有listeners的方法内部都是调用<code>EventPublishingRunListenr</code>的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？</p>\n<p>在<code>EventPublishingRunListener</code>的内部持有两个重要的对象，一个广播器<code>SimpleApplicationEventMulticaster</code>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">starting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.initialMulticaster.multicastEvent(<span class=\"keyword\">new</span> ApplicationStartingEvent(<span class=\"keyword\">this</span>.application, <span class=\"keyword\">this</span>.args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数<code>this.application</code>，这是持有的另一个重要的对象：<code>SpringApplication</code>。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将<code>SpringApplication</code>传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。</p>\n<h2 id=\"createApplicationContext\"><a href=\"#createApplicationContext\" class=\"headerlink\" title=\"createApplicationContext\"></a>createApplicationContext</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.context.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;annotation.AnnotationConfigApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.boot.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableApplicationContext <span class=\"title\">createApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; contextClass = <span class=\"keyword\">this</span>.applicationContextClass;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.webApplicationType) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SERVLET:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> REACTIVE:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。</p>\n<h2 id=\"prepareContext\"><a href=\"#prepareContext\" class=\"headerlink\" title=\"prepareContext\"></a>prepareContext</h2><p>创建完上下文，我们再来看刷新前的准备工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareContext</span><span class=\"params\">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class=\"line\">    context.setEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 后置处理上下文</span></span><br><span class=\"line\">    postProcessApplicationContext(context);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化上下文</span></span><br><span class=\"line\">    applyInitializers(context);</span><br><span class=\"line\">    listeners.contextPrepared(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">        logStartupInfo(context.getParent() == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        logStartupProfileInfo(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Add boot specific singleton beans</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">    beanFactory.registerSingleton(<span class=\"string\">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (printedBanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory <span class=\"keyword\">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class=\"line\">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class=\"line\">        .setAllowBeanDefinitionOverriding(<span class=\"keyword\">this</span>.allowBeanDefinitionOverriding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lazyInitialization) &#123;</span><br><span class=\"line\">        context.addBeanFactoryPostProcessor(<span class=\"keyword\">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Load the sources</span></span><br><span class=\"line\">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class=\"line\">    Assert.notEmpty(sources, <span class=\"string\">&quot;Sources must not be empty&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建BeanDefinitionLoader</span></span><br><span class=\"line\">    load(context, sources.toArray(<span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    listeners.contextLoaded(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了<em>contextPrepared</em>和<em>contextLoaded</em>。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。</p>\n<h3 id=\"contextPrepared\"><a href=\"#contextPrepared\" class=\"headerlink\" title=\"contextPrepared\"></a>contextPrepared</h3><p>这个阶段主要做两件事：后置处理，初始化。我们一件一件看。</p>\n<h4 id=\"postProcess\"><a href=\"#postProcess\" class=\"headerlink\" title=\"postProcess\"></a>postProcess</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessApplicationContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为bean命名</span></span><br><span class=\"line\">        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</span><br><span class=\"line\">                                                   <span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> GenericApplicationContext) &#123;</span><br><span class=\"line\">            ((GenericApplicationContext) context).setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> DefaultResourceLoader) &#123;</span><br><span class=\"line\">            ((DefaultResourceLoader) context).setClassLoader(<span class=\"keyword\">this</span>.resourceLoader.getClassLoader());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addConversionService) &#123;</span><br><span class=\"line\">        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要为上下文装配工厂的<code>beanNameGenerator</code>、资源加载器和类加载器。</p>\n<h4 id=\"applyInitializers\"><a href=\"#applyInitializers\" class=\"headerlink\" title=\"applyInitializers\"></a>applyInitializers</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">applyInitializers</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class=\"line\">                                                                        ApplicationContextInitializer.class);</span><br><span class=\"line\">        Assert.isInstanceOf(requiredType, context, <span class=\"string\">&quot;Unable to call initializer.&quot;</span>);</span><br><span class=\"line\">        initializer.initialize(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。</p>\n<h3 id=\"contextLoaded\"><a href=\"#contextLoaded\" class=\"headerlink\" title=\"contextLoaded\"></a>contextLoaded</h3><p>这里主要是创建<code>BeanDefinitionLoader</code>，用来后续从xml、javaConfig中加载bean。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setBeanNameGenerator(<span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setEnvironment(<span class=\"keyword\">this</span>.environment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loader.load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：</p>\n<ul>\n<li>根据应用程序的类型创建对应的上下文</li>\n<li>初始化器配置上下文</li>\n<li>监听机制响应对应的事件</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。</p>","more":"<p>​        使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。</p>\n<!--toc-->\n\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MyApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：</p>\n<ul>\n<li>@SpringBootApplication</li>\n<li>调用类SpringApplication的静态方法run，传入启动类的class以及main的args</li>\n</ul>\n<p>所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事</p>\n<ul>\n<li>实例化SpringApplication</li>\n<li>调用实例方法run</li>\n</ul>\n<p>接下来我们先从实例化看起。</p>\n<h1 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringApplication</span><span class=\"params\">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化资源加载器，这里是null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resourceLoader = resourceLoader;</span><br><span class=\"line\">    Assert.notNull(primarySources, <span class=\"string\">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 启动类的class</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.primarySources = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class=\"line\">    <span class=\"comment\">// 判断应用程序的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化器</span></span><br><span class=\"line\">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class=\"line\">    <span class=\"comment\">// 设置监听器</span></span><br><span class=\"line\">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class=\"line\">    <span class=\"comment\">// 判断启动类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。</p>\n<h2 id=\"应用程序类型\"><a href=\"#应用程序类型\" class=\"headerlink\" title=\"应用程序类型\"></a>应用程序类型</h2><p>虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。</p>\n<p>如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBMVC_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBFLUX_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String JERSEY_INDICATOR_CLASS = <span class=\"string\">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> WebApplicationType <span class=\"title\">deduceFromClasspath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class=\"keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> WebApplicationType.REACTIVE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ClassUtils.isPresent(className, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> WebApplicationType.NONE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebApplicationType.SERVLET;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h2><p>在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String FACTORIES_RESOURCE_LOCATION = <span class=\"string\">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>SpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是<code>ApplicaitonListener</code>的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。</p>\n<h2 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationListener</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.ClearCachesApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.builder.ParentContextCloserApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.context.FileEncodingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.AnsiOutputApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.ConfigFileApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.LoggingApplicationListener,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span></span><br></pre></td></tr></table></figure>\n\n<p>这里列出一部分的<em>spring.facories</em>中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如<code>ClearCachesApplicationListener</code>，清除缓存。</p>\n<p>这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。</p>\n<h2 id=\"初始化器\"><a href=\"#初始化器\" class=\"headerlink\" title=\"初始化器\"></a>初始化器</h2><p>初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借<code>ApplicationContextInitializer</code>）找对应的全类名</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationContextInitializer</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.ContextIdApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。</p>\n<h1 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h1><p>实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">    StopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</span><br><span class=\"line\">    stopWatch.start();</span><br><span class=\"line\">    ConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    configureHeadlessProperty();</span><br><span class=\"line\">    <span class=\"comment\">// 获取listeners，是listener的持有者</span></span><br><span class=\"line\">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class=\"line\">    listeners.starting();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(args);</span><br><span class=\"line\">        <span class=\"comment\">// 准备环境</span></span><br><span class=\"line\">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">        configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">        Banner printedBanner = printBanner(environment);</span><br><span class=\"line\">        <span class=\"comment\">// 创建上下文</span></span><br><span class=\"line\">        context = createApplicationContext();</span><br><span class=\"line\">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">                                                         <span class=\"keyword\">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">        <span class=\"comment\">// 准备上下文，初始化</span></span><br><span class=\"line\">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">        <span class=\"comment\">// 刷新上下文</span></span><br><span class=\"line\">        refreshContext(context);</span><br><span class=\"line\">        afterRefresh(context, applicationArguments);</span><br><span class=\"line\">        stopWatch.stop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listeners.started(context);</span><br><span class=\"line\">        callRunners(context, applicationArguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        listeners.running(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。</p>\n<h2 id=\"RunListeners\"><a href=\"#RunListeners\" class=\"headerlink\" title=\"RunListeners\"></a>RunListeners</h2><p>通过名字可以看出，<code>SpringApplicaitonRunListeners</code>掌握着各种listener，但是不是那么的直接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SpringApplicationRunListeners <span class=\"title\">getRunListeners</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] types = <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplicationRunListeners(logger,</span><br><span class=\"line\">                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class=\"keyword\">this</span>, args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，<code>EventPublishingRunListener</code>。也就是说<code>SpringApplicationRunListeners</code>持有类<code>EventPublishingRunListener</code>，run方法中的所有listeners的方法内部都是调用<code>EventPublishingRunListenr</code>的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？</p>\n<p>在<code>EventPublishingRunListener</code>的内部持有两个重要的对象，一个广播器<code>SimpleApplicationEventMulticaster</code>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">starting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.initialMulticaster.multicastEvent(<span class=\"keyword\">new</span> ApplicationStartingEvent(<span class=\"keyword\">this</span>.application, <span class=\"keyword\">this</span>.args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数<code>this.application</code>，这是持有的另一个重要的对象：<code>SpringApplication</code>。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将<code>SpringApplication</code>传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。</p>\n<h2 id=\"createApplicationContext\"><a href=\"#createApplicationContext\" class=\"headerlink\" title=\"createApplicationContext\"></a>createApplicationContext</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.context.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;annotation.AnnotationConfigApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.boot.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableApplicationContext <span class=\"title\">createApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; contextClass = <span class=\"keyword\">this</span>.applicationContextClass;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.webApplicationType) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SERVLET:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> REACTIVE:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。</p>\n<h2 id=\"prepareContext\"><a href=\"#prepareContext\" class=\"headerlink\" title=\"prepareContext\"></a>prepareContext</h2><p>创建完上下文，我们再来看刷新前的准备工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareContext</span><span class=\"params\">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class=\"line\">    context.setEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 后置处理上下文</span></span><br><span class=\"line\">    postProcessApplicationContext(context);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化上下文</span></span><br><span class=\"line\">    applyInitializers(context);</span><br><span class=\"line\">    listeners.contextPrepared(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">        logStartupInfo(context.getParent() == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        logStartupProfileInfo(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Add boot specific singleton beans</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">    beanFactory.registerSingleton(<span class=\"string\">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (printedBanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory <span class=\"keyword\">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class=\"line\">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class=\"line\">        .setAllowBeanDefinitionOverriding(<span class=\"keyword\">this</span>.allowBeanDefinitionOverriding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lazyInitialization) &#123;</span><br><span class=\"line\">        context.addBeanFactoryPostProcessor(<span class=\"keyword\">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Load the sources</span></span><br><span class=\"line\">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class=\"line\">    Assert.notEmpty(sources, <span class=\"string\">&quot;Sources must not be empty&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建BeanDefinitionLoader</span></span><br><span class=\"line\">    load(context, sources.toArray(<span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    listeners.contextLoaded(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了<em>contextPrepared</em>和<em>contextLoaded</em>。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。</p>\n<h3 id=\"contextPrepared\"><a href=\"#contextPrepared\" class=\"headerlink\" title=\"contextPrepared\"></a>contextPrepared</h3><p>这个阶段主要做两件事：后置处理，初始化。我们一件一件看。</p>\n<h4 id=\"postProcess\"><a href=\"#postProcess\" class=\"headerlink\" title=\"postProcess\"></a>postProcess</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessApplicationContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为bean命名</span></span><br><span class=\"line\">        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</span><br><span class=\"line\">                                                   <span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> GenericApplicationContext) &#123;</span><br><span class=\"line\">            ((GenericApplicationContext) context).setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> DefaultResourceLoader) &#123;</span><br><span class=\"line\">            ((DefaultResourceLoader) context).setClassLoader(<span class=\"keyword\">this</span>.resourceLoader.getClassLoader());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addConversionService) &#123;</span><br><span class=\"line\">        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要为上下文装配工厂的<code>beanNameGenerator</code>、资源加载器和类加载器。</p>\n<h4 id=\"applyInitializers\"><a href=\"#applyInitializers\" class=\"headerlink\" title=\"applyInitializers\"></a>applyInitializers</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">applyInitializers</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class=\"line\">                                                                        ApplicationContextInitializer.class);</span><br><span class=\"line\">        Assert.isInstanceOf(requiredType, context, <span class=\"string\">&quot;Unable to call initializer.&quot;</span>);</span><br><span class=\"line\">        initializer.initialize(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。</p>\n<h3 id=\"contextLoaded\"><a href=\"#contextLoaded\" class=\"headerlink\" title=\"contextLoaded\"></a>contextLoaded</h3><p>这里主要是创建<code>BeanDefinitionLoader</code>，用来后续从xml、javaConfig中加载bean。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setBeanNameGenerator(<span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setEnvironment(<span class=\"keyword\">this</span>.environment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loader.load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：</p>\n<ul>\n<li>根据应用程序的类型创建对应的上下文</li>\n<li>初始化器配置上下文</li>\n<li>监听机制响应对应的事件</li>\n</ul>"},{"title":"mq","date":"2020-07-20T13:04:40.000Z","_content":"\nmq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。\n\n<!--more-->\n\n# MQ的引入\n\n模拟几个场景：\n\n1. `学生模块`和`老师模块`。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。\n\n   解决方式：引入`班长模块`，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。\n\n2. `系统A`需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。\n\n   上线后又新增了一个需求，`D`也要接收`A`的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对`A`进行改造，开发、联调效率低，耦合严重，增加`A`的负担。\n\n## 好处\n\n- 解决耦合  当新的模块接进来时，可以做到代码改动最小\n\n- 异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力\n\n- 削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨\n\n# 订阅模式\n\n| 比较项目   | Topic模式队列                                                | Queue模式队列                                                |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 工作模式   | ”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。 | ”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。 |\n| 有无状态   | 无状态                                                       | Queue数据默认会在mq服务器上以文件形式保存                    |\n| 传递完整性 | 如果没有订阅者，消息会被丢弃。不完整。                       | 消息不会丢弃                                                 |\n| 处理效率   | 由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异 | 由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的 |\n\n# JMS\n\nJava消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。\n\n实现JMS接口和规范的消息中间件，即我们的MQ服务器。\n\n## MESSAGE\n\nJMS message的组成：消息头 + 消息体 + 消息属性\n\n### 消息头\n\n记录常用的\n\n- JMSDestination 消息发送的目的地，Queue或Topic\n\n- JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。\n\n- JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除\n\n- JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通\n\n- JMSMessgeID 唯一ID，判断是否重复消费，幂等性\n\n### 消息体\n\n封装具体消息数据，5种格式。（使用频率高）\n\n- TextMessage 普通字符串消息 （使用频率高）\n\n- MapMessage map类型消息，key为String类型，值为Java基本数据类型\n\n- BytesMessage 二进制数组消息\n\n- StreamMessage 流\n\n- ObjectMessage 可序列化的Java对象\n\n发送和接受的消息类型必须一致。\n\n### 消息属性\n\n如果需要除消息头字段以外的值，那么可以使用消息属性。\n\n```java\nTextMessage tm = session.createTextMessage(\"wa wa\");\ntm.setStringProperty(\"c01\",\"vip\"); // 增加属性\n\n\nTextMessage tms = (TextMessage) messge;\nSystem.out.println(tms.getStringProperty(\"c01\")); // 接收\n```\n\n# 可靠性\n\nMQ挂了，消息的持久话和丢失的情况如何？一般有**三个特征**来保障：持久化、事务、签收，其中**事务偏生产者，签收偏消费者**。此外对于对于宕机，还有**多节点集群**。\n\n## 持久化 PERSISTENT\n\n参考redis的持久化（有rdb和aof），消息也有类似的辅助。\n\n### QUEUE\n\n#### 参数设置\n\n1. 非持久 服务器宕机，消息不存在\n\n   > messaegeProducer.setDeliveryMode(DeliveryMode.*NON_PRESISTENT*);\n\n2. 持久化 服务器宕机后消息依然存在\n\n   > messageProducer.setDelieveryMode(DeliveryMode._PRESISTENT_);\n\n#### 模拟场景\n\n非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。\n\n持久化时，上述操作后，数据依然存在。\n\n在队列中，如果**不显示标注持久**，**默认持久化**，因为可靠性是优先考虑的因素。\n\n持久、事物、签收\n\n### TOPIC\n\n对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：\n\n1. 先运行一次消费者，等于向MQ注册\n\n2. 然后再运行生产者发送信息\n\n3. 消费者一定会收到订阅消息。不在线的话下次连接时会接收。\n\n## 事务 TRANSACTION\n\n数据库的事务、ACID、隔离级别\n\n```java\n// 创建session的第一个参数即 事务是否开启\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n### 生产者\n\n- false 关闭事务，只要执行`send`就进入到队列中\n\n- true 开启事物，先执行`send`再执行`commit`，消息才被真正提交到队列中。\n\n对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。\n\n```java\ntry{\n    // ok session.commit;\n}catch (Exception e){\n    // error\n    session.rollback();\n}finally{\n    if(null != session){\n        session.close();\n    }\n}\n```\n\n### 消费者\n\n创建session时将事务改为`true`，同样需要`commit`，否则事务会被重复消费。\n\n## 签收 ACKNOWLEDGE\n\n分为事务和非事务两种情况\n\n#### 非事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n- 自动签收（默认）   **AUTO_ACKNOWLEDGE**  （使用频率高）\n\n- 手动签收 **CLIENT_ACKNOWLEDGE** （使用频率高）\n\n- 允许重复消息 **DUPS_OK_ACKNOWLEDGE**\n\n手动签收时需要手动标记，否则会造成重复消费：\n\n```java\nTextMessage tm = (TextMessage)messageConsumer.receive(4000L);\nif(null != tm){\n    tm.acknowledge();\n}else{\n    break;\n}\n// ...\n```\n\n### 事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n```\n\n有事务就需要`commit`。\n\n## 点对点\n\n基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的**异步传输**成为可能。类比平时的即时通讯工具。\n\n- 如果在**Session**关闭时有部分消息已被收到但还没有签收（**acknowledge**)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）\n\n- 队列可以长久地保存消息直到消费者收到消息。**消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态**，充分体现了异步传输模式的优势。\n\n## 发布订阅\n\nJMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作**topic**，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。\n\n### 非持久\n\n对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。\n\n### 持久化\n\n客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。\n\n# BROKER\n\n集群、配置时会用到。\n\n相当于一个ActiveMQ服务器**实例**，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。\n\n之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.\n\n## 消息发送模式\n\nActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。\n\n`ActiveMQ默认使用异步发送的模式`，**同步发送有两种情况**：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。\n\n异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，`允许在失败的情况下有少量的数据丢失`。\n\n# ACTIVEMQ的传输协议\n\nQ: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？\n\n调优：使用NIO传输协议\n\n支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）\n\n| 协议   | 描述                                |\n| ------ | ----------------------------------- |\n| TCP    | 默认的协议，性能相对可以            |\n| NIO    | 基于TCP协议之上的，进行了扩展和优化 |\n| HTP(s) | 基于HTTP(s)                         |\n\n## NIO\n\n要换为NIO，需要修改`activemq.xml`配置文件。\n\n```xml\n<broker>\n    ...\n        <transportConnectors>\n            <transportConnector name=\"nio\" uri=\"nio://192.168.111.136\"/>\n        </transportConnectors>\n    ...\n</broker>\n```\n\n在消费者、生产者修改代码，指定传输协议：\n\n```java\npublic stati final String ACTIVEMQ_URL = \"nio://192.168.111.136\";\n\n\npublic static void main(String[] args){\n    ActiveMQConnectionFactory af = new ActiveMQConnectionFactory(ACTIVEMQ_URL);\n    ......\n}\n```\n\n### 增强\n\nQ: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持`openwire（TCP）`，如何让这个端口支持NIO，又支持多个协议呢？\n\n默认是`BIO+TCP`，目前是`NIO+TCP`，那么如何做到`NIO+TCP/Mqtt/stomp`。\n\nA: 开启多协议支持，用`auto`关键字，[reference](https://activemq.apache.org/auto)。\n\n```xml\n<transportConnector name=\"auto\" uri=\"auto://localhost:5761\"/>\n```\n\n**note:** 在activeMQ后台配置面板的`Network`可以查看开启的网络协议。\n\n# ACTIVEMQ的存储和可持久化\n\n对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会`采用持久化机制`（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。\n\n主要介绍两个DB：`KahaDB`, `LevelDB`, `JDBC`\n\nQ: AMQ持久化机制\n\n## KahaDB\n\n基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。\n\n在配置文件中，有：\n\n```xml\n<persistenceAdapter>\n    <kahaDB directory=\"${activemq.data}/kahadb\"/>\n</persistenceAdpter>\n```\n\n### 存储原理\n\nreference [here](https:/activemq.apache.org/kahadb)\n\n可用于任何场合，提高了性能和恢复能力。消息存储使用一个**事务日志**和一个**索引文件**（存储所有地址）。\n\nKahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）\n\n#### db\\<Number\\>.log\n\n存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。\n\n#### db.data\n\n包含了持久化的`BTree索引`，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向`db-\\<Number>.log`里面存储的消息。\n\n#### db.free\n\n当前`db.data`文件里哪些页面是空闲的，文件具体内容是所有空闲页的**ID**. 类比linux的bash命令`free`。\n\n#### db.redo\n\n用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。\n\n#### lock\n\n相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。\n\n## JDBC\n\n主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。\n\n## LevelDB\n\n## JDBC Message store with ActiveMQ Journal\n\n主要。\n\n# Q&A\n\n1. 引入消息队列后该如何保证其高可用性\n\n2. 异步投递Async Sends\n\n3. 延迟投递和定时投递\n\n4. 分发策略\n\n5. ActiveMQ消费重试机制\n\n6. 死信队列\n\n7. 如何保证消息不被重复消费呢？谈谈幂等性问题\n\n## 高可用\n\nzookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。\n\n## 异步投递\n\n如何确认发送成功？ \n\n在消息发送完后接收回调。\n\n```java\nActiveMQConnectionFacotry acf = new ActiveMQConnectionFactory(URL);\n// 设置为异步发送消息\nacf.setUseAsyncSend(true);\nActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);\n...\nTextMessage message = session.createTextMessage();\n// 未message设置属性\nmessage.setJMSMessageID(UUID.randomUUID().toString());\n\n// 使用带有回调的send方法来发送\namp.send(message, new AsyncCallback(){\n    @Override\n    public void onSucces(){\n\n        System.out.println(message.getJMSmessageID+\" succeed\")\n    }\n    @Override\n    public void onException(JMSException exception){\n        // 拿到属性来确认发送失败的消息\n        System.out.println(message.getJMSmessageID+\" fail\")\n    }\n})\n```\n\n## 延迟投递和定时投递\n\n参考[官网说明](http://activemq.apache.org/delay-and-schedule-message-delivery.html)\n\n| Property name          | type   | description        |\n| ---------------------- | ------ | ------------------ |\n| AMQ\\_SCHEDULED\\_DELAY  | long   | 延迟投递的时间     |\n| AMQ\\_SCHEDULED\\_PERIOD | long   | 重复投递的时间间隔 |\n| AMQ\\_SCHEDULED\\_REPEAT | int    | 重复投递次数       |\n| AMQ\\_SCHEDULED\\_CRON   | String | Cron表达式         |\n\n在`activemq.xml`中配置*schedulerSupport*属性为*true*且Java代码中封装的辅助消息类型为*ScheduledMessage*即可。\n\n```java\nlong delay = 3 * 1000; //延迟投递的时间，每3秒\nlong period = 4 * 1000;\nint repeat = 5;\n\nTextMessage message = session.createTextMessage();\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);\nmessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);\n\nmessageProducer.send(mesage);\n...\n```\n\n## ActiveMQ消费重试机制\n\n- 哪些情况会引起消息重发？\n\n- 消息重发时间间隔和重发次数\n\n- 有毒消息Posion ACK\n\nreference [here](activemq.apache.org/redelivery-policy)\n\n重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。\n\n## 如何保证消息不被重复消费（幂等性）\n\n**note**: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。\n\n- 如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突\n\n- 使用第三方服务来做消费记录。以redis为例，给消息分配一个**全局id**，只要消费过该消息，将\\<id, message\\>以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。","source":"_posts/mq.md","raw":"---\ntitle: mq\ndate: 2020-07-20 21:04:40\ncategories: MiddleWare\ntags: activemq\n---\n\nmq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。\n\n<!--more-->\n\n# MQ的引入\n\n模拟几个场景：\n\n1. `学生模块`和`老师模块`。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。\n\n   解决方式：引入`班长模块`，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。\n\n2. `系统A`需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。\n\n   上线后又新增了一个需求，`D`也要接收`A`的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对`A`进行改造，开发、联调效率低，耦合严重，增加`A`的负担。\n\n## 好处\n\n- 解决耦合  当新的模块接进来时，可以做到代码改动最小\n\n- 异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力\n\n- 削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨\n\n# 订阅模式\n\n| 比较项目   | Topic模式队列                                                | Queue模式队列                                                |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 工作模式   | ”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。 | ”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。 |\n| 有无状态   | 无状态                                                       | Queue数据默认会在mq服务器上以文件形式保存                    |\n| 传递完整性 | 如果没有订阅者，消息会被丢弃。不完整。                       | 消息不会丢弃                                                 |\n| 处理效率   | 由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异 | 由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的 |\n\n# JMS\n\nJava消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。\n\n实现JMS接口和规范的消息中间件，即我们的MQ服务器。\n\n## MESSAGE\n\nJMS message的组成：消息头 + 消息体 + 消息属性\n\n### 消息头\n\n记录常用的\n\n- JMSDestination 消息发送的目的地，Queue或Topic\n\n- JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。\n\n- JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除\n\n- JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通\n\n- JMSMessgeID 唯一ID，判断是否重复消费，幂等性\n\n### 消息体\n\n封装具体消息数据，5种格式。（使用频率高）\n\n- TextMessage 普通字符串消息 （使用频率高）\n\n- MapMessage map类型消息，key为String类型，值为Java基本数据类型\n\n- BytesMessage 二进制数组消息\n\n- StreamMessage 流\n\n- ObjectMessage 可序列化的Java对象\n\n发送和接受的消息类型必须一致。\n\n### 消息属性\n\n如果需要除消息头字段以外的值，那么可以使用消息属性。\n\n```java\nTextMessage tm = session.createTextMessage(\"wa wa\");\ntm.setStringProperty(\"c01\",\"vip\"); // 增加属性\n\n\nTextMessage tms = (TextMessage) messge;\nSystem.out.println(tms.getStringProperty(\"c01\")); // 接收\n```\n\n# 可靠性\n\nMQ挂了，消息的持久话和丢失的情况如何？一般有**三个特征**来保障：持久化、事务、签收，其中**事务偏生产者，签收偏消费者**。此外对于对于宕机，还有**多节点集群**。\n\n## 持久化 PERSISTENT\n\n参考redis的持久化（有rdb和aof），消息也有类似的辅助。\n\n### QUEUE\n\n#### 参数设置\n\n1. 非持久 服务器宕机，消息不存在\n\n   > messaegeProducer.setDeliveryMode(DeliveryMode.*NON_PRESISTENT*);\n\n2. 持久化 服务器宕机后消息依然存在\n\n   > messageProducer.setDelieveryMode(DeliveryMode._PRESISTENT_);\n\n#### 模拟场景\n\n非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。\n\n持久化时，上述操作后，数据依然存在。\n\n在队列中，如果**不显示标注持久**，**默认持久化**，因为可靠性是优先考虑的因素。\n\n持久、事物、签收\n\n### TOPIC\n\n对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：\n\n1. 先运行一次消费者，等于向MQ注册\n\n2. 然后再运行生产者发送信息\n\n3. 消费者一定会收到订阅消息。不在线的话下次连接时会接收。\n\n## 事务 TRANSACTION\n\n数据库的事务、ACID、隔离级别\n\n```java\n// 创建session的第一个参数即 事务是否开启\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n### 生产者\n\n- false 关闭事务，只要执行`send`就进入到队列中\n\n- true 开启事物，先执行`send`再执行`commit`，消息才被真正提交到队列中。\n\n对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。\n\n```java\ntry{\n    // ok session.commit;\n}catch (Exception e){\n    // error\n    session.rollback();\n}finally{\n    if(null != session){\n        session.close();\n    }\n}\n```\n\n### 消费者\n\n创建session时将事务改为`true`，同样需要`commit`，否则事务会被重复消费。\n\n## 签收 ACKNOWLEDGE\n\n分为事务和非事务两种情况\n\n#### 非事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n- 自动签收（默认）   **AUTO_ACKNOWLEDGE**  （使用频率高）\n\n- 手动签收 **CLIENT_ACKNOWLEDGE** （使用频率高）\n\n- 允许重复消息 **DUPS_OK_ACKNOWLEDGE**\n\n手动签收时需要手动标记，否则会造成重复消费：\n\n```java\nTextMessage tm = (TextMessage)messageConsumer.receive(4000L);\nif(null != tm){\n    tm.acknowledge();\n}else{\n    break;\n}\n// ...\n```\n\n### 事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n```\n\n有事务就需要`commit`。\n\n## 点对点\n\n基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的**异步传输**成为可能。类比平时的即时通讯工具。\n\n- 如果在**Session**关闭时有部分消息已被收到但还没有签收（**acknowledge**)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）\n\n- 队列可以长久地保存消息直到消费者收到消息。**消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态**，充分体现了异步传输模式的优势。\n\n## 发布订阅\n\nJMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作**topic**，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。\n\n### 非持久\n\n对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。\n\n### 持久化\n\n客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。\n\n# BROKER\n\n集群、配置时会用到。\n\n相当于一个ActiveMQ服务器**实例**，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。\n\n之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.\n\n## 消息发送模式\n\nActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。\n\n`ActiveMQ默认使用异步发送的模式`，**同步发送有两种情况**：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。\n\n异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，`允许在失败的情况下有少量的数据丢失`。\n\n# ACTIVEMQ的传输协议\n\nQ: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？\n\n调优：使用NIO传输协议\n\n支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）\n\n| 协议   | 描述                                |\n| ------ | ----------------------------------- |\n| TCP    | 默认的协议，性能相对可以            |\n| NIO    | 基于TCP协议之上的，进行了扩展和优化 |\n| HTP(s) | 基于HTTP(s)                         |\n\n## NIO\n\n要换为NIO，需要修改`activemq.xml`配置文件。\n\n```xml\n<broker>\n    ...\n        <transportConnectors>\n            <transportConnector name=\"nio\" uri=\"nio://192.168.111.136\"/>\n        </transportConnectors>\n    ...\n</broker>\n```\n\n在消费者、生产者修改代码，指定传输协议：\n\n```java\npublic stati final String ACTIVEMQ_URL = \"nio://192.168.111.136\";\n\n\npublic static void main(String[] args){\n    ActiveMQConnectionFactory af = new ActiveMQConnectionFactory(ACTIVEMQ_URL);\n    ......\n}\n```\n\n### 增强\n\nQ: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持`openwire（TCP）`，如何让这个端口支持NIO，又支持多个协议呢？\n\n默认是`BIO+TCP`，目前是`NIO+TCP`，那么如何做到`NIO+TCP/Mqtt/stomp`。\n\nA: 开启多协议支持，用`auto`关键字，[reference](https://activemq.apache.org/auto)。\n\n```xml\n<transportConnector name=\"auto\" uri=\"auto://localhost:5761\"/>\n```\n\n**note:** 在activeMQ后台配置面板的`Network`可以查看开启的网络协议。\n\n# ACTIVEMQ的存储和可持久化\n\n对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会`采用持久化机制`（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。\n\n主要介绍两个DB：`KahaDB`, `LevelDB`, `JDBC`\n\nQ: AMQ持久化机制\n\n## KahaDB\n\n基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。\n\n在配置文件中，有：\n\n```xml\n<persistenceAdapter>\n    <kahaDB directory=\"${activemq.data}/kahadb\"/>\n</persistenceAdpter>\n```\n\n### 存储原理\n\nreference [here](https:/activemq.apache.org/kahadb)\n\n可用于任何场合，提高了性能和恢复能力。消息存储使用一个**事务日志**和一个**索引文件**（存储所有地址）。\n\nKahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）\n\n#### db\\<Number\\>.log\n\n存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。\n\n#### db.data\n\n包含了持久化的`BTree索引`，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向`db-\\<Number>.log`里面存储的消息。\n\n#### db.free\n\n当前`db.data`文件里哪些页面是空闲的，文件具体内容是所有空闲页的**ID**. 类比linux的bash命令`free`。\n\n#### db.redo\n\n用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。\n\n#### lock\n\n相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。\n\n## JDBC\n\n主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。\n\n## LevelDB\n\n## JDBC Message store with ActiveMQ Journal\n\n主要。\n\n# Q&A\n\n1. 引入消息队列后该如何保证其高可用性\n\n2. 异步投递Async Sends\n\n3. 延迟投递和定时投递\n\n4. 分发策略\n\n5. ActiveMQ消费重试机制\n\n6. 死信队列\n\n7. 如何保证消息不被重复消费呢？谈谈幂等性问题\n\n## 高可用\n\nzookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。\n\n## 异步投递\n\n如何确认发送成功？ \n\n在消息发送完后接收回调。\n\n```java\nActiveMQConnectionFacotry acf = new ActiveMQConnectionFactory(URL);\n// 设置为异步发送消息\nacf.setUseAsyncSend(true);\nActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);\n...\nTextMessage message = session.createTextMessage();\n// 未message设置属性\nmessage.setJMSMessageID(UUID.randomUUID().toString());\n\n// 使用带有回调的send方法来发送\namp.send(message, new AsyncCallback(){\n    @Override\n    public void onSucces(){\n\n        System.out.println(message.getJMSmessageID+\" succeed\")\n    }\n    @Override\n    public void onException(JMSException exception){\n        // 拿到属性来确认发送失败的消息\n        System.out.println(message.getJMSmessageID+\" fail\")\n    }\n})\n```\n\n## 延迟投递和定时投递\n\n参考[官网说明](http://activemq.apache.org/delay-and-schedule-message-delivery.html)\n\n| Property name          | type   | description        |\n| ---------------------- | ------ | ------------------ |\n| AMQ\\_SCHEDULED\\_DELAY  | long   | 延迟投递的时间     |\n| AMQ\\_SCHEDULED\\_PERIOD | long   | 重复投递的时间间隔 |\n| AMQ\\_SCHEDULED\\_REPEAT | int    | 重复投递次数       |\n| AMQ\\_SCHEDULED\\_CRON   | String | Cron表达式         |\n\n在`activemq.xml`中配置*schedulerSupport*属性为*true*且Java代码中封装的辅助消息类型为*ScheduledMessage*即可。\n\n```java\nlong delay = 3 * 1000; //延迟投递的时间，每3秒\nlong period = 4 * 1000;\nint repeat = 5;\n\nTextMessage message = session.createTextMessage();\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);\nmessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);\n\nmessageProducer.send(mesage);\n...\n```\n\n## ActiveMQ消费重试机制\n\n- 哪些情况会引起消息重发？\n\n- 消息重发时间间隔和重发次数\n\n- 有毒消息Posion ACK\n\nreference [here](activemq.apache.org/redelivery-policy)\n\n重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。\n\n## 如何保证消息不被重复消费（幂等性）\n\n**note**: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。\n\n- 如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突\n\n- 使用第三方服务来做消费记录。以redis为例，给消息分配一个**全局id**，只要消费过该消息，将\\<id, message\\>以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。","slug":"mq","published":1,"updated":"2020-11-08T07:20:16.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn438q930041w5ih5mop3veu","content":"<p>mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"MQ的引入\"><a href=\"#MQ的引入\" class=\"headerlink\" title=\"MQ的引入\"></a>MQ的引入</h1><p>模拟几个场景：</p>\n<ol>\n<li><p><code>学生模块</code>和<code>老师模块</code>。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。</p>\n<p>解决方式：引入<code>班长模块</code>，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。</p>\n</li>\n<li><p><code>系统A</code>需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。</p>\n<p>上线后又新增了一个需求，<code>D</code>也要接收<code>A</code>的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对<code>A</code>进行改造，开发、联调效率低，耦合严重，增加<code>A</code>的负担。</p>\n</li>\n</ol>\n<h2 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h2><ul>\n<li><p>解决耦合  当新的模块接进来时，可以做到代码改动最小</p>\n</li>\n<li><p>异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力</p>\n</li>\n<li><p>削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨</p>\n</li>\n</ul>\n<h1 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h1><table>\n<thead>\n<tr>\n<th>比较项目</th>\n<th>Topic模式队列</th>\n<th>Queue模式队列</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工作模式</td>\n<td>”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。</td>\n<td>”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。</td>\n</tr>\n<tr>\n<td>有无状态</td>\n<td>无状态</td>\n<td>Queue数据默认会在mq服务器上以文件形式保存</td>\n</tr>\n<tr>\n<td>传递完整性</td>\n<td>如果没有订阅者，消息会被丢弃。不完整。</td>\n<td>消息不会丢弃</td>\n</tr>\n<tr>\n<td>处理效率</td>\n<td>由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异</td>\n<td>由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的</td>\n</tr>\n</tbody></table>\n<h1 id=\"JMS\"><a href=\"#JMS\" class=\"headerlink\" title=\"JMS\"></a>JMS</h1><p>Java消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。</p>\n<p>实现JMS接口和规范的消息中间件，即我们的MQ服务器。</p>\n<h2 id=\"MESSAGE\"><a href=\"#MESSAGE\" class=\"headerlink\" title=\"MESSAGE\"></a>MESSAGE</h2><p>JMS message的组成：消息头 + 消息体 + 消息属性</p>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><p>记录常用的</p>\n<ul>\n<li><p>JMSDestination 消息发送的目的地，Queue或Topic</p>\n</li>\n<li><p>JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。</p>\n</li>\n<li><p>JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除</p>\n</li>\n<li><p>JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通</p>\n</li>\n<li><p>JMSMessgeID 唯一ID，判断是否重复消费，幂等性</p>\n</li>\n</ul>\n<h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><p>封装具体消息数据，5种格式。（使用频率高）</p>\n<ul>\n<li><p>TextMessage 普通字符串消息 （使用频率高）</p>\n</li>\n<li><p>MapMessage map类型消息，key为String类型，值为Java基本数据类型</p>\n</li>\n<li><p>BytesMessage 二进制数组消息</p>\n</li>\n<li><p>StreamMessage 流</p>\n</li>\n<li><p>ObjectMessage 可序列化的Java对象</p>\n</li>\n</ul>\n<p>发送和接受的消息类型必须一致。</p>\n<h3 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h3><p>如果需要除消息头字段以外的值，那么可以使用消息属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = session.createTextMessage(<span class=\"string\">&quot;wa wa&quot;</span>);</span><br><span class=\"line\">tm.setStringProperty(<span class=\"string\">&quot;c01&quot;</span>,<span class=\"string\">&quot;vip&quot;</span>); <span class=\"comment\">// 增加属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage tms = (TextMessage) messge;</span><br><span class=\"line\">System.out.println(tms.getStringProperty(<span class=\"string\">&quot;c01&quot;</span>)); <span class=\"comment\">// 接收</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>MQ挂了，消息的持久话和丢失的情况如何？一般有<strong>三个特征</strong>来保障：持久化、事务、签收，其中<strong>事务偏生产者，签收偏消费者</strong>。此外对于对于宕机，还有<strong>多节点集群</strong>。</p>\n<h2 id=\"持久化-PERSISTENT\"><a href=\"#持久化-PERSISTENT\" class=\"headerlink\" title=\"持久化 PERSISTENT\"></a>持久化 PERSISTENT</h2><p>参考redis的持久化（有rdb和aof），消息也有类似的辅助。</p>\n<h3 id=\"QUEUE\"><a href=\"#QUEUE\" class=\"headerlink\" title=\"QUEUE\"></a>QUEUE</h3><h4 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h4><ol>\n<li><p>非持久 服务器宕机，消息不存在</p>\n<blockquote>\n<p>messaegeProducer.setDeliveryMode(DeliveryMode.<em>NON_PRESISTENT</em>);</p>\n</blockquote>\n</li>\n<li><p>持久化 服务器宕机后消息依然存在</p>\n<blockquote>\n<p>messageProducer.setDelieveryMode(DeliveryMode.<em>PRESISTENT</em>);</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"模拟场景\"><a href=\"#模拟场景\" class=\"headerlink\" title=\"模拟场景\"></a>模拟场景</h4><p>非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。</p>\n<p>持久化时，上述操作后，数据依然存在。</p>\n<p>在队列中，如果<strong>不显示标注持久</strong>，<strong>默认持久化</strong>，因为可靠性是优先考虑的因素。</p>\n<p>持久、事物、签收</p>\n<h3 id=\"TOPIC\"><a href=\"#TOPIC\" class=\"headerlink\" title=\"TOPIC\"></a>TOPIC</h3><p>对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：</p>\n<ol>\n<li><p>先运行一次消费者，等于向MQ注册</p>\n</li>\n<li><p>然后再运行生产者发送信息</p>\n</li>\n<li><p>消费者一定会收到订阅消息。不在线的话下次连接时会接收。</p>\n</li>\n</ol>\n<h2 id=\"事务-TRANSACTION\"><a href=\"#事务-TRANSACTION\" class=\"headerlink\" title=\"事务 TRANSACTION\"></a>事务 TRANSACTION</h2><p>数据库的事务、ACID、隔离级别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第一个参数即 事务是否开启</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><ul>\n<li><p>false 关闭事务，只要执行<code>send</code>就进入到队列中</p>\n</li>\n<li><p>true 开启事物，先执行<code>send</code>再执行<code>commit</code>，消息才被真正提交到队列中。</p>\n</li>\n</ul>\n<p>对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ok session.commit;</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">    session.rollback();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != session)&#123;</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>创建session时将事务改为<code>true</code>，同样需要<code>commit</code>，否则事务会被重复消费。</p>\n<h2 id=\"签收-ACKNOWLEDGE\"><a href=\"#签收-ACKNOWLEDGE\" class=\"headerlink\" title=\"签收 ACKNOWLEDGE\"></a>签收 ACKNOWLEDGE</h2><p>分为事务和非事务两种情况</p>\n<h4 id=\"非事务\"><a href=\"#非事务\" class=\"headerlink\" title=\"非事务\"></a>非事务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>自动签收（默认）   <strong>AUTO_ACKNOWLEDGE</strong>  （使用频率高）</p>\n</li>\n<li><p>手动签收 <strong>CLIENT_ACKNOWLEDGE</strong> （使用频率高）</p>\n</li>\n<li><p>允许重复消息 <strong>DUPS_OK_ACKNOWLEDGE</strong></p>\n</li>\n</ul>\n<p>手动签收时需要手动标记，否则会造成重复消费：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = (TextMessage)messageConsumer.receive(<span class=\"number\">4000L</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != tm)&#123;</span><br><span class=\"line\">    tm.acknowledge();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<p>有事务就需要<code>commit</code>。</p>\n<h2 id=\"点对点\"><a href=\"#点对点\" class=\"headerlink\" title=\"点对点\"></a>点对点</h2><p>基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。类比平时的即时通讯工具。</p>\n<ul>\n<li><p>如果在<strong>Session</strong>关闭时有部分消息已被收到但还没有签收（<strong>acknowledge</strong>)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）</p>\n</li>\n<li><p>队列可以长久地保存消息直到消费者收到消息。<strong>消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态</strong>，充分体现了异步传输模式的优势。</p>\n</li>\n</ul>\n<h2 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h2><p>JMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作<strong>topic</strong>，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。</p>\n<h3 id=\"非持久\"><a href=\"#非持久\" class=\"headerlink\" title=\"非持久\"></a>非持久</h3><p>对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。</p>\n<h3 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h3><p>客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。</p>\n<h1 id=\"BROKER\"><a href=\"#BROKER\" class=\"headerlink\" title=\"BROKER\"></a>BROKER</h1><p>集群、配置时会用到。</p>\n<p>相当于一个ActiveMQ服务器<strong>实例</strong>，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。</p>\n<p>之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.</p>\n<h2 id=\"消息发送模式\"><a href=\"#消息发送模式\" class=\"headerlink\" title=\"消息发送模式\"></a>消息发送模式</h2><p>ActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。</p>\n<p><code>ActiveMQ默认使用异步发送的模式</code>，<strong>同步发送有两种情况</strong>：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。</p>\n<p>异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，<code>允许在失败的情况下有少量的数据丢失</code>。</p>\n<h1 id=\"ACTIVEMQ的传输协议\"><a href=\"#ACTIVEMQ的传输协议\" class=\"headerlink\" title=\"ACTIVEMQ的传输协议\"></a>ACTIVEMQ的传输协议</h1><p>Q: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？</p>\n<p>调优：使用NIO传输协议</p>\n<p>支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP</td>\n<td>默认的协议，性能相对可以</td>\n</tr>\n<tr>\n<td>NIO</td>\n<td>基于TCP协议之上的，进行了扩展和优化</td>\n</tr>\n<tr>\n<td>HTP(s)</td>\n<td>基于HTTP(s)</td>\n</tr>\n</tbody></table>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>要换为NIO，需要修改<code>activemq.xml</code>配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">broker</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nio&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;nio://192.168.111.136&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">broker</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在消费者、生产者修改代码，指定传输协议：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> stati <span class=\"keyword\">final</span> String ACTIVEMQ_URL = <span class=\"string\">&quot;nio://192.168.111.136&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    ActiveMQConnectionFactory af = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增强\"><a href=\"#增强\" class=\"headerlink\" title=\"增强\"></a>增强</h3><p>Q: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持<code>openwire（TCP）</code>，如何让这个端口支持NIO，又支持多个协议呢？</p>\n<p>默认是<code>BIO+TCP</code>，目前是<code>NIO+TCP</code>，那么如何做到<code>NIO+TCP/Mqtt/stomp</code>。</p>\n<p>A: 开启多协议支持，用<code>auto</code>关键字，<a href=\"https://activemq.apache.org/auto\">reference</a>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;auto://localhost:5761&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 在activeMQ后台配置面板的<code>Network</code>可以查看开启的网络协议。</p>\n<h1 id=\"ACTIVEMQ的存储和可持久化\"><a href=\"#ACTIVEMQ的存储和可持久化\" class=\"headerlink\" title=\"ACTIVEMQ的存储和可持久化\"></a>ACTIVEMQ的存储和可持久化</h1><p>对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会<code>采用持久化机制</code>（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p>\n<p>主要介绍两个DB：<code>KahaDB</code>, <code>LevelDB</code>, <code>JDBC</code></p>\n<p>Q: AMQ持久化机制</p>\n<h2 id=\"KahaDB\"><a href=\"#KahaDB\" class=\"headerlink\" title=\"KahaDB\"></a>KahaDB</h2><p>基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。</p>\n<p>在配置文件中，有：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">persistenceAdapter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">kahaDB</span> <span class=\"attr\">directory</span>=<span class=\"string\">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">persistenceAdpter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储原理\"><a href=\"#存储原理\" class=\"headerlink\" title=\"存储原理\"></a>存储原理</h3><p>reference <a href=\"https://activemq.apache.org/kahadb\">here</a></p>\n<p>可用于任何场合，提高了性能和恢复能力。消息存储使用一个<strong>事务日志</strong>和一个<strong>索引文件</strong>（存储所有地址）。</p>\n<p>Kahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）</p>\n<h4 id=\"db-lt-Number-gt-log\"><a href=\"#db-lt-Number-gt-log\" class=\"headerlink\" title=\"db&lt;Number&gt;.log\"></a>db&lt;Number&gt;.log</h4><p>存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。</p>\n<h4 id=\"db-data\"><a href=\"#db-data\" class=\"headerlink\" title=\"db.data\"></a>db.data</h4><p>包含了持久化的<code>BTree索引</code>，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向<code>db-\\&lt;Number&gt;.log</code>里面存储的消息。</p>\n<h4 id=\"db-free\"><a href=\"#db-free\" class=\"headerlink\" title=\"db.free\"></a>db.free</h4><p>当前<code>db.data</code>文件里哪些页面是空闲的，文件具体内容是所有空闲页的<strong>ID</strong>. 类比linux的bash命令<code>free</code>。</p>\n<h4 id=\"db-redo\"><a href=\"#db-redo\" class=\"headerlink\" title=\"db.redo\"></a>db.redo</h4><p>用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。</p>\n<h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h4><p>相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。</p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。</p>\n<h2 id=\"LevelDB\"><a href=\"#LevelDB\" class=\"headerlink\" title=\"LevelDB\"></a>LevelDB</h2><h2 id=\"JDBC-Message-store-with-ActiveMQ-Journal\"><a href=\"#JDBC-Message-store-with-ActiveMQ-Journal\" class=\"headerlink\" title=\"JDBC Message store with ActiveMQ Journal\"></a>JDBC Message store with ActiveMQ Journal</h2><p>主要。</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><ol>\n<li><p>引入消息队列后该如何保证其高可用性</p>\n</li>\n<li><p>异步投递Async Sends</p>\n</li>\n<li><p>延迟投递和定时投递</p>\n</li>\n<li><p>分发策略</p>\n</li>\n<li><p>ActiveMQ消费重试机制</p>\n</li>\n<li><p>死信队列</p>\n</li>\n<li><p>如何保证消息不被重复消费呢？谈谈幂等性问题</p>\n</li>\n</ol>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><p>zookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。</p>\n<h2 id=\"异步投递\"><a href=\"#异步投递\" class=\"headerlink\" title=\"异步投递\"></a>异步投递</h2><p>如何确认发送成功？ </p>\n<p>在消息发送完后接收回调。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveMQConnectionFacotry acf = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(URL);</span><br><span class=\"line\"><span class=\"comment\">// 设置为异步发送消息</span></span><br><span class=\"line\">acf.setUseAsyncSend(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">ActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class=\"line\">...</span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\"><span class=\"comment\">// 未message设置属性</span></span><br><span class=\"line\">message.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用带有回调的send方法来发送</span></span><br><span class=\"line\">amp.send(message, <span class=\"keyword\">new</span> AsyncCallback()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSucces</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; succeed&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(JMSException exception)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到属性来确认发送失败的消息</span></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; fail&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"延迟投递和定时投递\"><a href=\"#延迟投递和定时投递\" class=\"headerlink\" title=\"延迟投递和定时投递\"></a>延迟投递和定时投递</h2><p>参考<a href=\"http://activemq.apache.org/delay-and-schedule-message-delivery.html\">官网说明</a></p>\n<table>\n<thead>\n<tr>\n<th>Property name</th>\n<th>type</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AMQ_SCHEDULED_DELAY</td>\n<td>long</td>\n<td>延迟投递的时间</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_PERIOD</td>\n<td>long</td>\n<td>重复投递的时间间隔</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_REPEAT</td>\n<td>int</td>\n<td>重复投递次数</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_CRON</td>\n<td>String</td>\n<td>Cron表达式</td>\n</tr>\n</tbody></table>\n<p>在<code>activemq.xml</code>中配置<em>schedulerSupport</em>属性为<em>true</em>且Java代码中封装的辅助消息类型为<em>ScheduledMessage</em>即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> delay = <span class=\"number\">3</span> * <span class=\"number\">1000</span>; <span class=\"comment\">//延迟投递的时间，每3秒</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> period = <span class=\"number\">4</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> repeat = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);</span><br><span class=\"line\">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);</span><br><span class=\"line\"></span><br><span class=\"line\">messageProducer.send(mesage);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ActiveMQ消费重试机制\"><a href=\"#ActiveMQ消费重试机制\" class=\"headerlink\" title=\"ActiveMQ消费重试机制\"></a>ActiveMQ消费重试机制</h2><ul>\n<li><p>哪些情况会引起消息重发？</p>\n</li>\n<li><p>消息重发时间间隔和重发次数</p>\n</li>\n<li><p>有毒消息Posion ACK</p>\n</li>\n</ul>\n<p>reference <a href=\"activemq.apache.org/redelivery-policy\">here</a></p>\n<p>重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。</p>\n<h2 id=\"如何保证消息不被重复消费（幂等性）\"><a href=\"#如何保证消息不被重复消费（幂等性）\" class=\"headerlink\" title=\"如何保证消息不被重复消费（幂等性）\"></a>如何保证消息不被重复消费（幂等性）</h2><p><strong>note</strong>: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。</p>\n<ul>\n<li><p>如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突</p>\n</li>\n<li><p>使用第三方服务来做消费记录。以redis为例，给消息分配一个<strong>全局id</strong>，只要消费过该消息，将&lt;id, message&gt;以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。</p>\n</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。</p>","more":"<h1 id=\"MQ的引入\"><a href=\"#MQ的引入\" class=\"headerlink\" title=\"MQ的引入\"></a>MQ的引入</h1><p>模拟几个场景：</p>\n<ol>\n<li><p><code>学生模块</code>和<code>老师模块</code>。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。</p>\n<p>解决方式：引入<code>班长模块</code>，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。</p>\n</li>\n<li><p><code>系统A</code>需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。</p>\n<p>上线后又新增了一个需求，<code>D</code>也要接收<code>A</code>的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对<code>A</code>进行改造，开发、联调效率低，耦合严重，增加<code>A</code>的负担。</p>\n</li>\n</ol>\n<h2 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h2><ul>\n<li><p>解决耦合  当新的模块接进来时，可以做到代码改动最小</p>\n</li>\n<li><p>异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力</p>\n</li>\n<li><p>削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨</p>\n</li>\n</ul>\n<h1 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h1><table>\n<thead>\n<tr>\n<th>比较项目</th>\n<th>Topic模式队列</th>\n<th>Queue模式队列</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工作模式</td>\n<td>”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。</td>\n<td>”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。</td>\n</tr>\n<tr>\n<td>有无状态</td>\n<td>无状态</td>\n<td>Queue数据默认会在mq服务器上以文件形式保存</td>\n</tr>\n<tr>\n<td>传递完整性</td>\n<td>如果没有订阅者，消息会被丢弃。不完整。</td>\n<td>消息不会丢弃</td>\n</tr>\n<tr>\n<td>处理效率</td>\n<td>由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异</td>\n<td>由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的</td>\n</tr>\n</tbody></table>\n<h1 id=\"JMS\"><a href=\"#JMS\" class=\"headerlink\" title=\"JMS\"></a>JMS</h1><p>Java消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。</p>\n<p>实现JMS接口和规范的消息中间件，即我们的MQ服务器。</p>\n<h2 id=\"MESSAGE\"><a href=\"#MESSAGE\" class=\"headerlink\" title=\"MESSAGE\"></a>MESSAGE</h2><p>JMS message的组成：消息头 + 消息体 + 消息属性</p>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><p>记录常用的</p>\n<ul>\n<li><p>JMSDestination 消息发送的目的地，Queue或Topic</p>\n</li>\n<li><p>JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。</p>\n</li>\n<li><p>JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除</p>\n</li>\n<li><p>JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通</p>\n</li>\n<li><p>JMSMessgeID 唯一ID，判断是否重复消费，幂等性</p>\n</li>\n</ul>\n<h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><p>封装具体消息数据，5种格式。（使用频率高）</p>\n<ul>\n<li><p>TextMessage 普通字符串消息 （使用频率高）</p>\n</li>\n<li><p>MapMessage map类型消息，key为String类型，值为Java基本数据类型</p>\n</li>\n<li><p>BytesMessage 二进制数组消息</p>\n</li>\n<li><p>StreamMessage 流</p>\n</li>\n<li><p>ObjectMessage 可序列化的Java对象</p>\n</li>\n</ul>\n<p>发送和接受的消息类型必须一致。</p>\n<h3 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h3><p>如果需要除消息头字段以外的值，那么可以使用消息属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = session.createTextMessage(<span class=\"string\">&quot;wa wa&quot;</span>);</span><br><span class=\"line\">tm.setStringProperty(<span class=\"string\">&quot;c01&quot;</span>,<span class=\"string\">&quot;vip&quot;</span>); <span class=\"comment\">// 增加属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage tms = (TextMessage) messge;</span><br><span class=\"line\">System.out.println(tms.getStringProperty(<span class=\"string\">&quot;c01&quot;</span>)); <span class=\"comment\">// 接收</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>MQ挂了，消息的持久话和丢失的情况如何？一般有<strong>三个特征</strong>来保障：持久化、事务、签收，其中<strong>事务偏生产者，签收偏消费者</strong>。此外对于对于宕机，还有<strong>多节点集群</strong>。</p>\n<h2 id=\"持久化-PERSISTENT\"><a href=\"#持久化-PERSISTENT\" class=\"headerlink\" title=\"持久化 PERSISTENT\"></a>持久化 PERSISTENT</h2><p>参考redis的持久化（有rdb和aof），消息也有类似的辅助。</p>\n<h3 id=\"QUEUE\"><a href=\"#QUEUE\" class=\"headerlink\" title=\"QUEUE\"></a>QUEUE</h3><h4 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h4><ol>\n<li><p>非持久 服务器宕机，消息不存在</p>\n<blockquote>\n<p>messaegeProducer.setDeliveryMode(DeliveryMode.<em>NON_PRESISTENT</em>);</p>\n</blockquote>\n</li>\n<li><p>持久化 服务器宕机后消息依然存在</p>\n<blockquote>\n<p>messageProducer.setDelieveryMode(DeliveryMode.<em>PRESISTENT</em>);</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"模拟场景\"><a href=\"#模拟场景\" class=\"headerlink\" title=\"模拟场景\"></a>模拟场景</h4><p>非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。</p>\n<p>持久化时，上述操作后，数据依然存在。</p>\n<p>在队列中，如果<strong>不显示标注持久</strong>，<strong>默认持久化</strong>，因为可靠性是优先考虑的因素。</p>\n<p>持久、事物、签收</p>\n<h3 id=\"TOPIC\"><a href=\"#TOPIC\" class=\"headerlink\" title=\"TOPIC\"></a>TOPIC</h3><p>对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：</p>\n<ol>\n<li><p>先运行一次消费者，等于向MQ注册</p>\n</li>\n<li><p>然后再运行生产者发送信息</p>\n</li>\n<li><p>消费者一定会收到订阅消息。不在线的话下次连接时会接收。</p>\n</li>\n</ol>\n<h2 id=\"事务-TRANSACTION\"><a href=\"#事务-TRANSACTION\" class=\"headerlink\" title=\"事务 TRANSACTION\"></a>事务 TRANSACTION</h2><p>数据库的事务、ACID、隔离级别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第一个参数即 事务是否开启</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><ul>\n<li><p>false 关闭事务，只要执行<code>send</code>就进入到队列中</p>\n</li>\n<li><p>true 开启事物，先执行<code>send</code>再执行<code>commit</code>，消息才被真正提交到队列中。</p>\n</li>\n</ul>\n<p>对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ok session.commit;</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">    session.rollback();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != session)&#123;</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>创建session时将事务改为<code>true</code>，同样需要<code>commit</code>，否则事务会被重复消费。</p>\n<h2 id=\"签收-ACKNOWLEDGE\"><a href=\"#签收-ACKNOWLEDGE\" class=\"headerlink\" title=\"签收 ACKNOWLEDGE\"></a>签收 ACKNOWLEDGE</h2><p>分为事务和非事务两种情况</p>\n<h4 id=\"非事务\"><a href=\"#非事务\" class=\"headerlink\" title=\"非事务\"></a>非事务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>自动签收（默认）   <strong>AUTO_ACKNOWLEDGE</strong>  （使用频率高）</p>\n</li>\n<li><p>手动签收 <strong>CLIENT_ACKNOWLEDGE</strong> （使用频率高）</p>\n</li>\n<li><p>允许重复消息 <strong>DUPS_OK_ACKNOWLEDGE</strong></p>\n</li>\n</ul>\n<p>手动签收时需要手动标记，否则会造成重复消费：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = (TextMessage)messageConsumer.receive(<span class=\"number\">4000L</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != tm)&#123;</span><br><span class=\"line\">    tm.acknowledge();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<p>有事务就需要<code>commit</code>。</p>\n<h2 id=\"点对点\"><a href=\"#点对点\" class=\"headerlink\" title=\"点对点\"></a>点对点</h2><p>基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。类比平时的即时通讯工具。</p>\n<ul>\n<li><p>如果在<strong>Session</strong>关闭时有部分消息已被收到但还没有签收（<strong>acknowledge</strong>)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）</p>\n</li>\n<li><p>队列可以长久地保存消息直到消费者收到消息。<strong>消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态</strong>，充分体现了异步传输模式的优势。</p>\n</li>\n</ul>\n<h2 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h2><p>JMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作<strong>topic</strong>，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。</p>\n<h3 id=\"非持久\"><a href=\"#非持久\" class=\"headerlink\" title=\"非持久\"></a>非持久</h3><p>对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。</p>\n<h3 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h3><p>客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。</p>\n<h1 id=\"BROKER\"><a href=\"#BROKER\" class=\"headerlink\" title=\"BROKER\"></a>BROKER</h1><p>集群、配置时会用到。</p>\n<p>相当于一个ActiveMQ服务器<strong>实例</strong>，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。</p>\n<p>之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.</p>\n<h2 id=\"消息发送模式\"><a href=\"#消息发送模式\" class=\"headerlink\" title=\"消息发送模式\"></a>消息发送模式</h2><p>ActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。</p>\n<p><code>ActiveMQ默认使用异步发送的模式</code>，<strong>同步发送有两种情况</strong>：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。</p>\n<p>异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，<code>允许在失败的情况下有少量的数据丢失</code>。</p>\n<h1 id=\"ACTIVEMQ的传输协议\"><a href=\"#ACTIVEMQ的传输协议\" class=\"headerlink\" title=\"ACTIVEMQ的传输协议\"></a>ACTIVEMQ的传输协议</h1><p>Q: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？</p>\n<p>调优：使用NIO传输协议</p>\n<p>支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP</td>\n<td>默认的协议，性能相对可以</td>\n</tr>\n<tr>\n<td>NIO</td>\n<td>基于TCP协议之上的，进行了扩展和优化</td>\n</tr>\n<tr>\n<td>HTP(s)</td>\n<td>基于HTTP(s)</td>\n</tr>\n</tbody></table>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>要换为NIO，需要修改<code>activemq.xml</code>配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">broker</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nio&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;nio://192.168.111.136&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">broker</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在消费者、生产者修改代码，指定传输协议：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> stati <span class=\"keyword\">final</span> String ACTIVEMQ_URL = <span class=\"string\">&quot;nio://192.168.111.136&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    ActiveMQConnectionFactory af = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增强\"><a href=\"#增强\" class=\"headerlink\" title=\"增强\"></a>增强</h3><p>Q: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持<code>openwire（TCP）</code>，如何让这个端口支持NIO，又支持多个协议呢？</p>\n<p>默认是<code>BIO+TCP</code>，目前是<code>NIO+TCP</code>，那么如何做到<code>NIO+TCP/Mqtt/stomp</code>。</p>\n<p>A: 开启多协议支持，用<code>auto</code>关键字，<a href=\"https://activemq.apache.org/auto\">reference</a>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;auto://localhost:5761&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 在activeMQ后台配置面板的<code>Network</code>可以查看开启的网络协议。</p>\n<h1 id=\"ACTIVEMQ的存储和可持久化\"><a href=\"#ACTIVEMQ的存储和可持久化\" class=\"headerlink\" title=\"ACTIVEMQ的存储和可持久化\"></a>ACTIVEMQ的存储和可持久化</h1><p>对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会<code>采用持久化机制</code>（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p>\n<p>主要介绍两个DB：<code>KahaDB</code>, <code>LevelDB</code>, <code>JDBC</code></p>\n<p>Q: AMQ持久化机制</p>\n<h2 id=\"KahaDB\"><a href=\"#KahaDB\" class=\"headerlink\" title=\"KahaDB\"></a>KahaDB</h2><p>基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。</p>\n<p>在配置文件中，有：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">persistenceAdapter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">kahaDB</span> <span class=\"attr\">directory</span>=<span class=\"string\">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">persistenceAdpter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储原理\"><a href=\"#存储原理\" class=\"headerlink\" title=\"存储原理\"></a>存储原理</h3><p>reference <a href=\"https://activemq.apache.org/kahadb\">here</a></p>\n<p>可用于任何场合，提高了性能和恢复能力。消息存储使用一个<strong>事务日志</strong>和一个<strong>索引文件</strong>（存储所有地址）。</p>\n<p>Kahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）</p>\n<h4 id=\"db-lt-Number-gt-log\"><a href=\"#db-lt-Number-gt-log\" class=\"headerlink\" title=\"db&lt;Number&gt;.log\"></a>db&lt;Number&gt;.log</h4><p>存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。</p>\n<h4 id=\"db-data\"><a href=\"#db-data\" class=\"headerlink\" title=\"db.data\"></a>db.data</h4><p>包含了持久化的<code>BTree索引</code>，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向<code>db-\\&lt;Number&gt;.log</code>里面存储的消息。</p>\n<h4 id=\"db-free\"><a href=\"#db-free\" class=\"headerlink\" title=\"db.free\"></a>db.free</h4><p>当前<code>db.data</code>文件里哪些页面是空闲的，文件具体内容是所有空闲页的<strong>ID</strong>. 类比linux的bash命令<code>free</code>。</p>\n<h4 id=\"db-redo\"><a href=\"#db-redo\" class=\"headerlink\" title=\"db.redo\"></a>db.redo</h4><p>用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。</p>\n<h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h4><p>相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。</p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。</p>\n<h2 id=\"LevelDB\"><a href=\"#LevelDB\" class=\"headerlink\" title=\"LevelDB\"></a>LevelDB</h2><h2 id=\"JDBC-Message-store-with-ActiveMQ-Journal\"><a href=\"#JDBC-Message-store-with-ActiveMQ-Journal\" class=\"headerlink\" title=\"JDBC Message store with ActiveMQ Journal\"></a>JDBC Message store with ActiveMQ Journal</h2><p>主要。</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><ol>\n<li><p>引入消息队列后该如何保证其高可用性</p>\n</li>\n<li><p>异步投递Async Sends</p>\n</li>\n<li><p>延迟投递和定时投递</p>\n</li>\n<li><p>分发策略</p>\n</li>\n<li><p>ActiveMQ消费重试机制</p>\n</li>\n<li><p>死信队列</p>\n</li>\n<li><p>如何保证消息不被重复消费呢？谈谈幂等性问题</p>\n</li>\n</ol>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><p>zookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。</p>\n<h2 id=\"异步投递\"><a href=\"#异步投递\" class=\"headerlink\" title=\"异步投递\"></a>异步投递</h2><p>如何确认发送成功？ </p>\n<p>在消息发送完后接收回调。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveMQConnectionFacotry acf = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(URL);</span><br><span class=\"line\"><span class=\"comment\">// 设置为异步发送消息</span></span><br><span class=\"line\">acf.setUseAsyncSend(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">ActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class=\"line\">...</span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\"><span class=\"comment\">// 未message设置属性</span></span><br><span class=\"line\">message.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用带有回调的send方法来发送</span></span><br><span class=\"line\">amp.send(message, <span class=\"keyword\">new</span> AsyncCallback()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSucces</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; succeed&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(JMSException exception)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到属性来确认发送失败的消息</span></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; fail&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"延迟投递和定时投递\"><a href=\"#延迟投递和定时投递\" class=\"headerlink\" title=\"延迟投递和定时投递\"></a>延迟投递和定时投递</h2><p>参考<a href=\"http://activemq.apache.org/delay-and-schedule-message-delivery.html\">官网说明</a></p>\n<table>\n<thead>\n<tr>\n<th>Property name</th>\n<th>type</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AMQ_SCHEDULED_DELAY</td>\n<td>long</td>\n<td>延迟投递的时间</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_PERIOD</td>\n<td>long</td>\n<td>重复投递的时间间隔</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_REPEAT</td>\n<td>int</td>\n<td>重复投递次数</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_CRON</td>\n<td>String</td>\n<td>Cron表达式</td>\n</tr>\n</tbody></table>\n<p>在<code>activemq.xml</code>中配置<em>schedulerSupport</em>属性为<em>true</em>且Java代码中封装的辅助消息类型为<em>ScheduledMessage</em>即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> delay = <span class=\"number\">3</span> * <span class=\"number\">1000</span>; <span class=\"comment\">//延迟投递的时间，每3秒</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> period = <span class=\"number\">4</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> repeat = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);</span><br><span class=\"line\">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);</span><br><span class=\"line\"></span><br><span class=\"line\">messageProducer.send(mesage);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ActiveMQ消费重试机制\"><a href=\"#ActiveMQ消费重试机制\" class=\"headerlink\" title=\"ActiveMQ消费重试机制\"></a>ActiveMQ消费重试机制</h2><ul>\n<li><p>哪些情况会引起消息重发？</p>\n</li>\n<li><p>消息重发时间间隔和重发次数</p>\n</li>\n<li><p>有毒消息Posion ACK</p>\n</li>\n</ul>\n<p>reference <a href=\"activemq.apache.org/redelivery-policy\">here</a></p>\n<p>重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。</p>\n<h2 id=\"如何保证消息不被重复消费（幂等性）\"><a href=\"#如何保证消息不被重复消费（幂等性）\" class=\"headerlink\" title=\"如何保证消息不被重复消费（幂等性）\"></a>如何保证消息不被重复消费（幂等性）</h2><p><strong>note</strong>: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。</p>\n<ul>\n<li><p>如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突</p>\n</li>\n<li><p>使用第三方服务来做消费记录。以redis为例，给消息分配一个<strong>全局id</strong>，只要消费过该消息，将&lt;id, message&gt;以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。</p>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckn438q6q0003w5ih0fh0ht7b","category_id":"ckn438q6w0007w5ihfov39dki","_id":"ckn438q77000lw5ih8whl47y7"},{"post_id":"ckn438q74000iw5ih3umqdncr","category_id":"ckn438q72000gw5ih4fz680oe","_id":"ckn438q7a000rw5ih3h807mtd"},{"post_id":"ckn438q6v0006w5ih90kr1epz","category_id":"ckn438q72000gw5ih4fz680oe","_id":"ckn438q7d000vw5ihd4aabp2w"},{"post_id":"ckn438q6x0009w5ihdile7yi8","category_id":"ckn438q77000nw5ihe8o31505","_id":"ckn438q7f000zw5ih3yq03s28"},{"post_id":"ckn438q7a000qw5ihcptj9jqw","category_id":"ckn438q77000nw5ihe8o31505","_id":"ckn438q7h0012w5ih42kv1sc8"},{"post_id":"ckn438q7c000uw5ihbz9pcsev","category_id":"ckn438q77000nw5ihe8o31505","_id":"ckn438q7j0016w5ihagn3br01"},{"post_id":"ckn438q6z000bw5iheq0k9nyw","category_id":"ckn438q72000gw5ih4fz680oe","_id":"ckn438q7k0019w5ih629kbdya"},{"post_id":"ckn438q72000fw5ih3h1zgn5l","category_id":"ckn438q72000gw5ih4fz680oe","_id":"ckn438q7l001cw5ih6ba33if8"},{"post_id":"ckn438q78000ow5ih6vi74u1i","category_id":"ckn438q7i0015w5ih7i3w3bry","_id":"ckn438q7o001jw5ih0dtj1lo5"},{"post_id":"ckn438q7n001hw5ih9xrv26ea","category_id":"ckn438q77000nw5ihe8o31505","_id":"ckn438q7x001qw5ih5ttb60kv"},{"post_id":"ckn438q7e000xw5ih6igs72r5","category_id":"ckn438q7m001dw5ih88ir7jkg","_id":"ckn438q7z001uw5ihcuicaucf"},{"post_id":"ckn438q7p001lw5ih0n9t6rvg","category_id":"ckn438q6w0007w5ihfov39dki","_id":"ckn438q83001xw5ih8eod7fhy"},{"post_id":"ckn438q7t001nw5ihe0yj0268","category_id":"ckn438q6w0007w5ihfov39dki","_id":"ckn438q850021w5ih9yny10lr"},{"post_id":"ckn438q7g0011w5ih3swj1f2a","category_id":"ckn438q7p001mw5ih7xcsbosh","_id":"ckn438q880025w5ih2wbn1gaq"},{"post_id":"ckn438q7v001pw5ihb0ns40jx","category_id":"ckn438q6w0007w5ihfov39dki","_id":"ckn438q8a0029w5ihhffxejjs"},{"post_id":"ckn438q7z001tw5ih51vqajrg","category_id":"ckn438q7m001dw5ih88ir7jkg","_id":"ckn438q8b002bw5ih0vpj8mv8"},{"post_id":"ckn438q7h0013w5ihhdjgbwme","category_id":"ckn438q7y001sw5ih0sg45v3l","_id":"ckn438q8c002gw5ih2wn63l5m"},{"post_id":"ckn438q82001ww5ih4e46g5xd","category_id":"ckn438q7i0015w5ih7i3w3bry","_id":"ckn438q8d002iw5ih9urd5ruh"},{"post_id":"ckn438q7j0018w5ihfke5chrb","category_id":"ckn438q7y001sw5ih0sg45v3l","_id":"ckn438q8f002lw5ihccwff3xp"},{"post_id":"ckn438q870024w5ihg38x2fc4","category_id":"ckn438q7y001sw5ih0sg45v3l","_id":"ckn438q8g002ow5ih7ezy90n0"},{"post_id":"ckn438q890028w5ihdly0flea","category_id":"ckn438q72000gw5ih4fz680oe","_id":"ckn438q8h002qw5ihdyej3gzn"},{"post_id":"ckn438q7k001aw5ih69a14lt6","category_id":"ckn438q880026w5ih6eyq98uq","_id":"ckn438q8h002tw5ihbdwt4ssu"},{"post_id":"ckn438q8c002fw5ihend92pom","category_id":"ckn438q77000nw5ihe8o31505","_id":"ckn438q8i002ww5ihdrsy7jz5"},{"post_id":"ckn438q7m001fw5ih3bqj38se","category_id":"ckn438q8b002dw5ih57sx7km6","_id":"ckn438q8i002yw5ih98ntcwpp"},{"post_id":"ckn438q8e002kw5ih3cavee9c","category_id":"ckn438q880026w5ih6eyq98uq","_id":"ckn438q8j002zw5ih2we20mum"},{"post_id":"ckn438q8f002nw5ih51ws5ehk","category_id":"ckn438q880026w5ih6eyq98uq","_id":"ckn438q8k0032w5ih6w4wdp1o"},{"post_id":"ckn438q840020w5ihbhmmer5d","category_id":"ckn438q8f002mw5ihg5u9d8op","_id":"ckn438q8k0033w5ihf41gesdy"},{"post_id":"ckn438q8a002aw5ihd43v2r8d","category_id":"ckn438q8h002rw5ihb64d1w7t","_id":"ckn438q8l0036w5ihewey59bk"},{"post_id":"ckn438q920040w5ih87kh5m6w","category_id":"ckn438q7y001sw5ih0sg45v3l","_id":"ckn438q950044w5ihcy705yiz"},{"post_id":"ckn438q930041w5ih5mop3veu","category_id":"ckn438q8b002dw5ih57sx7km6","_id":"ckn438q950045w5ihgufj4arc"}],"PostTag":[{"post_id":"ckn438q6m0001w5ih4jvxamag","tag_id":"ckn438q6s0004w5ihg9x6ejhl","_id":"ckn438q71000dw5ihdha23wxo"},{"post_id":"ckn438q6q0003w5ih0fh0ht7b","tag_id":"ckn438q70000cw5iheyqw7s81","_id":"ckn438q77000mw5ih9f6c29xq"},{"post_id":"ckn438q6v0006w5ih90kr1epz","tag_id":"ckn438q75000jw5ihhq3r3ost","_id":"ckn438q7a000sw5ih7o8h7r75"},{"post_id":"ckn438q6x0009w5ihdile7yi8","tag_id":"ckn438q79000pw5ihgj47fuw0","_id":"ckn438q7f0010w5ih6488ahf7"},{"post_id":"ckn438q6z000bw5iheq0k9nyw","tag_id":"ckn438q7e000ww5ihgg94fabu","_id":"ckn438q7j0017w5ihclscdliv"},{"post_id":"ckn438q72000fw5ih3h1zgn5l","tag_id":"ckn438q7e000ww5ihgg94fabu","_id":"ckn438q7m001ew5ihdo0yelll"},{"post_id":"ckn438q7k001aw5ih69a14lt6","tag_id":"ckn438q6s0004w5ihg9x6ejhl","_id":"ckn438q7n001gw5ih94kv3fyu"},{"post_id":"ckn438q74000iw5ih3umqdncr","tag_id":"ckn438q7e000ww5ihgg94fabu","_id":"ckn438q7p001kw5iha3qz114w"},{"post_id":"ckn438q76000kw5ihc54z9u0j","tag_id":"ckn438q7o001iw5ih1uyf0os2","_id":"ckn438q7x001rw5ihhmdw9k6c"},{"post_id":"ckn438q78000ow5ih6vi74u1i","tag_id":"ckn438q7u001ow5ih8iww1rn0","_id":"ckn438q83001yw5ih6flehp6m"},{"post_id":"ckn438q82001ww5ih4e46g5xd","tag_id":"ckn438q7u001ow5ih8iww1rn0","_id":"ckn438q860022w5ihdipo6932"},{"post_id":"ckn438q7a000qw5ihcptj9jqw","tag_id":"ckn438q80001vw5ihfn3b81yb","_id":"ckn438q890027w5ihe5p1epgr"},{"post_id":"ckn438q7c000uw5ihbz9pcsev","tag_id":"ckn438q860023w5ihcy6sfn1h","_id":"ckn438q8c002ew5ih0wb8858u"},{"post_id":"ckn438q7e000xw5ih6igs72r5","tag_id":"ckn438q8b002cw5ih3emi9udw","_id":"ckn438q8h002sw5ihc7kgfw8p"},{"post_id":"ckn438q7e000xw5ih6igs72r5","tag_id":"ckn438q8e002jw5ih5w8k15wa","_id":"ckn438q8h002uw5ih3m8n7zzi"},{"post_id":"ckn438q7g0011w5ih3swj1f2a","tag_id":"ckn438q8g002pw5iheeazbcui","_id":"ckn438q8i002xw5ihgixxdis1"},{"post_id":"ckn438q7h0013w5ihhdjgbwme","tag_id":"ckn438q8i002vw5ihdqa6bnlh","_id":"ckn438q8k0031w5ihbufg0c8w"},{"post_id":"ckn438q7j0018w5ihfke5chrb","tag_id":"ckn438q8i002vw5ihdqa6bnlh","_id":"ckn438q8l0035w5ih9g7ncgsh"},{"post_id":"ckn438q7m001fw5ih3bqj38se","tag_id":"ckn438q8k0034w5ih7u83dzhl","_id":"ckn438q8m0038w5ihhilm0dae"},{"post_id":"ckn438q7n001hw5ih9xrv26ea","tag_id":"ckn438q8l0037w5ih9kmrdito","_id":"ckn438q8m003aw5ih7dmk475e"},{"post_id":"ckn438q7p001lw5ih0n9t6rvg","tag_id":"ckn438q8m0039w5ihdw416zim","_id":"ckn438q8n003cw5ih18k07l0u"},{"post_id":"ckn438q7t001nw5ihe0yj0268","tag_id":"ckn438q8m0039w5ihdw416zim","_id":"ckn438q8o003ew5ihf8kda29v"},{"post_id":"ckn438q7v001pw5ihb0ns40jx","tag_id":"ckn438q8m0039w5ihdw416zim","_id":"ckn438q8o003gw5ihhhg57e7h"},{"post_id":"ckn438q7z001tw5ih51vqajrg","tag_id":"ckn438q8o003fw5ihfejyh7iu","_id":"ckn438q8p003iw5ih36787t8p"},{"post_id":"ckn438q840020w5ihbhmmer5d","tag_id":"ckn438q8p003hw5ih1dc1aswe","_id":"ckn438q8w003lw5ihancvbtcc"},{"post_id":"ckn438q840020w5ihbhmmer5d","tag_id":"ckn438q8q003jw5ihhj53a6zo","_id":"ckn438q8x003mw5ih3w441tit"},{"post_id":"ckn438q870024w5ihg38x2fc4","tag_id":"ckn438q8i002vw5ihdqa6bnlh","_id":"ckn438q8x003ow5ihgdp8691y"},{"post_id":"ckn438q890028w5ihdly0flea","tag_id":"ckn438q8x003nw5ih8c652feo","_id":"ckn438q8y003rw5ih7kc28kfm"},{"post_id":"ckn438q890028w5ihdly0flea","tag_id":"ckn438q8x003pw5ih7h5ab1nc","_id":"ckn438q8y003sw5ih2x3jf89x"},{"post_id":"ckn438q8a002aw5ihd43v2r8d","tag_id":"ckn438q8y003qw5ihhky6h97j","_id":"ckn438q8z003uw5ihaqgjhn70"},{"post_id":"ckn438q8c002fw5ihend92pom","tag_id":"ckn438q8l0037w5ih9kmrdito","_id":"ckn438q8z003ww5ihgwg178wb"},{"post_id":"ckn438q8e002kw5ih3cavee9c","tag_id":"ckn438q8z003vw5ihgh0h6fzk","_id":"ckn438q90003yw5ih70lzcp52"},{"post_id":"ckn438q8f002nw5ih51ws5ehk","tag_id":"ckn438q8z003xw5ihawm77h56","_id":"ckn438q90003zw5ih4up17u11"},{"post_id":"ckn438q920040w5ih87kh5m6w","tag_id":"ckn438q8i002vw5ihdqa6bnlh","_id":"ckn438q940042w5ih94ldcffy"},{"post_id":"ckn438q930041w5ih5mop3veu","tag_id":"ckn438q940043w5ihdjql3uj6","_id":"ckn438q960046w5ihhk340nwe"}],"Tag":[{"name":"summary","_id":"ckn438q6s0004w5ihg9x6ejhl"},{"name":"spring security","_id":"ckn438q70000cw5iheyqw7s81"},{"name":"bst","_id":"ckn438q75000jw5ihhq3r3ost"},{"name":"bitwise","_id":"ckn438q79000pw5ihgj47fuw0"},{"name":"algorithm","_id":"ckn438q7e000ww5ihgg94fabu"},{"name":"LeetCode","_id":"ckn438q7o001iw5ih1uyf0os2"},{"name":"design_patterns","_id":"ckn438q7u001ow5ih8iww1rn0"},{"name":"hashmap, data structure","_id":"ckn438q80001vw5ihfn3b81yb"},{"name":"datastructure","_id":"ckn438q860023w5ihcy6sfn1h"},{"name":"http","_id":"ckn438q8b002cw5ih3emi9udw"},{"name":"https","_id":"ckn438q8e002jw5ih5w8k15wa"},{"name":"framework","_id":"ckn438q8g002pw5iheeazbcui"},{"name":"source","_id":"ckn438q8i002vw5ihdqa6bnlh"},{"name":"kafka","_id":"ckn438q8k0034w5ih7u83dzhl"},{"name":"lock","_id":"ckn438q8l0037w5ih9kmrdito"},{"name":"mybatis","_id":"ckn438q8m0039w5ihdw416zim"},{"name":"network","_id":"ckn438q8o003fw5ihfejyh7iu"},{"name":"redis","_id":"ckn438q8p003hw5ih1dc1aswe"},{"name":"nosql","_id":"ckn438q8q003jw5ihhj53a6zo"},{"name":"double poiters","_id":"ckn438q8x003nw5ih8c652feo"},{"name":"map+preSum","_id":"ckn438q8x003pw5ih7h5ab1nc"},{"name":"utils","_id":"ckn438q8y003qw5ihhky6h97j"},{"name":"classloader","_id":"ckn438q8z003vw5ihgh0h6fzk"},{"name":"memory","_id":"ckn438q8z003xw5ihawm77h56"},{"name":"activemq","_id":"ckn438q940043w5ihdjql3uj6"}]}}