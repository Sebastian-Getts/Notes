{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/2020-end.md","hash":"f66843357ea865707dfeca9e7d3ff8eed503b1a5","modified":1622989196831},{"_id":"source/_posts/2021-mid.md","hash":"5b9a1050d64366e39a31ed035d94745e7f3e286d","modified":1622992023786},{"_id":"source/_posts/Spring-Security-AutoConfiguration.md","hash":"c6d6cee3fdc2cb94c8ac1afc1f3e8871adc59f99","modified":1617601454656},{"_id":"source/_posts/SpringBoot-environment.md","hash":"189452e08bdc061df1e9280fdb4ba20395371b27","modified":1616926802102},{"_id":"source/_posts/SpringBoot-refresh.md","hash":"b8bd045afcac890d452da416fafffc3613d28339","modified":1616926802106},{"_id":"source/_posts/SpringBoot-startup.md","hash":"d0ccc987ea7a0318b2990160195f06f6a3d4c7a8","modified":1616926802107},{"_id":"source/_posts/acm-standard-inputoutput.md","hash":"755968a55a7479865438b5abca96a9517a41b1ee","modified":1621672131743},{"_id":"source/_posts/arraylist-grow.md","hash":"0ffe6a4dc9441de16f53d18bc3c4a147b84c8da4","modified":1620879140991},{"_id":"source/_posts/binary-search-tre.md","hash":"a671c102d8a0875eb0d39fccca42c01e404aa05b","modified":1616926802107},{"_id":"source/_posts/bitwise.md","hash":"cadf23b285c674af5e1af6be3af763191f8d5f45","modified":1621690624463},{"_id":"source/_posts/decorating.md","hash":"f79881d18ed402886d613a5d1fc10db39d7262b5","modified":1617601454672},{"_id":"source/_posts/hashmap.md","hash":"68e7581a1edab21acb8dce7d4187bb2f4d1b64d3","modified":1616926802113},{"_id":"source/_posts/heap.md","hash":"80966092f9e48741e6b437c9bfa996bd63e74bee","modified":1621690579003},{"_id":"source/_posts/https.md","hash":"4be7dca47f0e30949d75cb6677175f1caf64b7ac","modified":1620833777239},{"_id":"source/_posts/java-collection-framework.md","hash":"544cb87f989b003fd2773ef7900a4bda52fd0bff","modified":1617601939522},{"_id":"source/_posts/jump-games.md","hash":"e46882c4822b4e17f984b5ea38a9aaf61f72d705","modified":1621870505633},{"_id":"source/_posts/jvm-classloader.md","hash":"45afcb2a5b662638fb93bb0c228cde38ed7735b9","modified":1617601454701},{"_id":"source/_posts/jvm-concurrency.md","hash":"eb8aa621ce459001e998addcb935e33b514b4681","modified":1617601454718},{"_id":"source/_posts/jvm-memory-manage.md","hash":"e095249c757700a93d2c2b6e834085a92cbfe85f","modified":1617601454734},{"_id":"source/_posts/jvm.md","hash":"6042e5130d6858a76d6c956f31037e027bbe2169","modified":1617601454761},{"_id":"source/_posts/linux-command-line.md","hash":"4148625d5cdf55c6e46967f225b55e308cc48e3e","modified":1621690677364},{"_id":"source/_posts/lock.md","hash":"757b541a8d59915c4deaaa212e635ec3724bd834","modified":1616926802119},{"_id":"source/_posts/mybatis-autoconfiguration.md","hash":"02a1003644811ef80c219d8c6985db2c435d00c6","modified":1616926802122},{"_id":"source/_posts/mq.md","hash":"5aa02f0de0bb6c70da132fed68137ecd4c70a6ca","modified":1616926802120},{"_id":"source/_posts/mybatis-sql-resolution.md","hash":"f7ad84ae66fb3b427f37074b918a40c2dbcab23e","modified":1617601454778},{"_id":"source/_posts/mybatis_preview.md","hash":"c2110258833298e72efcb499e4c530f815021cc0","modified":1616926802124},{"_id":"source/_posts/nginx.md","hash":"435507d15f3c21a1c144776d1b0bd4abead304f2","modified":1616926802124},{"_id":"source/_posts/observer.md","hash":"18489e3e3c9599feefe2b3ec1e7b00d539f5acd7","modified":1616926802125},{"_id":"source/_posts/predict-the-winner.md","hash":"f58e10a9536f72f95da950c42355959e1bc4f679","modified":1620981596362},{"_id":"source/_posts/redis.md","hash":"236d55c325ab8a92928c4d776d82e56f33f5d3df","modified":1616926802126},{"_id":"source/_posts/search-suggestions-system.md","hash":"d2a6322b538c377a50d9adc72fd70ab3605d9f7b","modified":1622511169617},{"_id":"source/_posts/springboot-servlet.md","hash":"cc4719c7e6728061628ddab5cf250cfa124d853a","modified":1616926802127},{"_id":"source/_posts/springmvc-argument.md","hash":"95fcce877d49c6246d597ff5e81cea3c3969e3be","modified":1619360271832},{"_id":"source/_posts/springmvc-dispatch.md","hash":"c75ff5a7463c43c6366c6ead8967df7ddc24ee4a","modified":1617769154664},{"_id":"source/_posts/subarray.md","hash":"f47090688651c1c97db8cb251c7f5cf61611d066","modified":1616926802127},{"_id":"source/_posts/springmvc-dispatcherservlet.md","hash":"3727bd394c0c5d798036ef6c61448885c9a9a84b","modified":1617695762649},{"_id":"source/_posts/uml.md","hash":"b5e547f6cbb3fc6ec13c248aa2c348bd69f49a97","modified":1616926802128},{"_id":"source/_posts/volatile.md","hash":"24954f2fdf7ed1dcc33644bdce3ae61ab0b8308d","modified":1616926802128},{"_id":"source/about/index.md","hash":"d4ee235f83218de4eae1b19b4e918f97c99e2c24","modified":1616926802129},{"_id":"source/all-categories/index.md","hash":"dd1913fed30423aa34bc57f99309a57ea63875a4","modified":1616926802131},{"_id":"source/all-tags/index.md","hash":"5aa760db75941096ee36caed76a21c5512e734c5","modified":1616926802134},{"_id":"source/all-archives/index.md","hash":"f50ce93de4f9960a3834ca045b95d014afd71d24","modified":1616926802130},{"_id":"source/tags/index.md","hash":"a5c16d9bb618a3ec431b65a61877a47ee0a430d2","modified":1616926802136},{"_id":"source/categories/index.md","hash":"f76e38fed545135e4f73d11bbcbe905a02c47dd7","modified":1616926802135},{"_id":"source/top/index.md","hash":"b59cd1918ea3385ab79b1e5f331ca483a479c145","modified":1616926802137},{"_id":"themes/tranquilpeak/.gitignore","hash":"95a5fbfabbef5e4a81481150dc718bc0a507d027","modified":1616926802232},{"_id":"themes/tranquilpeak/.eslintignore","hash":"b58a409db37839e821fcfb67341f09a4110a1abe","modified":1616926802224},{"_id":"themes/tranquilpeak/.eslintrc","hash":"6b4eb0104229bfa76b2787a2fd6af5500a16b1ca","modified":1616926802224},{"_id":"themes/tranquilpeak/README.md","hash":"4ff45a6f496471b104be66ae7831f2b12a295977","modified":1616926802236},{"_id":"themes/tranquilpeak/_config.yml","hash":"dda9224ba2eacbecb083bc327a841570d3786607","modified":1616926802237},{"_id":"themes/tranquilpeak/Gruntfile.js","hash":"7310a3704e7890326f8ea1d24e4b0e969e18306e","modified":1616926802234},{"_id":"themes/tranquilpeak/LICENSE","hash":"b93ea24b0ab23d669a5d2ad5f43e5a59189ead78","modified":1616926802235},{"_id":"themes/tranquilpeak/DOCUMENTATION.md","hash":"1c61dcb0b88336641ace720d8bce85830761a2e5","modified":1616926802233},{"_id":"themes/tranquilpeak/scripts/.eslintrc.json","hash":"d7a206835ece0e7311c73242eb1208699fecd805","modified":1616926802285},{"_id":"themes/tranquilpeak/package.json","hash":"b92b1269f66ad8c9ab5514bb6d2ccae8ccd0f6b7","modified":1616926802283},{"_id":"themes/tranquilpeak/tasks/pipeline.js","hash":"12c4231a983230fe512a9834ed512439d43f4a37","modified":1616926802399},{"_id":"themes/tranquilpeak/renovate.json","hash":"538108c8f403201a38efd37abacac45caccbfe9e","modified":1616926802284},{"_id":"themes/tranquilpeak/languages/en.yml","hash":"e89147bab2037022273028bb5b8d1ac2a57a4cda","modified":1616926802239},{"_id":"themes/tranquilpeak/languages/de-DE.yml","hash":"04267335f86bf58d0a1efb3abeeaa05ce54fb1d4","modified":1616926802238},{"_id":"themes/tranquilpeak/languages/es.yml","hash":"1d90c5525bca54ff88ea24be1caa9649242797b4","modified":1616926802239},{"_id":"themes/tranquilpeak/source/_css/tranquilpeak.scss","hash":"f585d7efe1859b655637c009d2f1723f99b9692b","modified":1616926802342},{"_id":"themes/tranquilpeak/languages/ja.yml","hash":"1e99f3f9f9e66cf27a672b6467f55900a976382a","modified":1616926802243},{"_id":"themes/tranquilpeak/languages/it-IT.yml","hash":"a6c2cbee0bc797d1a38485a1dee5c2cfdeaaf2d5","modified":1616926802242},{"_id":"themes/tranquilpeak/languages/fa.yml","hash":"39c49486be424ce636cc05f9231cbeff43145890","modified":1616926802241},{"_id":"themes/tranquilpeak/languages/ko.yml","hash":"fe3627288feb720ba4b2cde6b2eb66083b70fcea","modified":1616926802246},{"_id":"themes/tranquilpeak/languages/ru.yml","hash":"94d5135fb18cfa816ac1b0cb18afbb0cc79a7bdd","modified":1616926802247},{"_id":"themes/tranquilpeak/languages/pt-br.yml","hash":"c02beacbc330beb07aa4c19c550d0ffe4c91eb83","modified":1616926802246},{"_id":"themes/tranquilpeak/languages/fr-FR.yml","hash":"0a609179a6a1b08400399852f16f36188529c7b3","modified":1616926802241},{"_id":"themes/tranquilpeak/languages/zh-tw.yml","hash":"5b1b42a955162d36313c839ef0d81137be23162d","modified":1616926802249},{"_id":"themes/tranquilpeak/.github/CONTRIBUTING.md","hash":"c7a7fbe24c483687b1698fbc48dd01c9a9b00861","modified":1616926802225},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE.md","hash":"f00b5c3dc447f4bfc4eab6f93232394cb100ddc9","modified":1616926802226},{"_id":"themes/tranquilpeak/languages/zh-cn.yml","hash":"99c3a7c9afa83ea7965473cbc7579d882a449c3c","modified":1616926802248},{"_id":"themes/tranquilpeak/.github/PULL_REQUEST_TEMPLATE.md","hash":"693db4460131f90e53bfb9bac817117d5a71fbb5","modified":1616926802231},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-bold.ttf","hash":"e6d0ffb2d0348d9e22de97e57214b7db795e9513","modified":1616926802358},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-light-italic.ttf","hash":"c3835119c62e78a21cfb33e2de6686fb4a5929a0","modified":1616926802360},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-bold-italic.ttf","hash":"c1b8593dc9ddbf1a1a6268d31e08c4041448ed76","modified":1616926802357},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-light.ttf","hash":"69bd3f15962cf91348a133d3d38571a5c67eca65","modified":1616926802361},{"_id":"themes/tranquilpeak/scripts/filters/thumbnail_image_url.js","hash":"9a0cb80f2d069af85c0cca00edce2ef184b3eba3","modified":1616926802289},{"_id":"themes/tranquilpeak/scripts/filters/excerpt.js","hash":"8a7ddc62811c9dc6d86c5ad04e1a61d83ff2639a","modified":1616926802288},{"_id":"themes/tranquilpeak/scripts/helpers/absolute_url.js","hash":"496fefd84e23eddb85a6644fdcf0dce4509e9dfe","modified":1616926802290},{"_id":"themes/tranquilpeak/scripts/helpers/generate_sharing_link.js","hash":"bc986984c45815be9a958ec0b53c3ccdec08a01c","modified":1616926802291},{"_id":"themes/tranquilpeak/scripts/helpers/is_remote_url.js","hash":"b89fec5dbdbc9adc9846fdd9f832d7ca49171b8c","modified":1616926802293},{"_id":"themes/tranquilpeak/scripts/helpers/json_ld.js","hash":"b04b41be6eb1687cd2a49f312cd0b49bddba89a6","modified":1616926802294},{"_id":"themes/tranquilpeak/scripts/helpers/resolve_asset_url.js","hash":"0b5ecf5dba85f4ea69d7ca366d3cbd65f35cd63e","modified":1616926802294},{"_id":"themes/tranquilpeak/scripts/tags/alert.js","hash":"bdf7c5e7bdc9a1f68fb3e6c90fecf8f286c3e620","modified":1616926802295},{"_id":"themes/tranquilpeak/scripts/tags/fancybox.js","hash":"cc66a0600b0e5c7dffe0901b133420814bc97003","modified":1616926802296},{"_id":"themes/tranquilpeak/scripts/tags/highlight_text.js","hash":"f35c0cd8233c991ac815b704b29fb7a0f3676c54","modified":1616926802297},{"_id":"themes/tranquilpeak/scripts/tags/image.js","hash":"febac317ea3f21463552cae57b0b7ec2c74fc1c2","modified":1616926802298},{"_id":"themes/tranquilpeak/scripts/tags/tabbed_codeblock.js","hash":"8dddaf1e5f21f7fac5dc95d68763260ac9abab52","modified":1616926802299},{"_id":"themes/tranquilpeak/scripts/tags/video.js","hash":"6424a09449e30e0fba0d22fcea727ed120ed8b55","modified":1616926802300},{"_id":"themes/tranquilpeak/scripts/tags/wide_image.js","hash":"54f9993d946691a547655465d474ea722f30c9db","modified":1616926802300},{"_id":"themes/tranquilpeak/source/_fonts/merriweather.ttf","hash":"d392237948e74246a2fb0d0d886498776a185e54","modified":1616926802362},{"_id":"themes/tranquilpeak/source/_fonts/open-sans.ttf","hash":"618b78a8f6ffe7e1998eab67268859e2ab54be8e","modified":1616926802365},{"_id":"themes/tranquilpeak/source/_fonts/open-sans-bold.ttf","hash":"3823779db9f51a34658809ce66bdd6ed1145ed8e","modified":1616926802363},{"_id":"themes/tranquilpeak/source/_js/.eslintrc.json","hash":"7668eb84911a730e01204740a563a9bd1634f22e","modified":1616926802378},{"_id":"themes/tranquilpeak/source/_js/codeblock-resizer.js","hash":"ea89298810da769e984f5a37203f965d3899f5bd","modified":1616926802383},{"_id":"themes/tranquilpeak/source/_js/about.js","hash":"257714d1b4f345a5f9115eefe9dfac8defba7f60","modified":1616926802379},{"_id":"themes/tranquilpeak/source/_js/archives-filter.js","hash":"0add1a22fc93ba2553a2834877acd66af2ab702f","modified":1616926802381},{"_id":"themes/tranquilpeak/source/_js/categories-filter.js","hash":"b9566b283fbf8618cd6ec8663c6fb8f28c1874a7","modified":1616926802382},{"_id":"themes/tranquilpeak/source/_js/header.js","hash":"767b4c69b9bd6f3789b05f871ab56d2e8db436ce","modified":1616926802385},{"_id":"themes/tranquilpeak/source/_js/post-bottom-bar.js","hash":"f5e3eb000909ce1e47fa954b6e2f5ea256c6cc04","modified":1616926802387},{"_id":"themes/tranquilpeak/source/_js/image-gallery.js","hash":"d915e4f9b0a0c0fcea7c6893ec0b823abde2c344","modified":1616926802386},{"_id":"themes/tranquilpeak/source/_js/share-options.js","hash":"fe6da11927cd07ed8b156d071d7f61239fa58367","modified":1616926802388},{"_id":"themes/tranquilpeak/source/_js/fancybox.js","hash":"27e3a97c88ecb0bff6b05fcbc92d7bd7005d055a","modified":1616926802384},{"_id":"themes/tranquilpeak/source/_js/search-modal.js","hash":"f28688ec78a38eefbc6d491ffc6ba04e7b4aec8c","modified":1616926802387},{"_id":"themes/tranquilpeak/source/_js/tabbed-codeblocks.js","hash":"5a69e71e77b8ace6730d1003d7bbe1a7966f8690","modified":1616926802390},{"_id":"themes/tranquilpeak/source/_js/sidebar.js","hash":"d2b3345de8ff34e02ddd3ce91e23d7862f89d648","modified":1616926802389},{"_id":"themes/tranquilpeak/source/_js/smartresize.js","hash":"c5b82e44bf98305afb897e73f082810faefd85c6","modified":1616926802390},{"_id":"themes/tranquilpeak/source/_images/logo-algolia-nebula-blue-full.svg","hash":"d5e4426b6bd2d8b8c3f477f83d348d8f3b3ec1ca","modified":1616926802377},{"_id":"themes/tranquilpeak/source/_js/tags-filter.js","hash":"62f0bf0fea06e2877f38b8f059b46ef39d143a3d","modified":1616926802391},{"_id":"themes/tranquilpeak/layout/archive.ejs","hash":"eaf8d7e5595daa728199434dc7fe5b50c2f7ee80","modified":1616926802276},{"_id":"themes/tranquilpeak/layout/category.ejs","hash":"1590069ffd66497ee1e9f854fab8ea9eeae47333","modified":1616926802277},{"_id":"themes/tranquilpeak/layout/index.ejs","hash":"3486384a86ad4fcc1b192f57cdb1d78d751ed93d","modified":1616926802277},{"_id":"themes/tranquilpeak/layout/all-categories.ejs","hash":"81d9e4bb6b3fc2ac0cc2a1258ac08b61aca96991","modified":1616926802275},{"_id":"themes/tranquilpeak/layout/all-tags.ejs","hash":"51e9861778fb04b400651e54ac76b3a400b8167e","modified":1616926802275},{"_id":"themes/tranquilpeak/layout/page.ejs","hash":"aacb3c66f4e8a6d49c77fe821b14ed5fc8fbacfe","modified":1616926802279},{"_id":"themes/tranquilpeak/layout/post.ejs","hash":"aacb3c66f4e8a6d49c77fe821b14ed5fc8fbacfe","modified":1616926802279},{"_id":"themes/tranquilpeak/layout/tag.ejs","hash":"72bff1ae241fbe2ddca0537e8ed77c791a7d1766","modified":1616926802280},{"_id":"themes/tranquilpeak/tasks/config/clean.js","hash":"3d4d13265c10d036bc0ecac7733327daa9a95b17","modified":1616926802392},{"_id":"themes/tranquilpeak/layout/all-archives.ejs","hash":"906af6fc218fa12c41f243b8878c34507b00a216","modified":1616926802274},{"_id":"themes/tranquilpeak/tasks/config/concat.js","hash":"4e87d31d2d92fcdc64b16e253072d24e5f8a007d","modified":1616926802393},{"_id":"themes/tranquilpeak/tasks/config/replace.js","hash":"18015172ede5943d3507a93ef569cb0d3dcbdf6d","modified":1616926802395},{"_id":"themes/tranquilpeak/tasks/config/copy.js","hash":"55c8a6d7f4f450bbe901b9e61ea8e0c58b539e2e","modified":1616926802394},{"_id":"themes/tranquilpeak/tasks/config/cssmin.js","hash":"082ebe087a09f0c7054bea0754ec7e647d432f93","modified":1616926802394},{"_id":"themes/tranquilpeak/tasks/config/sails-linker.js","hash":"8d723b894b644a8bb863ee25c81b51df1726e7c1","modified":1616926802396},{"_id":"themes/tranquilpeak/tasks/config/watch.js","hash":"c9011b289e1201b3192126f8f3b7aff92b0118d2","modified":1616926802399},{"_id":"themes/tranquilpeak/tasks/config/uglify.js","hash":"5009aaf01593527962784b39deef505d004e288a","modified":1616926802398},{"_id":"themes/tranquilpeak/layout/layout.ejs","hash":"d5446823651e83242007715f650f8dc8c0c4d882","modified":1616926802278},{"_id":"themes/tranquilpeak/tasks/register/build.js","hash":"a517462ebaf29a4ce1c6664c2d823cc254894c2c","modified":1616926802400},{"_id":"themes/tranquilpeak/tasks/config/sync.js","hash":"1f7b7fcdd346679a693e0a9dee8ad9062d94f2ce","modified":1616926802397},{"_id":"themes/tranquilpeak/source/_css/base/_base.scss","hash":"2b51219cc1ca7986004dbf2ad027a7f119da6379","modified":1616926802302},{"_id":"themes/tranquilpeak/tasks/register/buildProd.js","hash":"bf2ff77506eedfd6f424e130367b30c14cf13af2","modified":1616926802401},{"_id":"themes/tranquilpeak/tasks/register/default.js","hash":"da5f3afd5f8731a2cc25ee979b46a6156d262373","modified":1616926802403},{"_id":"themes/tranquilpeak/tasks/register/compileAssets.js","hash":"931a415c2fcbe2f53854c794fff0eb64f99b2985","modified":1616926802402},{"_id":"themes/tranquilpeak/tasks/register/eslint.js","hash":"0fd7f14108a8c757218bdd7001e495ddbe908c1e","modified":1616926802404},{"_id":"themes/tranquilpeak/tasks/register/linkAssets.js","hash":"b6bb4521d655f81fb1ae1e15f7a45ce85deb3870","modified":1616926802405},{"_id":"themes/tranquilpeak/tasks/register/syncAssets.js","hash":"66c24fb87b902e2e1e49f20fc256dd092c8cd7bd","modified":1616926802406},{"_id":"themes/tranquilpeak/tasks/register/linkAssetsProd.js","hash":"bc1cf26bfa57ab3045c6115c5ca96451d0f453bb","modified":1616926802406},{"_id":"themes/tranquilpeak/tasks/config/sass.js","hash":"50bfbb4368e9ed7a3433184246ad01334b421c7b","modified":1616926802397},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-custom.scss","hash":"a58578043a982be82e29952f32c96ebd69849974","modified":1616926802340},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-tranquilpeak.scss","hash":"d120782c7a4ffa112820ebad906d2c35e7f78822","modified":1616926802340},{"_id":"themes/tranquilpeak/source/_css/utils/_fonts.scss","hash":"23e59e7378c2bd79aeb45247f1879842e776ab5a","modified":1616926802344},{"_id":"themes/tranquilpeak/source/_css/pages/_search.scss","hash":"96a292b594d3b216dfa319a4f38af9df20afb03c","modified":1616926802338},{"_id":"themes/tranquilpeak/source/_css/layouts/_blog.scss","hash":"e390770731ab5b0fea5cbb1866e4efb93e6079c0","modified":1616926802331},{"_id":"themes/tranquilpeak/source/_css/utils/_variables.scss","hash":"30745fc41bd0c467c810d4e3d9ae710081cfebc2","modified":1616926802344},{"_id":"themes/tranquilpeak/source/_css/layouts/_about.scss","hash":"6cb5551b3f1185c8292b3e45a3f15a8bcae5190e","modified":1616926802331},{"_id":"themes/tranquilpeak/source/_css/layouts/_cover.scss","hash":"2095f2c726f324757efffe25a01fe40b48fdb714","modified":1616926802333},{"_id":"themes/tranquilpeak/source/_css/layouts/_footer.scss","hash":"ffad0f76f9329ea9a902530e2db410d48996851c","modified":1616926802334},{"_id":"themes/tranquilpeak/source/_css/layouts/_bottom-bar.scss","hash":"003642701849244ec30bba561ba771ee0f1d1303","modified":1616926802332},{"_id":"themes/tranquilpeak/.github/workflows/nodejs.yml","hash":"f3462c414dfe2e5bf81c9e7b933b3a39abd83594","modified":1616926802232},{"_id":"themes/tranquilpeak/source/_css/layouts/_header.scss","hash":"c2132f256e329c3b6b23a5aeb9072d49a66b0ba8","modified":1616926802335},{"_id":"themes/tranquilpeak/source/_css/layouts/_sidebar.scss","hash":"38898fae223592090e01f5266b118ad7623d1477","modified":1616926802337},{"_id":"themes/tranquilpeak/source/_css/layouts/_main.scss","hash":"f327f42f787091b4b738bcc3521499ba70c2fe3e","modified":1616926802336},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/question.md","hash":"09ff758aa13fe66e881d9bc26fd8cecf3e4ae876","modified":1616926802230},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/bug-report.md","hash":"b5df9cd9cd1e4a1208462e7d4044deaa954d4323","modified":1616926802227},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/feature-request---improvement.md","hash":"0d05e7f78a827aba06ae24889ba2972581725fca","modified":1616926802228},{"_id":"themes/tranquilpeak/layout/_partial/archive.ejs","hash":"bfba8f72c46c54582ba58722ccde8e55801f29f2","modified":1616926802251},{"_id":"themes/tranquilpeak/layout/_partial/cover.ejs","hash":"e574e5c0798f183626eec49a85b3ecc58d54c9e6","modified":1616926802253},{"_id":"themes/tranquilpeak/layout/_partial/baidu-analytics.ejs","hash":"871040d068ddcd31558095ea1c5893f8adc5435a","modified":1616926802252},{"_id":"themes/tranquilpeak/layout/_partial/about.ejs","hash":"13e25607c08ae6971ab4b9815e13c4b12dc320cc","modified":1616926802250},{"_id":"themes/tranquilpeak/layout/_partial/footer.ejs","hash":"ee47c57a9c682212e1a5a367fa83e9b5dc54919f","modified":1616926802254},{"_id":"themes/tranquilpeak/layout/_partial/google-analytics.ejs","hash":"d008e9101a6d5bb5a9888abb3d50caee737af9ef","modified":1616926802255},{"_id":"themes/tranquilpeak/layout/_partial/archive-post.ejs","hash":"9f9d0b50dbb093f6d41d48cf15f31c1e1df909bf","modified":1616926802251},{"_id":"themes/tranquilpeak/layout/_partial/pagination.ejs","hash":"646dcab0febb5aeaebb654af9012fc6aa5afae75","modified":1616926802259},{"_id":"themes/tranquilpeak/layout/_partial/post.ejs","hash":"aaeada776ef8818a8e806f7576c71af8a2ea613c","modified":1616926802259},{"_id":"themes/tranquilpeak/layout/_partial/header.ejs","hash":"60233dad83a81f11db590bda1c16ebdb0c3f7ee5","modified":1616926802256},{"_id":"themes/tranquilpeak/layout/_partial/index.ejs","hash":"4fb1ceb6899b2edce57a299c21387e14381fcf91","modified":1616926802258},{"_id":"themes/tranquilpeak/layout/_partial/head.ejs","hash":"c7c53fda43c8189adbe33727d84f49bb03be1ed7","modified":1616926802255},{"_id":"themes/tranquilpeak/source/_css/components/_alert.scss","hash":"2db9894ed798139cc11df637325237a94fa960a3","modified":1616926802304},{"_id":"themes/tranquilpeak/layout/_partial/search.ejs","hash":"006d608d38e8e3326b0bf6b3b1cc5e899955e816","modified":1616926802272},{"_id":"themes/tranquilpeak/layout/_partial/script.ejs","hash":"3e4e24521f3c598c16fd77e78466e7856d73f203","modified":1616926802272},{"_id":"themes/tranquilpeak/source/_css/components/_box.scss","hash":"806359baf70199bfb930b7bcd46598e982e11e7c","modified":1616926802305},{"_id":"themes/tranquilpeak/source/_css/components/_button.scss","hash":"899e5796853b31e4bdd98d96eef2ed85a926ac0c","modified":1616926802306},{"_id":"themes/tranquilpeak/layout/_partial/sidebar.ejs","hash":"55f976c44a92afa6218aab5d18c26d4938cc50e8","modified":1616926802273},{"_id":"themes/tranquilpeak/source/_css/components/_caption.scss","hash":"7d6ee5066304b82ff555e1e4d09bd226db6855d5","modified":1616926802307},{"_id":"themes/tranquilpeak/source/_css/components/_archive.scss","hash":"e6da3fbd34e4aa5a786cc9d6dd60d057a4f6e09e","modified":1616926802304},{"_id":"themes/tranquilpeak/source/_css/components/_fancybox.scss","hash":"7e8da9a681478bf55a6dbedacb3876a38043085d","modified":1616926802308},{"_id":"themes/tranquilpeak/source/_css/components/_code.scss","hash":"f52da79a13bc0daf47189f5e305f8a48b3cb8837","modified":1616926802308},{"_id":"themes/tranquilpeak/source/_css/components/_form.scss","hash":"471d60275c22b11ba6d0560155d0ab9466d718f5","modified":1616926802310},{"_id":"themes/tranquilpeak/source/_css/components/_figure.scss","hash":"a43a18feb6224cc033a8f7fb3fc40d36e2eeb4d0","modified":1616926802309},{"_id":"themes/tranquilpeak/source/_css/components/_hide.scss","hash":"c9e5f2e86404243e254103f86485dd3ead6cf985","modified":1616926802311},{"_id":"themes/tranquilpeak/source/_css/components/_icon.scss","hash":"20e0698a8f0963cbad5beb78bfb5d01257622ced","modified":1616926802312},{"_id":"themes/tranquilpeak/source/_css/components/_link.scss","hash":"51e76a3ce339b2ac13db46afda2fe51d6c295c5c","modified":1616926802314},{"_id":"themes/tranquilpeak/source/_css/components/_image-gallery.scss","hash":"cc81bfb41c7646550beb2f63d4ec538fae7c6ef6","modified":1616926802313},{"_id":"themes/tranquilpeak/source/_css/components/_main-content.scss","hash":"30a5577a001d7af4ee9acb10561939d54284b70b","modified":1616926802315},{"_id":"themes/tranquilpeak/source/_css/components/_highlight-text.scss","hash":"9bbafdd6d16beb1a4974facf189d5e20e1574c17","modified":1616926802312},{"_id":"themes/tranquilpeak/source/_css/components/_media.scss","hash":"c8dac3ad7cd23d6feef409256b93c743828a2142","modified":1616926802316},{"_id":"themes/tranquilpeak/source/_css/components/_markdown.scss","hash":"d90de4c61310037c8414cfec4f8b0b97acfe9426","modified":1616926802316},{"_id":"themes/tranquilpeak/source/_css/components/_modal.scss","hash":"aab1d74706ee10c0750d5cc043c20d6dec436efa","modified":1616926802317},{"_id":"themes/tranquilpeak/source/_css/components/_post.scss","hash":"15fe756fbe5e6ca1ba79f3db894ad6db589b87f9","modified":1616926802322},{"_id":"themes/tranquilpeak/source/_css/components/_pagination.scss","hash":"903f49aa615d78660c93b3fb1db0c55708b94190","modified":1616926802319},{"_id":"themes/tranquilpeak/source/_css/components/_pullquote.scss","hash":"b9d56d3bbf31dab2e647133c9376b9c6aef9b150","modified":1616926802324},{"_id":"themes/tranquilpeak/source/_css/components/_post-header-cover.scss","hash":"80030d4e3c5d5ef77979e00e8ceec6c175c34e9e","modified":1616926802322},{"_id":"themes/tranquilpeak/source/_css/components/_postShorten.scss","hash":"7e14316ad11dbf73d9f182099cf2ee203b203632","modified":1616926802323},{"_id":"themes/tranquilpeak/source/_css/components/_post-actions.scss","hash":"884dc890848b3f328fb81246ae13665463cb127c","modified":1616926802321},{"_id":"themes/tranquilpeak/source/_css/components/_share-options-bar.scss","hash":"443d06df9be3349b3a354cc62ddcb98a74c236d8","modified":1616926802325},{"_id":"themes/tranquilpeak/source/_css/components/_text.scss","hash":"80285f7820a696c716a3d71bb35658d4c42ff933","modified":1616926802327},{"_id":"themes/tranquilpeak/source/_css/components/_video.scss","hash":"2d65fe9ed477c6680cc7cc0f31584c72d76beb58","modified":1616926802329},{"_id":"themes/tranquilpeak/source/_css/components/_tooltip.scss","hash":"54745301f0c3d1c46b6822ad7140e3a175e8a426","modified":1616926802328},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_button.scss","hash":"aa8f36e0e6e8691251c9468e119f5b27d4a5abc0","modified":1616926802346},{"_id":"themes/tranquilpeak/source/_css/components/_tag.scss","hash":"17cf385de30a1c2468db05697b1d7d7e64374f1b","modified":1616926802326},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_form.scss","hash":"a73ebe20494dd8b3718276ad9810d615f8995f5f","modified":1616926802348},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_category.scss","hash":"a058a31159ef24846b108bc87516fe889ff4805d","modified":1616926802347},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_main.scss","hash":"920ee98db90c7aaa0b7660131189b0aadb5c219a","modified":1616926802350},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_header.scss","hash":"dbf40cf0add41713676a8e2e3a343d9bf25447a0","modified":1616926802349},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_opacity.scss","hash":"38e03eaf1afc7a5a601479e556ca4c8f9abfb464","modified":1616926802350},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_post-header-cover.scss","hash":"4146edd386a91cafe3c13662f3f02ca2b13dbeb9","modified":1616926802351},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_prefix.scss","hash":"6dc39f77c8322a26edf51be9418c60174720cdaa","modified":1616926802353},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_bottom-bar.scss","hash":"742f3a6eeae8581bf1db5c9172aa8c030c8a92e6","modified":1616926802346},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_tag.scss","hash":"1f989247cd8fb95c02f1a12871455f13d01d4678","modified":1616926802356},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_sidebar.scss","hash":"8fc983c82790810f19631689819898c60cd1cca3","modified":1616926802355},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_share-options-bar.scss","hash":"bc8e88cdda0f3c184f432ecb51abae8a27bec2f8","modified":1616926802354},{"_id":"themes/tranquilpeak/layout/_partial/post/disqus.ejs","hash":"c72be41780f9c65cab2f278cc23b22b6dbb5bac1","modified":1616926802262},{"_id":"themes/tranquilpeak/layout/_partial/post/duoshuo.ejs","hash":"6881233b163a5812eaad64db94ee052040865c6e","modified":1616926802263},{"_id":"themes/tranquilpeak/layout/_partial/post/category.ejs","hash":"5eb3b1f246568724c766163541355d27d4eb8cc5","modified":1616926802262},{"_id":"themes/tranquilpeak/layout/_partial/post/gitalk.ejs","hash":"51853f5e1b466d876bade6fb1c65a2e25c9df992","modified":1616926802264},{"_id":"themes/tranquilpeak/layout/_partial/post/gitment.ejs","hash":"1dcfdca4d20bab5a43bda44cf37df506ab3a0fb7","modified":1616926802265},{"_id":"themes/tranquilpeak/layout/_partial/post/gallery.ejs","hash":"b24d69e8863e02b4f688cd04c1e6cb76aa4b841f","modified":1616926802264},{"_id":"themes/tranquilpeak/layout/_partial/post/header-cover.ejs","hash":"0c5586a219481a2370065ffb804dd32a9d6b2752","modified":1616926802266},{"_id":"themes/tranquilpeak/layout/_partial/post/tag.ejs","hash":"602f51f0b83dd6e06d4988425c2d0b27448d8c94","modified":1616926802271},{"_id":"themes/tranquilpeak/layout/_partial/post/actions.ejs","hash":"80c5406e336b32cb49e7e02b409d96decf4dc58d","modified":1616926802261},{"_id":"themes/tranquilpeak/layout/_partial/post/meta.ejs","hash":"72d2a835a31f70a4d39faaa0b3adf5bebf0f632c","modified":1616926802270},{"_id":"themes/tranquilpeak/layout/_partial/post/share-options.ejs","hash":"12211764ed21e025258135eae05739a70ba047a7","modified":1616926802270},{"_id":"themes/tranquilpeak/source/_images/avatar.png","hash":"fae7a4bc08bad88136de5f66c9abe97954741234","modified":1616926802366},{"_id":"themes/tranquilpeak/source/_images/cover.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1616926802376},{"_id":"themes/tranquilpeak/source/_images/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1616926802372},{"_id":"themes/tranquilpeak/layout/_partial/post/header.ejs","hash":"5978dbb96f616f90ce71343ee94b4ff9388ccbd0","modified":1616926802269},{"_id":"themes/tranquilpeak/package-lock.json","hash":"f30132f3b3d18d2f58857ad94ce0c8f38dc4be0e","modified":1616926802282},{"_id":"public/about/index.html","hash":"ec8e498791eecc2bc700cd500bae541c8cfbff5e","modified":1622992059492},{"_id":"public/categories/index.html","hash":"e5d5eeb0441f22a6e249cce53eee068517b2992a","modified":1622992059492},{"_id":"public/tags/index.html","hash":"cfa0d27ebb2cb5ac13e08ef379abaa52df0fbb9f","modified":1622992059492},{"_id":"public/top/index.html","hash":"8a45ba32b6ae13c9a5245c0433c4dcd1bce80719","modified":1622992059492},{"_id":"public/archives/2020/page/2/index.html","hash":"dfe60cc9f221a2888ba623d8ac1b7ff6633bda49","modified":1622992059492},{"_id":"public/archives/2020/01/index.html","hash":"15f4ed74cad6c84a5f2aba31ce482a021bd45f36","modified":1622992059492},{"_id":"public/archives/2020/03/index.html","hash":"270f970d83e324adc1db933a8878ca1c0c85ddb8","modified":1622992059492},{"_id":"public/archives/2020/05/index.html","hash":"2afdc2b0b5669b24c7cbca8f436e46fb986cc131","modified":1622992059492},{"_id":"public/archives/2020/06/index.html","hash":"223703bd2ee4082fa67b6eea1c4448e873ecc8a9","modified":1622992059492},{"_id":"public/archives/2020/07/index.html","hash":"e03c6eae154238c071635a7b9d1419d5035799dd","modified":1622992059492},{"_id":"public/archives/2020/08/index.html","hash":"34b315f55119b2f99eb02c2bbea7e558e9bf45b9","modified":1622992059492},{"_id":"public/archives/2021/page/3/index.html","hash":"804e64465707ce398acb2c58275126e5329cc6d0","modified":1622992059492},{"_id":"public/archives/2021/01/index.html","hash":"92396bce95ee4148829c82fdc97d58bd61c43622","modified":1622992059492},{"_id":"public/archives/2021/05/index.html","hash":"a3a9082de649479d42130af7f89a66385ded8a91","modified":1622992059492},{"_id":"public/archives/2021/06/index.html","hash":"d1790b5ee3d311bbc34c4a4f84f7655916791eb4","modified":1622992059492},{"_id":"public/categories/essay/index.html","hash":"f64b6beee7c3afb88753793b8cbfdc838d3ff2b6","modified":1622992059492},{"_id":"public/categories/framework/index.html","hash":"dacdd9de54fd53e12649c2a472d2707f91317899","modified":1622992059492},{"_id":"public/categories/springboot/index.html","hash":"af62160293ab6ec855099f616c11742116d3dc67","modified":1622992059492},{"_id":"public/categories/Leetcode/index.html","hash":"75e9dff820769455482b337000fdb20cd0420939","modified":1622992059492},{"_id":"public/categories/DesignPatterns/index.html","hash":"60a5791521f6008dc82e81333c41c7fc970653d4","modified":1622992059492},{"_id":"public/categories/jdk/index.html","hash":"c5f699022ed098195bc1bbd70c4e86319d77e8d8","modified":1622992059492},{"_id":"public/categories/LeetCode/index.html","hash":"1f3754c9b6dedcfdf79704b34f5fa1efab0e6a71","modified":1622992059492},{"_id":"public/categories/JVM/index.html","hash":"87d40ed98da4fdb1417dd831c8f27a3c5635c28e","modified":1622992059492},{"_id":"public/categories/Linux/index.html","hash":"339c84bde7374f75afd3b0f7c00e7e8a33388e04","modified":1622992059492},{"_id":"public/categories/DB/index.html","hash":"92e9cd54218ed82479d4f61207c53c7b4a2fb482","modified":1622992059492},{"_id":"public/categories/springmvc/index.html","hash":"4f9586bdba7d1a032d17190f1e745b621d694e22","modified":1622992059492},{"_id":"public/categories/Utils/index.html","hash":"276eb93fd5dddc34ab8bf5bd68cec059865e2258","modified":1622992059492},{"_id":"public/categories/MiddleWare/index.html","hash":"554e1b004548c9053eb025291b42c5b3de48d687","modified":1622992059492},{"_id":"public/tags/summary/index.html","hash":"93cc490dc049ef3feac48e3c811437053cab6457","modified":1622992059492},{"_id":"public/tags/spring-security/index.html","hash":"5994bdbc58eae2de68b4b46e70bf23873e3d5ed9","modified":1622992059492},{"_id":"public/tags/standard/index.html","hash":"e37ff07ebeea664fa2c108e8d225b59c72f88b9d","modified":1622992059492},{"_id":"public/tags/bst/index.html","hash":"50b73ed84fc5c07ec57a859d077958cfa0cbabf8","modified":1622992059492},{"_id":"public/tags/bitwise/index.html","hash":"180a64ded43b2c38b393092c21dfcfd08f45f3ef","modified":1622992059492},{"_id":"public/tags/design-patterns/index.html","hash":"6bf2efd1f448454c4cf8f16e6dce1d330156359a","modified":1622992059492},{"_id":"public/tags/hashmap-data-structure/index.html","hash":"6481ede781d99594d2ded40b1373b3cfca037885","modified":1622992059492},{"_id":"public/tags/datastructure/index.html","hash":"ce2398566057bd9fca9e279ed2281526c6ff3902","modified":1622992059492},{"_id":"public/tags/http/index.html","hash":"8f87f3400a065765d52b09f96159835273ffb303","modified":1622992059492},{"_id":"public/tags/https/index.html","hash":"e6a814e17883999e39a3d52a47614fd46fee675d","modified":1622992059492},{"_id":"public/tags/framework/index.html","hash":"13cf02db00f7720cc886b7649d601a5e1519e142","modified":1622992059492},{"_id":"public/tags/greedy-dp-stratey/index.html","hash":"bff645eccda893e046109e8d7c0e8885e38e87ff","modified":1622992059492},{"_id":"public/tags/classloader/index.html","hash":"78be7df284e01f0c9a965c6f57005d396a8d18ab","modified":1622992059492},{"_id":"public/tags/memory/index.html","hash":"27e42538c44ed14fd7467f14d5c0d52c597d7c4d","modified":1622992059492},{"_id":"public/tags/utils/index.html","hash":"e4d5cc92169052937bc497a0a05ed0bb729fceb2","modified":1622992059492},{"_id":"public/tags/lock/index.html","hash":"2d4b46484f210abc5f2d8a7e8710295253cd4aea","modified":1622992059492},{"_id":"public/tags/mybatis/index.html","hash":"6419806ae0d0e544cc25ff7d122c6479bf4f6df8","modified":1622992059492},{"_id":"public/tags/dp/index.html","hash":"bba262ba74d194547359bb04ea8760b83ee6f985","modified":1622992059492},{"_id":"public/tags/redis/index.html","hash":"6ce7472295570946c7b1d05fd5abb838689e330f","modified":1622992059492},{"_id":"public/tags/nosql/index.html","hash":"652f4353c939ca9ee4e1792be4c595ee72260e54","modified":1622992059492},{"_id":"public/tags/treeMap-trie/index.html","hash":"b7cc66abfef3b5fb0e4ae72b1370ed1f28c9b2b5","modified":1622992059492},{"_id":"public/tags/double-poiters/index.html","hash":"34a3557f8642b759fdf149c917f9b306ebfb531a","modified":1622992059492},{"_id":"public/tags/map-preSum/index.html","hash":"0d0abb45a22ec5221e5b4a7bfdd1338a52b228cb","modified":1622992059492},{"_id":"public/tags/activemq/index.html","hash":"0832fe3b064290532d4979abcae73b2045eda7de","modified":1622992059492},{"_id":"public/all-archives/index.html","hash":"58b078a82cc93c2b4a44fcff5a3b45aa1e4b1781","modified":1622992059492},{"_id":"public/all-categories/index.html","hash":"a58b9fbe46f1d535d580792787a1f9bf614d26e2","modified":1622992059492},{"_id":"public/all-tags/index.html","hash":"a00fec92bd876dfcfdb320365a24b2e5ff14ecce","modified":1622992059492},{"_id":"public/2021/06/06/2021-mid/index.html","hash":"c37cbe743ec89dacb332d3eaf19810107f36532d","modified":1622992059492},{"_id":"public/2021/05/31/search-suggestions-system/index.html","hash":"4f6656404d8f78537d71f843b5d9fd6acb01d561","modified":1622992059492},{"_id":"public/2021/05/24/jump-games/index.html","hash":"9c1b05d2387ad80b217439cefa3c4e01172567a5","modified":1622992059492},{"_id":"public/2021/05/14/predict-the-winner/index.html","hash":"34e1102983aa6e7c54eeb13f3ef6a5bec1192c64","modified":1622992059492},{"_id":"public/2021/05/12/arraylist-grow/index.html","hash":"4b21e350fa462a8179da95b0d43fc9120739918b","modified":1622992059492},{"_id":"public/2021/04/20/linux-command-line/index.html","hash":"35f8402fd25a09bf3e599fc1bfe4c9990508841f","modified":1622992059492},{"_id":"public/2021/04/19/acm-standard-inputoutput/index.html","hash":"cfae0daae1b7d4daf73199c2bc9046b741fb9fad","modified":1622992059492},{"_id":"public/2021/04/07/springmvc-argument/index.html","hash":"bf6617a75add5b7719c14cae35ebdd0e299bb1c2","modified":1622992059492},{"_id":"public/2021/04/06/springmvc-dispatch/index.html","hash":"659082dd6653f527c69ecea379a28a21929624bc","modified":1622992059492},{"_id":"public/2021/04/06/springmvc-dispatcherservlet/index.html","hash":"56bfcc602faaa78eb4d13318bdc9c6ccbc73ffe4","modified":1622992059492},{"_id":"public/2021/03/23/jvm-memory-manage/index.html","hash":"cbe38979f797513c46f9a2e234db3ba04edabb06","modified":1622992059492},{"_id":"public/2021/03/23/jvm-concurrency/index.html","hash":"beb6abd4dd17309640259c60a953e6fad8f6a5b6","modified":1622992059492},{"_id":"public/2021/03/23/jvm-classloader/index.html","hash":"cec3ef6405770e5aec65643de84dbf0241e58a47","modified":1622992059492},{"_id":"public/2021/03/22/Spring-Security-AutoConfiguration/index.html","hash":"4d7a8df56d9c2b660a5bbb4e4298d068aa113852","modified":1622992059492},{"_id":"public/2021/03/09/mybatis-autoconfiguration/index.html","hash":"fc3b31f73d30c1fade84713a323c956eb495350a","modified":1622992059492},{"_id":"public/2021/03/07/mybatis-sql-resolution/index.html","hash":"54c220c66a47d64219ed9912ac6d0b96c94056ff","modified":1622992059492},{"_id":"public/2021/03/06/java-collection-framework/index.html","hash":"0fffdbd74fdcf2f5e9626b472984abae1fee54e0","modified":1622992059492},{"_id":"public/2021/02/28/springboot-servlet/index.html","hash":"a9020d7d71e05968c5aae280e3f6f672cde7cf08","modified":1622992059492},{"_id":"public/2021/02/27/binary-search-tre/index.html","hash":"53ac1a925555b32360f9820d4c2b4de3f0f82f6e","modified":1622992059492},{"_id":"public/2021/02/27/subarray/index.html","hash":"49aad029f7d66a4b9df0668c693face8ef803a0b","modified":1622992059492},{"_id":"public/2021/02/15/SpringBoot-refresh/index.html","hash":"25af81599435a078df4e5f9e55a8783a45c234f0","modified":1622992059492},{"_id":"public/2021/02/15/SpringBoot-environment/index.html","hash":"eddf25fcaa7ec1fdcd231e91aa2ff184fc9de58f","modified":1622992059492},{"_id":"public/2021/02/15/SpringBoot-startup/index.html","hash":"75a986451c6231c9b8bcf175a6159ac45b23811a","modified":1622992059492},{"_id":"public/2021/01/03/2020-end/index.html","hash":"fe3336a7c2d563b75e54256cfeb06b3ff7591ed0","modified":1622992059492},{"_id":"public/2020/08/20/hashmap/index.html","hash":"d6ccc9d8deaaeef525c34231b6c2bc1618e70449","modified":1622992059492},{"_id":"public/2020/08/05/mybatis_preview/index.html","hash":"072c4e8f37cbb15a5b2f87afb8aff7706a496bc6","modified":1622992059492},{"_id":"public/2020/07/20/lock/index.html","hash":"4690374859deaec81e050b187c1dac4e5b0de490","modified":1622992059492},{"_id":"public/2020/07/20/volatile/index.html","hash":"f2becdb45ac8f505688ddab17584d87de7a1677a","modified":1622992059492},{"_id":"public/2020/07/20/mq/index.html","hash":"793e2cd7db3d507f276f25e4582648ec2790d9f8","modified":1622992059492},{"_id":"public/2020/06/12/decorating/index.html","hash":"c0de34bc00954805d8ea1ac6a2a09e17f845ab2d","modified":1622992059492},{"_id":"public/2020/06/12/observer/index.html","hash":"b2c1dcb64aeb712773bb72e138b579bad047df33","modified":1622992059492},{"_id":"public/2020/06/09/redis/index.html","hash":"db2da8eeb5868ab034c7ed36602551aa6e40e9a9","modified":1622992059492},{"_id":"public/2020/06/06/heap/index.html","hash":"34c947c217140f457923d30cb86d86872bf3bf23","modified":1622992059492},{"_id":"public/2020/06/01/bitwise/index.html","hash":"53d9f2f086f8bfa3dc00894744d12c23dc116aa9","modified":1622992059492},{"_id":"public/2020/05/24/jvm/index.html","hash":"f6fedddcae8d0fff3d3ac27e3b2135c02db21bdc","modified":1622992059492},{"_id":"public/2020/03/14/https/index.html","hash":"826e7edcd41054642a0c411a67c3e608bd68035c","modified":1622992059492},{"_id":"public/2020/01/12/uml/index.html","hash":"fa2169c3605570605a934300b1d6c5f646ca11f7","modified":1622992059492},{"_id":"public/2019/11/02/nginx/index.html","hash":"fec980653204e20a2dec12941217941d34ecdc1f","modified":1622992059492},{"_id":"public/archives/index.html","hash":"8b377618cf67aa98994bd8fa9a6ba11bed38ae76","modified":1622992059492},{"_id":"public/archives/page/2/index.html","hash":"2d2ba828475255dcaf3aa2a1409705a08bfc7781","modified":1622992059492},{"_id":"public/archives/page/3/index.html","hash":"10c3a9758e510abb9fa3310808d45da4bc76b3ee","modified":1622992059492},{"_id":"public/archives/page/4/index.html","hash":"450121366a12ce359dc053477f69973f24bece33","modified":1622992059492},{"_id":"public/archives/2019/index.html","hash":"4707f2330e1efc700622dba7b0497b9603059ed2","modified":1622992059492},{"_id":"public/archives/2019/11/index.html","hash":"3cb4c20ab6601d8a6b28bd81337d2a6b1ef35b3e","modified":1622992059492},{"_id":"public/archives/2020/index.html","hash":"449c4cce537912004e1465ebe64eec9fe8de11a2","modified":1622992059492},{"_id":"public/archives/2021/index.html","hash":"69a867bb007f5a91a5f5a2404118eb16e1395ce4","modified":1622992059492},{"_id":"public/archives/2021/page/2/index.html","hash":"bf84b3f76d77e8f6b2f4fb59747ee32c88509447","modified":1622992059492},{"_id":"public/archives/2021/02/index.html","hash":"5bc90c3b3d5a60ba274d1622336b2db053f4fcc9","modified":1622992059492},{"_id":"public/archives/2021/03/index.html","hash":"5b18634892dbf2d0a68eb8ea18dcc58b271ebf9a","modified":1622992059492},{"_id":"public/archives/2021/04/index.html","hash":"0386da45285d0f6472020ce1d1554fc1960deb74","modified":1622992059492},{"_id":"public/categories/Java/index.html","hash":"43e0da938d3cd7c62db14ec1538bef8d93741edb","modified":1622992059492},{"_id":"public/categories/Network/index.html","hash":"c55d4b059f7e88c22e0844e4fc73d3303adfb996","modified":1622992059492},{"_id":"public/index.html","hash":"5d7ec24b2cb604e767928ca2c73c033197d2d468","modified":1622992059492},{"_id":"public/page/2/index.html","hash":"9466a45b55014044765d123f33500be6e9d18012","modified":1622992059492},{"_id":"public/page/3/index.html","hash":"c6dd6223c49a4e1e5a17063ddd508c81779fa9ec","modified":1622992059492},{"_id":"public/page/4/index.html","hash":"81b9e498a9ce7b4eebefe89135b0a3f571da6442","modified":1622992059492},{"_id":"public/tags/source/index.html","hash":"0e10b36189276d6342de1a0209848502af94e2d8","modified":1622992059492},{"_id":"public/tags/network/index.html","hash":"2c81eb1b0d7a380e2ce3016822944a79e13eae7b","modified":1622992059492}],"Category":[{"name":"essay","_id":"ckplbkj6d0004ts9qfbu9btqs"},{"name":"framework","_id":"ckplbkj7q000jts9q7op70z98"},{"name":"springboot","_id":"ckplbkj7z000rts9qa868gmhl"},{"name":"Leetcode","_id":"ckplbkj8d0012ts9q1la7e6nm"},{"name":"Java","_id":"ckplbkj8l0019ts9qgyv22jyr"},{"name":"DesignPatterns","_id":"ckplbkj96001sts9q2td30ce8"},{"name":"Network","_id":"ckplbkj9o002dts9qa6490lu3"},{"name":"jdk","_id":"ckplbkj9u002kts9q78qjfxmx"},{"name":"LeetCode","_id":"ckplbkja1002sts9q80597743"},{"name":"JVM","_id":"ckplbkja90032ts9qfwkb2y9z"},{"name":"Linux","_id":"ckplbkjag003jts9qbywh5f5z"},{"name":"DB","_id":"ckplbkjak003rts9qe5cofz84"},{"name":"springmvc","_id":"ckplbkjap003zts9q9eww8ywd"},{"name":"Utils","_id":"ckplbkjay004bts9qe2dp0ld4"},{"name":"MiddleWare","_id":"ckplbkjdp004wts9qh7u55pmw"}],"Data":[],"Page":[{"title":"all-archives","layout":"all-archives","date":"2020-08-16T04:51:57.000Z","_content":"","source":"all-archives/index.md","raw":"---\ntitle: all-archives\nlayout: all-archives\ndate: 2020-08-16 12:51:57\n---\n","updated":"2021-03-28T10:20:02.130Z","path":"all-archives/index.html","comments":1,"_id":"ckplbkj5e0000ts9qgjk2cg27","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"about","date":"2019-11-02T16:17:30.000Z","type":"about","_content":"\n- 2019年毕业\n- 目前在深圳\n- 司职Java后端开发","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-11-03 00:17:30\ntype: about\n---\n\n- 2019年毕业\n- 目前在深圳\n- 司职Java后端开发","updated":"2021-03-28T10:20:02.129Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckplbkj690002ts9q5z9q5gxx","content":"<ul>\n<li>2019年毕业</li>\n<li>目前在深圳</li>\n<li>司职Java后端开发</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<ul>\n<li>2019年毕业</li>\n<li>目前在深圳</li>\n<li>司职Java后端开发</li>\n</ul>\n"},{"title":"all-categories","layout":"all-categories","date":"2020-08-16T04:51:22.000Z","_content":"","source":"all-categories/index.md","raw":"---\ntitle: all-categories\nlayout: all-categories\ndate: 2020-08-16 12:51:22\n---\n","updated":"2021-03-28T10:20:02.131Z","path":"all-categories/index.html","comments":1,"_id":"ckplbkj6j0006ts9q77rd9m6d","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"all-tags","layout":"all-tags","date":"2020-08-16T04:51:43.000Z","_content":"","source":"all-tags/index.md","raw":"---\ntitle: all-tags\nlayout: all-tags\ndate: 2020-08-16 12:51:43\n---\n","updated":"2021-03-28T10:20:02.134Z","path":"all-tags/index.html","comments":1,"_id":"ckplbkj6n0008ts9q93bhf792","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"categories","date":"2019-11-01T07:35:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-11-01 15:35:36\ntype: categories\n---\n","updated":"2021-03-28T10:20:02.135Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckplbkj6q000ats9q5dx3b581","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"tags","date":"2019-11-01T07:08:49.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-11-01 15:08:49\ntype: tags\n---","updated":"2021-03-28T10:20:02.136Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckplbkj7i000fts9q50ru76oo","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"top","date":"2019-11-01T13:50:25.000Z","_content":"<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>","source":"top/index.md","raw":"---\ntitle: top\ndate: 2019-11-01 21:50:25\n---\n<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>","updated":"2021-03-28T10:20:02.137Z","path":"top/index.html","comments":1,"layout":"page","_id":"ckplbkj7n000hts9q7ij5ebug","content":"<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<div id=\"post-rank\"></div>\n\n<script src=\"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\"></script>\n<script>\n  var APP_ID = ******;  //输入个人LeanCloud账号AppID\n  var APP_KEY = ******;  //输入个人LeanCloud账号AppKey\n  AV.init({\n    appId: APP_ID,\n    appKey: APP_KEY\n  });\n\n  var query = new AV.Query('Counter');//表名\n  query.descending('time'); //结果按阅读次数降序排序\n  query.limit(10);  //最终只返回10条结果\n  query.find().then( response => {\n    var content = response.reduce( (accum, {attributes}) => {\n      accum += `<p><div class=\"prefix\">热度 ${attributes.time} ℃</div><div><a href=\"${attributes.url}\">${attributes.title}</a></div></p>`\n      return accum;\n    },\"\")\n    document.querySelector(\"#post-rank\").innerHTML = content;\n  })\n  .catch( error => {\n    console.log(error);\n  });\n</script>\n\n<style type=\"text/css\">\n  #post-rank {\n    text-align: center;\n  }\n  #post-rank .prefix {\n    color: #ff4d4f;\n  }\n</style>"}],"Post":[{"title":"2020_end","date":"2021-01-03T13:35:35.000Z","_content":"\n2020过完了，做个总结，同时简要规划新一年的目标。\n\n<!-- more -->\n\n时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。\n\n<!--toc-->\n\n## 上半年\n\n### 19年的下半年\n\n从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。\n\n从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门\n\n- 熟悉Java集合框架\n- 熟悉使用SpringBoot，SpringCloud\n\n关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。\n\n- Java语言程序设计-基础版\n- Java语言程序设计-进阶版\n\n### 20年的上半年\n\n预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。\n\n这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路\n\n- 微信小程序开发\n  - Javascript, css（flowbox）\n- Leetcode入门\n\n这半年也有持续的看书，主要是HeadFirst系列:\n\n- HeadFirst Servlet JSP\n- HeadFirst Java\n- HeadFirst DesignPattern\n\n## 下半年\n\n下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。\n\n主要业务点\n\n- ElasticSearch\n- Spring Security\n\n除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。\n\n- 深入理解Java虚拟机\n- Java8实战，lambda表达式减轻了后端对数据的解析的代码压力\n\n为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。\n\n## 目标\n\n- [ ] 书读完要有自己的一个认识，**做好读书笔记**，目前看来艾派德不理想。\n- [ ] 一直希望有开源项目方面的贡献，**pull request** 争取突破0。加入一些有趣的组织，同样争取突破0.\n- [ ] **框架理解透彻**，能自己写个demo验证，或者写个插件、扩展等。\n- [ ] 把Java刷过的Leetcode用**Python**和**C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。**算法导论**安排上\n- [ ] **408**，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟\n- [ ] 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出**高质量博客**。\n- [ ] **多线程**、**网络编程**，做个能运行的demo\n- [ ] 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。","source":"_posts/2020-end.md","raw":"---\ntitle: 2020_end\ndate: 2021-01-03 21:35:35\ncategories: essay\ntags: summary\n---\n\n2020过完了，做个总结，同时简要规划新一年的目标。\n\n<!-- more -->\n\n时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。\n\n<!--toc-->\n\n## 上半年\n\n### 19年的下半年\n\n从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。\n\n从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门\n\n- 熟悉Java集合框架\n- 熟悉使用SpringBoot，SpringCloud\n\n关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。\n\n- Java语言程序设计-基础版\n- Java语言程序设计-进阶版\n\n### 20年的上半年\n\n预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。\n\n这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路\n\n- 微信小程序开发\n  - Javascript, css（flowbox）\n- Leetcode入门\n\n这半年也有持续的看书，主要是HeadFirst系列:\n\n- HeadFirst Servlet JSP\n- HeadFirst Java\n- HeadFirst DesignPattern\n\n## 下半年\n\n下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。\n\n主要业务点\n\n- ElasticSearch\n- Spring Security\n\n除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。\n\n- 深入理解Java虚拟机\n- Java8实战，lambda表达式减轻了后端对数据的解析的代码压力\n\n为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。\n\n## 目标\n\n- [ ] 书读完要有自己的一个认识，**做好读书笔记**，目前看来艾派德不理想。\n- [ ] 一直希望有开源项目方面的贡献，**pull request** 争取突破0。加入一些有趣的组织，同样争取突破0.\n- [ ] **框架理解透彻**，能自己写个demo验证，或者写个插件、扩展等。\n- [ ] 把Java刷过的Leetcode用**Python**和**C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。**算法导论**安排上\n- [ ] **408**，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟\n- [ ] 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出**高质量博客**。\n- [ ] **多线程**、**网络编程**，做个能运行的demo\n- [ ] 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。","slug":"2020-end","published":1,"updated":"2021-06-06T14:19:56.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj5u0001ts9qfdfnd0ea","content":"<p>2020过完了，做个总结，同时简要规划新一年的目标。</p>\n<span id=\"more\"></span>\n\n<p>时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。</p>\n<!--toc-->\n\n<h2 id=\"上半年\"><a href=\"#上半年\" class=\"headerlink\" title=\"上半年\"></a>上半年</h2><h3 id=\"19年的下半年\"><a href=\"#19年的下半年\" class=\"headerlink\" title=\"19年的下半年\"></a>19年的下半年</h3><p>从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。</p>\n<p>从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门</p>\n<ul>\n<li>熟悉Java集合框架</li>\n<li>熟悉使用SpringBoot，SpringCloud</li>\n</ul>\n<p>关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。</p>\n<ul>\n<li>Java语言程序设计-基础版</li>\n<li>Java语言程序设计-进阶版</li>\n</ul>\n<h3 id=\"20年的上半年\"><a href=\"#20年的上半年\" class=\"headerlink\" title=\"20年的上半年\"></a>20年的上半年</h3><p>预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。</p>\n<p>这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路</p>\n<ul>\n<li>微信小程序开发<ul>\n<li>Javascript, css（flowbox）</li>\n</ul>\n</li>\n<li>Leetcode入门</li>\n</ul>\n<p>这半年也有持续的看书，主要是HeadFirst系列:</p>\n<ul>\n<li>HeadFirst Servlet JSP</li>\n<li>HeadFirst Java</li>\n<li>HeadFirst DesignPattern</li>\n</ul>\n<h2 id=\"下半年\"><a href=\"#下半年\" class=\"headerlink\" title=\"下半年\"></a>下半年</h2><p>下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。</p>\n<p>主要业务点</p>\n<ul>\n<li>ElasticSearch</li>\n<li>Spring Security</li>\n</ul>\n<p>除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。</p>\n<ul>\n<li>深入理解Java虚拟机</li>\n<li>Java8实战，lambda表达式减轻了后端对数据的解析的代码压力</li>\n</ul>\n<p>为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 书读完要有自己的一个认识，<strong>做好读书笔记</strong>，目前看来艾派德不理想。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一直希望有开源项目方面的贡献，<strong>pull request</strong> 争取突破0。加入一些有趣的组织，同样争取突破0.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>框架理解透彻</strong>，能自己写个demo验证，或者写个插件、扩展等。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 把Java刷过的Leetcode用<strong>Python</strong>和<strong>C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。</strong>算法导论**安排上</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>408</strong>，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟</li>\n<li><input disabled=\"\" type=\"checkbox\"> 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出<strong>高质量博客</strong>。</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>多线程</strong>、<strong>网络编程</strong>，做个能运行的demo</li>\n<li><input disabled=\"\" type=\"checkbox\"> 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>2020过完了，做个总结，同时简要规划新一年的目标。</p>","more":"<p>时间线上可以方便地从两个维度来写，上半年与下半年分别就职于两家公司。</p>\n<!--toc-->\n\n<h2 id=\"上半年\"><a href=\"#上半年\" class=\"headerlink\" title=\"上半年\"></a>上半年</h2><h3 id=\"19年的下半年\"><a href=\"#19年的下半年\" class=\"headerlink\" title=\"19年的下半年\"></a>19年的下半年</h3><p>从2019年到2020年6月，共一年（2020年底没写总结，是因为没意识到，11月才开的博客），在海口就职于第一家公司。在这家公司我才初次接触了企业级的Java项目（原谅起步晚），半年的时间尽可能吸收更多的知识，跟着公司的其他开发工程师学习。发现拿本子记录还是慢的，在去年底开了博客。三个月是个分水岭，越来越觉得教科书是满足不了的，开始尝试看一些其他的书籍，在公司做微服务之前就查阅资料、看视频学习，所以上手得很快，在公司显得“不落后”了。这是技术方面，在平时的沟通方面也学到了很多，公司规模不大，属于小作坊式，扁平化管理，主要还是大胆与皮厚。</p>\n<p>从现在的角度看以前，那时只能算是熟练的技术工，但也算是一成就吧，更主要的是我突破了Github这一屏障，打开了新世界的大门</p>\n<ul>\n<li>熟悉Java集合框架</li>\n<li>熟悉使用SpringBoot，SpringCloud</li>\n</ul>\n<p>关于书籍，主要是两本，尤其是进阶版，目前还是手边的工具书，时不时拿来查阅。</p>\n<ul>\n<li>Java语言程序设计-基础版</li>\n<li>Java语言程序设计-进阶版</li>\n</ul>\n<h3 id=\"20年的上半年\"><a href=\"#20年的上半年\" class=\"headerlink\" title=\"20年的上半年\"></a>20年的上半年</h3><p>预研微信小程序是主戏，在公司待了半年后业务逐渐上手，可以抗大旗了。春节在家，又伴随疫情，在家研究完小程序后又开发了两款小程序，其中简单的一款开放出来给用户学习拼音，稍难的那个就当用来练习了，后来公司让开发的小程序也每难过练习的。我同时维护的前端与后端的工程，算是个伪全栈吧，知道了前后端开发是如何交互的（我形容这种后端前端都写的像“既当爹又当妈”），有了自己的开发视野和框架体系的认知。接触的东西越多越知道自己的不足，不过还是停留在框架的使用层面和Java开发层面，比如lambda表达式的使用和版本差异，主动地去使用一些框架特性，如SpringAOP、自定义注解等。</p>\n<p>这半年我向前端迈了一小步，向去外面的世界看看，随后受到了算法的打击，于是也开始了算法之路</p>\n<ul>\n<li>微信小程序开发<ul>\n<li>Javascript, css（flowbox）</li>\n</ul>\n</li>\n<li>Leetcode入门</li>\n</ul>\n<p>这半年也有持续的看书，主要是HeadFirst系列:</p>\n<ul>\n<li>HeadFirst Servlet JSP</li>\n<li>HeadFirst Java</li>\n<li>HeadFirst DesignPattern</li>\n</ul>\n<h2 id=\"下半年\"><a href=\"#下半年\" class=\"headerlink\" title=\"下半年\"></a>下半年</h2><p>下半年不仅换了工作，还换了地方。来到了深圳，我也觉得深圳才能装的下我的野心，来了之后发现我的野心还是太小了，可以再大些。这半年我知道了技术不在广而在于精，小而精，必须要有深度，得有刨根问底的精神。之前的个人开源的小程序上线后很少大改，偶尔维护，目前更多的精力放在后端。截止目前，这半年主要做了两个部分：ES、权限管控。两个部分对我来说都是有挑战性的，我也乐于接受，设计并编码了公司ES业务；随后又改造了权限管控部分，使用了Spring Security。因为见了更多的项目，见识到了比原来更规范或更不规范的代码。</p>\n<p>主要业务点</p>\n<ul>\n<li>ElasticSearch</li>\n<li>Spring Security</li>\n</ul>\n<p>除了业务方面带来了新的技术挑战，我时刻关注着技术深度，同时也没有停止算法之路，我也意识到关于某个技术的书籍，不能只停留在某一本，书不可能面面俱到。书籍方面最大的惊喜可以说是JVM，揭开了不少关于Java的疑惑，框架方面我也研究了SpringBoot和MyBatis，不是只停留在使用了，每每看过框架源码都让人大呼过瘾，但是感觉还有一段路要走。数据库方面我在读相关的书籍，还没读完。唯一有些遗憾的是在新公司对于SpringCloud的使用微乎其微。</p>\n<ul>\n<li>深入理解Java虚拟机</li>\n<li>Java8实战，lambda表达式减轻了后端对数据的解析的代码压力</li>\n</ul>\n<p>为了提升自己的竞争力和信心（毕竟考研被做炮灰），我还去考了一个“软件设计师”，还好过了，其实也没有花太多精力，因为大部分的知识以前都学过，算法之类的和设计模式也都经常在用。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 书读完要有自己的一个认识，<strong>做好读书笔记</strong>，目前看来艾派德不理想。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 一直希望有开源项目方面的贡献，<strong>pull request</strong> 争取突破0。加入一些有趣的组织，同样争取突破0.</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>框架理解透彻</strong>，能自己写个demo验证，或者写个插件、扩展等。</li>\n<li><input disabled=\"\" type=\"checkbox\"> 把Java刷过的Leetcode用<strong>Python</strong>和<strong>C++**过一遍，or不止一遍。抛开面试，算法对于编码也非常有意义。</strong>算法导论**安排上</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>408</strong>，fight！国内的教材完成后还要看看国外的教材，要做到滚瓜烂熟</li>\n<li><input disabled=\"\" type=\"checkbox\"> 原本的博客数量有不少，目前删了很多，随着时间的推移发现之前的博客质量不高，后续陆续推出<strong>高质量博客</strong>。</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>多线程</strong>、<strong>网络编程</strong>，做个能运行的demo</li>\n<li><input disabled=\"\" type=\"checkbox\"> 长期支持的版本Java17据说9月份出，要提前了解，熟悉目的。</li>\n</ul>"},{"title":"2021_mid","date":"2021-06-06T14:22:06.000Z","_content":"\n2021过了一半，结合2020年末的总结，对2021年中做了总结，这是一年的承上启下。\n\n<!-- more -->\n\n上半年，做了件“大”事——换了工作，与金融相关，做的不是那么的纯计算机的工作了，除了金融，还涉及了项目管理的工作，总的来说是拔高的。一直觉得计算机行业需要交叉，需要交叉学科的人才，我也算是中途出道的，金融小白一枚。\n\n## 上半年总结\n\n- 算法和数据结构：计划完成，在LeetCode平台上进行了每日的打卡和算法竞赛，比赛中从一开始的完成签到题都困难，到目前至少能完成2道题，偶尔三道，国内排名有时候也能突破前1000.\n- 《算法导论》：在能手撕基础算法的情况下，完成了该书的阅读，尤其是动态规划那一板块很有帮助。应该作为handbook，时常翻阅。\n- 408：正好面试会涉及，就一并带过了，不过应该不深，算50%吧。\n- 框架：研究了Spring、Mybatis和SpringMVC框架源码，达到了前所未有的深度，对他的设计有了更深入的思考。\n- 分布式、中间件：从操作系统以及分布式理论的角度学习了中间件相关的东西\n- 项目设计：这是面向面试去做的学习和准备，毕竟“开发练习时长一年多”的我还没有实战的设计经验，例如“分布式的唯一id”这样，但可以提前了解。\n\n上半年就这样，去年年末定下来的任务完成了一部分，剩下的还是比较艰巨的，因为有了新的工作，会带来新的挑战。通过面试我也发现了不足，尤其是对项目的理解，有些面试官的问题是很有深度的，这也是一个思想交流的机会。\n\n## 下半年计划\n\n- 跟入一项新的开源项目，要有提交贡献！！（学习项目架构和设计）\n- 熟悉vue，做到全栈。从小程序的角度去学习vue，应该会很快。这人很单独开一个repo放在github上面。\n- 学习项目管理！PMP安排上！\n- 学习金融知识，完成一些书的阅读与笔记整理，从小白进化成小黑\n- 算法和数据结构，进阶，多语言的练习，上面提到了vue，所以后续可以用js去刷 。有时间的情况下可以战CodeForces\n- 408：基础知识都熟悉了，该刷题巩固了\n- 数学：慢慢来，白板不只可以拿来写算法\n- 逃避虽可耻但有用：看了一集，哈哈哈 安排上。\n- Java紧跟潮流，新版本，新特性，以及JVM。\n","source":"_posts/2021-mid.md","raw":"---\ntitle: 2021_mid\ndate: 2021-06-06 22:22:06\ncategories: essay\ntags: summary\n---\n\n2021过了一半，结合2020年末的总结，对2021年中做了总结，这是一年的承上启下。\n\n<!-- more -->\n\n上半年，做了件“大”事——换了工作，与金融相关，做的不是那么的纯计算机的工作了，除了金融，还涉及了项目管理的工作，总的来说是拔高的。一直觉得计算机行业需要交叉，需要交叉学科的人才，我也算是中途出道的，金融小白一枚。\n\n## 上半年总结\n\n- 算法和数据结构：计划完成，在LeetCode平台上进行了每日的打卡和算法竞赛，比赛中从一开始的完成签到题都困难，到目前至少能完成2道题，偶尔三道，国内排名有时候也能突破前1000.\n- 《算法导论》：在能手撕基础算法的情况下，完成了该书的阅读，尤其是动态规划那一板块很有帮助。应该作为handbook，时常翻阅。\n- 408：正好面试会涉及，就一并带过了，不过应该不深，算50%吧。\n- 框架：研究了Spring、Mybatis和SpringMVC框架源码，达到了前所未有的深度，对他的设计有了更深入的思考。\n- 分布式、中间件：从操作系统以及分布式理论的角度学习了中间件相关的东西\n- 项目设计：这是面向面试去做的学习和准备，毕竟“开发练习时长一年多”的我还没有实战的设计经验，例如“分布式的唯一id”这样，但可以提前了解。\n\n上半年就这样，去年年末定下来的任务完成了一部分，剩下的还是比较艰巨的，因为有了新的工作，会带来新的挑战。通过面试我也发现了不足，尤其是对项目的理解，有些面试官的问题是很有深度的，这也是一个思想交流的机会。\n\n## 下半年计划\n\n- 跟入一项新的开源项目，要有提交贡献！！（学习项目架构和设计）\n- 熟悉vue，做到全栈。从小程序的角度去学习vue，应该会很快。这人很单独开一个repo放在github上面。\n- 学习项目管理！PMP安排上！\n- 学习金融知识，完成一些书的阅读与笔记整理，从小白进化成小黑\n- 算法和数据结构，进阶，多语言的练习，上面提到了vue，所以后续可以用js去刷 。有时间的情况下可以战CodeForces\n- 408：基础知识都熟悉了，该刷题巩固了\n- 数学：慢慢来，白板不只可以拿来写算法\n- 逃避虽可耻但有用：看了一集，哈哈哈 安排上。\n- Java紧跟潮流，新版本，新特性，以及JVM。\n","slug":"2021-mid","published":1,"updated":"2021-06-06T15:07:03.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj6a0003ts9q6d53ai5v","content":"<p>2021过了一半，结合2020年末的总结，对2021年中做了总结，这是一年的承上启下。</p>\n<span id=\"more\"></span>\n\n<p>上半年，做了件“大”事——换了工作，与金融相关，做的不是那么的纯计算机的工作了，除了金融，还涉及了项目管理的工作，总的来说是拔高的。一直觉得计算机行业需要交叉，需要交叉学科的人才，我也算是中途出道的，金融小白一枚。</p>\n<h2 id=\"上半年总结\"><a href=\"#上半年总结\" class=\"headerlink\" title=\"上半年总结\"></a>上半年总结</h2><ul>\n<li>算法和数据结构：计划完成，在LeetCode平台上进行了每日的打卡和算法竞赛，比赛中从一开始的完成签到题都困难，到目前至少能完成2道题，偶尔三道，国内排名有时候也能突破前1000.</li>\n<li>《算法导论》：在能手撕基础算法的情况下，完成了该书的阅读，尤其是动态规划那一板块很有帮助。应该作为handbook，时常翻阅。</li>\n<li>408：正好面试会涉及，就一并带过了，不过应该不深，算50%吧。</li>\n<li>框架：研究了Spring、Mybatis和SpringMVC框架源码，达到了前所未有的深度，对他的设计有了更深入的思考。</li>\n<li>分布式、中间件：从操作系统以及分布式理论的角度学习了中间件相关的东西</li>\n<li>项目设计：这是面向面试去做的学习和准备，毕竟“开发练习时长一年多”的我还没有实战的设计经验，例如“分布式的唯一id”这样，但可以提前了解。</li>\n</ul>\n<p>上半年就这样，去年年末定下来的任务完成了一部分，剩下的还是比较艰巨的，因为有了新的工作，会带来新的挑战。通过面试我也发现了不足，尤其是对项目的理解，有些面试官的问题是很有深度的，这也是一个思想交流的机会。</p>\n<h2 id=\"下半年计划\"><a href=\"#下半年计划\" class=\"headerlink\" title=\"下半年计划\"></a>下半年计划</h2><ul>\n<li>跟入一项新的开源项目，要有提交贡献！！（学习项目架构和设计）</li>\n<li>熟悉vue，做到全栈。从小程序的角度去学习vue，应该会很快。这人很单独开一个repo放在github上面。</li>\n<li>学习项目管理！PMP安排上！</li>\n<li>学习金融知识，完成一些书的阅读与笔记整理，从小白进化成小黑</li>\n<li>算法和数据结构，进阶，多语言的练习，上面提到了vue，所以后续可以用js去刷 。有时间的情况下可以战CodeForces</li>\n<li>408：基础知识都熟悉了，该刷题巩固了</li>\n<li>数学：慢慢来，白板不只可以拿来写算法</li>\n<li>逃避虽可耻但有用：看了一集，哈哈哈 安排上。</li>\n<li>Java紧跟潮流，新版本，新特性，以及JVM。</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>2021过了一半，结合2020年末的总结，对2021年中做了总结，这是一年的承上启下。</p>","more":"<p>上半年，做了件“大”事——换了工作，与金融相关，做的不是那么的纯计算机的工作了，除了金融，还涉及了项目管理的工作，总的来说是拔高的。一直觉得计算机行业需要交叉，需要交叉学科的人才，我也算是中途出道的，金融小白一枚。</p>\n<h2 id=\"上半年总结\"><a href=\"#上半年总结\" class=\"headerlink\" title=\"上半年总结\"></a>上半年总结</h2><ul>\n<li>算法和数据结构：计划完成，在LeetCode平台上进行了每日的打卡和算法竞赛，比赛中从一开始的完成签到题都困难，到目前至少能完成2道题，偶尔三道，国内排名有时候也能突破前1000.</li>\n<li>《算法导论》：在能手撕基础算法的情况下，完成了该书的阅读，尤其是动态规划那一板块很有帮助。应该作为handbook，时常翻阅。</li>\n<li>408：正好面试会涉及，就一并带过了，不过应该不深，算50%吧。</li>\n<li>框架：研究了Spring、Mybatis和SpringMVC框架源码，达到了前所未有的深度，对他的设计有了更深入的思考。</li>\n<li>分布式、中间件：从操作系统以及分布式理论的角度学习了中间件相关的东西</li>\n<li>项目设计：这是面向面试去做的学习和准备，毕竟“开发练习时长一年多”的我还没有实战的设计经验，例如“分布式的唯一id”这样，但可以提前了解。</li>\n</ul>\n<p>上半年就这样，去年年末定下来的任务完成了一部分，剩下的还是比较艰巨的，因为有了新的工作，会带来新的挑战。通过面试我也发现了不足，尤其是对项目的理解，有些面试官的问题是很有深度的，这也是一个思想交流的机会。</p>\n<h2 id=\"下半年计划\"><a href=\"#下半年计划\" class=\"headerlink\" title=\"下半年计划\"></a>下半年计划</h2><ul>\n<li>跟入一项新的开源项目，要有提交贡献！！（学习项目架构和设计）</li>\n<li>熟悉vue，做到全栈。从小程序的角度去学习vue，应该会很快。这人很单独开一个repo放在github上面。</li>\n<li>学习项目管理！PMP安排上！</li>\n<li>学习金融知识，完成一些书的阅读与笔记整理，从小白进化成小黑</li>\n<li>算法和数据结构，进阶，多语言的练习，上面提到了vue，所以后续可以用js去刷 。有时间的情况下可以战CodeForces</li>\n<li>408：基础知识都熟悉了，该刷题巩固了</li>\n<li>数学：慢慢来，白板不只可以拿来写算法</li>\n<li>逃避虽可耻但有用：看了一集，哈哈哈 安排上。</li>\n<li>Java紧跟潮流，新版本，新特性，以及JVM。</li>\n</ul>"},{"title":"Spring Security AutoConfiguration","date":"2021-03-22T14:18:10.000Z","_content":"\n​\t\t最近有设计权限模块，用到了*Spring Security*，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 入口\n\n​\t\t在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration*的天下，开启一个模块的功能同样需要它。开头提到的那个注解*@EnableWebSecurity*就是探究的入口：\n\n```java\n@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)\n@Target(value = { java.lang.annotation.ElementType.TYPE })\n@Documented\n@Import({ WebSecurityConfiguration.class,\n\t\tSpringWebMvcImportSelector.class,\n\t\tOAuth2ImportSelector.class })\n@EnableGlobalAuthentication\n@Configuration\npublic @interface EnableWebSecurity {\n\n\t/**\n\t * Controls debugging support for Spring Security. Default is false.\n\t * @return if true, enables debug support with Spring Security\n\t */\n\tboolean debug() default false;\n}\n```\n\n我们看到通过*@Import(...)*导入了三个class，后两个都是以*Selector*结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地*@Import(...)*，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个*WebSecurityConfiguration*配置类。\n\n在进入第一个配置类之前有必要看一下这个注解的注释信息：\n\n>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods\n\n告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：\n\n```java\n@EnableWebSecurity\n@Configuration\npublic class MyWebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    public void confugre(HttpSecurity httpSecurity){\n        // ....\n    }\n}\n```\n\n下面我们进入配置类。\n\n# 配置类\n\nSpring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：\n\n> Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.\n\n我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：\n\n## setFilterChainProxySecurityConfigurer\n\n```java\n@Autowired(required = false)\npublic void setFilterChainProxySecurityConfigurer(\n    // 入参一\n    ObjectPostProcessor<Object> objectPostProcessor,\n    // 入参二\n    @Value(\"#{@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()}\") List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers)\n    throws Exception {\n    webSecurity = objectPostProcessor\n        .postProcess(new WebSecurity(objectPostProcessor));\n    if (debugEnabled != null) {\n        webSecurity.debug(debugEnabled);\n    }\n    \n    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);\n\n    Integer previousOrder = null;\n    Object previousConfig = null;\n    for (SecurityConfigurer<Filter, WebSecurity> config : webSecurityConfigurers) {\n        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);\n        if (previousOrder != null && previousOrder.equals(order)) {\n            throw new IllegalStateException(\n                \"@Order on WebSecurityConfigurers must be unique. Order of \"\n                + order + \" was already used on \" + previousConfig + \", so it cannot be used on \"\n                + config + \" too.\");\n        }\n        previousOrder = order;\n        previousConfig = config;\n    }\n    for (SecurityConfigurer<Filter, WebSecurity> webSecurityConfigurer : webSecurityConfigurers) {\n        // 遍历webSecurityConfigures，执行webSecurity的apply\n        webSecurity.apply(webSecurityConfigurer);\n    }\n    // 将confugures赋给势力变量\n    this.webSecurityConfigurers = webSecurityConfigurers;\n}\n```\n\n\n\n### getWebSecurityConfigurers\n\n入参二是有些奇怪的，实际上是执行了类`AutowiredWebSecurityConfigurersIgnoreParents`中的静态方法*getWebSecurityConfigurers*，目的是从上下文中获取到configures：\n\n```java\npublic List<SecurityConfigurer<Filter, WebSecurity>> getWebSecurityConfigurers() {\n   List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers = new ArrayList<>();\n   Map<String, WebSecurityConfigurer> beansOfType = beanFactory\n         .getBeansOfType(WebSecurityConfigurer.class);\n   for (Entry<String, WebSecurityConfigurer> entry : beansOfType.entrySet()) {\n      webSecurityConfigurers.add(entry.getValue());\n   }\n   return webSecurityConfigurers;\n}\n```\n\n\n\n### apply\n\n这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。\n\n```java\nprivate <C extends SecurityConfigurer<O, B>> void add(C configurer) {\n    // ...\n    synchronized (configurers) {\n        // ...\n        List<SecurityConfigurer<O, B>> configs = allowConfigurersOfSameType ? this.configurers\n            .get(clazz) : null;\n        if (configs == null) {\n            configs = new ArrayList<>(1);\n        }\n        configs.add(configurer);\n        // private final LinkedHashMap<Class<? extends SecurityConfigurer<O, B>>, List<SecurityConfigurer<O, B>>> configurers = new LinkedHashMap<>();\n        this.configurers.put(clazz, configs);\n        // ...\n    }\n}\n```\n\n要知道，我们在*入口*处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个*WebSecurityConfigurer*，他实现了接口：\n\n```java\npublic abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer<WebSecurity> {\n    // ...\n}\n```\n\n所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法*getWebSecurityConfigurers*从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。\n\n\n\n## springSecurityFilterChain\n\n准备工作之后是过滤器链。\n\n```java\n// \tpublic static final String DEFAULT_FILTER_NAME = \"springSecurityFilterChain\";\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)\npublic Filter springSecurityFilterChain() throws Exception {\n    // 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true\n    boolean hasConfigurers = webSecurityConfigurers != null\n        && !webSecurityConfigurers.isEmpty();\n    if (!hasConfigurers) {\n        // 为空的话新建一个\n        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor\n            .postProcess(new WebSecurityConfigurerAdapter() {\n            });\n        // 再次执行apply\n        webSecurity.apply(adapter);\n    }\n    // 不为空的话 会直接执行这里的build方法\n    return webSecurity.build();\n}\n```\n\n到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。\n\n```java\nprivate AtomicBoolean building = new AtomicBoolean();\n\npublic final O build() throws Exception {\n    // 这里对build方法用了自旋CAS防止重复构建\n    if (this.building.compareAndSet(false, true)) {\n        this.object = doBuild();\n        return this.object;\n    }\n    throw new AlreadyBuiltException(\"This object has already been built\");\n}\n```\n\n在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。\n\n### init\n\n初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：\n\n```java\npublic void init(final WebSecurity web) throws Exception {\n    // 获取httpSecurity\n    final HttpSecurity http = getHttp();\n    // web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值\n    web.addSecurityFilterChainBuilder(http).postBuildAction(() -> {\n        FilterSecurityInterceptor securityInterceptor = http\n            .getSharedObject(FilterSecurityInterceptor.class);\n        web.securityInterceptor(securityInterceptor);\n    });\n}\n```\n\n#### getHttp\n\n```java\nprotected final HttpSecurity getHttp() throws Exception {\n   if (http != null) {\n      return http;\n   }\n\n   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();\n   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);\n\n   AuthenticationManager authenticationManager = authenticationManager();\n   authenticationBuilder.parentAuthenticationManager(authenticationManager);\n   Map<Class<?>, Object> sharedObjects = createSharedObjects();\n\n    // 生成对象\n   http = new HttpSecurity(objectPostProcessor, authenticationBuilder,\n         sharedObjects);\n    // 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置\n   if (!disableDefaults) {\n      // @formatter:off\n      http\n         .csrf().and()\n         .addFilter(new WebAsyncManagerIntegrationFilter())\n         .exceptionHandling().and()\n         .headers().and()\n         .sessionManagement().and()\n         .securityContext().and()\n         .requestCache().and()\n         .anonymous().and()\n         .servletApi().and()\n         .apply(new DefaultLoginPageConfigurer<>()).and()\n         .logout();\n      // @formatter:on\n      ClassLoader classLoader = this.context.getClassLoader();\n      List<AbstractHttpConfigurer> defaultHttpConfigurers =\n            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);\n\n      for (AbstractHttpConfigurer configurer : defaultHttpConfigurers) {\n         http.apply(configurer);\n      }\n   }\n    // 配置httpSecurity\n   configure(http);\n   return http;\n}\n```\n\n上面的方法中在返回httpSecurity对象之前会执行*configure*方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity*？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写*configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。\n\n\n\n# 小结\n\n以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。","source":"_posts/Spring-Security-AutoConfiguration.md","raw":"---\ntitle: Spring Security AutoConfiguration\ndate: 2021-03-22 22:18:10\ncategories: framework\ntags: spring security\n---\n\n​\t\t最近有设计权限模块，用到了*Spring Security*，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 入口\n\n​\t\t在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration*的天下，开启一个模块的功能同样需要它。开头提到的那个注解*@EnableWebSecurity*就是探究的入口：\n\n```java\n@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)\n@Target(value = { java.lang.annotation.ElementType.TYPE })\n@Documented\n@Import({ WebSecurityConfiguration.class,\n\t\tSpringWebMvcImportSelector.class,\n\t\tOAuth2ImportSelector.class })\n@EnableGlobalAuthentication\n@Configuration\npublic @interface EnableWebSecurity {\n\n\t/**\n\t * Controls debugging support for Spring Security. Default is false.\n\t * @return if true, enables debug support with Spring Security\n\t */\n\tboolean debug() default false;\n}\n```\n\n我们看到通过*@Import(...)*导入了三个class，后两个都是以*Selector*结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地*@Import(...)*，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个*WebSecurityConfiguration*配置类。\n\n在进入第一个配置类之前有必要看一下这个注解的注释信息：\n\n>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods\n\n告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：\n\n```java\n@EnableWebSecurity\n@Configuration\npublic class MyWebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    \n    @Override\n    public void confugre(HttpSecurity httpSecurity){\n        // ....\n    }\n}\n```\n\n下面我们进入配置类。\n\n# 配置类\n\nSpring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：\n\n> Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.\n\n我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：\n\n## setFilterChainProxySecurityConfigurer\n\n```java\n@Autowired(required = false)\npublic void setFilterChainProxySecurityConfigurer(\n    // 入参一\n    ObjectPostProcessor<Object> objectPostProcessor,\n    // 入参二\n    @Value(\"#{@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()}\") List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers)\n    throws Exception {\n    webSecurity = objectPostProcessor\n        .postProcess(new WebSecurity(objectPostProcessor));\n    if (debugEnabled != null) {\n        webSecurity.debug(debugEnabled);\n    }\n    \n    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);\n\n    Integer previousOrder = null;\n    Object previousConfig = null;\n    for (SecurityConfigurer<Filter, WebSecurity> config : webSecurityConfigurers) {\n        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);\n        if (previousOrder != null && previousOrder.equals(order)) {\n            throw new IllegalStateException(\n                \"@Order on WebSecurityConfigurers must be unique. Order of \"\n                + order + \" was already used on \" + previousConfig + \", so it cannot be used on \"\n                + config + \" too.\");\n        }\n        previousOrder = order;\n        previousConfig = config;\n    }\n    for (SecurityConfigurer<Filter, WebSecurity> webSecurityConfigurer : webSecurityConfigurers) {\n        // 遍历webSecurityConfigures，执行webSecurity的apply\n        webSecurity.apply(webSecurityConfigurer);\n    }\n    // 将confugures赋给势力变量\n    this.webSecurityConfigurers = webSecurityConfigurers;\n}\n```\n\n\n\n### getWebSecurityConfigurers\n\n入参二是有些奇怪的，实际上是执行了类`AutowiredWebSecurityConfigurersIgnoreParents`中的静态方法*getWebSecurityConfigurers*，目的是从上下文中获取到configures：\n\n```java\npublic List<SecurityConfigurer<Filter, WebSecurity>> getWebSecurityConfigurers() {\n   List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers = new ArrayList<>();\n   Map<String, WebSecurityConfigurer> beansOfType = beanFactory\n         .getBeansOfType(WebSecurityConfigurer.class);\n   for (Entry<String, WebSecurityConfigurer> entry : beansOfType.entrySet()) {\n      webSecurityConfigurers.add(entry.getValue());\n   }\n   return webSecurityConfigurers;\n}\n```\n\n\n\n### apply\n\n这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。\n\n```java\nprivate <C extends SecurityConfigurer<O, B>> void add(C configurer) {\n    // ...\n    synchronized (configurers) {\n        // ...\n        List<SecurityConfigurer<O, B>> configs = allowConfigurersOfSameType ? this.configurers\n            .get(clazz) : null;\n        if (configs == null) {\n            configs = new ArrayList<>(1);\n        }\n        configs.add(configurer);\n        // private final LinkedHashMap<Class<? extends SecurityConfigurer<O, B>>, List<SecurityConfigurer<O, B>>> configurers = new LinkedHashMap<>();\n        this.configurers.put(clazz, configs);\n        // ...\n    }\n}\n```\n\n要知道，我们在*入口*处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个*WebSecurityConfigurer*，他实现了接口：\n\n```java\npublic abstract class WebSecurityConfigurerAdapter implements WebSecurityConfigurer<WebSecurity> {\n    // ...\n}\n```\n\n所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法*getWebSecurityConfigurers*从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。\n\n\n\n## springSecurityFilterChain\n\n准备工作之后是过滤器链。\n\n```java\n// \tpublic static final String DEFAULT_FILTER_NAME = \"springSecurityFilterChain\";\n@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)\npublic Filter springSecurityFilterChain() throws Exception {\n    // 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true\n    boolean hasConfigurers = webSecurityConfigurers != null\n        && !webSecurityConfigurers.isEmpty();\n    if (!hasConfigurers) {\n        // 为空的话新建一个\n        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor\n            .postProcess(new WebSecurityConfigurerAdapter() {\n            });\n        // 再次执行apply\n        webSecurity.apply(adapter);\n    }\n    // 不为空的话 会直接执行这里的build方法\n    return webSecurity.build();\n}\n```\n\n到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。\n\n```java\nprivate AtomicBoolean building = new AtomicBoolean();\n\npublic final O build() throws Exception {\n    // 这里对build方法用了自旋CAS防止重复构建\n    if (this.building.compareAndSet(false, true)) {\n        this.object = doBuild();\n        return this.object;\n    }\n    throw new AlreadyBuiltException(\"This object has already been built\");\n}\n```\n\n在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。\n\n### init\n\n初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：\n\n```java\npublic void init(final WebSecurity web) throws Exception {\n    // 获取httpSecurity\n    final HttpSecurity http = getHttp();\n    // web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值\n    web.addSecurityFilterChainBuilder(http).postBuildAction(() -> {\n        FilterSecurityInterceptor securityInterceptor = http\n            .getSharedObject(FilterSecurityInterceptor.class);\n        web.securityInterceptor(securityInterceptor);\n    });\n}\n```\n\n#### getHttp\n\n```java\nprotected final HttpSecurity getHttp() throws Exception {\n   if (http != null) {\n      return http;\n   }\n\n   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();\n   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);\n\n   AuthenticationManager authenticationManager = authenticationManager();\n   authenticationBuilder.parentAuthenticationManager(authenticationManager);\n   Map<Class<?>, Object> sharedObjects = createSharedObjects();\n\n    // 生成对象\n   http = new HttpSecurity(objectPostProcessor, authenticationBuilder,\n         sharedObjects);\n    // 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置\n   if (!disableDefaults) {\n      // @formatter:off\n      http\n         .csrf().and()\n         .addFilter(new WebAsyncManagerIntegrationFilter())\n         .exceptionHandling().and()\n         .headers().and()\n         .sessionManagement().and()\n         .securityContext().and()\n         .requestCache().and()\n         .anonymous().and()\n         .servletApi().and()\n         .apply(new DefaultLoginPageConfigurer<>()).and()\n         .logout();\n      // @formatter:on\n      ClassLoader classLoader = this.context.getClassLoader();\n      List<AbstractHttpConfigurer> defaultHttpConfigurers =\n            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);\n\n      for (AbstractHttpConfigurer configurer : defaultHttpConfigurers) {\n         http.apply(configurer);\n      }\n   }\n    // 配置httpSecurity\n   configure(http);\n   return http;\n}\n```\n\n上面的方法中在返回httpSecurity对象之前会执行*configure*方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity*？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写*configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。\n\n\n\n# 小结\n\n以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。","slug":"Spring-Security-AutoConfiguration","published":1,"updated":"2021-04-05T05:44:14.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj6k0007ts9qgtkoa4mh","content":"<p>​        最近有设计权限模块，用到了<em>Spring Security</em>，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>​        在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration<em>的天下，开启一个模块的功能同样需要它。开头提到的那个注解</em>@EnableWebSecurity*就是探究的入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; WebSecurityConfiguration.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tSpringWebMvcImportSelector.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tOAuth2ImportSelector.class &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableGlobalAuthentication</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableWebSecurity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Controls debugging support for Spring Security. Default is false.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> if true, enables debug support with Spring Security</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">debug</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到通过*@Import(…)<em>导入了三个class，后两个都是以</em>Selector<em>结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地</em>@Import(…)<em>，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个</em>WebSecurityConfiguration*配置类。</p>\n<p>在进入第一个配置类之前有必要看一下这个注解的注释信息：</p>\n<blockquote>\n<p>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods</p>\n</blockquote>\n<p>告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebSecurityConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confugre</span><span class=\"params\">(HttpSecurity httpSecurity)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们进入配置类。</p>\n<h1 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h1><p>Spring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：</p>\n<blockquote>\n<p>Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.</p>\n</blockquote>\n<p>我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：</p>\n<h2 id=\"setFilterChainProxySecurityConfigurer\"><a href=\"#setFilterChainProxySecurityConfigurer\" class=\"headerlink\" title=\"setFilterChainProxySecurityConfigurer\"></a>setFilterChainProxySecurityConfigurer</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired(required = false)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFilterChainProxySecurityConfigurer</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参一</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参二</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"meta\">@Value(&quot;#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;&quot;)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    webSecurity = objectPostProcessor</span><br><span class=\"line\">        .postProcess(<span class=\"keyword\">new</span> WebSecurity(objectPostProcessor));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (debugEnabled != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        webSecurity.debug(debugEnabled);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer previousOrder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Object previousConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previousOrder != <span class=\"keyword\">null</span> &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;@Order on WebSecurityConfigurers must be unique. Order of &quot;</span></span><br><span class=\"line\">                + order + <span class=\"string\">&quot; was already used on &quot;</span> + previousConfig + <span class=\"string\">&quot;, so it cannot be used on &quot;</span></span><br><span class=\"line\">                + config + <span class=\"string\">&quot; too.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previousOrder = order;</span><br><span class=\"line\">        previousConfig = config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历webSecurityConfigures，执行webSecurity的apply</span></span><br><span class=\"line\">        webSecurity.apply(webSecurityConfigurer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将confugures赋给势力变量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webSecurityConfigurers = webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"getWebSecurityConfigurers\"><a href=\"#getWebSecurityConfigurers\" class=\"headerlink\" title=\"getWebSecurityConfigurers\"></a>getWebSecurityConfigurers</h3><p>入参二是有些奇怪的，实际上是执行了类<code>AutowiredWebSecurityConfigurersIgnoreParents</code>中的静态方法<em>getWebSecurityConfigurers</em>，目的是从上下文中获取到configures：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; getWebSecurityConfigurers() &#123;</span><br><span class=\"line\">   List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">   Map&lt;String, WebSecurityConfigurer&gt; beansOfType = beanFactory</span><br><span class=\"line\">         .getBeansOfType(WebSecurityConfigurer.class);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, WebSecurityConfigurer&gt; entry : beansOfType.entrySet()) &#123;</span><br><span class=\"line\">      webSecurityConfigurers.add(entry.getValue());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;C extends SecurityConfigurer&lt;O, B&gt;&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(C configurer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (configurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = allowConfigurersOfSameType ? <span class=\"keyword\">this</span>.configurers</span><br><span class=\"line\">            .get(clazz) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            configs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        configs.add(configurer);</span><br><span class=\"line\">        <span class=\"comment\">// private final LinkedHashMap&lt;Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt;, List&lt;SecurityConfigurer&lt;O, B&gt;&gt;&gt; configurers = new LinkedHashMap&lt;&gt;();</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configurers.put(clazz, configs);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要知道，我们在<em>入口</em>处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个<em>WebSecurityConfigurer</em>，他实现了接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebSecurityConfigurer</span>&lt;<span class=\"title\">WebSecurity</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法<em>getWebSecurityConfigurers</em>从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。</p>\n<h2 id=\"springSecurityFilterChain\"><a href=\"#springSecurityFilterChain\" class=\"headerlink\" title=\"springSecurityFilterChain\"></a>springSecurityFilterChain</h2><p>准备工作之后是过滤器链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \tpublic static final String DEFAULT_FILTER_NAME = &quot;springSecurityFilterChain&quot;;</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Filter <span class=\"title\">springSecurityFilterChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> hasConfigurers = webSecurityConfigurers != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为空的话新建一个</span></span><br><span class=\"line\">        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor</span><br><span class=\"line\">            .postProcess(<span class=\"keyword\">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 再次执行apply</span></span><br><span class=\"line\">        webSecurity.apply(adapter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为空的话 会直接执行这里的build方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> webSecurity.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> AtomicBoolean building = <span class=\"keyword\">new</span> AtomicBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> O <span class=\"title\">build</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里对build方法用了自旋CAS防止重复构建</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.building.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = doBuild();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AlreadyBuiltException(<span class=\"string\">&quot;This object has already been built&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。</p>\n<h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><p>初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取httpSecurity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> HttpSecurity http = getHttp();</span><br><span class=\"line\">    <span class=\"comment\">// web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值</span></span><br><span class=\"line\">    web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123;</span><br><span class=\"line\">        FilterSecurityInterceptor securityInterceptor = http</span><br><span class=\"line\">            .getSharedObject(FilterSecurityInterceptor.class);</span><br><span class=\"line\">        web.securityInterceptor(securityInterceptor);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"getHttp\"><a href=\"#getHttp\" class=\"headerlink\" title=\"getHttp\"></a>getHttp</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> HttpSecurity <span class=\"title\">getHttp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (http != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();</span><br><span class=\"line\">   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationManager authenticationManager = authenticationManager();</span><br><span class=\"line\">   authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class=\"line\">   Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成对象</span></span><br><span class=\"line\">   http = <span class=\"keyword\">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class=\"line\">         sharedObjects);</span><br><span class=\"line\">    <span class=\"comment\">// 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!disableDefaults) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:off</span></span><br><span class=\"line\">      http</span><br><span class=\"line\">         .csrf().and()</span><br><span class=\"line\">         .addFilter(<span class=\"keyword\">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class=\"line\">         .exceptionHandling().and()</span><br><span class=\"line\">         .headers().and()</span><br><span class=\"line\">         .sessionManagement().and()</span><br><span class=\"line\">         .securityContext().and()</span><br><span class=\"line\">         .requestCache().and()</span><br><span class=\"line\">         .anonymous().and()</span><br><span class=\"line\">         .servletApi().and()</span><br><span class=\"line\">         .apply(<span class=\"keyword\">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class=\"line\">         .logout();</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:on</span></span><br><span class=\"line\">      ClassLoader classLoader = <span class=\"keyword\">this</span>.context.getClassLoader();</span><br><span class=\"line\">      List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class=\"line\">            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class=\"line\">         http.apply(configurer);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 配置httpSecurity</span></span><br><span class=\"line\">   configure(http);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法中在返回httpSecurity对象之前会执行<em>configure</em>方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity<em>？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写</em>configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>​        最近有设计权限模块，用到了<em>Spring Security</em>，在SpringBoot项目中导入了相关的jar包后几乎不用做任何配置（当然，除了启用的*@EnableWebSecurity*）就会拦截请求，达到了“安全“的目的，配置的方式也是多种多样，我们先从”方便使用“这个角度，看看他如何做到的”拆箱即用“。</p>","more":"<!-- toc -->\n\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>​        在SpringBoot中使用注解来解放xml配置文件后，一直都是*@Configuration<em>的天下，开启一个模块的功能同样需要它。开头提到的那个注解</em>@EnableWebSecurity*就是探究的入口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; WebSecurityConfiguration.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tSpringWebMvcImportSelector.class,</span></span><br><span class=\"line\"><span class=\"meta\">\t\tOAuth2ImportSelector.class &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableGlobalAuthentication</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableWebSecurity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Controls debugging support for Spring Security. Default is false.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> if true, enables debug support with Spring Security</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">debug</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到通过*@Import(…)<em>导入了三个class，后两个都是以</em>Selector<em>结尾，在命名规范的Spring源码中大概是可以猜出内容的：根据某个条件选择性地加载类，也就是动态地</em>@Import(…)<em>，这里我们不去关注Selector，从”方便使用“的角度，我们是来探究开箱即用的，所以着重看下第一个</em>WebSecurityConfiguration*配置类。</p>\n<p>在进入第一个配置类之前有必要看一下这个注解的注释信息：</p>\n<blockquote>\n<p>Add this annotation to an @Configuration class to have the Spring Security configuration defined in any WebSecurityConfigurer or more likely by extending the WebSecurityConfigurerAdapter base class and overriding individual methods</p>\n</blockquote>\n<p>告诉了我们如何使用以及自定义安全规则，那么使用起来应该是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebSecurityConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confugre</span><span class=\"params\">(HttpSecurity httpSecurity)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们进入配置类。</p>\n<h1 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h1><p>Spring Security从来不是单独存在的，正如他的名字一般，前面是有Spring的，Spring的核心就是IoC，所以，配置也是一样，一定会从把各个bean交代给容器。我们来看看他都做了啥。一进入类中，注释就讲得明明白白：</p>\n<blockquote>\n<p>Uses a WebSecurity to create the FilterChainProxy that performs the web based security for Spring Security. It then exports the necessary beans. Customizations can be made to WebSecurity by extending WebSecurityConfigurerAdapter and exposing it as a Configuration or implementing WebSecurityConfigurer and exposing it as a Configuration. This configuration is imported when using EnableWebSecurity.</p>\n</blockquote>\n<p>我们都知道web请求是典型的责任链，或者说是过滤器链，在这个配置类中就注册了过滤器的持有类和相关配置，先看看他的准备工作：</p>\n<h2 id=\"setFilterChainProxySecurityConfigurer\"><a href=\"#setFilterChainProxySecurityConfigurer\" class=\"headerlink\" title=\"setFilterChainProxySecurityConfigurer\"></a>setFilterChainProxySecurityConfigurer</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired(required = false)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFilterChainProxySecurityConfigurer</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参一</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    // 入参二</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"meta\">@Value(&quot;#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;&quot;)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    webSecurity = objectPostProcessor</span><br><span class=\"line\">        .postProcess(<span class=\"keyword\">new</span> WebSecurity(objectPostProcessor));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (debugEnabled != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        webSecurity.debug(debugEnabled);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class=\"line\"></span><br><span class=\"line\">    Integer previousOrder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Object previousConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        Integer order = AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previousOrder != <span class=\"keyword\">null</span> &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;@Order on WebSecurityConfigurers must be unique. Order of &quot;</span></span><br><span class=\"line\">                + order + <span class=\"string\">&quot; was already used on &quot;</span> + previousConfig + <span class=\"string\">&quot;, so it cannot be used on &quot;</span></span><br><span class=\"line\">                + config + <span class=\"string\">&quot; too.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previousOrder = order;</span><br><span class=\"line\">        previousConfig = config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历webSecurityConfigures，执行webSecurity的apply</span></span><br><span class=\"line\">        webSecurity.apply(webSecurityConfigurer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将confugures赋给势力变量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webSecurityConfigurers = webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"getWebSecurityConfigurers\"><a href=\"#getWebSecurityConfigurers\" class=\"headerlink\" title=\"getWebSecurityConfigurers\"></a>getWebSecurityConfigurers</h3><p>入参二是有些奇怪的，实际上是执行了类<code>AutowiredWebSecurityConfigurersIgnoreParents</code>中的静态方法<em>getWebSecurityConfigurers</em>，目的是从上下文中获取到configures：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; getWebSecurityConfigurers() &#123;</span><br><span class=\"line\">   List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">   Map&lt;String, WebSecurityConfigurer&gt; beansOfType = beanFactory</span><br><span class=\"line\">         .getBeansOfType(WebSecurityConfigurer.class);</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, WebSecurityConfigurer&gt; entry : beansOfType.entrySet()) &#123;</span><br><span class=\"line\">      webSecurityConfigurers.add(entry.getValue());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> webSecurityConfigurers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>这里的apply是配置类中的属性webSecurity执行的，方法内实际的操作是”添加“，即把configures添加到容器中做保存，相当与是为webSecurity的属性赋值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;C extends SecurityConfigurer&lt;O, B&gt;&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(C configurer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (configurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = allowConfigurersOfSameType ? <span class=\"keyword\">this</span>.configurers</span><br><span class=\"line\">            .get(clazz) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            configs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        configs.add(configurer);</span><br><span class=\"line\">        <span class=\"comment\">// private final LinkedHashMap&lt;Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt;, List&lt;SecurityConfigurer&lt;O, B&gt;&gt;&gt; configurers = new LinkedHashMap&lt;&gt;();</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configurers.put(clazz, configs);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要知道，我们在<em>入口</em>处提到的用法，是在一个继承了抽象类的类上使用注解，并可以自定义安全规则，那个抽象类就是一个<em>WebSecurityConfigurer</em>，他实现了接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebSecurityConfigurer</span>&lt;<span class=\"title\">WebSecurity</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以可以总结一下这个方法：在这个配置类的这一方法中，我们实现的configurer会被方法<em>getWebSecurityConfigurers</em>从上下文中取出，经过排序等操作后填充至webSecurity的属性中保存。</p>\n<h2 id=\"springSecurityFilterChain\"><a href=\"#springSecurityFilterChain\" class=\"headerlink\" title=\"springSecurityFilterChain\"></a>springSecurityFilterChain</h2><p>准备工作之后是过滤器链。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// \tpublic static final String DEFAULT_FILTER_NAME = &quot;springSecurityFilterChain&quot;;</span></span><br><span class=\"line\"><span class=\"meta\">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Filter <span class=\"title\">springSecurityFilterChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在上个方法中有给属性赋值，我们有继承的话 这里不为空，即true</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> hasConfigurers = webSecurityConfigurers != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasConfigurers) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为空的话新建一个</span></span><br><span class=\"line\">        WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor</span><br><span class=\"line\">            .postProcess(<span class=\"keyword\">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 再次执行apply</span></span><br><span class=\"line\">        webSecurity.apply(adapter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为空的话 会直接执行这里的build方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> webSecurity.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里我们可以大致猜测他后续的步骤，最上面的demo中方法是configure，入参是httpSecurity，所以过滤器链也会与这些对象和方法有关，build也应该是构建过滤器链的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> AtomicBoolean building = <span class=\"keyword\">new</span> AtomicBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> O <span class=\"title\">build</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里对build方法用了自旋CAS防止重复构建</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.building.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.object = doBuild();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AlreadyBuiltException(<span class=\"string\">&quot;This object has already been built&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在*doBuild()*方法里用到了模板方法模式，同SpringBoot启动时做的refresh一样，给开发者留了余地，在构建前后都能实现一些方法，我们这里着重看看他内部实现了的。</p>\n<h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><p>初始化，方法中会遍历configurer，其中包括我们自己实现的（假设我们继承了WebSecurityAdapter），那我们来看看init做了啥：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取httpSecurity</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> HttpSecurity http = getHttp();</span><br><span class=\"line\">    <span class=\"comment\">// web是webSecurity的一个实例变量，通过获取的httpSecurity为其属性赋值</span></span><br><span class=\"line\">    web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123;</span><br><span class=\"line\">        FilterSecurityInterceptor securityInterceptor = http</span><br><span class=\"line\">            .getSharedObject(FilterSecurityInterceptor.class);</span><br><span class=\"line\">        web.securityInterceptor(securityInterceptor);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"getHttp\"><a href=\"#getHttp\" class=\"headerlink\" title=\"getHttp\"></a>getHttp</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> HttpSecurity <span class=\"title\">getHttp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (http != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();</span><br><span class=\"line\">   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class=\"line\"></span><br><span class=\"line\">   AuthenticationManager authenticationManager = authenticationManager();</span><br><span class=\"line\">   authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class=\"line\">   Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生成对象</span></span><br><span class=\"line\">   http = <span class=\"keyword\">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class=\"line\">         sharedObjects);</span><br><span class=\"line\">    <span class=\"comment\">// 默认的话 会生产默认的安全策略。就相当与我们什么都没有配置</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!disableDefaults) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:off</span></span><br><span class=\"line\">      http</span><br><span class=\"line\">         .csrf().and()</span><br><span class=\"line\">         .addFilter(<span class=\"keyword\">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class=\"line\">         .exceptionHandling().and()</span><br><span class=\"line\">         .headers().and()</span><br><span class=\"line\">         .sessionManagement().and()</span><br><span class=\"line\">         .securityContext().and()</span><br><span class=\"line\">         .requestCache().and()</span><br><span class=\"line\">         .anonymous().and()</span><br><span class=\"line\">         .servletApi().and()</span><br><span class=\"line\">         .apply(<span class=\"keyword\">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class=\"line\">         .logout();</span><br><span class=\"line\">      <span class=\"comment\">// @formatter:on</span></span><br><span class=\"line\">      ClassLoader classLoader = <span class=\"keyword\">this</span>.context.getClassLoader();</span><br><span class=\"line\">      List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class=\"line\">            SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class=\"line\">         http.apply(configurer);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 配置httpSecurity</span></span><br><span class=\"line\">   configure(http);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> http;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的方法中在返回httpSecurity对象之前会执行<em>configure</em>方法，是否记得demo以及开篇时讲的关于如何使用注解*@EnableSpringSecurity<em>？注释给的方法是在一个实现了抽象类的配置类中用该注解，并且重写</em>configure*方法，于是，在这里就用到了，方法会以httpSecurity作为配置对象并实现安全机制。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上梳理了SpringSecurity为何能做到开箱即用，主要是自定义的配置在何处生效的。然而还有相当多的地方没有讲解到，以后逐一梳理。</p>"},{"title":"SpringBoot environment","date":"2021-02-15T08:19:17.000Z","_content":"\n​\t\tSpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？\n\n<!--more-->\n\n<!--toc-->\n\n前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的\n\n```java\nprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {\n    // 根据应用类型创建对应的环境\n    ConfigurableEnvironment environment = getOrCreateEnvironment();\n    configureEnvironment(environment, applicationArguments.getSourceArgs());\n    ConfigurationPropertySources.attach(environment);\n    listeners.environmentPrepared(environment);\n    bindToSpringApplication(environment);\n    if (!this.isCustomEnvironment) {\n        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());\n    }\n    ConfigurationPropertySources.attach(environment);\n    return environment;\n}\n```\n\n一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。\n\n# 创建环境\n\n首先我们先看创建环境。`getOrCreateEnvironment`会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：*默认*，*Servlet*， *REACTIVE*。这三个环境的都会继承一个接口`ConfigurableEnvironment`，我们看看接口都做了什么\n\n```java\nvoid setActiveProfiles(String... profiles);\n\nvoid addActiveProfile(String profile);\n\nvoid setDefaultProfiles(String... profiles);\n\nMutablePropertySources getPropertySources();\n\nMap<String, Object> getSystemProperties();\n\nMap<String, Object> getSystemEnvironment();\n\nvoid merge(ConfigurableEnvironment parent);\n```\n\n可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。\n\n# 配置环境\n\n配置环境的方法是模板方法，详细分为了`property`和`profile`。前者是添加默认配置和命令行配置，后者是选择激活的profile。\n\n接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理\n\n```java\nprivate static final String ATTACHED_PROPERTY_SOURCE_NAME = \"configurationProperties\";\n```\n\n除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个*CopyOnWriteArrayList*实现的线性表，仅此而已，返型是PropertySource对象。\n\n下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener `ConfigFileApplicationListener`被触发后的执行：\n\n```java\nprivate void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {\n    List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();\n    // 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor\n    postProcessors.add(this);\n    AnnotationAwareOrderComparator.sort(postProcessors);\n    for (EnvironmentPostProcessor postProcessor : postProcessors) {\n        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());\n    }\n}\n```\n\n响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。\n\n```java\nList<EnvironmentPostProcessor> loadPostProcessors() {\n    // 获取环境后置处理器的方式与之前的监听器初始化器相同\n    return SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());\n}\n```\n\n```properties\n# Environment Post Processors\norg.springframework.boot.env.EnvironmentPostProcessor=\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\\norg.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\\norg.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor\n```\n\n由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。\n\n## Load\n\n后置处理也是层层委托\n\n```java\nprotected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {\n    RandomValuePropertySource.addToEnvironment(environment);\n    // 创建loader后调用load方法\n    new Loader(environment, resourceLoader).load();\n}\n```\n\n```java\nprivate static final Set<String> LOAD_FILTERED_PROPERTY;\n\nstatic {\n    Set<String> filteredProperties = new HashSet<>();\n    filteredProperties.add(\"spring.profiles.active\");\n    filteredProperties.add(\"spring.profiles.include\");\n    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);\n}\nvoid load() {\n    // defaultProperties\n    FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,\n                                 (defaultProperties) -> {\n                                     this.profiles = new LinkedList<>();\n                                     this.processedProfiles = new LinkedList<>();\n                                     this.activatedProfiles = false;\n                                     this.loaded = new LinkedHashMap<>();\n                                     initializeProfiles();\n                                     while (!this.profiles.isEmpty()) {\n                                         Profile profile = this.profiles.poll();\n                                         if (isDefaultProfile(profile)) {\n                                             addProfileToEnvironment(profile.getName());\n                                         }\n                                         // 重载load\n                                         load(profile, this::getPositiveProfileFilter,\n                                              addToLoaded(MutablePropertySources::addLast, false));\n                                         this.processedProfiles.add(profile);\n                                     }\n                                     // 重载load\n                                     load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true));\n                                     addLoadedPropertySources();\n                                     applyActiveProfiles(defaultProperties);\n                                 });\n\n```\n\n上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用*propertySourceLoaders*中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：`PropertiesPropertySourceLoader`和`YamlPropertySourceLoader`。\n\n## 自定义\n\n我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了`EnvironmentPostProcessor`的类。可以参考给出的类来写，将配置文件加入列表即可。","source":"_posts/SpringBoot-environment.md","raw":"---\ntitle: SpringBoot environment\ndate: 2021-02-15 16:19:17\ncategories: springboot\ntags: source\n---\n\n​\t\tSpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？\n\n<!--more-->\n\n<!--toc-->\n\n前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的\n\n```java\nprivate ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {\n    // 根据应用类型创建对应的环境\n    ConfigurableEnvironment environment = getOrCreateEnvironment();\n    configureEnvironment(environment, applicationArguments.getSourceArgs());\n    ConfigurationPropertySources.attach(environment);\n    listeners.environmentPrepared(environment);\n    bindToSpringApplication(environment);\n    if (!this.isCustomEnvironment) {\n        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());\n    }\n    ConfigurationPropertySources.attach(environment);\n    return environment;\n}\n```\n\n一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。\n\n# 创建环境\n\n首先我们先看创建环境。`getOrCreateEnvironment`会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：*默认*，*Servlet*， *REACTIVE*。这三个环境的都会继承一个接口`ConfigurableEnvironment`，我们看看接口都做了什么\n\n```java\nvoid setActiveProfiles(String... profiles);\n\nvoid addActiveProfile(String profile);\n\nvoid setDefaultProfiles(String... profiles);\n\nMutablePropertySources getPropertySources();\n\nMap<String, Object> getSystemProperties();\n\nMap<String, Object> getSystemEnvironment();\n\nvoid merge(ConfigurableEnvironment parent);\n```\n\n可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。\n\n# 配置环境\n\n配置环境的方法是模板方法，详细分为了`property`和`profile`。前者是添加默认配置和命令行配置，后者是选择激活的profile。\n\n接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理\n\n```java\nprivate static final String ATTACHED_PROPERTY_SOURCE_NAME = \"configurationProperties\";\n```\n\n除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个*CopyOnWriteArrayList*实现的线性表，仅此而已，返型是PropertySource对象。\n\n下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener `ConfigFileApplicationListener`被触发后的执行：\n\n```java\nprivate void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {\n    List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();\n    // 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor\n    postProcessors.add(this);\n    AnnotationAwareOrderComparator.sort(postProcessors);\n    for (EnvironmentPostProcessor postProcessor : postProcessors) {\n        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());\n    }\n}\n```\n\n响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。\n\n```java\nList<EnvironmentPostProcessor> loadPostProcessors() {\n    // 获取环境后置处理器的方式与之前的监听器初始化器相同\n    return SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());\n}\n```\n\n```properties\n# Environment Post Processors\norg.springframework.boot.env.EnvironmentPostProcessor=\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\\norg.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\\norg.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor\n```\n\n由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。\n\n## Load\n\n后置处理也是层层委托\n\n```java\nprotected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {\n    RandomValuePropertySource.addToEnvironment(environment);\n    // 创建loader后调用load方法\n    new Loader(environment, resourceLoader).load();\n}\n```\n\n```java\nprivate static final Set<String> LOAD_FILTERED_PROPERTY;\n\nstatic {\n    Set<String> filteredProperties = new HashSet<>();\n    filteredProperties.add(\"spring.profiles.active\");\n    filteredProperties.add(\"spring.profiles.include\");\n    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);\n}\nvoid load() {\n    // defaultProperties\n    FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,\n                                 (defaultProperties) -> {\n                                     this.profiles = new LinkedList<>();\n                                     this.processedProfiles = new LinkedList<>();\n                                     this.activatedProfiles = false;\n                                     this.loaded = new LinkedHashMap<>();\n                                     initializeProfiles();\n                                     while (!this.profiles.isEmpty()) {\n                                         Profile profile = this.profiles.poll();\n                                         if (isDefaultProfile(profile)) {\n                                             addProfileToEnvironment(profile.getName());\n                                         }\n                                         // 重载load\n                                         load(profile, this::getPositiveProfileFilter,\n                                              addToLoaded(MutablePropertySources::addLast, false));\n                                         this.processedProfiles.add(profile);\n                                     }\n                                     // 重载load\n                                     load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true));\n                                     addLoadedPropertySources();\n                                     applyActiveProfiles(defaultProperties);\n                                 });\n\n```\n\n上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用*propertySourceLoaders*中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：`PropertiesPropertySourceLoader`和`YamlPropertySourceLoader`。\n\n## 自定义\n\n我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了`EnvironmentPostProcessor`的类。可以参考给出的类来写，将配置文件加入列表即可。","slug":"SpringBoot-environment","published":1,"updated":"2021-03-28T10:20:02.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj6o0009ts9qex9egao6","content":"<p>​        SpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？</p>\n<span id=\"more\"></span>\n\n<!--toc-->\n\n<p>前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">prepareEnvironment</span><span class=\"params\">(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据应用类型创建对应的环境</span></span><br><span class=\"line\">    ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class=\"line\">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    listeners.environmentPrepared(environment);</span><br><span class=\"line\">    bindToSpringApplication(environment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isCustomEnvironment) &#123;</span><br><span class=\"line\">        environment = <span class=\"keyword\">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> environment;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。</p>\n<h1 id=\"创建环境\"><a href=\"#创建环境\" class=\"headerlink\" title=\"创建环境\"></a>创建环境</h1><p>首先我们先看创建环境。<code>getOrCreateEnvironment</code>会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：<em>默认</em>，<em>Servlet</em>， <em>REACTIVE</em>。这三个环境的都会继承一个接口<code>ConfigurableEnvironment</code>，我们看看接口都做了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setActiveProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addActiveProfile</span><span class=\"params\">(String profile)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDefaultProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MutablePropertySources <span class=\"title\">getPropertySources</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemProperties</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ConfigurableEnvironment parent)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。</p>\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h1><p>配置环境的方法是模板方法，详细分为了<code>property</code>和<code>profile</code>。前者是添加默认配置和命令行配置，后者是选择激活的profile。</p>\n<p>接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ATTACHED_PROPERTY_SOURCE_NAME = <span class=\"string\">&quot;configurationProperties&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个<em>CopyOnWriteArrayList</em>实现的线性表，仅此而已，返型是PropertySource对象。</p>\n<p>下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener <code>ConfigFileApplicationListener</code>被触发后的执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEnvironmentPreparedEvent</span><span class=\"params\">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();</span><br><span class=\"line\">    <span class=\"comment\">// 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor</span></span><br><span class=\"line\">    postProcessors.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    AnnotationAwareOrderComparator.sort(postProcessors);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;</span><br><span class=\"line\">        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;EnvironmentPostProcessor&gt; <span class=\"title\">loadPostProcessors</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取环境后置处理器的方式与之前的监听器初始化器相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Environment Post Processors</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span></span><br></pre></td></tr></table></figure>\n\n<p>由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。</p>\n<h2 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h2><p>后置处理也是层层委托</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addPropertySources</span><span class=\"params\">(ConfigurableEnvironment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class=\"line\">    RandomValuePropertySource.addToEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 创建loader后调用load方法</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Loader(environment, resourceLoader).load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;String&gt; LOAD_FILTERED_PROPERTY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; filteredProperties = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.active&quot;</span>);</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.include&quot;</span>);</span><br><span class=\"line\">    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// defaultProperties</span></span><br><span class=\"line\">    FilteredPropertySource.apply(<span class=\"keyword\">this</span>.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,</span><br><span class=\"line\">                                 (defaultProperties) -&gt; &#123;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.profiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.processedProfiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.activatedProfiles = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.loaded = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">                                     initializeProfiles();</span><br><span class=\"line\">                                     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.profiles.isEmpty()) &#123;</span><br><span class=\"line\">                                         Profile profile = <span class=\"keyword\">this</span>.profiles.poll();</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span> (isDefaultProfile(profile)) &#123;</span><br><span class=\"line\">                                             addProfileToEnvironment(profile.getName());</span><br><span class=\"line\">                                         &#125;</span><br><span class=\"line\">                                         <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                         load(profile, <span class=\"keyword\">this</span>::getPositiveProfileFilter,</span><br><span class=\"line\">                                              addToLoaded(MutablePropertySources::addLast, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">                                         <span class=\"keyword\">this</span>.processedProfiles.add(profile);</span><br><span class=\"line\">                                     &#125;</span><br><span class=\"line\">                                     <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                     load(<span class=\"keyword\">null</span>, <span class=\"keyword\">this</span>::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">                                     addLoadedPropertySources();</span><br><span class=\"line\">                                     applyActiveProfiles(defaultProperties);</span><br><span class=\"line\">                                 &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用<em>propertySourceLoaders</em>中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：<code>PropertiesPropertySourceLoader</code>和<code>YamlPropertySourceLoader</code>。</p>\n<h2 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h2><p>我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了<code>EnvironmentPostProcessor</code>的类。可以参考给出的类来写，将配置文件加入列表即可。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>​        SpringBoot配置文件的相关分析。我们都知道目前SpringBoot的配置文件可以配置文件很简单，支持多环境，有yml和properties，那么他的加载机制是怎样的呢？又是如何读取的？</p>","more":"<!--toc-->\n\n<p>前面提到，启动SpringBoot项目分为实例化类SpringApplication和run，在run阶段会准备环境。我们先通过代码看看环境是如何被准备的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ConfigurableEnvironment <span class=\"title\">prepareEnvironment</span><span class=\"params\">(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据应用类型创建对应的环境</span></span><br><span class=\"line\">    ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class=\"line\">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    listeners.environmentPrepared(environment);</span><br><span class=\"line\">    bindToSpringApplication(environment);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.isCustomEnvironment) &#123;</span><br><span class=\"line\">        environment = <span class=\"keyword\">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ConfigurationPropertySources.attach(environment);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> environment;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个从产生的对象，要将它生产出来一般都离不开创建与初始化，所以也可以将上面的分为这两部分。</p>\n<h1 id=\"创建环境\"><a href=\"#创建环境\" class=\"headerlink\" title=\"创建环境\"></a>创建环境</h1><p>首先我们先看创建环境。<code>getOrCreateEnvironment</code>会根据应用类型初始化相应的环境，条件与之前分析的创建应用上下文的相同，分为：<em>默认</em>，<em>Servlet</em>， <em>REACTIVE</em>。这三个环境的都会继承一个接口<code>ConfigurableEnvironment</code>，我们看看接口都做了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setActiveProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addActiveProfile</span><span class=\"params\">(String profile)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDefaultProfiles</span><span class=\"params\">(String... profiles)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">MutablePropertySources <span class=\"title\">getPropertySources</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemProperties</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getSystemEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(ConfigurableEnvironment parent)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到他们后续的抽象类及继承类都是围绕着profile和property来工作的，前者分为默认和激活两个状态，后者用map来存储配置文件中的键值对。</p>\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h1><p>配置环境的方法是模板方法，详细分为了<code>property</code>和<code>profile</code>。前者是添加默认配置和命令行配置，后者是选择激活的profile。</p>\n<p>接下来是ConfigurationPropertySources的attach。这个方法会检查特殊字段是否为空 ，然后去做对应的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ATTACHED_PROPERTY_SOURCE_NAME = <span class=\"string\">&quot;configurationProperties&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>除了这个，我们还需要了解environment中的propertySource的类型：MutablePropertySource。他的属性是一个<em>CopyOnWriteArrayList</em>实现的线性表，仅此而已，返型是PropertySource对象。</p>\n<p>下面是一个非常重要的处理，监听器的执行。之前提到，执行时会创建相应的event，然后再通过广播去找对应的listener，我们来看看listener <code>ConfigFileApplicationListener</code>被触发后的执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEnvironmentPreparedEvent</span><span class=\"params\">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();</span><br><span class=\"line\">    <span class=\"comment\">// 把自己也加入到了后置处理器中，因为这个listener也继承了EnvironmentPostProcessor</span></span><br><span class=\"line\">    postProcessors.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    AnnotationAwareOrderComparator.sort(postProcessors);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;</span><br><span class=\"line\">        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应的事件也如之前所说，都很简洁，这里环境准备的响应首先获取到后置处理器，随后将类本身也加入进去，排序后依次执行后置处理器的方法对环境做处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">List&lt;EnvironmentPostProcessor&gt; <span class=\"title\">loadPostProcessors</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取环境后置处理器的方式与之前的监听器初始化器相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Environment Post Processors</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span></span><br></pre></td></tr></table></figure>\n\n<p>由于listener本身也是processor（单独把它加入到processor里了），所以我们重点关注这里的后置处理。这部分也是加载配置文件的关键。</p>\n<h2 id=\"Load\"><a href=\"#Load\" class=\"headerlink\" title=\"Load\"></a>Load</h2><p>后置处理也是层层委托</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addPropertySources</span><span class=\"params\">(ConfigurableEnvironment environment, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class=\"line\">    RandomValuePropertySource.addToEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 创建loader后调用load方法</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Loader(environment, resourceLoader).load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;String&gt; LOAD_FILTERED_PROPERTY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    Set&lt;String&gt; filteredProperties = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.active&quot;</span>);</span><br><span class=\"line\">    filteredProperties.add(<span class=\"string\">&quot;spring.profiles.include&quot;</span>);</span><br><span class=\"line\">    LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// defaultProperties</span></span><br><span class=\"line\">    FilteredPropertySource.apply(<span class=\"keyword\">this</span>.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,</span><br><span class=\"line\">                                 (defaultProperties) -&gt; &#123;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.profiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.processedProfiles = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.activatedProfiles = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.loaded = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">                                     initializeProfiles();</span><br><span class=\"line\">                                     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.profiles.isEmpty()) &#123;</span><br><span class=\"line\">                                         Profile profile = <span class=\"keyword\">this</span>.profiles.poll();</span><br><span class=\"line\">                                         <span class=\"keyword\">if</span> (isDefaultProfile(profile)) &#123;</span><br><span class=\"line\">                                             addProfileToEnvironment(profile.getName());</span><br><span class=\"line\">                                         &#125;</span><br><span class=\"line\">                                         <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                         load(profile, <span class=\"keyword\">this</span>::getPositiveProfileFilter,</span><br><span class=\"line\">                                              addToLoaded(MutablePropertySources::addLast, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">                                         <span class=\"keyword\">this</span>.processedProfiles.add(profile);</span><br><span class=\"line\">                                     &#125;</span><br><span class=\"line\">                                     <span class=\"comment\">// 重载load</span></span><br><span class=\"line\">                                     load(<span class=\"keyword\">null</span>, <span class=\"keyword\">this</span>::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">                                     addLoadedPropertySources();</span><br><span class=\"line\">                                     applyActiveProfiles(defaultProperties);</span><br><span class=\"line\">                                 &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的方法看着长，别被lambda吓到了，实际上是调用了apply方法，后面那个只是一个consumer参数。也就是在这个listener里解析了properties以及yml，定义了解析顺序和规则。里面有多个重载的load方法，在load方法内还会遍历地用<em>propertySourceLoaders</em>中的loader去调用load方法，propertySourceLoader是一个接口，有两个实现类：<code>PropertiesPropertySourceLoader</code>和<code>YamlPropertySourceLoader</code>。</p>\n<h2 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h2><p>我们知道，加载了postprocessor后会触发processor，如果要自定义配置文件或者指定路径呢？利用他的SPI机制，我们可以在在META-INF下创建spring.factories，在里面按照给定的key加上我们实现了<code>EnvironmentPostProcessor</code>的类。可以参考给出的类来写，将配置文件加入列表即可。</p>"},{"title":"SpringBoot refresh","date":"2021-02-15T08:19:30.000Z","_content":"\n这篇主要分析SpringBoot在run阶段的*refresh*过程。\n\n<!--more-->\n\n之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：\n\n```java\nsynchronized (this.startupShutdownMonitor) {\n    // Prepare this context for refreshing.\n    prepareRefresh();\n\n    // Tell the subclass to refresh the internal bean factory.\n    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n    // Prepare the bean factory for use in this context.\n    prepareBeanFactory(beanFactory);\n\n    try {\n        // Allows post-processing of the bean factory in context subclasses.\n        postProcessBeanFactory(beanFactory);\n\n        // Invoke factory processors registered as beans in the context.\n        invokeBeanFactoryPostProcessors(beanFactory);\n\n        // Register bean processors that intercept bean creation.\n        registerBeanPostProcessors(beanFactory);\n\n        // Initialize message source for this context.\n        initMessageSource();\n\n        // Initialize event multicaster for this context.\n        initApplicationEventMulticaster();\n\n        // Initialize other special beans in specific context subclasses.\n        onRefresh();\n\n        // Check for listener beans and register them.\n        registerListeners();\n\n        // Instantiate all remaining (non-lazy-init) singletons.\n        finishBeanFactoryInitialization(beanFactory);\n\n        // Last step: publish corresponding event.\n        finishRefresh();\n    }\n```\n\n<!--toc-->\n\n# prepareRefresh\n\n刷新前的准备工作，设置一些开关；初始化property。\n\n\n\n# prepareBeanFactory\n\n准备beanFactory，可以分为以下几个部分：\n\n1. 设置类加载器和bean解析器\n\n2. 添加beanPostProcessor：`ApplicationContextAwarePostProcessor`，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。\n\n   ```java\n   // Configure the bean factory with context callbacks.\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n   ```\n\n3. 手动设置注入的bean，相当与初始化。*registerResolvableDependency*方法是将对应的入参以key-value的形式放入map中。\n\n   ```java\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   // this是上下文容器\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n   ```\n\n\n\n# postProcessBeanFactory\n\n添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。\n\n```java\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    // add之后紧接着ignore，说明加入的processor实现了后者的功能\n    beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n\n    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);\n}\n```\n\n\n\n# invokeBeanFactoryPostProcessors\n\n参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给`PostProcessorRegistrationDelegate`，实现的细节代码较长，这里就不贴了。\n\n​\t\t首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往*BeanDefinitionRegistry*加入postProcessor。\n\n```java\nString[] postProcessorNames =\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) {\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n        // configurationClassPostProcessor，用来解析@Config注解\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    }\n}\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n```\n\n​\t\t随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类`ConfigurationClassParser`，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在*doProcessConfigurationClass*方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的`selector`并再次递归，如此往复。\n\n​\t\t以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration // 启动自动装配\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ...\n}\n```\n\n我们主要查看他自动装配的原理：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class) // 这里的代码会被解析\npublic @interface EnableAutoConfiguration {\n    // ...\n}\n```\n\n在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有`getCandidateConfigurations`，顾名思义，根据*EnableAutoConfiguration.class*这个key从*spring.factories*中获取对应的values：\n\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n# ...\n```\n\n共一百多个，这些会被解析后放入beanFactory中。\n\n\n\n# registerBeanPostProcessors\n\n这个方法内的步骤与上一个一样。委托给`PostProcessorRegistrationDelegate`来做事。\n\n\n\n# InitMessageSource\n\n国际化处理\n\n\n\n# initApplicationEventMulticaster\n\n初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。\n\n\n\n# onRefresh\n\n抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。\n\n\n\n# registerListeners\n\n添加监听器到持有者中。\n\n\n\n# finishBeanFactoryInitialization\n\n这一步是实例化所有的bean了。\n\n\n\n# finishRefresh\n\n最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。\n\n\n\n# 总结\n\nrefresh的内容还是很多的。重点关注这几个方面：\n\n- 实现了与注解的联动\n- 完成了自动化配置\n- 解析bean之间的依赖并实例化","source":"_posts/SpringBoot-refresh.md","raw":"---\ntitle: SpringBoot refresh\ndate: 2021-02-15 16:19:30\ncategories: springboot\ntags: source\n---\n\n这篇主要分析SpringBoot在run阶段的*refresh*过程。\n\n<!--more-->\n\n之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：\n\n```java\nsynchronized (this.startupShutdownMonitor) {\n    // Prepare this context for refreshing.\n    prepareRefresh();\n\n    // Tell the subclass to refresh the internal bean factory.\n    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n    // Prepare the bean factory for use in this context.\n    prepareBeanFactory(beanFactory);\n\n    try {\n        // Allows post-processing of the bean factory in context subclasses.\n        postProcessBeanFactory(beanFactory);\n\n        // Invoke factory processors registered as beans in the context.\n        invokeBeanFactoryPostProcessors(beanFactory);\n\n        // Register bean processors that intercept bean creation.\n        registerBeanPostProcessors(beanFactory);\n\n        // Initialize message source for this context.\n        initMessageSource();\n\n        // Initialize event multicaster for this context.\n        initApplicationEventMulticaster();\n\n        // Initialize other special beans in specific context subclasses.\n        onRefresh();\n\n        // Check for listener beans and register them.\n        registerListeners();\n\n        // Instantiate all remaining (non-lazy-init) singletons.\n        finishBeanFactoryInitialization(beanFactory);\n\n        // Last step: publish corresponding event.\n        finishRefresh();\n    }\n```\n\n<!--toc-->\n\n# prepareRefresh\n\n刷新前的准备工作，设置一些开关；初始化property。\n\n\n\n# prepareBeanFactory\n\n准备beanFactory，可以分为以下几个部分：\n\n1. 设置类加载器和bean解析器\n\n2. 添加beanPostProcessor：`ApplicationContextAwarePostProcessor`，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。\n\n   ```java\n   // Configure the bean factory with context callbacks.\n   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n   ```\n\n3. 手动设置注入的bean，相当与初始化。*registerResolvableDependency*方法是将对应的入参以key-value的形式放入map中。\n\n   ```java\n   // BeanFactory interface not registered as resolvable type in a plain factory.\n   // MessageSource registered (and found for autowiring) as a bean.\n   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n   // this是上下文容器\n   beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n   beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n   ```\n\n\n\n# postProcessBeanFactory\n\n添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。\n\n```java\nprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    // add之后紧接着ignore，说明加入的processor实现了后者的功能\n    beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));\n    beanFactory.ignoreDependencyInterface(ServletContextAware.class);\n    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);\n\n    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);\n    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);\n}\n```\n\n\n\n# invokeBeanFactoryPostProcessors\n\n参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给`PostProcessorRegistrationDelegate`，实现的细节代码较长，这里就不贴了。\n\n​\t\t首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往*BeanDefinitionRegistry*加入postProcessor。\n\n```java\nString[] postProcessorNames =\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) {\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n        // configurationClassPostProcessor，用来解析@Config注解\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    }\n}\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n```\n\n​\t\t随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类`ConfigurationClassParser`，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在*doProcessConfigurationClass*方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的`selector`并再次递归，如此往复。\n\n​\t\t以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration // 启动自动装配\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    // ...\n}\n```\n\n我们主要查看他自动装配的原理：\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class) // 这里的代码会被解析\npublic @interface EnableAutoConfiguration {\n    // ...\n}\n```\n\n在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有`getCandidateConfigurations`，顾名思义，根据*EnableAutoConfiguration.class*这个key从*spring.factories*中获取对应的values：\n\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n# ...\n```\n\n共一百多个，这些会被解析后放入beanFactory中。\n\n\n\n# registerBeanPostProcessors\n\n这个方法内的步骤与上一个一样。委托给`PostProcessorRegistrationDelegate`来做事。\n\n\n\n# InitMessageSource\n\n国际化处理\n\n\n\n# initApplicationEventMulticaster\n\n初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。\n\n\n\n# onRefresh\n\n抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。\n\n\n\n# registerListeners\n\n添加监听器到持有者中。\n\n\n\n# finishBeanFactoryInitialization\n\n这一步是实例化所有的bean了。\n\n\n\n# finishRefresh\n\n最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。\n\n\n\n# 总结\n\nrefresh的内容还是很多的。重点关注这几个方面：\n\n- 实现了与注解的联动\n- 完成了自动化配置\n- 解析bean之间的依赖并实例化","slug":"SpringBoot-refresh","published":1,"updated":"2021-03-28T10:20:02.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj6r000bts9qdqk86rdb","content":"<p>这篇主要分析SpringBoot在run阶段的<em>refresh</em>过程。</p>\n<span id=\"more\"></span>\n\n<p>之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Prepare this context for refreshing.</span></span><br><span class=\"line\">    prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prepare the bean factory for use in this context.</span></span><br><span class=\"line\">    prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class=\"line\">        postProcessBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Invoke factory processors registered as beans in the context.</span></span><br><span class=\"line\">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Register bean processors that intercept bean creation.</span></span><br><span class=\"line\">        registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize message source for this context.</span></span><br><span class=\"line\">        initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize event multicaster for this context.</span></span><br><span class=\"line\">        initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize other special beans in specific context subclasses.</span></span><br><span class=\"line\">        onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check for listener beans and register them.</span></span><br><span class=\"line\">        registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class=\"line\">        finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Last step: publish corresponding event.</span></span><br><span class=\"line\">        finishRefresh();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<!--toc-->\n\n<h1 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h1><p>刷新前的准备工作，设置一些开关；初始化property。</p>\n<h1 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h1><p>准备beanFactory，可以分为以下几个部分：</p>\n<ol>\n<li><p>设置类加载器和bean解析器</p>\n</li>\n<li><p>添加beanPostProcessor：<code>ApplicationContextAwarePostProcessor</code>，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Configure the bean factory with context callbacks.</span></span><br><span class=\"line\">beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>手动设置注入的bean，相当与初始化。<em>registerResolvableDependency</em>方法是将对应的入参以key-value的形式放入map中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class=\"line\"><span class=\"comment\">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\"><span class=\"comment\">// this是上下文容器</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h1 id=\"postProcessBeanFactory\"><a href=\"#postProcessBeanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory\"></a>postProcessBeanFactory</h1><p>添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// add之后紧接着ignore，说明加入的processor实现了后者的功能</span></span><br><span class=\"line\">    beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ServletContextAwareProcessor(<span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig));</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class=\"keyword\">this</span>.servletContext);</span><br><span class=\"line\">    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h1><p>参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给<code>PostProcessorRegistrationDelegate</code>，实现的细节代码较长，这里就不贴了。</p>\n<p>​        首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往<em>BeanDefinitionRegistry</em>加入postProcessor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] postProcessorNames =</span><br><span class=\"line\">    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// configurationClassPostProcessor，用来解析@Config注解</span></span><br><span class=\"line\">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">        processedBeans.add(ppName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">currentRegistryProcessors.clear();</span><br></pre></td></tr></table></figure>\n\n<p>​        随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类<code>ConfigurationClassParser</code>，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在<em>doProcessConfigurationClass</em>方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的<code>selector</code>并再次递归，如此往复。</p>\n<p>​        以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span> <span class=\"comment\">// 启动自动装配</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要查看他自动装配的原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationImportSelector.class)</span> <span class=\"comment\">// 这里的代码会被解析</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有<code>getCandidateConfigurations</code>，顾名思义，根据<em>EnableAutoConfiguration.class</em>这个key从<em>spring.factories</em>中获取对应的values：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n\n<p>共一百多个，这些会被解析后放入beanFactory中。</p>\n<h1 id=\"registerBeanPostProcessors\"><a href=\"#registerBeanPostProcessors\" class=\"headerlink\" title=\"registerBeanPostProcessors\"></a>registerBeanPostProcessors</h1><p>这个方法内的步骤与上一个一样。委托给<code>PostProcessorRegistrationDelegate</code>来做事。</p>\n<h1 id=\"InitMessageSource\"><a href=\"#InitMessageSource\" class=\"headerlink\" title=\"InitMessageSource\"></a>InitMessageSource</h1><p>国际化处理</p>\n<h1 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster\"></a>initApplicationEventMulticaster</h1><p>初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。</p>\n<h1 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh\"></a>onRefresh</h1><p>抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。</p>\n<h1 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners\"></a>registerListeners</h1><p>添加监听器到持有者中。</p>\n<h1 id=\"finishBeanFactoryInitialization\"><a href=\"#finishBeanFactoryInitialization\" class=\"headerlink\" title=\"finishBeanFactoryInitialization\"></a>finishBeanFactoryInitialization</h1><p>这一步是实例化所有的bean了。</p>\n<h1 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh\"></a>finishRefresh</h1><p>最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>refresh的内容还是很多的。重点关注这几个方面：</p>\n<ul>\n<li>实现了与注解的联动</li>\n<li>完成了自动化配置</li>\n<li>解析bean之间的依赖并实例化</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇主要分析SpringBoot在run阶段的<em>refresh</em>过程。</p>","more":"<p>之前提到，SpringBoot会根据应用的类型去创建对应的容器，在做refresh时也是用对应的容器对执行刷新方法的，但是无论是哪个容器都会调用抽象父类的refresh方法，换句话说，接口定义了容器规范，抽象类实现了部分功能（例如refresh），再由具体的容器类型去继承抽象类实现个性化。先来看看refresh：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Prepare this context for refreshing.</span></span><br><span class=\"line\">    prepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prepare the bean factory for use in this context.</span></span><br><span class=\"line\">    prepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class=\"line\">        postProcessBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Invoke factory processors registered as beans in the context.</span></span><br><span class=\"line\">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Register bean processors that intercept bean creation.</span></span><br><span class=\"line\">        registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize message source for this context.</span></span><br><span class=\"line\">        initMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize event multicaster for this context.</span></span><br><span class=\"line\">        initApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Initialize other special beans in specific context subclasses.</span></span><br><span class=\"line\">        onRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check for listener beans and register them.</span></span><br><span class=\"line\">        registerListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class=\"line\">        finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Last step: publish corresponding event.</span></span><br><span class=\"line\">        finishRefresh();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<!--toc-->\n\n<h1 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h1><p>刷新前的准备工作，设置一些开关；初始化property。</p>\n<h1 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h1><p>准备beanFactory，可以分为以下几个部分：</p>\n<ol>\n<li><p>设置类加载器和bean解析器</p>\n</li>\n<li><p>添加beanPostProcessor：<code>ApplicationContextAwarePostProcessor</code>，并忽略五个依赖，因为查看前者，会发现他已经实现了要忽略的五个依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Configure the bean factory with context callbacks.</span></span><br><span class=\"line\">beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>手动设置注入的bean，相当与初始化。<em>registerResolvableDependency</em>方法是将对应的入参以key-value的形式放入map中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class=\"line\"><span class=\"comment\">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\"><span class=\"comment\">// this是上下文容器</span></span><br><span class=\"line\">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h1 id=\"postProcessBeanFactory\"><a href=\"#postProcessBeanFactory\" class=\"headerlink\" title=\"postProcessBeanFactory\"></a>postProcessBeanFactory</h1><p>添加postProcessor；在beanFacotry中手动注册web容器相关的bean，如servletContext等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// add之后紧接着ignore，说明加入的processor实现了后者的功能</span></span><br><span class=\"line\">    beanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ServletContextAwareProcessor(<span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig));</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class=\"line\">    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class=\"keyword\">this</span>.servletContext);</span><br><span class=\"line\">    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class=\"keyword\">this</span>.servletContext, <span class=\"keyword\">this</span>.servletConfig);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h1><p>参照之前的postProcessContext一样，会调用一些postProcessor再去配置BeanFactory。内部会将实现委托给<code>PostProcessorRegistrationDelegate</code>，实现的细节代码较长，这里就不贴了。</p>\n<p>​        首先是排序，它会按照postProcessor的顺序来使用，顺序为：priorityOrdered, ordered, regular。但是有没有想过这些processor是哪里来的呢？之前都是在往context加入后置处理。实际上，在创建对应容器时，相应的context会会初始化，这个时候会往<em>BeanDefinitionRegistry</em>加入postProcessor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] postProcessorNames =</span><br><span class=\"line\">    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// configurationClassPostProcessor，用来解析@Config注解</span></span><br><span class=\"line\">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class=\"line\">        processedBeans.add(ppName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class=\"line\">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class=\"line\">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class=\"line\">currentRegistryProcessors.clear();</span><br></pre></td></tr></table></figure>\n\n<p>​        随后主要是解析Configertaion注解，在刚启动时也只有启动类上标注有注解（@SpringApplication中带有），在后置处理类中，更多的工作是负责处理解析与否，详细的解析工作是交给了类<code>ConfigurationClassParser</code>，每个bean都由BeanDefinitionHolder持有，有属性beanDefinition来定义bean，根据这个来做后续判断，在<em>doProcessConfigurationClass</em>方法中，可以看到过程如下：解析@PropertySource，@ComponentScan，@Import，@ImportResource等等。其中跟进import，会发现他还会解析其中的<code>selector</code>并再次递归，如此往复。</p>\n<p>​        以上涉及到了注解的解析，这时回到我们的启动类查看启动类上的注解@SpringApplication，跟进：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span> <span class=\"comment\">// 启动自动装配</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要查看他自动装配的原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationImportSelector.class)</span> <span class=\"comment\">// 这里的代码会被解析</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在AutoConfigurationImportSelector中，selectImport方法会被调用，在里面会有<code>getCandidateConfigurations</code>，顾名思义，根据<em>EnableAutoConfiguration.class</em>这个key从<em>spring.factories</em>中获取对应的values：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n\n<p>共一百多个，这些会被解析后放入beanFactory中。</p>\n<h1 id=\"registerBeanPostProcessors\"><a href=\"#registerBeanPostProcessors\" class=\"headerlink\" title=\"registerBeanPostProcessors\"></a>registerBeanPostProcessors</h1><p>这个方法内的步骤与上一个一样。委托给<code>PostProcessorRegistrationDelegate</code>来做事。</p>\n<h1 id=\"InitMessageSource\"><a href=\"#InitMessageSource\" class=\"headerlink\" title=\"InitMessageSource\"></a>InitMessageSource</h1><p>国际化处理</p>\n<h1 id=\"initApplicationEventMulticaster\"><a href=\"#initApplicationEventMulticaster\" class=\"headerlink\" title=\"initApplicationEventMulticaster\"></a>initApplicationEventMulticaster</h1><p>初始化广播器，其实之前是有初始化过的，直接拿来用。如果没有的话会在这里重新初始化一个。</p>\n<h1 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh\"></a>onRefresh</h1><p>抽象方法中这里空出来了，留给不同的实现类去实现，对于Servlet来说是创建web服务器。</p>\n<h1 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners\"></a>registerListeners</h1><p>添加监听器到持有者中。</p>\n<h1 id=\"finishBeanFactoryInitialization\"><a href=\"#finishBeanFactoryInitialization\" class=\"headerlink\" title=\"finishBeanFactoryInitialization\"></a>finishBeanFactoryInitialization</h1><p>这一步是实例化所有的bean了。</p>\n<h1 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh\"></a>finishRefresh</h1><p>最后一步除了发布相应的时间外还会清楚上下文缓存、初始化它的生命周期。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>refresh的内容还是很多的。重点关注这几个方面：</p>\n<ul>\n<li>实现了与注解的联动</li>\n<li>完成了自动化配置</li>\n<li>解析bean之间的依赖并实例化</li>\n</ul>"},{"title":"acm standard inputoutput","date":"2021-04-19T13:56:55.000Z","_content":"\n​\t\t算法题中通常有两种方式提交代码，一种是核心代码模式，就像LeetCode平台中的那样，还有的就是ACM模式，后者不仅要完成题目中的算法逻辑，还需要定义输入输出，尤其是输入输出，需要符合规范才可以（如果核心代码完成，因为输入输出而丢分就太可惜了）。这篇就是对输入输出的总结，题型来自牛客。\n\n<!-- more -->\n\n# 多组输入\n\n根据是否给定组数有两种循环，没有明确组数就用while，给定了的就用for循环一定的次数。**虽然给的示例是多行输入多行输出，但是多组输入实际上是多个测试，每输入一行数据，在回车输入下一行数据前就要有一个输出**。\n\n## 无限循环\n\n#### 题目A\n\n输入描述:\n\n```\n输入包括两个正整数a,b(1 <= a, b <= 10^9),输入数据包括多组。\n```\n\n输出描述:\n\n```markdown\n输出a+b的结果\n```\n\n示例1\n\n输入\n\n```\n1 5\n10 20\n```\n\n输出\n\n```markdown\n6\n30\n```\n\nTHINKING：每次输入两个整数，可输入多组，每组都会产生一个结果。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){ // next() or nextInt() is ok\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            // your business\n            System.out.println(a+b);\n        }\n    }\n}\n```\n\n#### 题目B\n\n输入描述:\n\n```\n输入数据有多组, 每行表示一组输入数据。\n每行的第一个整数为整数的个数n(1 <= n <= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n4 1 2 3 4\n5 1 2 3 4 5\n```\n\n输出\n\n```\n10\n15\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n    }\n}\n```\n\nTHINKING：这道题的输入跟下面的带结提示的相比就少了一个结束的判断条件。需要着重注意第一个数字与后面数字的关系处理，应该是**到一定个数后就进入业务逻辑处理，通过输出来进行换行**。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for(int i=0; i<n; i++){\n                arr[i] = sc.nextInt();\n            }\n            // your business\n            int sum = 0;\n            for(int num : arr){\n                sum += num;\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n#### 题目 C\n\n输入描述:\n\n```\n多个测试用例，每个测试用例一行。\n\n每行通过空格隔开，有n个字符，n＜100\n```\n\n输出描述:\n\n```\n对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开\n```\n\n示例1\n\n输入\n\n```\na c bb\nf dddd\nnowcoder\n```\n\n输出\n\n```\na bb c\ndddd f\nnowcoder\n```\n\nTHINKING：多组输入，只不过每个元素都是字符串。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            String[] str = sc.nextLine().split(\" \");\n            //  your business\n            Arrays.sort(str);\n            StringBuilder sb = new StringBuilder(str[0]);\n            for(int i=1; i<str.length; i++){\n                sb.append(\" \").append(str[i]);\n            }\n            System.out.println(sb.toString());\n        }\n    }\n}\n```\n\n\n\n### 结束提示\n\n虽然是不限定输入组数，但是给了结束标志，这时在while中添加一个判断条件，符合的话跳出循环。\n\n#### 题目 A\n\n输入描述:\n\n```\n输入包括两个正整数a,b(1 <= a, b <= 10^9),输入数据有多组, 如果输入为0 0则结束输入\n```\n\n输出描述:\n\n```\n输出a+b的结果\n```\n\n示例1\n\n输入\n\n```\n1 5\n10 20\n0 0\n```\n\n输出\n\n```\n6\n30\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if(a == 0 && b == 0) return;\n            // your business\n            System.out.println(a+b);\n        }\n    }\n}\n```\n\n#### 题目B\n\n比上面的稍微复杂一点，不过也是根据输入标志退出输入，需要额外处理的就是第一个数字和后面数字的关系\n\n输入描述:\n\n```\n输入数据包括多组。\n每组数据一行,每行的第一个整数为整数的个数n(1 <= n <= 100), n为0的时候结束输入。\n接下来n个正整数,即需要求和的每个正整数。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n4 1 2 3 4\n5 1 2 3 4 5\n0\n```\n\n输出\n\n```\n10\n15\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            // 注意这里是如何处理第一个数字和后续输入数字的关系的\n            int n = sc.nextInt();\n            if(n == 0) return;\n            int[] arr = new int[n];\n            for(int i=0; i<n; i++){\n                arr[i] = sc.nextInt();\n            }\n            // your business\n            int sum = 0;\n            for(int num : arr){\n                sum += num;\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n#### 题目C\n\n输入描述:\n\n```\n输入数据有多组, 每行表示一组输入数据。\n\n每行不定有n个整数，空格隔开。(1 <= n <= 100)。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n1 2 3\n4 5\n0 0 0 0 0\n```\n\n输出\n\n```\n6\n9\n0\n```\n\nTHINKING：这道题与前面的题有所不同了，首先他还是多组输入，每一行算作一组，但是每一组没有给定输入的个数，按照日常的操作来看我们是用回车来判断是否是一组的，在java中如何做呢？答案是方法`nextLine()`；其次是输入的元素，如果是两个的话，我们读取两次`nextInt()`就好，但这是不定个数的，再用这个方法会有些麻烦，再看题目，各个输入之间是用空格隔开的，**我们何不按行读取，然后用空格分开**，那么**每一行就被视作一个字符串，用函数`nextLine()`获取输入的一行就可以了**。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            String[] str = sc.nextLine().split(\" \");\n            // your business\n            int sum = 0;\n            for(String s : str){\n                sum += Integer.parseInt(s);\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n\n\n## 有限个数\n\n#### 题目A\n\n输入描述:\n\n```\n输入第一行包括一个数据组数t(1 <= t <= 100)\n接下来每行包括两个正整数a,b(1 <= a, b <= 10^9)\n```\n\n输出描述:\n\n```\n输出a+b的结果\n```\n\n示例1\n\n输入\n\n```\n2\n1 5\n10 20\n```\n\n输出\n\n```\n6\n30\n```\n\nTHINKING：相比较没有明确输入组数的，这个提到了输入的个数，那我们就不用while无限循环了， 只需要循环给定的个数就好了。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for(int i=0; i<t; i++){\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            // your business\n            System.out.println(a+b);\n        }\n    }\n}\n```\n\n#### 题目B\n\n输入描述:\n\n```\n输入的第一行包括一个正整数t(1 <= t <= 100), 表示数据组数。\n接下来t行, 每行一组数据。\n每行的第一个整数为整数的个数n(1 <= n <= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n2\n4 1 2 3 4\n5 1 2 3 4 5\n```\n\n输出\n\n```\n10\n15\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for(int i=0; i<t; i++){\n            int n= sc.nextInt();\n            int[] arr = new int[n];\n            for(int j=0; j<n; j++){\n                arr[j] = sc.nextInt();\n            }\n            // your business\n            int sum = 0;\n            for(int num : arr){\n                sum += num;\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n# 单组输入\n\n通过上面可以看出，多组输入是依靠**for循环**或者**while**用`hasNext()`不停地监控键盘来实现的，与之相比，单组输入就省去了循环。\n\n#### 题目A\n\n输入描述:\n\n```\n输入有两行，第一行n\n\n第二行是n个空格隔开的字符串\n```\n\n输出描述:\n\n```\n输出一行排序后的字符串，空格隔开，无结尾空格\n```\n\n示例1\n\n输入\n\n```\n5\nc d a bb e\n```\n\n输出\n\n```\na bb c d e\n```\n\nTHINKING：在第一行输入一个长度，在第二行输入给定长度的空格隔开的字符串。既然是字符串，我们能否直接拿取到整个字符串，然后空格隔开，按给定的长度来取前部分呢，事实上这么做就没问题的。**如果没有输入长度，而是题目中有要求长度，那么直接用整行再split后取一个长度也ok的**。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        // 第一行輸入的是一個數字，而且要換行來做下一行的輸入，要用nextLine\n        int n = Integer.parseInt(sc.nextLine());\n        String[] str = sc.nextLine().split(\" \");\n        // your business\n        Arrays.sort(str);\n        StringBuilder sb = new StringBuilder(str[0]);\n        for(int i=1; i<n; i++){\n            sb.append(\" \").append(str[i]);\n        }\n        System.out.println(sb.toString());\n    }\n}\n```\n\n# 总结\n\n​\t\t对于做习惯了Leetcode的“傻瓜式”算法题的人来说，ACM模式有些难以理解，尤其是算法部分都完成了，最后挂在了输入上导致提交不通过的人。但是不管怎么样，毕竟算法都能AC，这个花时间看看也不是很难，而且ACM模式也是主流，不仅仅是牛客，PAT、CodeForces这些也都采用的ACM模式。\n\n​\t\t提交时后台数据都不止一个用例，所以要着重掌握多组输入的情况，对于未告知数量的，用`hasNext()`来循环，单行数据较多或不确定的，使用`nextLine()`直接获取整行数据，再用`split()`分隔开后处理。**虽然是多组数据，但是每喂一组数据，就要调用编写的算法模块去处理一组并且输出**，而不是接受完统一处理。","source":"_posts/acm-standard-inputoutput.md","raw":"---\ntitle: acm standard inputoutput\ndate: 2021-04-19 21:56:55\ncategories: Leetcode\ntags: standard\n---\n\n​\t\t算法题中通常有两种方式提交代码，一种是核心代码模式，就像LeetCode平台中的那样，还有的就是ACM模式，后者不仅要完成题目中的算法逻辑，还需要定义输入输出，尤其是输入输出，需要符合规范才可以（如果核心代码完成，因为输入输出而丢分就太可惜了）。这篇就是对输入输出的总结，题型来自牛客。\n\n<!-- more -->\n\n# 多组输入\n\n根据是否给定组数有两种循环，没有明确组数就用while，给定了的就用for循环一定的次数。**虽然给的示例是多行输入多行输出，但是多组输入实际上是多个测试，每输入一行数据，在回车输入下一行数据前就要有一个输出**。\n\n## 无限循环\n\n#### 题目A\n\n输入描述:\n\n```\n输入包括两个正整数a,b(1 <= a, b <= 10^9),输入数据包括多组。\n```\n\n输出描述:\n\n```markdown\n输出a+b的结果\n```\n\n示例1\n\n输入\n\n```\n1 5\n10 20\n```\n\n输出\n\n```markdown\n6\n30\n```\n\nTHINKING：每次输入两个整数，可输入多组，每组都会产生一个结果。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){ // next() or nextInt() is ok\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            // your business\n            System.out.println(a+b);\n        }\n    }\n}\n```\n\n#### 题目B\n\n输入描述:\n\n```\n输入数据有多组, 每行表示一组输入数据。\n每行的第一个整数为整数的个数n(1 <= n <= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n4 1 2 3 4\n5 1 2 3 4 5\n```\n\n输出\n\n```\n10\n15\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n    }\n}\n```\n\nTHINKING：这道题的输入跟下面的带结提示的相比就少了一个结束的判断条件。需要着重注意第一个数字与后面数字的关系处理，应该是**到一定个数后就进入业务逻辑处理，通过输出来进行换行**。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for(int i=0; i<n; i++){\n                arr[i] = sc.nextInt();\n            }\n            // your business\n            int sum = 0;\n            for(int num : arr){\n                sum += num;\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n#### 题目 C\n\n输入描述:\n\n```\n多个测试用例，每个测试用例一行。\n\n每行通过空格隔开，有n个字符，n＜100\n```\n\n输出描述:\n\n```\n对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开\n```\n\n示例1\n\n输入\n\n```\na c bb\nf dddd\nnowcoder\n```\n\n输出\n\n```\na bb c\ndddd f\nnowcoder\n```\n\nTHINKING：多组输入，只不过每个元素都是字符串。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            String[] str = sc.nextLine().split(\" \");\n            //  your business\n            Arrays.sort(str);\n            StringBuilder sb = new StringBuilder(str[0]);\n            for(int i=1; i<str.length; i++){\n                sb.append(\" \").append(str[i]);\n            }\n            System.out.println(sb.toString());\n        }\n    }\n}\n```\n\n\n\n### 结束提示\n\n虽然是不限定输入组数，但是给了结束标志，这时在while中添加一个判断条件，符合的话跳出循环。\n\n#### 题目 A\n\n输入描述:\n\n```\n输入包括两个正整数a,b(1 <= a, b <= 10^9),输入数据有多组, 如果输入为0 0则结束输入\n```\n\n输出描述:\n\n```\n输出a+b的结果\n```\n\n示例1\n\n输入\n\n```\n1 5\n10 20\n0 0\n```\n\n输出\n\n```\n6\n30\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if(a == 0 && b == 0) return;\n            // your business\n            System.out.println(a+b);\n        }\n    }\n}\n```\n\n#### 题目B\n\n比上面的稍微复杂一点，不过也是根据输入标志退出输入，需要额外处理的就是第一个数字和后面数字的关系\n\n输入描述:\n\n```\n输入数据包括多组。\n每组数据一行,每行的第一个整数为整数的个数n(1 <= n <= 100), n为0的时候结束输入。\n接下来n个正整数,即需要求和的每个正整数。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n4 1 2 3 4\n5 1 2 3 4 5\n0\n```\n\n输出\n\n```\n10\n15\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            // 注意这里是如何处理第一个数字和后续输入数字的关系的\n            int n = sc.nextInt();\n            if(n == 0) return;\n            int[] arr = new int[n];\n            for(int i=0; i<n; i++){\n                arr[i] = sc.nextInt();\n            }\n            // your business\n            int sum = 0;\n            for(int num : arr){\n                sum += num;\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n#### 题目C\n\n输入描述:\n\n```\n输入数据有多组, 每行表示一组输入数据。\n\n每行不定有n个整数，空格隔开。(1 <= n <= 100)。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n1 2 3\n4 5\n0 0 0 0 0\n```\n\n输出\n\n```\n6\n9\n0\n```\n\nTHINKING：这道题与前面的题有所不同了，首先他还是多组输入，每一行算作一组，但是每一组没有给定输入的个数，按照日常的操作来看我们是用回车来判断是否是一组的，在java中如何做呢？答案是方法`nextLine()`；其次是输入的元素，如果是两个的话，我们读取两次`nextInt()`就好，但这是不定个数的，再用这个方法会有些麻烦，再看题目，各个输入之间是用空格隔开的，**我们何不按行读取，然后用空格分开**，那么**每一行就被视作一个字符串，用函数`nextLine()`获取输入的一行就可以了**。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            String[] str = sc.nextLine().split(\" \");\n            // your business\n            int sum = 0;\n            for(String s : str){\n                sum += Integer.parseInt(s);\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n\n\n## 有限个数\n\n#### 题目A\n\n输入描述:\n\n```\n输入第一行包括一个数据组数t(1 <= t <= 100)\n接下来每行包括两个正整数a,b(1 <= a, b <= 10^9)\n```\n\n输出描述:\n\n```\n输出a+b的结果\n```\n\n示例1\n\n输入\n\n```\n2\n1 5\n10 20\n```\n\n输出\n\n```\n6\n30\n```\n\nTHINKING：相比较没有明确输入组数的，这个提到了输入的个数，那我们就不用while无限循环了， 只需要循环给定的个数就好了。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for(int i=0; i<t; i++){\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            // your business\n            System.out.println(a+b);\n        }\n    }\n}\n```\n\n#### 题目B\n\n输入描述:\n\n```\n输入的第一行包括一个正整数t(1 <= t <= 100), 表示数据组数。\n接下来t行, 每行一组数据。\n每行的第一个整数为整数的个数n(1 <= n <= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n```\n\n输出描述:\n\n```\n每组数据输出求和的结果\n```\n\n示例1\n\n输入\n\n```\n2\n4 1 2 3 4\n5 1 2 3 4 5\n```\n\n输出\n\n```\n10\n15\n```\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for(int i=0; i<t; i++){\n            int n= sc.nextInt();\n            int[] arr = new int[n];\n            for(int j=0; j<n; j++){\n                arr[j] = sc.nextInt();\n            }\n            // your business\n            int sum = 0;\n            for(int num : arr){\n                sum += num;\n            }\n            System.out.println(sum);\n        }\n    }\n}\n```\n\n# 单组输入\n\n通过上面可以看出，多组输入是依靠**for循环**或者**while**用`hasNext()`不停地监控键盘来实现的，与之相比，单组输入就省去了循环。\n\n#### 题目A\n\n输入描述:\n\n```\n输入有两行，第一行n\n\n第二行是n个空格隔开的字符串\n```\n\n输出描述:\n\n```\n输出一行排序后的字符串，空格隔开，无结尾空格\n```\n\n示例1\n\n输入\n\n```\n5\nc d a bb e\n```\n\n输出\n\n```\na bb c d e\n```\n\nTHINKING：在第一行输入一个长度，在第二行输入给定长度的空格隔开的字符串。既然是字符串，我们能否直接拿取到整个字符串，然后空格隔开，按给定的长度来取前部分呢，事实上这么做就没问题的。**如果没有输入长度，而是题目中有要求长度，那么直接用整行再split后取一个长度也ok的**。\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        // 第一行輸入的是一個數字，而且要換行來做下一行的輸入，要用nextLine\n        int n = Integer.parseInt(sc.nextLine());\n        String[] str = sc.nextLine().split(\" \");\n        // your business\n        Arrays.sort(str);\n        StringBuilder sb = new StringBuilder(str[0]);\n        for(int i=1; i<n; i++){\n            sb.append(\" \").append(str[i]);\n        }\n        System.out.println(sb.toString());\n    }\n}\n```\n\n# 总结\n\n​\t\t对于做习惯了Leetcode的“傻瓜式”算法题的人来说，ACM模式有些难以理解，尤其是算法部分都完成了，最后挂在了输入上导致提交不通过的人。但是不管怎么样，毕竟算法都能AC，这个花时间看看也不是很难，而且ACM模式也是主流，不仅仅是牛客，PAT、CodeForces这些也都采用的ACM模式。\n\n​\t\t提交时后台数据都不止一个用例，所以要着重掌握多组输入的情况，对于未告知数量的，用`hasNext()`来循环，单行数据较多或不确定的，使用`nextLine()`直接获取整行数据，再用`split()`分隔开后处理。**虽然是多组数据，但是每喂一组数据，就要调用编写的算法模块去处理一组并且输出**，而不是接受完统一处理。","slug":"acm-standard-inputoutput","published":1,"updated":"2021-05-22T08:28:51.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj7j000gts9q0g46dpx6","content":"<p>​        算法题中通常有两种方式提交代码，一种是核心代码模式，就像LeetCode平台中的那样，还有的就是ACM模式，后者不仅要完成题目中的算法逻辑，还需要定义输入输出，尤其是输入输出，需要符合规范才可以（如果核心代码完成，因为输入输出而丢分就太可惜了）。这篇就是对输入输出的总结，题型来自牛客。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"多组输入\"><a href=\"#多组输入\" class=\"headerlink\" title=\"多组输入\"></a>多组输入</h1><p>根据是否给定组数有两种循环，没有明确组数就用while，给定了的就用for循环一定的次数。<strong>虽然给的示例是多行输入多行输出，但是多组输入实际上是多个测试，每输入一行数据，在回车输入下一行数据前就要有一个输出</strong>。</p>\n<h2 id=\"无限循环\"><a href=\"#无限循环\" class=\"headerlink\" title=\"无限循环\"></a>无限循环</h2><h4 id=\"题目A\"><a href=\"#题目A\" class=\"headerlink\" title=\"题目A\"></a>题目A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据包括多组。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出a+b的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 5</span><br><span class=\"line\">10 20</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：每次输入两个整数，可输入多组，每组都会产生一个结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123; <span class=\"comment\">// next() or nextInt() is ok</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = sc.nextInt();</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            System.out.println(a+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目B\"><a href=\"#题目B\" class=\"headerlink\" title=\"题目B\"></a>题目B</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数据有多组, 每行表示一组输入数据。</span><br><span class=\"line\">每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</span><br><span class=\"line\">接下来n个正整数, 即需要求和的每个正整数。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 1 2 3 4</span><br><span class=\"line\">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：这道题的输入跟下面的带结提示的相比就少了一个结束的判断条件。需要着重注意第一个数字与后面数字的关系处理，应该是<strong>到一定个数后就进入业务逻辑处理，通过输出来进行换行</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">                arr[i] = sc.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : arr)&#123;</span><br><span class=\"line\">                sum += num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目-C\"><a href=\"#题目-C\" class=\"headerlink\" title=\"题目 C\"></a>题目 C</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个测试用例，每个测试用例一行。</span><br><span class=\"line\"></span><br><span class=\"line\">每行通过空格隔开，有n个字符，n＜100</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a c bb</span><br><span class=\"line\">f dddd</span><br><span class=\"line\">nowcoder</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a bb c</span><br><span class=\"line\">dddd f</span><br><span class=\"line\">nowcoder</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：多组输入，只不过每个元素都是字符串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            String[] str = sc.nextLine().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//  your business</span></span><br><span class=\"line\">            Arrays.sort(str);</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(str[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;str.length; i++)&#123;</span><br><span class=\"line\">                sb.append(<span class=\"string\">&quot; &quot;</span>).append(str[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sb.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"结束提示\"><a href=\"#结束提示\" class=\"headerlink\" title=\"结束提示\"></a>结束提示</h3><p>虽然是不限定输入组数，但是给了结束标志，这时在while中添加一个判断条件，符合的话跳出循环。</p>\n<h4 id=\"题目-A\"><a href=\"#题目-A\" class=\"headerlink\" title=\"题目 A\"></a>题目 A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出a+b的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 5</span><br><span class=\"line\">10 20</span><br><span class=\"line\">0 0</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a == <span class=\"number\">0</span> &amp;&amp; b == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            System.out.println(a+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目B-1\"><a href=\"#题目B-1\" class=\"headerlink\" title=\"题目B\"></a>题目B</h4><p>比上面的稍微复杂一点，不过也是根据输入标志退出输入，需要额外处理的就是第一个数字和后面数字的关系</p>\n<p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数据包括多组。</span><br><span class=\"line\">每组数据一行,每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100), n为0的时候结束输入。</span><br><span class=\"line\">接下来n个正整数,即需要求和的每个正整数。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 1 2 3 4</span><br><span class=\"line\">5 1 2 3 4 5</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 注意这里是如何处理第一个数字和后续输入数字的关系的</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">                arr[i] = sc.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : arr)&#123;</span><br><span class=\"line\">                sum += num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目C\"><a href=\"#题目C\" class=\"headerlink\" title=\"题目C\"></a>题目C</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数据有多组, 每行表示一组输入数据。</span><br><span class=\"line\"></span><br><span class=\"line\">每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3</span><br><span class=\"line\">4 5</span><br><span class=\"line\">0 0 0 0 0</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">9</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：这道题与前面的题有所不同了，首先他还是多组输入，每一行算作一组，但是每一组没有给定输入的个数，按照日常的操作来看我们是用回车来判断是否是一组的，在java中如何做呢？答案是方法<code>nextLine()</code>；其次是输入的元素，如果是两个的话，我们读取两次<code>nextInt()</code>就好，但这是不定个数的，再用这个方法会有些麻烦，再看题目，各个输入之间是用空格隔开的，<strong>我们何不按行读取，然后用空格分开</strong>，那么<strong>每一行就被视作一个字符串，用函数<code>nextLine()</code>获取输入的一行就可以了</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            String[] str = sc.nextLine().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(String s : str)&#123;</span><br><span class=\"line\">                sum += Integer.parseInt(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"有限个数\"><a href=\"#有限个数\" class=\"headerlink\" title=\"有限个数\"></a>有限个数</h2><h4 id=\"题目A-1\"><a href=\"#题目A-1\" class=\"headerlink\" title=\"题目A\"></a>题目A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100)</span><br><span class=\"line\">接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9)</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出a+b的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">1 5</span><br><span class=\"line\">10 20</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：相比较没有明确输入组数的，这个提到了输入的个数，那我们就不用while无限循环了， 只需要循环给定的个数就好了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = sc.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;t; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = sc.nextInt();</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            System.out.println(a+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目B-2\"><a href=\"#题目B-2\" class=\"headerlink\" title=\"题目B\"></a>题目B</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。</span><br><span class=\"line\">接下来t行, 每行一组数据。</span><br><span class=\"line\">每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</span><br><span class=\"line\">接下来n个正整数, 即需要求和的每个正整数。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">4 1 2 3 4</span><br><span class=\"line\">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = sc.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;t; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n= sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;n; j++)&#123;</span><br><span class=\"line\">                arr[j] = sc.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : arr)&#123;</span><br><span class=\"line\">                sum += num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"单组输入\"><a href=\"#单组输入\" class=\"headerlink\" title=\"单组输入\"></a>单组输入</h1><p>通过上面可以看出，多组输入是依靠<strong>for循环</strong>或者<strong>while</strong>用<code>hasNext()</code>不停地监控键盘来实现的，与之相比，单组输入就省去了循环。</p>\n<h4 id=\"题目A-2\"><a href=\"#题目A-2\" class=\"headerlink\" title=\"题目A\"></a>题目A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入有两行，第一行n</span><br><span class=\"line\"></span><br><span class=\"line\">第二行是n个空格隔开的字符串</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出一行排序后的字符串，空格隔开，无结尾空格</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">c d a bb e</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a bb c d e</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：在第一行输入一个长度，在第二行输入给定长度的空格隔开的字符串。既然是字符串，我们能否直接拿取到整个字符串，然后空格隔开，按给定的长度来取前部分呢，事实上这么做就没问题的。<strong>如果没有输入长度，而是题目中有要求长度，那么直接用整行再split后取一个长度也ok的</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"comment\">// 第一行輸入的是一個數字，而且要換行來做下一行的輸入，要用nextLine</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = Integer.parseInt(sc.nextLine());</span><br><span class=\"line\">        String[] str = sc.nextLine().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// your business</span></span><br><span class=\"line\">        Arrays.sort(str);</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(str[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">            sb.append(<span class=\"string\">&quot; &quot;</span>).append(str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>​        对于做习惯了Leetcode的“傻瓜式”算法题的人来说，ACM模式有些难以理解，尤其是算法部分都完成了，最后挂在了输入上导致提交不通过的人。但是不管怎么样，毕竟算法都能AC，这个花时间看看也不是很难，而且ACM模式也是主流，不仅仅是牛客，PAT、CodeForces这些也都采用的ACM模式。</p>\n<p>​        提交时后台数据都不止一个用例，所以要着重掌握多组输入的情况，对于未告知数量的，用<code>hasNext()</code>来循环，单行数据较多或不确定的，使用<code>nextLine()</code>直接获取整行数据，再用<code>split()</code>分隔开后处理。<strong>虽然是多组数据，但是每喂一组数据，就要调用编写的算法模块去处理一组并且输出</strong>，而不是接受完统一处理。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>​        算法题中通常有两种方式提交代码，一种是核心代码模式，就像LeetCode平台中的那样，还有的就是ACM模式，后者不仅要完成题目中的算法逻辑，还需要定义输入输出，尤其是输入输出，需要符合规范才可以（如果核心代码完成，因为输入输出而丢分就太可惜了）。这篇就是对输入输出的总结，题型来自牛客。</p>","more":"<h1 id=\"多组输入\"><a href=\"#多组输入\" class=\"headerlink\" title=\"多组输入\"></a>多组输入</h1><p>根据是否给定组数有两种循环，没有明确组数就用while，给定了的就用for循环一定的次数。<strong>虽然给的示例是多行输入多行输出，但是多组输入实际上是多个测试，每输入一行数据，在回车输入下一行数据前就要有一个输出</strong>。</p>\n<h2 id=\"无限循环\"><a href=\"#无限循环\" class=\"headerlink\" title=\"无限循环\"></a>无限循环</h2><h4 id=\"题目A\"><a href=\"#题目A\" class=\"headerlink\" title=\"题目A\"></a>题目A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据包括多组。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出a+b的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 5</span><br><span class=\"line\">10 20</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：每次输入两个整数，可输入多组，每组都会产生一个结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123; <span class=\"comment\">// next() or nextInt() is ok</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = sc.nextInt();</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            System.out.println(a+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目B\"><a href=\"#题目B\" class=\"headerlink\" title=\"题目B\"></a>题目B</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数据有多组, 每行表示一组输入数据。</span><br><span class=\"line\">每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</span><br><span class=\"line\">接下来n个正整数, 即需要求和的每个正整数。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 1 2 3 4</span><br><span class=\"line\">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：这道题的输入跟下面的带结提示的相比就少了一个结束的判断条件。需要着重注意第一个数字与后面数字的关系处理，应该是<strong>到一定个数后就进入业务逻辑处理，通过输出来进行换行</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">                arr[i] = sc.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : arr)&#123;</span><br><span class=\"line\">                sum += num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目-C\"><a href=\"#题目-C\" class=\"headerlink\" title=\"题目 C\"></a>题目 C</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个测试用例，每个测试用例一行。</span><br><span class=\"line\"></span><br><span class=\"line\">每行通过空格隔开，有n个字符，n＜100</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a c bb</span><br><span class=\"line\">f dddd</span><br><span class=\"line\">nowcoder</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a bb c</span><br><span class=\"line\">dddd f</span><br><span class=\"line\">nowcoder</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：多组输入，只不过每个元素都是字符串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            String[] str = sc.nextLine().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//  your business</span></span><br><span class=\"line\">            Arrays.sort(str);</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(str[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;str.length; i++)&#123;</span><br><span class=\"line\">                sb.append(<span class=\"string\">&quot; &quot;</span>).append(str[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sb.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"结束提示\"><a href=\"#结束提示\" class=\"headerlink\" title=\"结束提示\"></a>结束提示</h3><p>虽然是不限定输入组数，但是给了结束标志，这时在while中添加一个判断条件，符合的话跳出循环。</p>\n<h4 id=\"题目-A\"><a href=\"#题目-A\" class=\"headerlink\" title=\"题目 A\"></a>题目 A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出a+b的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 5</span><br><span class=\"line\">10 20</span><br><span class=\"line\">0 0</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a == <span class=\"number\">0</span> &amp;&amp; b == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            System.out.println(a+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目B-1\"><a href=\"#题目B-1\" class=\"headerlink\" title=\"题目B\"></a>题目B</h4><p>比上面的稍微复杂一点，不过也是根据输入标志退出输入，需要额外处理的就是第一个数字和后面数字的关系</p>\n<p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数据包括多组。</span><br><span class=\"line\">每组数据一行,每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100), n为0的时候结束输入。</span><br><span class=\"line\">接下来n个正整数,即需要求和的每个正整数。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 1 2 3 4</span><br><span class=\"line\">5 1 2 3 4 5</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 注意这里是如何处理第一个数字和后续输入数字的关系的</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">                arr[i] = sc.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : arr)&#123;</span><br><span class=\"line\">                sum += num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目C\"><a href=\"#题目C\" class=\"headerlink\" title=\"题目C\"></a>题目C</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数据有多组, 每行表示一组输入数据。</span><br><span class=\"line\"></span><br><span class=\"line\">每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3</span><br><span class=\"line\">4 5</span><br><span class=\"line\">0 0 0 0 0</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">9</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：这道题与前面的题有所不同了，首先他还是多组输入，每一行算作一组，但是每一组没有给定输入的个数，按照日常的操作来看我们是用回车来判断是否是一组的，在java中如何做呢？答案是方法<code>nextLine()</code>；其次是输入的元素，如果是两个的话，我们读取两次<code>nextInt()</code>就好，但这是不定个数的，再用这个方法会有些麻烦，再看题目，各个输入之间是用空格隔开的，<strong>我们何不按行读取，然后用空格分开</strong>，那么<strong>每一行就被视作一个字符串，用函数<code>nextLine()</code>获取输入的一行就可以了</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sc.hasNext())&#123;</span><br><span class=\"line\">            String[] str = sc.nextLine().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(String s : str)&#123;</span><br><span class=\"line\">                sum += Integer.parseInt(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"有限个数\"><a href=\"#有限个数\" class=\"headerlink\" title=\"有限个数\"></a>有限个数</h2><h4 id=\"题目A-1\"><a href=\"#题目A-1\" class=\"headerlink\" title=\"题目A\"></a>题目A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100)</span><br><span class=\"line\">接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9)</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出a+b的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">1 5</span><br><span class=\"line\">10 20</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">30</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：相比较没有明确输入组数的，这个提到了输入的个数，那我们就不用while无限循环了， 只需要循环给定的个数就好了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = sc.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;t; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = sc.nextInt();</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            System.out.println(a+b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"题目B-2\"><a href=\"#题目B-2\" class=\"headerlink\" title=\"题目B\"></a>题目B</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。</span><br><span class=\"line\">接下来t行, 每行一组数据。</span><br><span class=\"line\">每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。</span><br><span class=\"line\">接下来n个正整数, 即需要求和的每个正整数。</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每组数据输出求和的结果</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">4 1 2 3 4</span><br><span class=\"line\">5 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = sc.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;t; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n= sc.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;n; j++)&#123;</span><br><span class=\"line\">                arr[j] = sc.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// your business</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : arr)&#123;</span><br><span class=\"line\">                sum += num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"单组输入\"><a href=\"#单组输入\" class=\"headerlink\" title=\"单组输入\"></a>单组输入</h1><p>通过上面可以看出，多组输入是依靠<strong>for循环</strong>或者<strong>while</strong>用<code>hasNext()</code>不停地监控键盘来实现的，与之相比，单组输入就省去了循环。</p>\n<h4 id=\"题目A-2\"><a href=\"#题目A-2\" class=\"headerlink\" title=\"题目A\"></a>题目A</h4><p>输入描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入有两行，第一行n</span><br><span class=\"line\"></span><br><span class=\"line\">第二行是n个空格隔开的字符串</span><br></pre></td></tr></table></figure>\n\n<p>输出描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出一行排序后的字符串，空格隔开，无结尾空格</span><br></pre></td></tr></table></figure>\n\n<p>示例1</p>\n<p>输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">c d a bb e</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a bb c d e</span><br></pre></td></tr></table></figure>\n\n<p>THINKING：在第一行输入一个长度，在第二行输入给定长度的空格隔开的字符串。既然是字符串，我们能否直接拿取到整个字符串，然后空格隔开，按给定的长度来取前部分呢，事实上这么做就没问题的。<strong>如果没有输入长度，而是题目中有要求长度，那么直接用整行再split后取一个长度也ok的</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"comment\">// 第一行輸入的是一個數字，而且要換行來做下一行的輸入，要用nextLine</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = Integer.parseInt(sc.nextLine());</span><br><span class=\"line\">        String[] str = sc.nextLine().split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// your business</span></span><br><span class=\"line\">        Arrays.sort(str);</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(str[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">            sb.append(<span class=\"string\">&quot; &quot;</span>).append(str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>​        对于做习惯了Leetcode的“傻瓜式”算法题的人来说，ACM模式有些难以理解，尤其是算法部分都完成了，最后挂在了输入上导致提交不通过的人。但是不管怎么样，毕竟算法都能AC，这个花时间看看也不是很难，而且ACM模式也是主流，不仅仅是牛客，PAT、CodeForces这些也都采用的ACM模式。</p>\n<p>​        提交时后台数据都不止一个用例，所以要着重掌握多组输入的情况，对于未告知数量的，用<code>hasNext()</code>来循环，单行数据较多或不确定的，使用<code>nextLine()</code>直接获取整行数据，再用<code>split()</code>分隔开后处理。<strong>虽然是多组数据，但是每喂一组数据，就要调用编写的算法模块去处理一组并且输出</strong>，而不是接受完统一处理。</p>"},{"title":"arraylist-grow","date":"2021-05-12T15:35:52.000Z","_content":"\n以前一直想当然的以为arrayList是双倍扩容（跟HashMap不一样！）……吸取教训，今天总结一下。\n\n<!-- more -->\n\n<!-- toc -->\n\n以下基于*jdk8*分析\n\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n可以看到，在*ensureCapacityInternal*之后就可以进行数组的插入了，而且插入后将size加1了。后一个*size++*容易理解，size记录数组的长度，赋值完元素后加1操作，这里有几个实例变量，`modCount`、`size`、`elementData`。\n\n- `modCount`，继承于AbstractList，用于记录着集合的修改次数，也就是每次add或remove都加1. 是**fail-fast**机制。在初始化迭代器时，**modCount的值会赋给expectedModCount，在迭代的过程中，只要modCount改变了，造成两者不一致，就会抛出currentModificationExpections**。\n- `size`，数组中包含元素的个数\n- `elementData`，数组，也就是ArrayList底层实际存储数据的地方\n\n# 确认容量\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n```\n\n这个方法内将他分为两步\n\n\n\n## 计算capacity\n\n```java\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n```\n\n怎么计算呢？判断是否是空的，如果是的话就赋予默认的容量，否则就返回入参minCapacity，所以，这一步就是为初始化（未指定大小）来做的。\n\n## 明确capacity\n\n```java\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\nadd操作，增加modCount来记录。由于传入的minCapacity是size+1，size是元素的个数（不是数组长度，初始10个坑位，可以只存2个元素），size+1表示期望的元素数量。紧接着判断期望的数量是否大于数组长度，如果大于的话执行执行*grow*方法。\n\n## 扩容\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n不是想象中简单的两倍，但是最终是一样的，拿到一个新的数组，将旧数组的元素复制过去，那么， 新的数组长度如何确认呢？关键就在这个方法中了。\n\n- `oldCapacity`：原始数组长度\n- `newCapacity`：原始数组长度 + 原始数组长度/2 （也就是1.5倍的原始数组长度）\n\n上面两个是初始定义的参数，除了这两个，还会传入一个参数`minCapacity`，这里会有个问题，按照定义的参数，新数组能满足期望的长度么？按理说每次都只是加一个元素，是可以满足的吧？代码中有后续的判断：\n\n- 如果新的容量小于期望容量，那么就将期望容量作为新的容量\n- 如果新的容量大于最大的数组容量，调用*hugeCapacity*来生成新的容量。新的容量有两种来源，一种是1.5倍的原始长度，另一种是被期望长度赋予，无论哪种，这里都要判断是否大于最大值。如果大于的话拿期望值作为参数去计算新的容量。这里也有两种可能：\n  - 1.5倍的原始长度符合期望，但是大于了最大长度，所以不能1.5倍的计算，要拿期望长度重新计算\n  - 1.5倍的原始长度不符合期望，直接拿期望长度作为新的长度，但是新的长度大于了最大长度，所以拿期望长度重新计算\n\n```java\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n大于最大值如何解决？小于0 的话溢出（size+1），抛出内存溢出，大于的话直接拿整型的最大值作为返回值，等于就返回最大值。\n\n# 执行加操作\n\n经过上一步，应该有位置放元素了，正常添加，然后size计数。","source":"_posts/arraylist-grow.md","raw":"---\ntitle: arraylist-grow\ndate: 2021-05-12 23:35:52\ncategories: Java\ntags: summary\n---\n\n以前一直想当然的以为arrayList是双倍扩容（跟HashMap不一样！）……吸取教训，今天总结一下。\n\n<!-- more -->\n\n<!-- toc -->\n\n以下基于*jdk8*分析\n\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n可以看到，在*ensureCapacityInternal*之后就可以进行数组的插入了，而且插入后将size加1了。后一个*size++*容易理解，size记录数组的长度，赋值完元素后加1操作，这里有几个实例变量，`modCount`、`size`、`elementData`。\n\n- `modCount`，继承于AbstractList，用于记录着集合的修改次数，也就是每次add或remove都加1. 是**fail-fast**机制。在初始化迭代器时，**modCount的值会赋给expectedModCount，在迭代的过程中，只要modCount改变了，造成两者不一致，就会抛出currentModificationExpections**。\n- `size`，数组中包含元素的个数\n- `elementData`，数组，也就是ArrayList底层实际存储数据的地方\n\n# 确认容量\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n```\n\n这个方法内将他分为两步\n\n\n\n## 计算capacity\n\n```java\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n```\n\n怎么计算呢？判断是否是空的，如果是的话就赋予默认的容量，否则就返回入参minCapacity，所以，这一步就是为初始化（未指定大小）来做的。\n\n## 明确capacity\n\n```java\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\nadd操作，增加modCount来记录。由于传入的minCapacity是size+1，size是元素的个数（不是数组长度，初始10个坑位，可以只存2个元素），size+1表示期望的元素数量。紧接着判断期望的数量是否大于数组长度，如果大于的话执行执行*grow*方法。\n\n## 扩容\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n不是想象中简单的两倍，但是最终是一样的，拿到一个新的数组，将旧数组的元素复制过去，那么， 新的数组长度如何确认呢？关键就在这个方法中了。\n\n- `oldCapacity`：原始数组长度\n- `newCapacity`：原始数组长度 + 原始数组长度/2 （也就是1.5倍的原始数组长度）\n\n上面两个是初始定义的参数，除了这两个，还会传入一个参数`minCapacity`，这里会有个问题，按照定义的参数，新数组能满足期望的长度么？按理说每次都只是加一个元素，是可以满足的吧？代码中有后续的判断：\n\n- 如果新的容量小于期望容量，那么就将期望容量作为新的容量\n- 如果新的容量大于最大的数组容量，调用*hugeCapacity*来生成新的容量。新的容量有两种来源，一种是1.5倍的原始长度，另一种是被期望长度赋予，无论哪种，这里都要判断是否大于最大值。如果大于的话拿期望值作为参数去计算新的容量。这里也有两种可能：\n  - 1.5倍的原始长度符合期望，但是大于了最大长度，所以不能1.5倍的计算，要拿期望长度重新计算\n  - 1.5倍的原始长度不符合期望，直接拿期望长度作为新的长度，但是新的长度大于了最大长度，所以拿期望长度重新计算\n\n```java\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n大于最大值如何解决？小于0 的话溢出（size+1），抛出内存溢出，大于的话直接拿整型的最大值作为返回值，等于就返回最大值。\n\n# 执行加操作\n\n经过上一步，应该有位置放元素了，正常添加，然后size计数。","slug":"arraylist-grow","published":1,"updated":"2021-05-13T04:12:20.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj7o000its9q5ovlcoal","content":"<p>以前一直想当然的以为arrayList是双倍扩容（跟HashMap不一样！）……吸取教训，今天总结一下。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<p>以下基于<em>jdk8</em>分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在<em>ensureCapacityInternal</em>之后就可以进行数组的插入了，而且插入后将size加1了。后一个*size++*容易理解，size记录数组的长度，赋值完元素后加1操作，这里有几个实例变量，<code>modCount</code>、<code>size</code>、<code>elementData</code>。</p>\n<ul>\n<li><code>modCount</code>，继承于AbstractList，用于记录着集合的修改次数，也就是每次add或remove都加1. 是<strong>fail-fast</strong>机制。在初始化迭代器时，<strong>modCount的值会赋给expectedModCount，在迭代的过程中，只要modCount改变了，造成两者不一致，就会抛出currentModificationExpections</strong>。</li>\n<li><code>size</code>，数组中包含元素的个数</li>\n<li><code>elementData</code>，数组，也就是ArrayList底层实际存储数据的地方</li>\n</ul>\n<h1 id=\"确认容量\"><a href=\"#确认容量\" class=\"headerlink\" title=\"确认容量\"></a>确认容量</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法内将他分为两步</p>\n<h2 id=\"计算capacity\"><a href=\"#计算capacity\" class=\"headerlink\" title=\"计算capacity\"></a>计算capacity</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么计算呢？判断是否是空的，如果是的话就赋予默认的容量，否则就返回入参minCapacity，所以，这一步就是为初始化（未指定大小）来做的。</p>\n<h2 id=\"明确capacity\"><a href=\"#明确capacity\" class=\"headerlink\" title=\"明确capacity\"></a>明确capacity</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>add操作，增加modCount来记录。由于传入的minCapacity是size+1，size是元素的个数（不是数组长度，初始10个坑位，可以只存2个元素），size+1表示期望的元素数量。紧接着判断期望的数量是否大于数组长度，如果大于的话执行执行<em>grow</em>方法。</p>\n<h2 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不是想象中简单的两倍，但是最终是一样的，拿到一个新的数组，将旧数组的元素复制过去，那么， 新的数组长度如何确认呢？关键就在这个方法中了。</p>\n<ul>\n<li><code>oldCapacity</code>：原始数组长度</li>\n<li><code>newCapacity</code>：原始数组长度 + 原始数组长度/2 （也就是1.5倍的原始数组长度）</li>\n</ul>\n<p>上面两个是初始定义的参数，除了这两个，还会传入一个参数<code>minCapacity</code>，这里会有个问题，按照定义的参数，新数组能满足期望的长度么？按理说每次都只是加一个元素，是可以满足的吧？代码中有后续的判断：</p>\n<ul>\n<li>如果新的容量小于期望容量，那么就将期望容量作为新的容量</li>\n<li>如果新的容量大于最大的数组容量，调用<em>hugeCapacity</em>来生成新的容量。新的容量有两种来源，一种是1.5倍的原始长度，另一种是被期望长度赋予，无论哪种，这里都要判断是否大于最大值。如果大于的话拿期望值作为参数去计算新的容量。这里也有两种可能：<ul>\n<li>1.5倍的原始长度符合期望，但是大于了最大长度，所以不能1.5倍的计算，要拿期望长度重新计算</li>\n<li>1.5倍的原始长度不符合期望，直接拿期望长度作为新的长度，但是新的长度大于了最大长度，所以拿期望长度重新计算</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大于最大值如何解决？小于0 的话溢出（size+1），抛出内存溢出，大于的话直接拿整型的最大值作为返回值，等于就返回最大值。</p>\n<h1 id=\"执行加操作\"><a href=\"#执行加操作\" class=\"headerlink\" title=\"执行加操作\"></a>执行加操作</h1><p>经过上一步，应该有位置放元素了，正常添加，然后size计数。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>以前一直想当然的以为arrayList是双倍扩容（跟HashMap不一样！）……吸取教训，今天总结一下。</p>","more":"<!-- toc -->\n\n<p>以下基于<em>jdk8</em>分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在<em>ensureCapacityInternal</em>之后就可以进行数组的插入了，而且插入后将size加1了。后一个*size++*容易理解，size记录数组的长度，赋值完元素后加1操作，这里有几个实例变量，<code>modCount</code>、<code>size</code>、<code>elementData</code>。</p>\n<ul>\n<li><code>modCount</code>，继承于AbstractList，用于记录着集合的修改次数，也就是每次add或remove都加1. 是<strong>fail-fast</strong>机制。在初始化迭代器时，<strong>modCount的值会赋给expectedModCount，在迭代的过程中，只要modCount改变了，造成两者不一致，就会抛出currentModificationExpections</strong>。</li>\n<li><code>size</code>，数组中包含元素的个数</li>\n<li><code>elementData</code>，数组，也就是ArrayList底层实际存储数据的地方</li>\n</ul>\n<h1 id=\"确认容量\"><a href=\"#确认容量\" class=\"headerlink\" title=\"确认容量\"></a>确认容量</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法内将他分为两步</p>\n<h2 id=\"计算capacity\"><a href=\"#计算capacity\" class=\"headerlink\" title=\"计算capacity\"></a>计算capacity</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么计算呢？判断是否是空的，如果是的话就赋予默认的容量，否则就返回入参minCapacity，所以，这一步就是为初始化（未指定大小）来做的。</p>\n<h2 id=\"明确capacity\"><a href=\"#明确capacity\" class=\"headerlink\" title=\"明确capacity\"></a>明确capacity</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>add操作，增加modCount来记录。由于传入的minCapacity是size+1，size是元素的个数（不是数组长度，初始10个坑位，可以只存2个元素），size+1表示期望的元素数量。紧接着判断期望的数量是否大于数组长度，如果大于的话执行执行<em>grow</em>方法。</p>\n<h2 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不是想象中简单的两倍，但是最终是一样的，拿到一个新的数组，将旧数组的元素复制过去，那么， 新的数组长度如何确认呢？关键就在这个方法中了。</p>\n<ul>\n<li><code>oldCapacity</code>：原始数组长度</li>\n<li><code>newCapacity</code>：原始数组长度 + 原始数组长度/2 （也就是1.5倍的原始数组长度）</li>\n</ul>\n<p>上面两个是初始定义的参数，除了这两个，还会传入一个参数<code>minCapacity</code>，这里会有个问题，按照定义的参数，新数组能满足期望的长度么？按理说每次都只是加一个元素，是可以满足的吧？代码中有后续的判断：</p>\n<ul>\n<li>如果新的容量小于期望容量，那么就将期望容量作为新的容量</li>\n<li>如果新的容量大于最大的数组容量，调用<em>hugeCapacity</em>来生成新的容量。新的容量有两种来源，一种是1.5倍的原始长度，另一种是被期望长度赋予，无论哪种，这里都要判断是否大于最大值。如果大于的话拿期望值作为参数去计算新的容量。这里也有两种可能：<ul>\n<li>1.5倍的原始长度符合期望，但是大于了最大长度，所以不能1.5倍的计算，要拿期望长度重新计算</li>\n<li>1.5倍的原始长度不符合期望，直接拿期望长度作为新的长度，但是新的长度大于了最大长度，所以拿期望长度重新计算</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大于最大值如何解决？小于0 的话溢出（size+1），抛出内存溢出，大于的话直接拿整型的最大值作为返回值，等于就返回最大值。</p>\n<h1 id=\"执行加操作\"><a href=\"#执行加操作\" class=\"headerlink\" title=\"执行加操作\"></a>执行加操作</h1><p>经过上一步，应该有位置放元素了，正常添加，然后size计数。</p>"},{"title":"binary search tree","date":"2021-02-27T07:58:06.000Z","_content":"\n这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 遍历\n\n二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。\n\n```java\npublic List<Integer> getValuesFromBST(TreeNode root){\n    TreeNode p = root;\n    List<Integer> list = new ArrayList<>();\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        list.add(p.val); // u can do anything here\n        p = p.right;\n    }\n    \n    return list;\n}\n```\n\n按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。\n\n# 有效\n\n根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：\n\n```java\npublic boolean isBSTValid(TreeNode root){\n    TreeNode p = root;\n    TreeNode pre = null; // 记录前一个节点\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p.left != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        if(pre != null && p.val <= pre.val){ // 判断是否合法\n            return false;\n        }\n        pre = p;\n        p = p.right;\n    }\n\n    return true;\n}\n```\n\n\n\n# 其他\n\n其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*[Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)*。","source":"_posts/binary-search-tre.md","raw":"---\ntitle: binary search tree\ndate: 2021-02-27 15:58:06\ncategories: Leetcode\ntags: bst\n---\n\n这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 遍历\n\n二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。\n\n```java\npublic List<Integer> getValuesFromBST(TreeNode root){\n    TreeNode p = root;\n    List<Integer> list = new ArrayList<>();\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        list.add(p.val); // u can do anything here\n        p = p.right;\n    }\n    \n    return list;\n}\n```\n\n按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。\n\n# 有效\n\n根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：\n\n```java\npublic boolean isBSTValid(TreeNode root){\n    TreeNode p = root;\n    TreeNode pre = null; // 记录前一个节点\n    Deque<TreeNode> deque = new ArrayDeque<>();\n    whlie(p != null || deque.isEmpty()){\n        while(p.left != null){\n            deque.offerLast(p);\n            p = p.left;\n        }\n        p = deque.pollLast();\n        if(pre != null && p.val <= pre.val){ // 判断是否合法\n            return false;\n        }\n        pre = p;\n        p = p.right;\n    }\n\n    return true;\n}\n```\n\n\n\n# 其他\n\n其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*[Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)*。","slug":"binary-search-tre","published":1,"updated":"2021-03-28T10:20:02.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj7s000nts9q195ogwm9","content":"<p>这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h1><p>二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">getValuesFromBST</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        list.add(p.val); <span class=\"comment\">// u can do anything here</span></span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。</p>\n<h1 id=\"有效\"><a href=\"#有效\" class=\"headerlink\" title=\"有效\"></a>有效</h1><p>根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBSTValid</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    TreeNode pre = <span class=\"keyword\">null</span>; <span class=\"comment\">// 记录前一个节点</span></span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"keyword\">null</span> &amp;&amp; p.val &lt;= pre.val)&#123; <span class=\"comment\">// 判断是否合法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*<a href=\"https://leetcode.com/problems/score-of-parentheses/\">Score of Parentheses</a>*。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇看看二分查找树，提到二分，有我们已知的二分搜索，它用在已排序的线性表，跟这个二分查找树又有什么关系呢？我想答案应该是方便维护。对于线性表，如果除了查询外还会往里面存入数据，那么我们需要频繁地去排序来让数组变得有序；对于树来讲，新增加节点，我们只需修改部分分支，且尽量让他保持平衡。</p>","more":"<!-- toc -->\n\n<h1 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h1><p>二叉树有前中后序遍历，其中，中序遍历能使我们得到二叉树从小到大的节点值。如何能按照中序遍历二叉树呢？根据我们的习惯，从左侧最下方开始找，按照这个思路，必然是一个深度优先的算法，可以从递归和迭代两个思路入手。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">getValuesFromBST</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        list.add(p.val); <span class=\"comment\">// u can do anything here</span></span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照上面遍历的代码，其实我们还可以做更多的事情，毕竟都能便利出来了，其他的诸如取前N个数、验证BST是否合法等等其他的都可以参照这个来做。</p>\n<h1 id=\"有效\"><a href=\"#有效\" class=\"headerlink\" title=\"有效\"></a>有效</h1><p>根据二叉树“左小右大”的特点，在进行中序遍历时就可以来验证他的有效性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBSTValid</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">    TreeNode p = root;</span><br><span class=\"line\">    TreeNode pre = <span class=\"keyword\">null</span>; <span class=\"comment\">// 记录前一个节点</span></span><br><span class=\"line\">    Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    whlie(p != <span class=\"keyword\">null</span> || deque.isEmpty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            deque.offerLast(p);</span><br><span class=\"line\">            p = p.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p = deque.pollLast();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"keyword\">null</span> &amp;&amp; p.val &lt;= pre.val)&#123; <span class=\"comment\">// 判断是否合法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        p = p.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>其实BST的可玩性挺高的，想对于其他数据结构，BST是活灵活现地展示出来的，而且还有具有二分查找的效率、左小右大的规律，所以题目大多来源于他的展示，例如打印前序遍历、中序遍历、层序遍历等等。还有一种是比较隐晦的，例如这道题：*<a href=\"https://leetcode.com/problems/score-of-parentheses/\">Score of Parentheses</a>*。</p>"},{"title":"bitwise","date":"2020-06-01T13:11:25.000Z","_content":"\nIntroduction of Java bitwise and operation.\n\n<!-- more -->\n\n# 简介\n\n| 操作符 | 名称         | 描述              |\n| ------ | ------------ | ----------------- |\n| &      | 与           | 1 & 1 = 1 (only)  |\n| \\|     | 或           | 0 \\| 0 = 0 (only) |\n| ^      | 异或         | 1 ^ 0 = 1         |\n| ~      | 非           | ~ 1 = 0           |\n| <<     | 左移         | 右边空出来的补0   |\n| >>     | 带符号位右移 | 最高位补符号位    |\n| >>>    | 无符号位右移 | 左边空出来的补0   |\n\n位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，<<=以及>>>=。\n\n位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。\n\n## 举例\n\n```java\nint a = -1;\n// 11111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a));\n// -1\nSystem.out.printlnl(a>>1);\n// 1111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a>>1));\n// 2147483647\nSystem.out.println(a>>>1);\n// 0111111111111111111111111111111111(31个1)\nSystem.out.prinlnt(Integer.toBinaryString(a>>>1));\n```\n\n### 分析：\n\n#### a>>1\n\n原码：10000000000000000000000000000001\n\n反码：1111111111111111111111111111111111110\n\n补码：1111111111111111111111111111111111111\n\n补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）\n\n取反：10000000000000000000000000000000\n\n原码：10000000000000000000000000000001 即 -1.\n\n#### a>>>1\n\n同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。\n\n补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）\n\n正数原码即补码。\n\n# 应用\n\n## HashMap\n\n```java\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的`^`, `|`, `<<`, `<<<`等位运算符。\n\n## 奇偶性\n\n```java\n2 & 1; // 0\n8 & 1; // 0\n7 & 1; // 1\n```\n\n1的原码：0001\n\n8的原码：1000\n\n7的原码：0111\n\n**奇数的最低位永远是1,偶数的为0**.\n\n## 求非重复数字\n\n```markdown\n2 ^ 2 ^ 1 = 1\n4 ^ 2 ^ 1 ^ 1 ^ 2 = 4\n```\n\n两个**相同的数字**做`^`运算时，值为`0`，再结合**交换律**，可以用来找出一组数字中“落单”的数字。\n\n## etc\n\n……\n\n","source":"_posts/bitwise.md","raw":"---\ntitle: bitwise\ndate: 2020-06-01 21:11:25\ncategories: Java\ntags: bitwise\n---\n\nIntroduction of Java bitwise and operation.\n\n<!-- more -->\n\n# 简介\n\n| 操作符 | 名称         | 描述              |\n| ------ | ------------ | ----------------- |\n| &      | 与           | 1 & 1 = 1 (only)  |\n| \\|     | 或           | 0 \\| 0 = 0 (only) |\n| ^      | 异或         | 1 ^ 0 = 1         |\n| ~      | 非           | ~ 1 = 0           |\n| <<     | 左移         | 右边空出来的补0   |\n| >>     | 带符号位右移 | 最高位补符号位    |\n| >>>    | 无符号位右移 | 左边空出来的补0   |\n\n位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，<<=以及>>>=。\n\n位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。\n\n## 举例\n\n```java\nint a = -1;\n// 11111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a));\n// -1\nSystem.out.printlnl(a>>1);\n// 1111111111111111111111111111111111(32个1)\nSystem.out.println(Integer.toBinaryString(a>>1));\n// 2147483647\nSystem.out.println(a>>>1);\n// 0111111111111111111111111111111111(31个1)\nSystem.out.prinlnt(Integer.toBinaryString(a>>>1));\n```\n\n### 分析：\n\n#### a>>1\n\n原码：10000000000000000000000000000001\n\n反码：1111111111111111111111111111111111110\n\n补码：1111111111111111111111111111111111111\n\n补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）\n\n取反：10000000000000000000000000000000\n\n原码：10000000000000000000000000000001 即 -1.\n\n#### a>>>1\n\n同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。\n\n补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）\n\n正数原码即补码。\n\n# 应用\n\n## HashMap\n\n```java\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的`^`, `|`, `<<`, `<<<`等位运算符。\n\n## 奇偶性\n\n```java\n2 & 1; // 0\n8 & 1; // 0\n7 & 1; // 1\n```\n\n1的原码：0001\n\n8的原码：1000\n\n7的原码：0111\n\n**奇数的最低位永远是1,偶数的为0**.\n\n## 求非重复数字\n\n```markdown\n2 ^ 2 ^ 1 = 1\n4 ^ 2 ^ 1 ^ 1 ^ 2 = 4\n```\n\n两个**相同的数字**做`^`运算时，值为`0`，再结合**交换律**，可以用来找出一组数字中“落单”的数字。\n\n## etc\n\n……\n\n","slug":"bitwise","published":1,"updated":"2021-05-22T13:37:04.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj7w000pts9qdvy7a0mb","content":"<p>Introduction of Java bitwise and operation.</p>\n<span id=\"more\"></span>\n\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>与</td>\n<td>1 &amp; 1 = 1 (only)</td>\n</tr>\n<tr>\n<td>|</td>\n<td>或</td>\n<td>0 | 0 = 0 (only)</td>\n</tr>\n<tr>\n<td>^</td>\n<td>异或</td>\n<td>1 ^ 0 = 1</td>\n</tr>\n<tr>\n<td>~</td>\n<td>非</td>\n<td>~ 1 = 0</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移</td>\n<td>右边空出来的补0</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>带符号位右移</td>\n<td>最高位补符号位</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td>无符号位右移</td>\n<td>左边空出来的补0</td>\n</tr>\n</tbody></table>\n<p>位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，&lt;&lt;=以及&gt;&gt;&gt;=。</p>\n<p>位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 11111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a));</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\">System.out.printlnl(a&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a&gt;&gt;<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2147483647</span></span><br><span class=\"line\">System.out.println(a&gt;&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 0111111111111111111111111111111111(31个1)</span></span><br><span class=\"line\">System.out.prinlnt(Integer.toBinaryString(a&gt;&gt;&gt;<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><h4 id=\"a-gt-gt-1\"><a href=\"#a-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;1\"></a>a&gt;&gt;1</h4><p>原码：10000000000000000000000000000001</p>\n<p>反码：1111111111111111111111111111111111110</p>\n<p>补码：1111111111111111111111111111111111111</p>\n<p>补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）</p>\n<p>取反：10000000000000000000000000000000</p>\n<p>原码：10000000000000000000000000000001 即 -1.</p>\n<h4 id=\"a-gt-gt-gt-1\"><a href=\"#a-gt-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;&gt;1\"></a>a&gt;&gt;&gt;1</h4><p>同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。</p>\n<p>补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）</p>\n<p>正数原码即补码。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的<code>^</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;&lt;</code>等位运算符。</p>\n<h2 id=\"奇偶性\"><a href=\"#奇偶性\" class=\"headerlink\" title=\"奇偶性\"></a>奇偶性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">8</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">7</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>1的原码：0001</p>\n<p>8的原码：1000</p>\n<p>7的原码：0111</p>\n<p><strong>奇数的最低位永远是1,偶数的为0</strong>.</p>\n<h2 id=\"求非重复数字\"><a href=\"#求非重复数字\" class=\"headerlink\" title=\"求非重复数字\"></a>求非重复数字</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 ^ 2 ^ 1 = 1</span><br><span class=\"line\">4 ^ 2 ^ 1 ^ 1 ^ 2 = 4</span><br></pre></td></tr></table></figure>\n\n<p>两个<strong>相同的数字</strong>做<code>^</code>运算时，值为<code>0</code>，再结合<strong>交换律</strong>，可以用来找出一组数字中“落单”的数字。</p>\n<h2 id=\"etc\"><a href=\"#etc\" class=\"headerlink\" title=\"etc\"></a>etc</h2><p>……</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Introduction of Java bitwise and operation.</p>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>与</td>\n<td>1 &amp; 1 = 1 (only)</td>\n</tr>\n<tr>\n<td>|</td>\n<td>或</td>\n<td>0 | 0 = 0 (only)</td>\n</tr>\n<tr>\n<td>^</td>\n<td>异或</td>\n<td>1 ^ 0 = 1</td>\n</tr>\n<tr>\n<td>~</td>\n<td>非</td>\n<td>~ 1 = 0</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移</td>\n<td>右边空出来的补0</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>带符号位右移</td>\n<td>最高位补符号位</td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td>无符号位右移</td>\n<td>左边空出来的补0</td>\n</tr>\n</tbody></table>\n<p>位操作符仅适用于整数类型（byte, short, int, long）。位操作涉及的字符将转换为整数。所有的位操作符可以构成位赋值操作符，例如=，|=，&lt;&lt;=以及&gt;&gt;&gt;=。</p>\n<p>位运算都是补码运算的，其中，负数做补码时，符号位不变，其余取反后加一；运算完成后，再做一遍之前的操作，得到源码。</p>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 11111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a));</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\">System.out.printlnl(a&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1111111111111111111111111111111111(32个1)</span></span><br><span class=\"line\">System.out.println(Integer.toBinaryString(a&gt;&gt;<span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">// 2147483647</span></span><br><span class=\"line\">System.out.println(a&gt;&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 0111111111111111111111111111111111(31个1)</span></span><br><span class=\"line\">System.out.prinlnt(Integer.toBinaryString(a&gt;&gt;&gt;<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><h4 id=\"a-gt-gt-1\"><a href=\"#a-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;1\"></a>a&gt;&gt;1</h4><p>原码：10000000000000000000000000000001</p>\n<p>反码：1111111111111111111111111111111111110</p>\n<p>补码：1111111111111111111111111111111111111</p>\n<p>补码做运算：11111111111111111111111111111111111111（右移一位，左侧空位用符号位（1）来补）</p>\n<p>取反：10000000000000000000000000000000</p>\n<p>原码：10000000000000000000000000000001 即 -1.</p>\n<h4 id=\"a-gt-gt-gt-1\"><a href=\"#a-gt-gt-gt-1\" class=\"headerlink\" title=\"a&gt;&gt;&gt;1\"></a>a&gt;&gt;&gt;1</h4><p>同样是补码运算，只是在后续操作中，将符号位看作是数字，那么该补码就如同正数补码一样。</p>\n<p>补码做运算：011111111111111111111111111111111111（右移一位，左侧空位用（0）来补）</p>\n<p>正数原码即补码。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上例代码基于jdk1.8，hashmap获取hash值的示例代码。在该类中使用了大量的<code>^</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&lt;&lt;&lt;</code>等位运算符。</p>\n<h2 id=\"奇偶性\"><a href=\"#奇偶性\" class=\"headerlink\" title=\"奇偶性\"></a>奇偶性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">8</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"number\">7</span> &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>1的原码：0001</p>\n<p>8的原码：1000</p>\n<p>7的原码：0111</p>\n<p><strong>奇数的最低位永远是1,偶数的为0</strong>.</p>\n<h2 id=\"求非重复数字\"><a href=\"#求非重复数字\" class=\"headerlink\" title=\"求非重复数字\"></a>求非重复数字</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 ^ 2 ^ 1 = 1</span><br><span class=\"line\">4 ^ 2 ^ 1 ^ 1 ^ 2 = 4</span><br></pre></td></tr></table></figure>\n\n<p>两个<strong>相同的数字</strong>做<code>^</code>运算时，值为<code>0</code>，再结合<strong>交换律</strong>，可以用来找出一组数字中“落单”的数字。</p>\n<h2 id=\"etc\"><a href=\"#etc\" class=\"headerlink\" title=\"etc\"></a>etc</h2><p>……</p>"},{"title":"decorating","date":"2020-06-12T10:30:28.000Z","_content":"\n继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。\n\n<!-- more -->\n\n# 场景\n\n一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是`Beverage`抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso... 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。\n\n如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？\n\n> 类应该堆扩展开放，对修改关闭。\n\n\n\n# 装饰者模式\n\n以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。\n\n1. DarkRoast对象\n2. 用摩卡装饰\n3. 用奶泡装饰\n4. 调用cost方法，依赖delegate添加价钱\n\n\n\n# 实现\n\n![Screenshot from 2020-06-12 20-50-33.png](https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png)\n\n\n\n其中`Condiment`是调料类，重写了`Beverage`的`getDescription`方法。以Whip为例：\n\n```java\npublic class Whip extends Condiment {\n    Beverage beverage;\n\n    public Whip(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription() {\n        return beverage.getDescription() + \", Whip\";\n    }\n\n    @Override\n    public double cost() {\n        return .30 + beverage.cost();\n    }\n}\n```\n\n它的_cost_方法入获取description的方法如出一辙，这样的好处在于：\n\n```java\nBeverage beverage1 = new DarRoast();\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Whip(beverage1);\nSystem.out.println(beverage1.getDescription() + \" $\" + beverage1.cost());\n```\n\n```console\nBrazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75\n```\n\n制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为**委托**.\n\n# 应用\n\n## Java I/O\n\n大量的`Decorator Pattern`在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。\n\n```flow\npara1=>parallel: FileInputStream\npara2=>parallel: BufferedInputStream\npara3=>parallel: LineNumberInputStream\nop1=>operation: Beferage\nop2=>operation: Espresso\nop3=>operation: Mocha\npara1(path1, bottom)->para2\npara2(path1,bottom)->para3\npara1(path2, right)->op1\npara2(path2, right)->op2\npara3(path2, right)->op3\n```\n\n","source":"_posts/decorating.md","raw":"---\n\ntitle: decorating\ndate: 2020-06-12 18:30:28\ncategories: DesignPatterns\ntags: design_patterns\n---\n\n继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。\n\n<!-- more -->\n\n# 场景\n\n一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是`Beverage`抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso... 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。\n\n如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？\n\n> 类应该堆扩展开放，对修改关闭。\n\n\n\n# 装饰者模式\n\n以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。\n\n1. DarkRoast对象\n2. 用摩卡装饰\n3. 用奶泡装饰\n4. 调用cost方法，依赖delegate添加价钱\n\n\n\n# 实现\n\n![Screenshot from 2020-06-12 20-50-33.png](https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png)\n\n\n\n其中`Condiment`是调料类，重写了`Beverage`的`getDescription`方法。以Whip为例：\n\n```java\npublic class Whip extends Condiment {\n    Beverage beverage;\n\n    public Whip(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public String getDescription() {\n        return beverage.getDescription() + \", Whip\";\n    }\n\n    @Override\n    public double cost() {\n        return .30 + beverage.cost();\n    }\n}\n```\n\n它的_cost_方法入获取description的方法如出一辙，这样的好处在于：\n\n```java\nBeverage beverage1 = new DarRoast();\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Mocha(beverage1);\nbeverage1 = new Whip(beverage1);\nSystem.out.println(beverage1.getDescription() + \" $\" + beverage1.cost());\n```\n\n```console\nBrazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75\n```\n\n制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为**委托**.\n\n# 应用\n\n## Java I/O\n\n大量的`Decorator Pattern`在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。\n\n```flow\npara1=>parallel: FileInputStream\npara2=>parallel: BufferedInputStream\npara3=>parallel: LineNumberInputStream\nop1=>operation: Beferage\nop2=>operation: Espresso\nop3=>operation: Mocha\npara1(path1, bottom)->para2\npara2(path1,bottom)->para3\npara1(path2, right)->op1\npara2(path2, right)->op2\npara3(path2, right)->op3\n```\n\n","slug":"decorating","published":1,"updated":"2021-04-05T05:44:14.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj82000tts9q7cnb0nrh","content":"<p>继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是<code>Beverage</code>抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso… 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。</p>\n<p>如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？</p>\n<blockquote>\n<p>类应该堆扩展开放，对修改关闭。</p>\n</blockquote>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><p>以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。</p>\n<ol>\n<li>DarkRoast对象</li>\n<li>用摩卡装饰</li>\n<li>用奶泡装饰</li>\n<li>调用cost方法，依赖delegate添加价钱</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p><img src=\"https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png\" alt=\"Screenshot from 2020-06-12 20-50-33.png\"></p>\n<p>其中<code>Condiment</code>是调料类，重写了<code>Beverage</code>的<code>getDescription</code>方法。以Whip为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Whip</span> <span class=\"keyword\">extends</span> <span class=\"title\">Condiment</span> </span>&#123;</span><br><span class=\"line\">    Beverage beverage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Whip</span><span class=\"params\">(Beverage beverage)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.beverage = beverage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDescription</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> beverage.getDescription() + <span class=\"string\">&quot;, Whip&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">cost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">.30</span> + beverage.cost();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的_cost_方法入获取description的方法如出一辙，这样的好处在于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Beverage beverage1 = <span class=\"keyword\">new</span> DarRoast();</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Whip(beverage1);</span><br><span class=\"line\">System.out.println(beverage1.getDescription() + <span class=\"string\">&quot; $&quot;</span> + beverage1.cost());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Brazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75</span><br></pre></td></tr></table></figure>\n\n<p>制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为<strong>委托</strong>.</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"Java-I-O\"><a href=\"#Java-I-O\" class=\"headerlink\" title=\"Java I/O\"></a>Java I/O</h2><p>大量的<code>Decorator Pattern</code>在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para1&#x3D;&gt;parallel: FileInputStream</span><br><span class=\"line\">para2&#x3D;&gt;parallel: BufferedInputStream</span><br><span class=\"line\">para3&#x3D;&gt;parallel: LineNumberInputStream</span><br><span class=\"line\">op1&#x3D;&gt;operation: Beferage</span><br><span class=\"line\">op2&#x3D;&gt;operation: Espresso</span><br><span class=\"line\">op3&#x3D;&gt;operation: Mocha</span><br><span class=\"line\">para1(path1, bottom)-&gt;para2</span><br><span class=\"line\">para2(path1,bottom)-&gt;para3</span><br><span class=\"line\">para1(path2, right)-&gt;op1</span><br><span class=\"line\">para2(path2, right)-&gt;op2</span><br><span class=\"line\">para3(path2, right)-&gt;op3</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>继承滥用：一个父类下有成百上千个子类，还无法高效解决问题，怎么优化？装饰者模式。</p>","more":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>一家咖啡厅售卖咖啡，在这里讨论的当然是网上售卖。父类是<code>Beverage</code>抽象类，包含一个抽象方法_cost()_，根据不同口味实现不同的价格，诸如HouseBlend, DarkRoast Decaf, Espresso… 购买咖啡时，也可以加入各种调料，如豆浆、摩卡等等，这些也是要收费的，最终下单时会将这些所有整合。</p>\n<p>如何高效设计呢？如果某个调料价格上涨该从何处修改？新增原料怎么办？</p>\n<blockquote>\n<p>类应该堆扩展开放，对修改关闭。</p>\n</blockquote>\n<h1 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h1><p>以上个场景为例，以父类为主体，在运行时以调味料来“装饰”父类，最终得到顾客想要的口味。</p>\n<ol>\n<li>DarkRoast对象</li>\n<li>用摩卡装饰</li>\n<li>用奶泡装饰</li>\n<li>调用cost方法，依赖delegate添加价钱</li>\n</ol>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><p><img src=\"https://i.loli.net/2020/06/12/jQwAkbz7V6n8dGK.png\" alt=\"Screenshot from 2020-06-12 20-50-33.png\"></p>\n<p>其中<code>Condiment</code>是调料类，重写了<code>Beverage</code>的<code>getDescription</code>方法。以Whip为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Whip</span> <span class=\"keyword\">extends</span> <span class=\"title\">Condiment</span> </span>&#123;</span><br><span class=\"line\">    Beverage beverage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Whip</span><span class=\"params\">(Beverage beverage)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.beverage = beverage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDescription</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> beverage.getDescription() + <span class=\"string\">&quot;, Whip&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">cost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">.30</span> + beverage.cost();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的_cost_方法入获取description的方法如出一辙，这样的好处在于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Beverage beverage1 = <span class=\"keyword\">new</span> DarRoast();</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Mocha(beverage1);</span><br><span class=\"line\">beverage1 = <span class=\"keyword\">new</span> Whip(beverage1);</span><br><span class=\"line\">System.out.println(beverage1.getDescription() + <span class=\"string\">&quot; $&quot;</span> + beverage1.cost());</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Brazil Dark Roast Coffee, Mocha, Mocha, Whip $2.75</span><br></pre></td></tr></table></figure>\n\n<p>制作一杯咖啡时，添加不同的调料只需要创建调料的实例，里面装上饮料父类，最后打印出描述和价格的时候，会自动加上父类的。这样的方式不妨称之为<strong>委托</strong>.</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"Java-I-O\"><a href=\"#Java-I-O\" class=\"headerlink\" title=\"Java I/O\"></a>Java I/O</h2><p>大量的<code>Decorator Pattern</code>在java的io包中运用。输入输出在计算机中的底层实现都是0101……来实现的，所以，例如，最底层的实现类是_FileInputStream_（好比是_Beverage_），往上”装饰“一层可以是字节_BufferedInputStream_（好比是_Espresso_），接着往上是_LineNumberInutStream_（好比是加调料_Mocha_）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">para1&#x3D;&gt;parallel: FileInputStream</span><br><span class=\"line\">para2&#x3D;&gt;parallel: BufferedInputStream</span><br><span class=\"line\">para3&#x3D;&gt;parallel: LineNumberInputStream</span><br><span class=\"line\">op1&#x3D;&gt;operation: Beferage</span><br><span class=\"line\">op2&#x3D;&gt;operation: Espresso</span><br><span class=\"line\">op3&#x3D;&gt;operation: Mocha</span><br><span class=\"line\">para1(path1, bottom)-&gt;para2</span><br><span class=\"line\">para2(path1,bottom)-&gt;para3</span><br><span class=\"line\">para1(path2, right)-&gt;op1</span><br><span class=\"line\">para2(path2, right)-&gt;op2</span><br><span class=\"line\">para3(path2, right)-&gt;op3</span><br></pre></td></tr></table></figure>"},{"title":"hashmap","date":"2020-08-20T15:04:30.000Z","_content":"\nJava Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。\n\n<!--more-->\n\n# Example\n\n```java\nMap<String, Object> map = new HashMap<>();\nmap.put(\"name\", \"Gloria\");\nmap.put(\"age\", 3);\nmap.put(\"wage\", 539.8);\nSystem.out.println(map);\n```\n\n通过一个简单的`put`操作，来看看究竟发生了什么。\n\n## 构造\n\n初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：\n\n```java\nMap<String, Object> map1 = new HashMap<>(map); // map为上方那个\n```\n\n来看看初始化容量时的装载因子：\n\n```java\n    /**\n     * The load factor for the hash table.\n     *\n     * @serial\n     */\n    final float loadFactor;\n```\n\nHashMap的容量是我们存入的数值乘以`0.75`,例如：\n\n```java\nMap<String, Object> map = new HashMap<>(16);\n```\n\n那么，这个map的**实际容量**就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的`0.75`,自定义**初始容量**。\n\n## put初识\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    return putVal(hash(key), key, value, false, true);\n}key\n```\n\nput有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个**位运算**:\n\n- ^ 异或(两个相同的数做异或运算结果为0)\n- \\>\\>\\> 无符号右移，左边空出来的补0\n\n首先是给h赋值为key的hashCode，key的hashcode是通过Object的`native方法`，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。\n\n关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量`table`，他的类型是`Noe<K,V> []`，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。\n\n\n\n# Node\n\n它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。\n\n```java\n /**\n  * Basic hash bin node, used for most entries.  (See below for\n  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)\n  */\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; // 用来定位数组索引位置\n    final K key;\n    V value;\n    Node<K,V> next; // 链接下一个Node\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    \n    // get, set equals ...\n}\n```\n\n- 脱脱的链表有么有！！！ `Node<K, V> next`！！！\n- 上面提到的`table`就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。\n- 实现了`Map.Entry<K, V>`接口，所以，他的本质（或者说表现）就是一个k-v键值对。\n- 与算法题通常定义的简易链表不同，除了`next`外这里存储了三个值：`hash`, `key`, `value`\n\n\n\n# 冲突解决\n\n首先想想：什么是哈希表。\n\n哈希表=数组+链表。通过`Node<K, V>`以及`Node<K, V> []`我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是`数组+链表`。\n\n哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于**桶**（即之前提到的`table`数组）和**哈希算法**，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：\n\n```java\n/**\n  * The number of key-value mappings contained in this map.\n  */\ntransient int size;\n\n/**\n  * The number of times this HashMap has been structurally modified\n  * Structural modifications are those that change the number of mappings in\n  * the HashMap or otherwise modify its internal structure (e.g.,\n  * rehash).  This field is used to make iterators on Collection-views of\n  * the HashMap fail-fast.  (See ConcurrentModificationException).\n  */\ntransient int modCount;\n\n/**\n  * The next size value at which to resize (capacity * load factor).\n  *\n  * @serial\n  */\n// (The javadoc description is true upon serialization.\n// Additionally, if the table array has not been allocated, this\n// field holds the initial array capacity, or zero signifying\n// DEFAULT_INITIAL_CAPACITY.)\nint threshold;\n\n/**\n  * The load factor for the hash table.\n  *\n  * @serial\n  */\nfinal float loadFactor;\n```\n\n`threshold`临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node<K,V>[] table的length是16, loadFactor是0.75,，那么\n\n> threshold = loadFactor * length\n\n也就是说，table数组中所能容纳的Node个数由`threshold`指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.\n\nsize就是表示目前存储的Node的数量。\n\n在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种**非常规**设计，为什么呢？一个冷知识：\n\n- 2的n次方的数为`合数`，实际上`质数`导致哈希冲突的概率要小于合数。\n\n参考HashTable的初始化，`initialCapacity`就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了**红黑树**，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。\n\n\n\n# 确定索引\n\n我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：\n\n> 取值（key的hashCode），高位运算，取模运算\n\n我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：\n\n```java\nif ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n```\n\n在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以`(n-1)&hash`等价于对length取模，比使用`%`具有更高的效率。\n\n \n\n# put详解\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 判断table的是否为空，是则执行扩容操作\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算插入数组的索引，如果为null，新建节点\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 判断key是否存在，如ugo存在直接覆盖掉value\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 判断是否是红黑树，如果是的话就在树中操作，\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 遍历table\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    // 链表的插入操作\n                    p.next = newNode(hash, key, value, null);\n                    // 长度大于8时转红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 超过最大容量就扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n\n\n# 扩容\n\n我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？\n\n> note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。\n\n```java\n/**\n * Initializes or doubles table size.  If null, allocates in\n * accord with initial capacity target held in field threshold.\n * Otherwise, because we are using power-of-two expansion, the\n * elements from each bin must either stay at same index, or move\n * with a power of two offset in the new table.\n *\n * @return the table\n */\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 太大就不管了，let it go\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，左移一位（X2）\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算resize的上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 遍历数组，把每个桶都移动到新的中去\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n","source":"_posts/hashmap.md","raw":"---\ntitle: hashmap\ndate: 2020-08-20 23:04:30\ncategories: Java\ntags: hashmap, data structure\n---\n\nJava Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。\n\n<!--more-->\n\n# Example\n\n```java\nMap<String, Object> map = new HashMap<>();\nmap.put(\"name\", \"Gloria\");\nmap.put(\"age\", 3);\nmap.put(\"wage\", 539.8);\nSystem.out.println(map);\n```\n\n通过一个简单的`put`操作，来看看究竟发生了什么。\n\n## 构造\n\n初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：\n\n```java\nMap<String, Object> map1 = new HashMap<>(map); // map为上方那个\n```\n\n来看看初始化容量时的装载因子：\n\n```java\n    /**\n     * The load factor for the hash table.\n     *\n     * @serial\n     */\n    final float loadFactor;\n```\n\nHashMap的容量是我们存入的数值乘以`0.75`,例如：\n\n```java\nMap<String, Object> map = new HashMap<>(16);\n```\n\n那么，这个map的**实际容量**就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的`0.75`,自定义**初始容量**。\n\n## put初识\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    return putVal(hash(key), key, value, false, true);\n}key\n```\n\nput有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个**位运算**:\n\n- ^ 异或(两个相同的数做异或运算结果为0)\n- \\>\\>\\> 无符号右移，左边空出来的补0\n\n首先是给h赋值为key的hashCode，key的hashcode是通过Object的`native方法`，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。\n\n关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量`table`，他的类型是`Noe<K,V> []`，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。\n\n\n\n# Node\n\n它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。\n\n```java\n /**\n  * Basic hash bin node, used for most entries.  (See below for\n  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)\n  */\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; // 用来定位数组索引位置\n    final K key;\n    V value;\n    Node<K,V> next; // 链接下一个Node\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n    \n    // get, set equals ...\n}\n```\n\n- 脱脱的链表有么有！！！ `Node<K, V> next`！！！\n- 上面提到的`table`就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。\n- 实现了`Map.Entry<K, V>`接口，所以，他的本质（或者说表现）就是一个k-v键值对。\n- 与算法题通常定义的简易链表不同，除了`next`外这里存储了三个值：`hash`, `key`, `value`\n\n\n\n# 冲突解决\n\n首先想想：什么是哈希表。\n\n哈希表=数组+链表。通过`Node<K, V>`以及`Node<K, V> []`我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是`数组+链表`。\n\n哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于**桶**（即之前提到的`table`数组）和**哈希算法**，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：\n\n```java\n/**\n  * The number of key-value mappings contained in this map.\n  */\ntransient int size;\n\n/**\n  * The number of times this HashMap has been structurally modified\n  * Structural modifications are those that change the number of mappings in\n  * the HashMap or otherwise modify its internal structure (e.g.,\n  * rehash).  This field is used to make iterators on Collection-views of\n  * the HashMap fail-fast.  (See ConcurrentModificationException).\n  */\ntransient int modCount;\n\n/**\n  * The next size value at which to resize (capacity * load factor).\n  *\n  * @serial\n  */\n// (The javadoc description is true upon serialization.\n// Additionally, if the table array has not been allocated, this\n// field holds the initial array capacity, or zero signifying\n// DEFAULT_INITIAL_CAPACITY.)\nint threshold;\n\n/**\n  * The load factor for the hash table.\n  *\n  * @serial\n  */\nfinal float loadFactor;\n```\n\n`threshold`临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node<K,V>[] table的length是16, loadFactor是0.75,，那么\n\n> threshold = loadFactor * length\n\n也就是说，table数组中所能容纳的Node个数由`threshold`指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.\n\nsize就是表示目前存储的Node的数量。\n\n在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种**非常规**设计，为什么呢？一个冷知识：\n\n- 2的n次方的数为`合数`，实际上`质数`导致哈希冲突的概率要小于合数。\n\n参考HashTable的初始化，`initialCapacity`就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了**红黑树**，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。\n\n\n\n# 确定索引\n\n我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：\n\n> 取值（key的hashCode），高位运算，取模运算\n\n我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：\n\n```java\nif ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n```\n\n在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以`(n-1)&hash`等价于对length取模，比使用`%`具有更高的效率。\n\n \n\n# put详解\n\n```java\n/**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don't change existing value\n * @param evict if false, the table is in creation mode.\n * @return previous value, or null if none\n */\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 判断table的是否为空，是则执行扩容操作\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 计算插入数组的索引，如果为null，新建节点\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        Node<K,V> e; K k;\n        // 判断key是否存在，如ugo存在直接覆盖掉value\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 判断是否是红黑树，如果是的话就在树中操作，\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 遍历table\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    // 链表的插入操作\n                    p.next = newNode(hash, key, value, null);\n                    // 长度大于8时转红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 超过最大容量就扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n\n\n# 扩容\n\n我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？\n\n> note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。\n\n```java\n/**\n * Initializes or doubles table size.  If null, allocates in\n * accord with initial capacity target held in field threshold.\n * Otherwise, because we are using power-of-two expansion, the\n * elements from each bin must either stay at same index, or move\n * with a power of two offset in the new table.\n *\n * @return the table\n */\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {\n        // 太大就不管了，let it go\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 没超过最大值，左移一位（X2）\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 计算resize的上限\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) {\n        // 遍历数组，把每个桶都移动到新的中去\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n","slug":"hashmap","published":1,"updated":"2021-03-28T10:20:02.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj85000vts9qdjrihczl","content":"<p>Java Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Gloria&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;wage&quot;</span>, <span class=\"number\">539.8</span>);</span><br><span class=\"line\">System.out.println(map);</span><br></pre></td></tr></table></figure>\n\n<p>通过一个简单的<code>put</code>操作，来看看究竟发生了什么。</p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p>初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map1 = <span class=\"keyword\">new</span> HashMap&lt;&gt;(map); <span class=\"comment\">// map为上方那个</span></span><br></pre></td></tr></table></figure>\n\n<p>来看看初始化容量时的装载因子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p>HashMap的容量是我们存入的数值乘以<code>0.75</code>,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么，这个map的<strong>实际容量</strong>就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的<code>0.75</code>,自定义<strong>初始容量</strong>。</p>\n<h2 id=\"put初识\"><a href=\"#put初识\" class=\"headerlink\" title=\"put初识\"></a>put初识</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;key</span><br></pre></td></tr></table></figure>\n\n<p>put有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个<strong>位运算</strong>:</p>\n<ul>\n<li>^ 异或(两个相同的数做异或运算结果为0)</li>\n<li>&gt;&gt;&gt; 无符号右移，左边空出来的补0</li>\n</ul>\n<p>首先是给h赋值为key的hashCode，key的hashcode是通过Object的<code>native方法</code>，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。</p>\n<p>关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量<code>table</code>，他的类型是<code>Noe&lt;K,V&gt; []</code>，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。</p>\n<h1 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h1><p>它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class=\"line\"><span class=\"comment\">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// 用来定位数组索引位置</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next; <span class=\"comment\">// 链接下一个Node</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// get, set equals ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脱脱的链表有么有！！！ <code>Node&lt;K, V&gt; next</code>！！！</li>\n<li>上面提到的<code>table</code>就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。</li>\n<li>实现了<code>Map.Entry&lt;K, V&gt;</code>接口，所以，他的本质（或者说表现）就是一个k-v键值对。</li>\n<li>与算法题通常定义的简易链表不同，除了<code>next</code>外这里存储了三个值：<code>hash</code>, <code>key</code>, <code>value</code></li>\n</ul>\n<h1 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h1><p>首先想想：什么是哈希表。</p>\n<p>哈希表=数组+链表。通过<code>Node&lt;K, V&gt;</code>以及<code>Node&lt;K, V&gt; []</code>我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是<code>数组+链表</code>。</p>\n<p>哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于<strong>桶</strong>（即之前提到的<code>table</code>数组）和<strong>哈希算法</strong>，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of key-value mappings contained in this map.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of times this HashMap has been structurally modified</span></span><br><span class=\"line\"><span class=\"comment\">  * Structural modifications are those that change the number of mappings in</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\">  * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"comment\">// (The javadoc description is true upon serialization.</span></span><br><span class=\"line\"><span class=\"comment\">// Additionally, if the table array has not been allocated, this</span></span><br><span class=\"line\"><span class=\"comment\">// field holds the initial array capacity, or zero signifying</span></span><br><span class=\"line\"><span class=\"comment\">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p><code>threshold</code>临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node&lt;K,V&gt;[] table的length是16, loadFactor是0.75,，那么</p>\n<blockquote>\n<p>threshold = loadFactor * length</p>\n</blockquote>\n<p>也就是说，table数组中所能容纳的Node个数由<code>threshold</code>指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.</p>\n<p>size就是表示目前存储的Node的数量。</p>\n<p>在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种<strong>非常规</strong>设计，为什么呢？一个冷知识：</p>\n<ul>\n<li>2的n次方的数为<code>合数</code>，实际上<code>质数</code>导致哈希冲突的概率要小于合数。</li>\n</ul>\n<p>参考HashTable的初始化，<code>initialCapacity</code>就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了<strong>红黑树</strong>，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。</p>\n<h1 id=\"确定索引\"><a href=\"#确定索引\" class=\"headerlink\" title=\"确定索引\"></a>确定索引</h1><p>我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：</p>\n<blockquote>\n<p>取值（key的hashCode），高位运算，取模运算</p>\n</blockquote>\n<p>我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以<code>(n-1)&amp;hash</code>等价于对length取模，比使用<code>%</code>具有更高的效率。</p>\n<h1 id=\"put详解\"><a href=\"#put详解\" class=\"headerlink\" title=\"put详解\"></a>put详解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 判断table的是否为空，是则执行扩容操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 计算插入数组的索引，如果为null，新建节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 判断key是否存在，如ugo存在直接覆盖掉value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是红黑树，如果是的话就在树中操作，</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历table</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 链表的插入操作</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 长度大于8时转红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 超过最大容量就扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h1><p>我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？</p>\n<blockquote>\n<p>note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class=\"line\"><span class=\"comment\"> * accord with initial capacity target held in field threshold.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements from each bin must either stay at same index, or move</span></span><br><span class=\"line\"><span class=\"comment\"> * with a power of two offset in the new table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the table</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 太大就不管了，let it go</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，左移一位（X2）</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算resize的上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历数组，把每个桶都移动到新的中去</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Java Hashmap，经典数据结构。主要理解他的组成结构和哈希原理，哈希冲突如何处理。基于jdk8。</p>","more":"<h1 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Gloria&quot;</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">&quot;wage&quot;</span>, <span class=\"number\">539.8</span>);</span><br><span class=\"line\">System.out.println(map);</span><br></pre></td></tr></table></figure>\n\n<p>通过一个简单的<code>put</code>操作，来看看究竟发生了什么。</p>\n<h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><p>初始化时，构造一个HashMap对象，这里有有参和无参（当然，阿里开发规约建议知道容量的情况下要指定大小）的构造方法，有参中你可以指定装载因子、容量、甚至是把map放进去：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map1 = <span class=\"keyword\">new</span> HashMap&lt;&gt;(map); <span class=\"comment\">// map为上方那个</span></span><br></pre></td></tr></table></figure>\n\n<p>来看看初始化容量时的装载因子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p>HashMap的容量是我们存入的数值乘以<code>0.75</code>,例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么，这个map的<strong>实际容量</strong>就是12，超过这个数量的话就会进行扩容操作。一般我们都使用默认的<code>0.75</code>,自定义<strong>初始容量</strong>。</p>\n<h2 id=\"put初识\"><a href=\"#put初识\" class=\"headerlink\" title=\"put初识\"></a>put初识</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;key</span><br></pre></td></tr></table></figure>\n\n<p>put有几个参数，其中之一是hash值，所以我们先来看看他的hash，上面是他的入参，可以看到，只对传入的key进行hash处理了。那么hash是如何做的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>惊不惊喜，意不意外？（好吧，很easy了）首先，他是一个三目元算，判断key是否为null，如果是返回0（说明hashmap允许存入key为null）,否则“一顿操作”。再来细看key不为null的情况，用到了两个<strong>位运算</strong>:</p>\n<ul>\n<li>^ 异或(两个相同的数做异或运算结果为0)</li>\n<li>&gt;&gt;&gt; 无符号右移，左边空出来的补0</li>\n</ul>\n<p>首先是给h赋值为key的hashCode，key的hashcode是通过Object的<code>native方法</code>，所以跟不下去了！所以重点放在位运算上，将h进行右移16位再与之自身进行异或。</p>\n<p>关于异或先放在这里，我们来看看后续是如何存储的，往下一跟便能发现一个变量<code>table</code>，他的类型是<code>Noe&lt;K,V&gt; []</code>，即Node类型数组，接下来我们来看看他的结构，包括存储时防止冲突的解决方法。</p>\n<h1 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h1><p>它是HahsMap的静态内部类，存储的核心，构造也不复杂，可以看看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class=\"line\"><span class=\"comment\">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash; <span class=\"comment\">// 用来定位数组索引位置</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next; <span class=\"comment\">// 链接下一个Node</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// get, set equals ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>脱脱的链表有么有！！！ <code>Node&lt;K, V&gt; next</code>！！！</li>\n<li>上面提到的<code>table</code>就是一个链表类型的数组，里面用来装Node链表。所以他的基本储存就明了了：数组+链表。</li>\n<li>实现了<code>Map.Entry&lt;K, V&gt;</code>接口，所以，他的本质（或者说表现）就是一个k-v键值对。</li>\n<li>与算法题通常定义的简易链表不同，除了<code>next</code>外这里存储了三个值：<code>hash</code>, <code>key</code>, <code>value</code></li>\n</ul>\n<h1 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h1><p>首先想想：什么是哈希表。</p>\n<p>哈希表=数组+链表。通过<code>Node&lt;K, V&gt;</code>以及<code>Node&lt;K, V&gt; []</code>我们知道hashmap是使用哈希表存储的。通过课本我们也了解到对需哈希冲突，解决的方式通常有两种：开放寻址、链地址。毫无疑问，既然用了链表，那就连地址呗，实现方式同样是<code>数组+链表</code>。</p>\n<p>哈希冲突是有条件的，或者说是限制。在hashmap中，冲突取决于<strong>桶</strong>（即之前提到的<code>table</code>数组）和<strong>哈希算法</strong>，前者代表了空间成本，后者则是时间成本，空间与时间的权衡是要自己考虑的了（一般默认）。它默认的做法是初始化一个大小，容不下时会进行扩容，如此一来，数组占的空间又小还能使得发生碰撞的概率减小。我们来看看初始化涉及到的一些参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of key-value mappings contained in this map.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The number of times this HashMap has been structurally modified</span></span><br><span class=\"line\"><span class=\"comment\">  * Structural modifications are those that change the number of mappings in</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class=\"line\"><span class=\"comment\">  * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class=\"line\"><span class=\"comment\">  * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"comment\">// (The javadoc description is true upon serialization.</span></span><br><span class=\"line\"><span class=\"comment\">// Additionally, if the table array has not been allocated, this</span></span><br><span class=\"line\"><span class=\"comment\">// field holds the initial array capacity, or zero signifying</span></span><br><span class=\"line\"><span class=\"comment\">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The load factor for the hash table.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p><code>threshold</code>临界值，所能容纳k-v的极限。如果不指定任何值，初始化时Node&lt;K,V&gt;[] table的length是16, loadFactor是0.75,，那么</p>\n<blockquote>\n<p>threshold = loadFactor * length</p>\n</blockquote>\n<p>也就是说，table数组中所能容纳的Node个数由<code>threshold</code>指定，初始为12.往里面装的Node个数超过12，会进行扩容， 扩容为之前的两倍。这里的负载因子可以看作是对空间的限制，毕竟长度16,由于负载因子变成了12,所以如果内存紧张，对时间要求也不高，可以加大因子，允许超过1.</p>\n<p>size就是表示目前存储的Node的数量。</p>\n<p>在HashMap中，哈希桶数组的table长度必须为2的n次方，这是一种<strong>非常规</strong>设计，为什么呢？一个冷知识：</p>\n<ul>\n<li>2的n次方的数为<code>合数</code>，实际上<code>质数</code>导致哈希冲突的概率要小于合数。</li>\n</ul>\n<p>参考HashTable的初始化，<code>initialCapacity</code>就是11. 进行这种非常规的设计必然是有道理的，这道理猜都能猜的到吧，当然是为了减少冲突，直接哈希是肯定不可能，不如素数来得快，所以必然是做了一些操作。什么操作呢？后续且看代码。另外，即时哈希算法和桶做得再合理也免不了出现链表过长的情况（数组中一个坑里好长的链表）。链表过长会影响性能，数组形同虚设，所以，在jdk8中引入了<strong>红黑树</strong>，当链表长度过长（默认为8）时会将链表转换为红黑数，利用它快速增删改查的特点提高hashmap的性能。</p>\n<h1 id=\"确定索引\"><a href=\"#确定索引\" class=\"headerlink\" title=\"确定索引\"></a>确定索引</h1><p>我们知道，数组的查询效率很高而链表很慢，hahsmap的查询效率与数组无异，我们存储的个k-v都以Node链表的形式放入table数组中，并且尽可能地使每个它分布均匀，每个位置上的元素只有一个，对于平时操作的增删改查都是以key的hash来进行查找，可以理解为table的index 了，当找到后最好是不用再遍历链表（最好是这样），所以非常的u迅速，那么，如何确定索引？根据上方的hash代码，总结起来三步：</p>\n<blockquote>\n<p>取值（key的hashCode），高位运算，取模运算</p>\n</blockquote>\n<p>我们知道，对于存入的任意key，只要它返回的hashCode相同，那么生成的hash码也一定相同。想让Node在数组中能均匀分布，我们首先想到的应该是对数组取模，这样一来一定是均匀分散在数组中 了，但是对于底层运算来说，取模的操作消耗还是比较大的，我们来看看hashmap是如何找到高效的替代方法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在代码中有这么一行，n为数组长度，hash为key的哈希码，由于n总是2的n次方，所以<code>(n-1)&amp;hash</code>等价于对length取模，比使用<code>%</code>具有更高的效率。</p>\n<h1 id=\"put详解\"><a href=\"#put详解\" class=\"headerlink\" title=\"put详解\"></a>put详解</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 判断table的是否为空，是则执行扩容操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 计算插入数组的索引，如果为null，新建节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 判断key是否存在，如ugo存在直接覆盖掉value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是红黑树，如果是的话就在树中操作，</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历table</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 链表的插入操作</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 长度大于8时转红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 超过最大容量就扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h1><p>我们知道HashMap的存储基础是桶，也就是数组，一般涉及数组的扩容，都是重新定一个大的数组，然后将小的数组拷贝过去（参考ArrayList），那么这里的HashMap是如何做的呢？怎么处理内部的Node以及红黑数呢？</p>\n<blockquote>\n<p>note: 要注意上方提到的一些实例变量，都是与HashMap相关的属性。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class=\"line\"><span class=\"comment\"> * accord with initial capacity target held in field threshold.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements from each bin must either stay at same index, or move</span></span><br><span class=\"line\"><span class=\"comment\"> * with a power of two offset in the new table.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the table</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 太大就不管了，let it go</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没超过最大值，左移一位（X2）</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算resize的上限</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历数组，把每个桶都移动到新的中去</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"heap","date":"2020-06-06T14:54:27.000Z","_content":"\n这里的堆是数据结构中的堆，不是JVM中的堆。\n\n关键词：堆，二叉树，优先级队列，排序，topN\n\n<!-- more -->\n\n<!-- toc -->\n\n# 结构\n\n堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。\t\n\n## 完全二叉树\n\n- 路径长度是指路径上的边数\n- 结点深度是指从根结点到该结点的路径的长度\n- 每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置\n\n## 二叉堆\n\n- 完全二叉树\n- 每个结点大于或等于它的任意一个孩子\n\n这里有个地方要跟BST做区别，BST的左右孩子是有大小区分的，而二叉堆中没有区分，主只要父节点比孩子结点大（大顶堆）就可以。\n\n\n\n# 存储\n\n可以将二叉堆用数组来存储。\n\n例如如下一个二叉堆：\n\n![Screenshot from 2020-06-06 15-24-34.png](https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png)\n\n在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}\n\n可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。\n\n## 过程分析\n\n我们详细看看他的 插入和删除的过程，（假设是大顶堆）\n\n插入：元素首先放在末尾，然后与父节点比较，如果比父节点大，与父节点换位子，如此往复，直到父节点比自己大为止。\n\n删除：移除根节点，将末尾元素拿来顶替，然后与孩子结点中最大的比较，如果比最大的孩子结点小，跟孩子结点换位子，如此往复，直到比最大的孩子结点大为止。\n\n\n\n## 时间复杂度分析\n\nO(nlogn)。\n\n首先分析logn，同快排、归并一样，logn可以是树高、递归的栈深。\n\n**这里的n指的是用来构建堆的时间**，有n个元素，那么就会有n个logn（最差情况下，每个新添的元素都会一路置换到顶部）。\n\n\n\n# 应用\n\n## 优先级队列\n\n优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题\n\n## TOP N\n\n给一组数据，求其中最大/小的几个数。\n\n```java\n// 求最小的n个数\npublic static int[] topN(int[] array, int n) {\n    if (n == 0) {\n        return new int[0];\n    }\n    // default big heap, lambda make it small heap\n    Queue<Integer> heap = new PriorityQueue<>(n, ((o1, o2) -> Integer.compare(o2, o1)));\n\n    for (int e : array) {\n        // put the integer in when it smaller than the top of integer\n        if (heap.isEmpty() || heap.size() < n || e < heap.peek()) {\n            heap.offer(e);\n        }\n        if (heap.size() > n) {\n            // delete the top of heap integer\n            heap.poll();\n        }\n    }\n\n    int[] res = new int[heap.size()];\n    int j = 0;\n    for (int e : heap) {\n        res[j++] = e;\n    }\n    return res;\n}\n```\n\n上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。\n\n稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：\n\n```java\n// 默认大顶堆\nQueue<Integer> heap = new PriorityQueue<>(n);\nfor(int e: array){\n    // 大于堆顶的放入优先级队列\n    if(heap.isEmpty() || heap.size() < n || e > heap.peak()){\n        heap.offer(e);\n    }\n    // 超过要求的个数，清除堆顶元素\n    if(heap.size() > n){\n        heap.pool();\n    }\n}\n```\n\n### 大数据\n\n当有千万级别的数据时，从中找出前若干个大（或小）的数据，虽然也是使用堆，但是多了一点选用的技巧：\n\n- 选前K个最小的数据，使用大顶堆\n- 选前K个最大的数据，使用小顶堆\n\n两个的原理是一样的，这里我用大顶堆举例。例如，在一千万的数据中找出前100个最小的数据，遍历的同时使用大顶堆来装数据，在遍历到第101个数据的时候，与堆顶做对比，此时会有两种情况：\n\n- 比堆顶的数字大：略过。我们要找的是前100个最小的元素\n- 比堆顶的数字小：移除堆顶元素，放入第101号元素\n\n这样一来，我们避免了对所有元素排序，核心原理就是**拿栈顶元素来做临界值**，时间复杂度也可以控制在*O(k\\*n)*，其中k是前K个元素的数量，n是全部的数据量。\n\n\n\n","source":"_posts/heap.md","raw":"---\ntitle: heap\ndate: 2020-06-06 22:54:27\ncategories: Java\ntags: datastructure\n---\n\n这里的堆是数据结构中的堆，不是JVM中的堆。\n\n关键词：堆，二叉树，优先级队列，排序，topN\n\n<!-- more -->\n\n<!-- toc -->\n\n# 结构\n\n堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。\t\n\n## 完全二叉树\n\n- 路径长度是指路径上的边数\n- 结点深度是指从根结点到该结点的路径的长度\n- 每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置\n\n## 二叉堆\n\n- 完全二叉树\n- 每个结点大于或等于它的任意一个孩子\n\n这里有个地方要跟BST做区别，BST的左右孩子是有大小区分的，而二叉堆中没有区分，主只要父节点比孩子结点大（大顶堆）就可以。\n\n\n\n# 存储\n\n可以将二叉堆用数组来存储。\n\n例如如下一个二叉堆：\n\n![Screenshot from 2020-06-06 15-24-34.png](https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png)\n\n在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}\n\n可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。\n\n## 过程分析\n\n我们详细看看他的 插入和删除的过程，（假设是大顶堆）\n\n插入：元素首先放在末尾，然后与父节点比较，如果比父节点大，与父节点换位子，如此往复，直到父节点比自己大为止。\n\n删除：移除根节点，将末尾元素拿来顶替，然后与孩子结点中最大的比较，如果比最大的孩子结点小，跟孩子结点换位子，如此往复，直到比最大的孩子结点大为止。\n\n\n\n## 时间复杂度分析\n\nO(nlogn)。\n\n首先分析logn，同快排、归并一样，logn可以是树高、递归的栈深。\n\n**这里的n指的是用来构建堆的时间**，有n个元素，那么就会有n个logn（最差情况下，每个新添的元素都会一路置换到顶部）。\n\n\n\n# 应用\n\n## 优先级队列\n\n优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题\n\n## TOP N\n\n给一组数据，求其中最大/小的几个数。\n\n```java\n// 求最小的n个数\npublic static int[] topN(int[] array, int n) {\n    if (n == 0) {\n        return new int[0];\n    }\n    // default big heap, lambda make it small heap\n    Queue<Integer> heap = new PriorityQueue<>(n, ((o1, o2) -> Integer.compare(o2, o1)));\n\n    for (int e : array) {\n        // put the integer in when it smaller than the top of integer\n        if (heap.isEmpty() || heap.size() < n || e < heap.peek()) {\n            heap.offer(e);\n        }\n        if (heap.size() > n) {\n            // delete the top of heap integer\n            heap.poll();\n        }\n    }\n\n    int[] res = new int[heap.size()];\n    int j = 0;\n    for (int e : heap) {\n        res[j++] = e;\n    }\n    return res;\n}\n```\n\n上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。\n\n稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：\n\n```java\n// 默认大顶堆\nQueue<Integer> heap = new PriorityQueue<>(n);\nfor(int e: array){\n    // 大于堆顶的放入优先级队列\n    if(heap.isEmpty() || heap.size() < n || e > heap.peak()){\n        heap.offer(e);\n    }\n    // 超过要求的个数，清除堆顶元素\n    if(heap.size() > n){\n        heap.pool();\n    }\n}\n```\n\n### 大数据\n\n当有千万级别的数据时，从中找出前若干个大（或小）的数据，虽然也是使用堆，但是多了一点选用的技巧：\n\n- 选前K个最小的数据，使用大顶堆\n- 选前K个最大的数据，使用小顶堆\n\n两个的原理是一样的，这里我用大顶堆举例。例如，在一千万的数据中找出前100个最小的数据，遍历的同时使用大顶堆来装数据，在遍历到第101个数据的时候，与堆顶做对比，此时会有两种情况：\n\n- 比堆顶的数字大：略过。我们要找的是前100个最小的元素\n- 比堆顶的数字小：移除堆顶元素，放入第101号元素\n\n这样一来，我们避免了对所有元素排序，核心原理就是**拿栈顶元素来做临界值**，时间复杂度也可以控制在*O(k\\*n)*，其中k是前K个元素的数量，n是全部的数据量。\n\n\n\n","slug":"heap","published":1,"updated":"2021-05-22T13:36:19.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj89000zts9q6ywr9roq","content":"<p>这里的堆是数据结构中的堆，不是JVM中的堆。</p>\n<p>关键词：堆，二叉树，优先级队列，排序，topN</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。    </p>\n<h2 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h2><ul>\n<li>路径长度是指路径上的边数</li>\n<li>结点深度是指从根结点到该结点的路径的长度</li>\n<li>每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置</li>\n</ul>\n<h2 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h2><ul>\n<li>完全二叉树</li>\n<li>每个结点大于或等于它的任意一个孩子</li>\n</ul>\n<p>这里有个地方要跟BST做区别，BST的左右孩子是有大小区分的，而二叉堆中没有区分，主只要父节点比孩子结点大（大顶堆）就可以。</p>\n<h1 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h1><p>可以将二叉堆用数组来存储。</p>\n<p>例如如下一个二叉堆：</p>\n<p><img src=\"https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png\" alt=\"Screenshot from 2020-06-06 15-24-34.png\"></p>\n<p>在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}</p>\n<p>可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。</p>\n<h2 id=\"过程分析\"><a href=\"#过程分析\" class=\"headerlink\" title=\"过程分析\"></a>过程分析</h2><p>我们详细看看他的 插入和删除的过程，（假设是大顶堆）</p>\n<p>插入：元素首先放在末尾，然后与父节点比较，如果比父节点大，与父节点换位子，如此往复，直到父节点比自己大为止。</p>\n<p>删除：移除根节点，将末尾元素拿来顶替，然后与孩子结点中最大的比较，如果比最大的孩子结点小，跟孩子结点换位子，如此往复，直到比最大的孩子结点大为止。</p>\n<h2 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h2><p>O(nlogn)。</p>\n<p>首先分析logn，同快排、归并一样，logn可以是树高、递归的栈深。</p>\n<p><strong>这里的n指的是用来构建堆的时间</strong>，有n个元素，那么就会有n个logn（最差情况下，每个新添的元素都会一路置换到顶部）。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><p>优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题</p>\n<h2 id=\"TOP-N\"><a href=\"#TOP-N\" class=\"headerlink\" title=\"TOP N\"></a>TOP N</h2><p>给一组数据，求其中最大/小的几个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求最小的n个数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] topN(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// default big heap, lambda make it small heap</span></span><br><span class=\"line\">    Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n, ((o1, o2) -&gt; Integer.compare(o2, o1)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : array) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// put the integer in when it smaller than the top of integer</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.isEmpty() || heap.size() &lt; n || e &lt; heap.peek()) &#123;</span><br><span class=\"line\">            heap.offer(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.size() &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// delete the top of heap integer</span></span><br><span class=\"line\">            heap.poll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[heap.size()];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : heap) &#123;</span><br><span class=\"line\">        res[j++] = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。</p>\n<p>稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认大顶堆</span></span><br><span class=\"line\">Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e: array)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 大于堆顶的放入优先级队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.isEmpty() || heap.size() &lt; n || e &gt; heap.peak())&#123;</span><br><span class=\"line\">        heap.offer(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 超过要求的个数，清除堆顶元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.size() &gt; n)&#123;</span><br><span class=\"line\">        heap.pool();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h3><p>当有千万级别的数据时，从中找出前若干个大（或小）的数据，虽然也是使用堆，但是多了一点选用的技巧：</p>\n<ul>\n<li>选前K个最小的数据，使用大顶堆</li>\n<li>选前K个最大的数据，使用小顶堆</li>\n</ul>\n<p>两个的原理是一样的，这里我用大顶堆举例。例如，在一千万的数据中找出前100个最小的数据，遍历的同时使用大顶堆来装数据，在遍历到第101个数据的时候，与堆顶做对比，此时会有两种情况：</p>\n<ul>\n<li>比堆顶的数字大：略过。我们要找的是前100个最小的元素</li>\n<li>比堆顶的数字小：移除堆顶元素，放入第101号元素</li>\n</ul>\n<p>这样一来，我们避免了对所有元素排序，核心原理就是<strong>拿栈顶元素来做临界值</strong>，时间复杂度也可以控制在<em>O(k\\</em>n)*，其中k是前K个元素的数量，n是全部的数据量。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这里的堆是数据结构中的堆，不是JVM中的堆。</p>\n<p>关键词：堆，二叉树，优先级队列，排序，topN</p>","more":"<!-- toc -->\n\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>堆的结构是完全二叉树，而且是有序的，分大顶堆和小顶堆。    </p>\n<h2 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h2><ul>\n<li>路径长度是指路径上的边数</li>\n<li>结点深度是指从根结点到该结点的路径的长度</li>\n<li>每一层都是满的或者最后一层不满但最后一层的叶子都是靠左放置</li>\n</ul>\n<h2 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a>二叉堆</h2><ul>\n<li>完全二叉树</li>\n<li>每个结点大于或等于它的任意一个孩子</li>\n</ul>\n<p>这里有个地方要跟BST做区别，BST的左右孩子是有大小区分的，而二叉堆中没有区分，主只要父节点比孩子结点大（大顶堆）就可以。</p>\n<h1 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h1><p>可以将二叉堆用数组来存储。</p>\n<p>例如如下一个二叉堆：</p>\n<p><img src=\"https://i.loli.net/2020/06/06/JbDlczXVh35sEF1.png\" alt=\"Screenshot from 2020-06-06 15-24-34.png\"></p>\n<p>在数组中保存：{62,42,59,32,39,44,13,22,29,14,33,30,17,9}</p>\n<p>可以看到相当是以广度优先遍历了这个二叉树，并将遍历的结点按顺序存入数组。可以从中发现一些存储的规律，对于任意一个位置_i_，他的左子结点在_2i+1_处，右子结点在_2i+2_处，父结点在_(i-1)/2_处。例如：39在数组中的下标是4，那么他的左子结点就在（2×4+1）=9处。</p>\n<h2 id=\"过程分析\"><a href=\"#过程分析\" class=\"headerlink\" title=\"过程分析\"></a>过程分析</h2><p>我们详细看看他的 插入和删除的过程，（假设是大顶堆）</p>\n<p>插入：元素首先放在末尾，然后与父节点比较，如果比父节点大，与父节点换位子，如此往复，直到父节点比自己大为止。</p>\n<p>删除：移除根节点，将末尾元素拿来顶替，然后与孩子结点中最大的比较，如果比最大的孩子结点小，跟孩子结点换位子，如此往复，直到比最大的孩子结点大为止。</p>\n<h2 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h2><p>O(nlogn)。</p>\n<p>首先分析logn，同快排、归并一样，logn可以是树高、递归的栈深。</p>\n<p><strong>这里的n指的是用来构建堆的时间</strong>，有n个元素，那么就会有n个logn（最差情况下，每个新添的元素都会一路置换到顶部）。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><p>优先级队列的底层就是用堆来实现的。同时一道比较经典的算法题用优先级队列可以轻松实现：top n 问题</p>\n<h2 id=\"TOP-N\"><a href=\"#TOP-N\" class=\"headerlink\" title=\"TOP N\"></a>TOP N</h2><p>给一组数据，求其中最大/小的几个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求最小的n个数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] topN(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// default big heap, lambda make it small heap</span></span><br><span class=\"line\">    Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n, ((o1, o2) -&gt; Integer.compare(o2, o1)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : array) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// put the integer in when it smaller than the top of integer</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.isEmpty() || heap.size() &lt; n || e &lt; heap.peek()) &#123;</span><br><span class=\"line\">            heap.offer(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap.size() &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// delete the top of heap integer</span></span><br><span class=\"line\">            heap.poll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[heap.size()];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> e : heap) &#123;</span><br><span class=\"line\">        res[j++] = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面用到了小顶堆，for循环中的两个判断，符合条件的放进堆中，第二个判断中，当堆中的元素个数大于要求的个数时，删除堆中的顶部元素（优先级队列的本质还是队列，进出满读FIFO）。</p>\n<p>稍作修改，可以让上面的代码输出最大的n个数，显而易见的是，我们只需修改入队列的条件以及优先级队列的堆排序方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认大顶堆</span></span><br><span class=\"line\">Queue&lt;Integer&gt; heap = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(n);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e: array)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 大于堆顶的放入优先级队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.isEmpty() || heap.size() &lt; n || e &gt; heap.peak())&#123;</span><br><span class=\"line\">        heap.offer(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 超过要求的个数，清除堆顶元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap.size() &gt; n)&#123;</span><br><span class=\"line\">        heap.pool();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h3><p>当有千万级别的数据时，从中找出前若干个大（或小）的数据，虽然也是使用堆，但是多了一点选用的技巧：</p>\n<ul>\n<li>选前K个最小的数据，使用大顶堆</li>\n<li>选前K个最大的数据，使用小顶堆</li>\n</ul>\n<p>两个的原理是一样的，这里我用大顶堆举例。例如，在一千万的数据中找出前100个最小的数据，遍历的同时使用大顶堆来装数据，在遍历到第101个数据的时候，与堆顶做对比，此时会有两种情况：</p>\n<ul>\n<li>比堆顶的数字大：略过。我们要找的是前100个最小的元素</li>\n<li>比堆顶的数字小：移除堆顶元素，放入第101号元素</li>\n</ul>\n<p>这样一来，我们避免了对所有元素排序，核心原理就是<strong>拿栈顶元素来做临界值</strong>，时间复杂度也可以控制在<em>O(k\\</em>n)*，其中k是前K个元素的数量，n是全部的数据量。</p>"},{"title":"https","date":"2020-03-14T02:43:29.000Z","_content":"\n**Hypertext Transfer Protocol Secure**, an extension of the Hypertext Transfer Protocol. \n\nHow to encrypt communication? Through referred to as **HTTP over TLS**, or **HTTP over SSL**\n\n- Transport Layer Security\n- Secure Sockets Layer\n\n<!-- more -->\n\n# HTTP与HTTPS\n\n\n\n## Difference\n\nHTTPS的URL地址开头是`https://`，默认使用的的端口是`443`，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。\n\n---\n\nHTTP的URL地址开头是`http://`，默认使用的端口是`80`，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。\n\n\n\n## 加密过程\n\n首先我们要知道，HTTPs是HTTP的安全版本，相当于在HTTP与TCP之间加了一层SSL，这一块主要看他是如何实现的。\n\n**原理**：采用**对称加密**和**非对称加密结合**的方式来保护浏览器和服务端之间的通信安全。\n\n**大致流程**：相比于HTTP多个SSL，这样就由原来的“不安全”变成了“安全”的，所以肯定的是：HTTPS是HTTP直接将报文信息传输给SSL套接字进行加密，SSL加密后将报文发送给TCP套接字，然后TCP套接字再将报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文发送给SSL套接字，SSL解密后交给对应进程。\n\n上面的自上而下的层面的理解，正如我们平时使用的那样，浏览器中输入的是https，从tcp的三次握手的角度看，https多了一次握手，**详细流程**：\n\n- 客户端发起握手请求，以明文传输请求信息（也就是https，，连接到服务端443端口）\n- 服务端返回信息，包括选择使用的协议版本、加密套件、压缩算法以及**证书（也就是公钥！）**\n- 客户端验证证书的合法性，如是否吊销、是否过期、域名等。这些工作是由客户端的SSL来完成，没问题的话就生成一个随机值，然后用随机值加密报文，再用证书加密随机值。\n- 客户端使用公钥对对称密钥加密，发送给服务端。通过上面可知，发送的是证书加密后的随机值（也就是对称密钥），目的是让服务端得到这个随机值，以后服务端和客户端的通信就可以通过这个随机值来进行加密解密了（对称加密原理）\n- 服务器用私钥解密，拿到对称加密的密钥。\n- 传输加密后的信息，这部分信息就是服务端用随机值加密后的，可以在客户端用随机值解密还原。\n- 客户端用之前生成的私钥解密服务端传过来的信息，获取内容。\n\n**小结**：用非对称加密来加密对称加密的密钥，发送的报文是用堆成加密来加密的，服务端私钥解密获取堆成加密的密钥，用它来解开密文。采用非对称加密是因为安全性，采用对称加密是因为速度快。\n\n## TLS VS SSL\n\n","source":"_posts/https.md","raw":"---\ntitle: https\ndate: 2020-03-14 10:43:29\ncategories: Network\ntags: ['http','https']\n---\n\n**Hypertext Transfer Protocol Secure**, an extension of the Hypertext Transfer Protocol. \n\nHow to encrypt communication? Through referred to as **HTTP over TLS**, or **HTTP over SSL**\n\n- Transport Layer Security\n- Secure Sockets Layer\n\n<!-- more -->\n\n# HTTP与HTTPS\n\n\n\n## Difference\n\nHTTPS的URL地址开头是`https://`，默认使用的的端口是`443`，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。\n\n---\n\nHTTP的URL地址开头是`http://`，默认使用的端口是`80`，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。\n\n\n\n## 加密过程\n\n首先我们要知道，HTTPs是HTTP的安全版本，相当于在HTTP与TCP之间加了一层SSL，这一块主要看他是如何实现的。\n\n**原理**：采用**对称加密**和**非对称加密结合**的方式来保护浏览器和服务端之间的通信安全。\n\n**大致流程**：相比于HTTP多个SSL，这样就由原来的“不安全”变成了“安全”的，所以肯定的是：HTTPS是HTTP直接将报文信息传输给SSL套接字进行加密，SSL加密后将报文发送给TCP套接字，然后TCP套接字再将报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文发送给SSL套接字，SSL解密后交给对应进程。\n\n上面的自上而下的层面的理解，正如我们平时使用的那样，浏览器中输入的是https，从tcp的三次握手的角度看，https多了一次握手，**详细流程**：\n\n- 客户端发起握手请求，以明文传输请求信息（也就是https，，连接到服务端443端口）\n- 服务端返回信息，包括选择使用的协议版本、加密套件、压缩算法以及**证书（也就是公钥！）**\n- 客户端验证证书的合法性，如是否吊销、是否过期、域名等。这些工作是由客户端的SSL来完成，没问题的话就生成一个随机值，然后用随机值加密报文，再用证书加密随机值。\n- 客户端使用公钥对对称密钥加密，发送给服务端。通过上面可知，发送的是证书加密后的随机值（也就是对称密钥），目的是让服务端得到这个随机值，以后服务端和客户端的通信就可以通过这个随机值来进行加密解密了（对称加密原理）\n- 服务器用私钥解密，拿到对称加密的密钥。\n- 传输加密后的信息，这部分信息就是服务端用随机值加密后的，可以在客户端用随机值解密还原。\n- 客户端用之前生成的私钥解密服务端传过来的信息，获取内容。\n\n**小结**：用非对称加密来加密对称加密的密钥，发送的报文是用堆成加密来加密的，服务端私钥解密获取堆成加密的密钥，用它来解开密文。采用非对称加密是因为安全性，采用对称加密是因为速度快。\n\n## TLS VS SSL\n\n","slug":"https","published":1,"updated":"2021-05-12T15:36:17.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8b0011ts9q1j86cyxa","content":"<p><strong>Hypertext Transfer Protocol Secure</strong>, an extension of the Hypertext Transfer Protocol. </p>\n<p>How to encrypt communication? Through referred to as <strong>HTTP over TLS</strong>, or <strong>HTTP over SSL</strong></p>\n<ul>\n<li>Transport Layer Security</li>\n<li>Secure Sockets Layer</li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h1><h2 id=\"Difference\"><a href=\"#Difference\" class=\"headerlink\" title=\"Difference\"></a>Difference</h2><p>HTTPS的URL地址开头是<code>https://</code>，默认使用的的端口是<code>443</code>，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。</p>\n<hr>\n<p>HTTP的URL地址开头是<code>http://</code>，默认使用的端口是<code>80</code>，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。</p>\n<h2 id=\"加密过程\"><a href=\"#加密过程\" class=\"headerlink\" title=\"加密过程\"></a>加密过程</h2><p>首先我们要知道，HTTPs是HTTP的安全版本，相当于在HTTP与TCP之间加了一层SSL，这一块主要看他是如何实现的。</p>\n<p><strong>原理</strong>：采用<strong>对称加密</strong>和<strong>非对称加密结合</strong>的方式来保护浏览器和服务端之间的通信安全。</p>\n<p><strong>大致流程</strong>：相比于HTTP多个SSL，这样就由原来的“不安全”变成了“安全”的，所以肯定的是：HTTPS是HTTP直接将报文信息传输给SSL套接字进行加密，SSL加密后将报文发送给TCP套接字，然后TCP套接字再将报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文发送给SSL套接字，SSL解密后交给对应进程。</p>\n<p>上面的自上而下的层面的理解，正如我们平时使用的那样，浏览器中输入的是https，从tcp的三次握手的角度看，https多了一次握手，<strong>详细流程</strong>：</p>\n<ul>\n<li>客户端发起握手请求，以明文传输请求信息（也就是https，，连接到服务端443端口）</li>\n<li>服务端返回信息，包括选择使用的协议版本、加密套件、压缩算法以及<strong>证书（也就是公钥！）</strong></li>\n<li>客户端验证证书的合法性，如是否吊销、是否过期、域名等。这些工作是由客户端的SSL来完成，没问题的话就生成一个随机值，然后用随机值加密报文，再用证书加密随机值。</li>\n<li>客户端使用公钥对对称密钥加密，发送给服务端。通过上面可知，发送的是证书加密后的随机值（也就是对称密钥），目的是让服务端得到这个随机值，以后服务端和客户端的通信就可以通过这个随机值来进行加密解密了（对称加密原理）</li>\n<li>服务器用私钥解密，拿到对称加密的密钥。</li>\n<li>传输加密后的信息，这部分信息就是服务端用随机值加密后的，可以在客户端用随机值解密还原。</li>\n<li>客户端用之前生成的私钥解密服务端传过来的信息，获取内容。</li>\n</ul>\n<p><strong>小结</strong>：用非对称加密来加密对称加密的密钥，发送的报文是用堆成加密来加密的，服务端私钥解密获取堆成加密的密钥，用它来解开密文。采用非对称加密是因为安全性，采用对称加密是因为速度快。</p>\n<h2 id=\"TLS-VS-SSL\"><a href=\"#TLS-VS-SSL\" class=\"headerlink\" title=\"TLS VS SSL\"></a>TLS VS SSL</h2>","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p><strong>Hypertext Transfer Protocol Secure</strong>, an extension of the Hypertext Transfer Protocol. </p>\n<p>How to encrypt communication? Through referred to as <strong>HTTP over TLS</strong>, or <strong>HTTP over SSL</strong></p>\n<ul>\n<li>Transport Layer Security</li>\n<li>Secure Sockets Layer</li>\n</ul>","more":"<h1 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h1><h2 id=\"Difference\"><a href=\"#Difference\" class=\"headerlink\" title=\"Difference\"></a>Difference</h2><p>HTTPS的URL地址开头是<code>https://</code>，默认使用的的端口是<code>443</code>，在http与TCP之间加入了SSL或者TSL，它的设计就是为了防止信息被窃取，会对包括header在内的整个信息加密。</p>\n<hr>\n<p>HTTP的URL地址开头是<code>http://</code>，默认使用的端口是<code>80</code>，他没有使用加密，直接通过TCP来进行传输，因此传输过程中的敏感信息有被窃听、攻击的风险。</p>\n<h2 id=\"加密过程\"><a href=\"#加密过程\" class=\"headerlink\" title=\"加密过程\"></a>加密过程</h2><p>首先我们要知道，HTTPs是HTTP的安全版本，相当于在HTTP与TCP之间加了一层SSL，这一块主要看他是如何实现的。</p>\n<p><strong>原理</strong>：采用<strong>对称加密</strong>和<strong>非对称加密结合</strong>的方式来保护浏览器和服务端之间的通信安全。</p>\n<p><strong>大致流程</strong>：相比于HTTP多个SSL，这样就由原来的“不安全”变成了“安全”的，所以肯定的是：HTTPS是HTTP直接将报文信息传输给SSL套接字进行加密，SSL加密后将报文发送给TCP套接字，然后TCP套接字再将报文发送给目的主机，目的主机将通过TCP套接字获取加密后的报文发送给SSL套接字，SSL解密后交给对应进程。</p>\n<p>上面的自上而下的层面的理解，正如我们平时使用的那样，浏览器中输入的是https，从tcp的三次握手的角度看，https多了一次握手，<strong>详细流程</strong>：</p>\n<ul>\n<li>客户端发起握手请求，以明文传输请求信息（也就是https，，连接到服务端443端口）</li>\n<li>服务端返回信息，包括选择使用的协议版本、加密套件、压缩算法以及<strong>证书（也就是公钥！）</strong></li>\n<li>客户端验证证书的合法性，如是否吊销、是否过期、域名等。这些工作是由客户端的SSL来完成，没问题的话就生成一个随机值，然后用随机值加密报文，再用证书加密随机值。</li>\n<li>客户端使用公钥对对称密钥加密，发送给服务端。通过上面可知，发送的是证书加密后的随机值（也就是对称密钥），目的是让服务端得到这个随机值，以后服务端和客户端的通信就可以通过这个随机值来进行加密解密了（对称加密原理）</li>\n<li>服务器用私钥解密，拿到对称加密的密钥。</li>\n<li>传输加密后的信息，这部分信息就是服务端用随机值加密后的，可以在客户端用随机值解密还原。</li>\n<li>客户端用之前生成的私钥解密服务端传过来的信息，获取内容。</li>\n</ul>\n<p><strong>小结</strong>：用非对称加密来加密对称加密的密钥，发送的报文是用堆成加密来加密的，服务端私钥解密获取堆成加密的密钥，用它来解开密文。采用非对称加密是因为安全性，采用对称加密是因为速度快。</p>\n<h2 id=\"TLS-VS-SSL\"><a href=\"#TLS-VS-SSL\" class=\"headerlink\" title=\"TLS VS SSL\"></a>TLS VS SSL</h2>"},{"title":"java collection framework","date":"2021-03-06T04:03:11.000Z","_content":"\n之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：**如果是你，你会怎么设计？**\n\n<!-- more-->\n\n<!-- toc -->\n\n# 换身份了\n\n​\t\t作为jdk的设计者，我希望推广我的作品--JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！\n\n# 容器的种类\n\n​\t\t装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。\n\n​\t\t银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他`Collection`吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个`iterator`接口出来，让`collection`继承了`iterator`。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：\n\n```java\npublic abstract Iterator<E> iterator();\n\npublic abstract int size();\n\npublic void clear() {\n    Iterator<E> it = iterator();\n    while (it.hasNext()) {\n        it.next();\n        it.remove();\n    }\n}\n\npublic Object[] toArray() {\n    // Estimate size of array; be prepared to see more or fewer elements\n    Object[] r = new Object[size()];\n    Iterator<E> it = iterator();\n    for (int i = 0; i < r.length; i++) {\n        if (! it.hasNext()) // fewer elements than expected\n            return Arrays.copyOf(r, i);\n        r[i] = it.next();\n    }\n    return it.hasNext() ? finishToArray(r, it) : r;\n}\n\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n```\n\n我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计`collection`接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有`List`、`Set`、`Queue`接口。有了接口，又回到刚才考虑`Collection`接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了`Collection`，所以要避免重复实现，我们的接口也是集成了`Collection`，这个时候我们具体容器的抽象类得集成`Collection`的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。\n\njdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。\n\n# 设计规律\n\n（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。\n\n","source":"_posts/java-collection-framework.md","raw":"---\ntitle: java collection framework\ndate: 2021-03-06 12:03:11\ncategories: jdk\ntags: framework\n---\n\n之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：**如果是你，你会怎么设计？**\n\n<!-- more-->\n\n<!-- toc -->\n\n# 换身份了\n\n​\t\t作为jdk的设计者，我希望推广我的作品--JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！\n\n# 容器的种类\n\n​\t\t装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。\n\n​\t\t银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他`Collection`吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个`iterator`接口出来，让`collection`继承了`iterator`。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：\n\n```java\npublic abstract Iterator<E> iterator();\n\npublic abstract int size();\n\npublic void clear() {\n    Iterator<E> it = iterator();\n    while (it.hasNext()) {\n        it.next();\n        it.remove();\n    }\n}\n\npublic Object[] toArray() {\n    // Estimate size of array; be prepared to see more or fewer elements\n    Object[] r = new Object[size()];\n    Iterator<E> it = iterator();\n    for (int i = 0; i < r.length; i++) {\n        if (! it.hasNext()) // fewer elements than expected\n            return Arrays.copyOf(r, i);\n        r[i] = it.next();\n    }\n    return it.hasNext() ? finishToArray(r, it) : r;\n}\n\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n```\n\n我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计`collection`接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有`List`、`Set`、`Queue`接口。有了接口，又回到刚才考虑`Collection`接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了`Collection`，所以要避免重复实现，我们的接口也是集成了`Collection`，这个时候我们具体容器的抽象类得集成`Collection`的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。\n\njdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。\n\n# 设计规律\n\n（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。\n\n","slug":"java-collection-framework","published":1,"updated":"2021-04-05T05:52:19.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8h0015ts9qeqp8105h","content":"<p>之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：<strong>如果是你，你会怎么设计？</strong></p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"换身份了\"><a href=\"#换身份了\" class=\"headerlink\" title=\"换身份了\"></a>换身份了</h1><p>​        作为jdk的设计者，我希望推广我的作品–JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！</p>\n<h1 id=\"容器的种类\"><a href=\"#容器的种类\" class=\"headerlink\" title=\"容器的种类\"></a>容器的种类</h1><p>​        装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。</p>\n<p>​        银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他<code>Collection</code>吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个<code>iterator</code>接口出来，让<code>collection</code>继承了<code>iterator</code>。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        it.next();</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class=\"line\">    Object[] r = <span class=\"keyword\">new</span> Object[size()];</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! it.hasNext()) <span class=\"comment\">// fewer elements than expected</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(r, i);</span><br><span class=\"line\">        r[i] = it.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计<code>collection</code>接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有<code>List</code>、<code>Set</code>、<code>Queue</code>接口。有了接口，又回到刚才考虑<code>Collection</code>接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了<code>Collection</code>，所以要避免重复实现，我们的接口也是集成了<code>Collection</code>，这个时候我们具体容器的抽象类得集成<code>Collection</code>的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。</p>\n<p>jdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。</p>\n<h1 id=\"设计规律\"><a href=\"#设计规律\" class=\"headerlink\" title=\"设计规律\"></a>设计规律</h1><p>（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>之前有过一篇集合框架的小结，随着时间的推移和使用体验，越发觉得那篇过于浅显，今天换个视角来看：<strong>如果是你，你会怎么设计？</strong></p>","more":"<!-- toc -->\n\n<h1 id=\"换身份了\"><a href=\"#换身份了\" class=\"headerlink\" title=\"换身份了\"></a>换身份了</h1><p>​        作为jdk的设计者，我希望推广我的作品–JDK，方便用户使用，得有一些拿来即用的产品，日常的操作离不开数据处理，数据需要有地方存，就叫容器吧。我的jdk有基础数据类型，这些不方便操作，不符合面向对象，于是有了他们的包装类，但是不管什么是什么对象，都是继承于Object的，我可以用语法糖来做编译检查，这也是提高用户体验的一种方式，所以我的容器得用范型。emmm，我的idea就这么产生了！下面得考虑容器的内部设计了！</p>\n<h1 id=\"容器的种类\"><a href=\"#容器的种类\" class=\"headerlink\" title=\"容器的种类\"></a>容器的种类</h1><p>​        装数据？拿什么装？我有数组，只能拿这个装，底层实现都是它，我把它封装起来好了。那用户可能有什么操作呢，增删改查，就这四个，但仔细想，还可以扩充出许多，例如，增，我可以在已有的后面追加，也可以第一个或中间任意一个地方加，其他的三个操作同理，这怎么搞？（好麻烦，不当设计者了吧？）现在就有了问题，细节怎么处理，是不是一开始考虑的太细节了？我把它作为一个作品、一个艺术品，艺术来源于生活，我都叫他容器了，想想生活中有什么器皿。</p>\n<p>​        银行柜员会挨个办理业务，这是一种读取数据的方式，往罐子里装食物，装完我先吃的都是后进去的，这也是一种……根据这个来做那成品岂不是容易理解，使用起来就不会陌生。我也是站在巨人的肩膀上，除了普通的类，还有接口和抽象类来使用，另外，参照生活中的“容器”，可以更好的使用面向对象。首先，无论是哪种容器，都得装东西吧，有装就有一些基本操作，先不考虑各种容器的差异，都会有大小、查找、是否包含、清空、返回数组（毕竟只有数组可以装东西了）等操作，那我就叫他<code>Collection</code>吧，规划蓝图，collection以后定会有不同的容器，难不成以后各个容器遍历的时候都要写一遍？我这个总接口都写好了，能否提供一个操作，不论里面装的啥、不论是哪种容器，使用这个方法都能把里面的东西挨个读出来，也就是说在某个地方写一个for循环就好了，于是我做了一个<code>iterator</code>接口出来，让<code>collection</code>继承了<code>iterator</code>。接口算是好了，我们需要让他逐渐具体。现在只有未实现的接口，想想有点像设计院的图纸，要出成品得交给工厂去做，而这个图纸目前来说就寥寥几笔，是一个蓝图的开始，需要再完善些。如何完善细节呢，要做哪些容器呢，还不知道，因为太多了，那我们就只具体一点点吧，不是还有抽象类么，没必要一步到位，所以找出通用的能实现的部分。因为有了iterator，所以可以做些事情了，例如，清空操作、定义实例变量等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        it.next();</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class=\"line\">    Object[] r = <span class=\"keyword\">new</span> Object[size()];</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! it.hasNext()) <span class=\"comment\">// fewer elements than expected</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(r, i);</span><br><span class=\"line\">        r[i] = it.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我已经实现了不少操作，是时候可以进一步了，根据元素的进出方式我觉得可以分为顺序进出、先进后出，又可以进一步以能否重复做划分。那么就有个问题，我设计<code>collection</code>接口的时候有些点没有想到，比如有序的容器我如果直接找出第几个元素怎么办？当时没做这个接口，没提供这个操作诶？是不是设计的有问题？其实不是，接口不也可以继承，本来就不是面面具到，就得一步步地完成抽象、进而具体的，我们可以继承collection接口去完善他，做出我们想要的容器的接口，因为继承，所以之前的操作都还在，他们是通用的。按照这个想法，可以有<code>List</code>、<code>Set</code>、<code>Queue</code>接口。有了接口，又回到刚才考虑<code>Collection</code>接口的点了，先用抽象类尽可能地实现接口，但同时要注意，我们已经实现过了<code>Collection</code>，所以要避免重复实现，我们的接口也是集成了<code>Collection</code>，这个时候我们具体容器的抽象类得集成<code>Collection</code>的抽象类。除了装成一堆的容器，也得有一对一的吧？比如商店售货员，给他一种商品价格，他得知道价格是多少，这就是一对一的关系，鉴于次，不同与collection的容器又被抽象出来了：Map（于是又要考虑一大堆并且设计接口、完成抽象类……）。</p>\n<p>jdk就是这样，一步一步地从功能、特性考虑对现实世界的物品建模，封装成我们能用的数据结构。</p>\n<h1 id=\"设计规律\"><a href=\"#设计规律\" class=\"headerlink\" title=\"设计规律\"></a>设计规律</h1><p>（好了 身份换回来了）集合框架给了我们典型的、优秀的设计案例：如何抽象、如何一步步地封装、如何变得具体。要学的不仅仅是如何使用，更重要的是思想。</p>"},{"title":"jump games","date":"2021-05-24T04:13:39.000Z","_content":"\n*Jump Games*在LeetCode中是一个系列的问题，涉及动态规划、贪心等策略，非常有意思，尤其是昨天周赛再次遇到了这个系列的新题，在此复盘、总结。\n\n<!-- more -->\n\n<!-- toc -->\n\n# Jump Game\n\n> 输入一个数组，从下标0开始，数组中每个数字表示你能跳跃的最大距离，问能否到达终点。\n\n这道题是能否到达终点，返回的是一个布尔值，所以不用关心到达终点的方式以及相关数量。假设有i，它可以跳跃的距离是d，那么在距离(i+1, i+d)之间都是可行进的范围，我们需要从这里面选出一步来往下走，对于下一步也重复上一步的操作，直到终点。但是这样做的话时间复杂度会到O(n^2)，提交肯定会TLE。\n\n### dp\n\n动态规划，用数组维护一个跳力值，只要到终点还有跳力（不为负）就说明是可行的。如何去写状态转移方程呢？对于一个位置i，只能从前n步中过来，但是这是不确定的，所以我们可以一步一步地往前走，同时维护最大跳力即可，所以回到刚才的位置i，他是从i-1过来的，那么他所剩的跳力可以从上一步中获取，到目前的i时减去一（i-1到i要耗费一个跳力）。对于i-1，有两种选择，一种是维护的跳力dp，另一种是i-1位置时获取的跳力nums，取一个最大值就行。dp中存储的就是跳力值了。\n\n```java\npublic boolean canReach(int[] nums){\n    int len = nums.length, res = 0;\n    int[] dp = new int[len];\n    for(int i=1; i<nums.length; i++){\n        res = Math.max(dp[i-1], nums[i-1]) - 1;\n        if(res < 0) return false;\n    }\n    \n    return true;\n}\n```\n\n### greedy\n\n可以对上面的dp做化简，我们只关心能否到达终点，一个简单的布尔值，不关心最终能跳多远，也就是跳力，所以可以只保留一个最远的值，判断他是否到比终点大就可，用到了贪心的思想。\n\n```java\npublic boolean canReach(int[] nums){\n    int len = nums.length, reach = 0;\n    for(int i=0; i<len; i++){\n        if(i > reach || reach >= len - 1) break;\n        reach = Math.max(reach, i + nums[i]);\n    }\n    \n    return reach >= len - 1;\n}\n```\n\n\n\n# Jump Game II\n\n> 同样是给一个数组，从下标0开始，每个数字表示你能跳跃的最大距离，区别是，在保证总能到达终点的情况下，返回耗费最少的跳跃次数。\n\n既然题目都保证了是终点可达的，那么是不是可以每次都选择跳的最远的那个？具体怎么选？其实不然，题目要求返回最少的次数，没有让详细返回跳的方案，所以，在一个能跳跃的区间内，总有一个符合条件的点，循环往复总会到达终点，我们只需要记录“循环”多少次不就行了。有三个变量：jump、curEnd、curFarthest，对于每一步都有一个区间范围，范围的末端就是curEnd，每个范围都会产生一个能到达的最远距离，我们以curEnd和curFarthest的最大值作为末尾标志，一旦区间跑完，就加一次jump，这样就做到了不关心具体在哪个点jump，而只关心次数了。\n\n```java\npublic boolean minJumpTimes(int[] nums){\n    int jumps = 0, curEnd = 0, curFarthest = 0;\n    for(int i=0; i<nums.length-1; i++){\n        curFarthest = Math.max(curFarthest, i + nums[i]);\n        if(i == curEnd){\n            jumps++;\n            curEnd = curFarthest;\n        }\n    }\n    \n    return jumps;\n}\n```\n\n\n\n# Jump Game III\n\n> 给定一个数组和一个起始位置start，对于每个点，只能走i-start或i+start两个位置，问能否访问到数组中任意0的位置。\n\n这种题实际上也是属于模拟，根据题目中的要求来做就好了，目前至少有两种方式，一种是递归地遍历（或者说深度优先），同时带上备忘录来标记访问过的点，另一种是广度优先，因为一个点可以带出来两个访问的方向，而且是顺序进行的。\n\n### dfs\n\n回溯，总是可以穷举出来的，每个点上都有两种方式可选，同一个点可能会被访问多次，我们也需要做一个标记来表示他被访问过，不能到达的话不必重复访问。\n\n```java\npublic boolean canReach(int][] nums, int start){\n    if(start >= 0 && start < nums.length && nums[start] < nums.length){\n        int jump = nums[start];\n        nums[start] += nums.length; // 做标记，这样nums[start]总是不合法的，不会再访问了\n        return jump == 0 || canReach(nums, start + jump) || canReach(nums, start - jump);\n    }\n    \n    return false;\n}\n```\n\n### bfs\n\n……\n\n\n\n# JumpGame VII\n\n> 给一个数组和一个minJump以及一个maxJump，其中只包含0或1，下标0处为0，从下标0处出发，每次跳跃的范围是(i+minJump, i+maxJump)且只能跳落到其中的0处，问能否跳跃到终点。\n\n可以怎么做？如果按照题目中的要求，在一个范围内找寻0来作为下一个起跳点，那么对于长度为n的数组，即便是使用dp来保存状态，时间复杂度也将会是O(n^2)。参考上面类似的思想， 他只询问能到到达终点，并不关心具体的路径，所以可以在范围的地方着手优化。","source":"_posts/jump-games.md","raw":"---\ntitle: jump games\ndate: 2021-05-24 12:13:39\ncategories: LeetCode\ntags: greedy dp stratey\n---\n\n*Jump Games*在LeetCode中是一个系列的问题，涉及动态规划、贪心等策略，非常有意思，尤其是昨天周赛再次遇到了这个系列的新题，在此复盘、总结。\n\n<!-- more -->\n\n<!-- toc -->\n\n# Jump Game\n\n> 输入一个数组，从下标0开始，数组中每个数字表示你能跳跃的最大距离，问能否到达终点。\n\n这道题是能否到达终点，返回的是一个布尔值，所以不用关心到达终点的方式以及相关数量。假设有i，它可以跳跃的距离是d，那么在距离(i+1, i+d)之间都是可行进的范围，我们需要从这里面选出一步来往下走，对于下一步也重复上一步的操作，直到终点。但是这样做的话时间复杂度会到O(n^2)，提交肯定会TLE。\n\n### dp\n\n动态规划，用数组维护一个跳力值，只要到终点还有跳力（不为负）就说明是可行的。如何去写状态转移方程呢？对于一个位置i，只能从前n步中过来，但是这是不确定的，所以我们可以一步一步地往前走，同时维护最大跳力即可，所以回到刚才的位置i，他是从i-1过来的，那么他所剩的跳力可以从上一步中获取，到目前的i时减去一（i-1到i要耗费一个跳力）。对于i-1，有两种选择，一种是维护的跳力dp，另一种是i-1位置时获取的跳力nums，取一个最大值就行。dp中存储的就是跳力值了。\n\n```java\npublic boolean canReach(int[] nums){\n    int len = nums.length, res = 0;\n    int[] dp = new int[len];\n    for(int i=1; i<nums.length; i++){\n        res = Math.max(dp[i-1], nums[i-1]) - 1;\n        if(res < 0) return false;\n    }\n    \n    return true;\n}\n```\n\n### greedy\n\n可以对上面的dp做化简，我们只关心能否到达终点，一个简单的布尔值，不关心最终能跳多远，也就是跳力，所以可以只保留一个最远的值，判断他是否到比终点大就可，用到了贪心的思想。\n\n```java\npublic boolean canReach(int[] nums){\n    int len = nums.length, reach = 0;\n    for(int i=0; i<len; i++){\n        if(i > reach || reach >= len - 1) break;\n        reach = Math.max(reach, i + nums[i]);\n    }\n    \n    return reach >= len - 1;\n}\n```\n\n\n\n# Jump Game II\n\n> 同样是给一个数组，从下标0开始，每个数字表示你能跳跃的最大距离，区别是，在保证总能到达终点的情况下，返回耗费最少的跳跃次数。\n\n既然题目都保证了是终点可达的，那么是不是可以每次都选择跳的最远的那个？具体怎么选？其实不然，题目要求返回最少的次数，没有让详细返回跳的方案，所以，在一个能跳跃的区间内，总有一个符合条件的点，循环往复总会到达终点，我们只需要记录“循环”多少次不就行了。有三个变量：jump、curEnd、curFarthest，对于每一步都有一个区间范围，范围的末端就是curEnd，每个范围都会产生一个能到达的最远距离，我们以curEnd和curFarthest的最大值作为末尾标志，一旦区间跑完，就加一次jump，这样就做到了不关心具体在哪个点jump，而只关心次数了。\n\n```java\npublic boolean minJumpTimes(int[] nums){\n    int jumps = 0, curEnd = 0, curFarthest = 0;\n    for(int i=0; i<nums.length-1; i++){\n        curFarthest = Math.max(curFarthest, i + nums[i]);\n        if(i == curEnd){\n            jumps++;\n            curEnd = curFarthest;\n        }\n    }\n    \n    return jumps;\n}\n```\n\n\n\n# Jump Game III\n\n> 给定一个数组和一个起始位置start，对于每个点，只能走i-start或i+start两个位置，问能否访问到数组中任意0的位置。\n\n这种题实际上也是属于模拟，根据题目中的要求来做就好了，目前至少有两种方式，一种是递归地遍历（或者说深度优先），同时带上备忘录来标记访问过的点，另一种是广度优先，因为一个点可以带出来两个访问的方向，而且是顺序进行的。\n\n### dfs\n\n回溯，总是可以穷举出来的，每个点上都有两种方式可选，同一个点可能会被访问多次，我们也需要做一个标记来表示他被访问过，不能到达的话不必重复访问。\n\n```java\npublic boolean canReach(int][] nums, int start){\n    if(start >= 0 && start < nums.length && nums[start] < nums.length){\n        int jump = nums[start];\n        nums[start] += nums.length; // 做标记，这样nums[start]总是不合法的，不会再访问了\n        return jump == 0 || canReach(nums, start + jump) || canReach(nums, start - jump);\n    }\n    \n    return false;\n}\n```\n\n### bfs\n\n……\n\n\n\n# JumpGame VII\n\n> 给一个数组和一个minJump以及一个maxJump，其中只包含0或1，下标0处为0，从下标0处出发，每次跳跃的范围是(i+minJump, i+maxJump)且只能跳落到其中的0处，问能否跳跃到终点。\n\n可以怎么做？如果按照题目中的要求，在一个范围内找寻0来作为下一个起跳点，那么对于长度为n的数组，即便是使用dp来保存状态，时间复杂度也将会是O(n^2)。参考上面类似的思想， 他只询问能到到达终点，并不关心具体的路径，所以可以在范围的地方着手优化。","slug":"jump-games","published":1,"updated":"2021-05-24T15:35:05.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8k0017ts9qc1j5gi2p","content":"<p><em>Jump Games</em>在LeetCode中是一个系列的问题，涉及动态规划、贪心等策略，非常有意思，尤其是昨天周赛再次遇到了这个系列的新题，在此复盘、总结。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"Jump-Game\"><a href=\"#Jump-Game\" class=\"headerlink\" title=\"Jump Game\"></a>Jump Game</h1><blockquote>\n<p>输入一个数组，从下标0开始，数组中每个数字表示你能跳跃的最大距离，问能否到达终点。</p>\n</blockquote>\n<p>这道题是能否到达终点，返回的是一个布尔值，所以不用关心到达终点的方式以及相关数量。假设有i，它可以跳跃的距离是d，那么在距离(i+1, i+d)之间都是可行进的范围，我们需要从这里面选出一步来往下走，对于下一步也重复上一步的操作，直到终点。但是这样做的话时间复杂度会到O(n^2)，提交肯定会TLE。</p>\n<h3 id=\"dp\"><a href=\"#dp\" class=\"headerlink\" title=\"dp\"></a>dp</h3><p>动态规划，用数组维护一个跳力值，只要到终点还有跳力（不为负）就说明是可行的。如何去写状态转移方程呢？对于一个位置i，只能从前n步中过来，但是这是不确定的，所以我们可以一步一步地往前走，同时维护最大跳力即可，所以回到刚才的位置i，他是从i-1过来的，那么他所剩的跳力可以从上一步中获取，到目前的i时减去一（i-1到i要耗费一个跳力）。对于i-1，有两种选择，一种是维护的跳力dp，另一种是i-1位置时获取的跳力nums，取一个最大值就行。dp中存储的就是跳力值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = nums.length, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">        res = Math.max(dp[i-<span class=\"number\">1</span>], nums[i-<span class=\"number\">1</span>]) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"greedy\"><a href=\"#greedy\" class=\"headerlink\" title=\"greedy\"></a>greedy</h3><p>可以对上面的dp做化简，我们只关心能否到达终点，一个简单的布尔值，不关心最终能跳多远，也就是跳力，所以可以只保留一个最远的值，判断他是否到比终点大就可，用到了贪心的思想。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = nums.length, reach = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; reach || reach &gt;= len - <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        reach = Math.max(reach, i + nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> reach &gt;= len - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Jump-Game-II\"><a href=\"#Jump-Game-II\" class=\"headerlink\" title=\"Jump Game II\"></a>Jump Game II</h1><blockquote>\n<p>同样是给一个数组，从下标0开始，每个数字表示你能跳跃的最大距离，区别是，在保证总能到达终点的情况下，返回耗费最少的跳跃次数。</p>\n</blockquote>\n<p>既然题目都保证了是终点可达的，那么是不是可以每次都选择跳的最远的那个？具体怎么选？其实不然，题目要求返回最少的次数，没有让详细返回跳的方案，所以，在一个能跳跃的区间内，总有一个符合条件的点，循环往复总会到达终点，我们只需要记录“循环”多少次不就行了。有三个变量：jump、curEnd、curFarthest，对于每一步都有一个区间范围，范围的末端就是curEnd，每个范围都会产生一个能到达的最远距离，我们以curEnd和curFarthest的最大值作为末尾标志，一旦区间跑完，就加一次jump，这样就做到了不关心具体在哪个点jump，而只关心次数了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">minJumpTimes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> jumps = <span class=\"number\">0</span>, curEnd = <span class=\"number\">0</span>, curFarthest = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length-<span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        curFarthest = Math.max(curFarthest, i + nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == curEnd)&#123;</span><br><span class=\"line\">            jumps++;</span><br><span class=\"line\">            curEnd = curFarthest;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> jumps;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Jump-Game-III\"><a href=\"#Jump-Game-III\" class=\"headerlink\" title=\"Jump Game III\"></a>Jump Game III</h1><blockquote>\n<p>给定一个数组和一个起始位置start，对于每个点，只能走i-start或i+start两个位置，问能否访问到数组中任意0的位置。</p>\n</blockquote>\n<p>这种题实际上也是属于模拟，根据题目中的要求来做就好了，目前至少有两种方式，一种是递归地遍历（或者说深度优先），同时带上备忘录来标记访问过的点，另一种是广度优先，因为一个点可以带出来两个访问的方向，而且是顺序进行的。</p>\n<h3 id=\"dfs\"><a href=\"#dfs\" class=\"headerlink\" title=\"dfs\"></a>dfs</h3><p>回溯，总是可以穷举出来的，每个点上都有两种方式可选，同一个点可能会被访问多次，我们也需要做一个标记来表示他被访问过，不能到达的话不必重复访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"keyword\">int</span>][] nums, <span class=\"keyword\">int</span> start)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start &gt;= <span class=\"number\">0</span> &amp;&amp; start &lt; nums.length &amp;&amp; nums[start] &lt; nums.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> jump = nums[start];</span><br><span class=\"line\">        nums[start] += nums.length; <span class=\"comment\">// 做标记，这样nums[start]总是不合法的，不会再访问了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> jump == <span class=\"number\">0</span> || canReach(nums, start + jump) || canReach(nums, start - jump);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bfs\"><a href=\"#bfs\" class=\"headerlink\" title=\"bfs\"></a>bfs</h3><p>……</p>\n<h1 id=\"JumpGame-VII\"><a href=\"#JumpGame-VII\" class=\"headerlink\" title=\"JumpGame VII\"></a>JumpGame VII</h1><blockquote>\n<p>给一个数组和一个minJump以及一个maxJump，其中只包含0或1，下标0处为0，从下标0处出发，每次跳跃的范围是(i+minJump, i+maxJump)且只能跳落到其中的0处，问能否跳跃到终点。</p>\n</blockquote>\n<p>可以怎么做？如果按照题目中的要求，在一个范围内找寻0来作为下一个起跳点，那么对于长度为n的数组，即便是使用dp来保存状态，时间复杂度也将会是O(n^2)。参考上面类似的思想， 他只询问能到到达终点，并不关心具体的路径，所以可以在范围的地方着手优化。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p><em>Jump Games</em>在LeetCode中是一个系列的问题，涉及动态规划、贪心等策略，非常有意思，尤其是昨天周赛再次遇到了这个系列的新题，在此复盘、总结。</p>","more":"<!-- toc -->\n\n<h1 id=\"Jump-Game\"><a href=\"#Jump-Game\" class=\"headerlink\" title=\"Jump Game\"></a>Jump Game</h1><blockquote>\n<p>输入一个数组，从下标0开始，数组中每个数字表示你能跳跃的最大距离，问能否到达终点。</p>\n</blockquote>\n<p>这道题是能否到达终点，返回的是一个布尔值，所以不用关心到达终点的方式以及相关数量。假设有i，它可以跳跃的距离是d，那么在距离(i+1, i+d)之间都是可行进的范围，我们需要从这里面选出一步来往下走，对于下一步也重复上一步的操作，直到终点。但是这样做的话时间复杂度会到O(n^2)，提交肯定会TLE。</p>\n<h3 id=\"dp\"><a href=\"#dp\" class=\"headerlink\" title=\"dp\"></a>dp</h3><p>动态规划，用数组维护一个跳力值，只要到终点还有跳力（不为负）就说明是可行的。如何去写状态转移方程呢？对于一个位置i，只能从前n步中过来，但是这是不确定的，所以我们可以一步一步地往前走，同时维护最大跳力即可，所以回到刚才的位置i，他是从i-1过来的，那么他所剩的跳力可以从上一步中获取，到目前的i时减去一（i-1到i要耗费一个跳力）。对于i-1，有两种选择，一种是维护的跳力dp，另一种是i-1位置时获取的跳力nums，取一个最大值就行。dp中存储的就是跳力值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = nums.length, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">        res = Math.max(dp[i-<span class=\"number\">1</span>], nums[i-<span class=\"number\">1</span>]) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"greedy\"><a href=\"#greedy\" class=\"headerlink\" title=\"greedy\"></a>greedy</h3><p>可以对上面的dp做化简，我们只关心能否到达终点，一个简单的布尔值，不关心最终能跳多远，也就是跳力，所以可以只保留一个最远的值，判断他是否到比终点大就可，用到了贪心的思想。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = nums.length, reach = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;len; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; reach || reach &gt;= len - <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        reach = Math.max(reach, i + nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> reach &gt;= len - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Jump-Game-II\"><a href=\"#Jump-Game-II\" class=\"headerlink\" title=\"Jump Game II\"></a>Jump Game II</h1><blockquote>\n<p>同样是给一个数组，从下标0开始，每个数字表示你能跳跃的最大距离，区别是，在保证总能到达终点的情况下，返回耗费最少的跳跃次数。</p>\n</blockquote>\n<p>既然题目都保证了是终点可达的，那么是不是可以每次都选择跳的最远的那个？具体怎么选？其实不然，题目要求返回最少的次数，没有让详细返回跳的方案，所以，在一个能跳跃的区间内，总有一个符合条件的点，循环往复总会到达终点，我们只需要记录“循环”多少次不就行了。有三个变量：jump、curEnd、curFarthest，对于每一步都有一个区间范围，范围的末端就是curEnd，每个范围都会产生一个能到达的最远距离，我们以curEnd和curFarthest的最大值作为末尾标志，一旦区间跑完，就加一次jump，这样就做到了不关心具体在哪个点jump，而只关心次数了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">minJumpTimes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> jumps = <span class=\"number\">0</span>, curEnd = <span class=\"number\">0</span>, curFarthest = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length-<span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        curFarthest = Math.max(curFarthest, i + nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == curEnd)&#123;</span><br><span class=\"line\">            jumps++;</span><br><span class=\"line\">            curEnd = curFarthest;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> jumps;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Jump-Game-III\"><a href=\"#Jump-Game-III\" class=\"headerlink\" title=\"Jump Game III\"></a>Jump Game III</h1><blockquote>\n<p>给定一个数组和一个起始位置start，对于每个点，只能走i-start或i+start两个位置，问能否访问到数组中任意0的位置。</p>\n</blockquote>\n<p>这种题实际上也是属于模拟，根据题目中的要求来做就好了，目前至少有两种方式，一种是递归地遍历（或者说深度优先），同时带上备忘录来标记访问过的点，另一种是广度优先，因为一个点可以带出来两个访问的方向，而且是顺序进行的。</p>\n<h3 id=\"dfs\"><a href=\"#dfs\" class=\"headerlink\" title=\"dfs\"></a>dfs</h3><p>回溯，总是可以穷举出来的，每个点上都有两种方式可选，同一个点可能会被访问多次，我们也需要做一个标记来表示他被访问过，不能到达的话不必重复访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canReach</span><span class=\"params\">(<span class=\"keyword\">int</span>][] nums, <span class=\"keyword\">int</span> start)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start &gt;= <span class=\"number\">0</span> &amp;&amp; start &lt; nums.length &amp;&amp; nums[start] &lt; nums.length)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> jump = nums[start];</span><br><span class=\"line\">        nums[start] += nums.length; <span class=\"comment\">// 做标记，这样nums[start]总是不合法的，不会再访问了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> jump == <span class=\"number\">0</span> || canReach(nums, start + jump) || canReach(nums, start - jump);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bfs\"><a href=\"#bfs\" class=\"headerlink\" title=\"bfs\"></a>bfs</h3><p>……</p>\n<h1 id=\"JumpGame-VII\"><a href=\"#JumpGame-VII\" class=\"headerlink\" title=\"JumpGame VII\"></a>JumpGame VII</h1><blockquote>\n<p>给一个数组和一个minJump以及一个maxJump，其中只包含0或1，下标0处为0，从下标0处出发，每次跳跃的范围是(i+minJump, i+maxJump)且只能跳落到其中的0处，问能否跳跃到终点。</p>\n</blockquote>\n<p>可以怎么做？如果按照题目中的要求，在一个范围内找寻0来作为下一个起跳点，那么对于长度为n的数组，即便是使用dp来保存状态，时间复杂度也将会是O(n^2)。参考上面类似的思想， 他只询问能到到达终点，并不关心具体的路径，所以可以在范围的地方着手优化。</p>"},{"title":"jvm classloader","date":"2021-03-23T15:32:02.000Z","_content":"\n类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。\n\n<!-- more -->\n\n<!-- toc -->\n\n# class\n\n提类加载器之前有必要说说他要加载的东西——class。\n\n\n\n# classLoader\n\n\n\n# 实践","source":"_posts/jvm-classloader.md","raw":"---\ntitle: jvm classloader\ndate: 2021-03-23 23:32:02\ncategories: JVM\ntags: classloader\n---\n\n类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。\n\n<!-- more -->\n\n<!-- toc -->\n\n# class\n\n提类加载器之前有必要说说他要加载的东西——class。\n\n\n\n# classLoader\n\n\n\n# 实践","slug":"jvm-classloader","published":1,"updated":"2021-04-05T05:44:14.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8m001bts9qaw8i6twl","content":"<p>类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h1><p>提类加载器之前有必要说说他要加载的东西——class。</p>\n<h1 id=\"classLoader\"><a href=\"#classLoader\" class=\"headerlink\" title=\"classLoader\"></a>classLoader</h1><h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1>","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>类加载器是java从抽象到更抽象的过程……我们写出来的是代码，编译后成了另一套代码（不是给人读的），然后通过类加载器加载进虚拟机给虚拟机去执行。所以类加载器就是这么一个位置。</p>","more":"<!-- toc -->\n\n<h1 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h1><p>提类加载器之前有必要说说他要加载的东西——class。</p>\n<h1 id=\"classLoader\"><a href=\"#classLoader\" class=\"headerlink\" title=\"classLoader\"></a>classLoader</h1><h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1>"},{"title":"jvm concurrency","date":"2021-03-23T15:32:31.000Z","_content":"","source":"_posts/jvm-concurrency.md","raw":"---\ntitle: jvm concurrency\ndate: 2021-03-23 23:32:31\ntags:\n---\n","slug":"jvm-concurrency","published":1,"updated":"2021-04-05T05:44:14.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8o001dts9q89vd6bwp","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"jvm memory-manage","date":"2021-03-23T15:38:15.000Z","_content":"\n温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 布局\n\n在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是**运行时数据区**。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。\n\n​\t\t普通的对象如何产生？在java代码层面我们通过关键字**new**来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放**new**的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。\n\n​\t\tjvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：**对象头，实例数据，对齐填充**。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。\n\n## 对象头\n\n拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。\n\n”打标记“这词儿我取的口语化，官方叫做*Mark Word*，用来存储自身的*运行时数据*，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。\n\n另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是**指针**。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用**句柄**。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：\n\n> reference -> 句柄 ->实例数据、类型数据\n\n其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。\n\n# 开辟\n\n上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。\n\n重点来了，虚拟机，开辟区域。\n\n真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做**指针碰撞（Bump the Pointer）**与**空闲链表（Free List）**。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁**CAS+失败重试**，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是**本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）**。\n\n# 回收\n\n​\t\t关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。\n\n如何确定对象该不该被回收，\n\n历史垃圾回收器，\n\nG1，新的分区方式，打破传统","source":"_posts/jvm-memory-manage.md","raw":"---\ntitle: jvm memory-manage\ndate: 2021-03-23 23:38:15\ncategories: JVM\ntags: memory\n---\n\n温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 布局\n\n在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是**运行时数据区**。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。\n\n​\t\t普通的对象如何产生？在java代码层面我们通过关键字**new**来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放**new**的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。\n\n​\t\tjvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：**对象头，实例数据，对齐填充**。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。\n\n## 对象头\n\n拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。\n\n”打标记“这词儿我取的口语化，官方叫做*Mark Word*，用来存储自身的*运行时数据*，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。\n\n另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是**指针**。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用**句柄**。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：\n\n> reference -> 句柄 ->实例数据、类型数据\n\n其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。\n\n# 开辟\n\n上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。\n\n重点来了，虚拟机，开辟区域。\n\n真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做**指针碰撞（Bump the Pointer）**与**空闲链表（Free List）**。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁**CAS+失败重试**，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是**本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）**。\n\n# 回收\n\n​\t\t关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。\n\n如何确定对象该不该被回收，\n\n历史垃圾回收器，\n\nG1，新的分区方式，打破传统","slug":"jvm-memory-manage","published":1,"updated":"2021-04-05T05:44:14.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8q001fts9q7yj03cl7","content":"<p>温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h1><p>在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是<strong>运行时数据区</strong>。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。</p>\n<p>​        普通的对象如何产生？在java代码层面我们通过关键字<strong>new</strong>来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放<strong>new</strong>的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。</p>\n<p>​        jvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：<strong>对象头，实例数据，对齐填充</strong>。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。</p>\n<h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。</p>\n<p>”打标记“这词儿我取的口语化，官方叫做<em>Mark Word</em>，用来存储自身的<em>运行时数据</em>，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。</p>\n<p>另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是<strong>指针</strong>。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用<strong>句柄</strong>。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：</p>\n<blockquote>\n<p>reference -&gt; 句柄 -&gt;实例数据、类型数据</p>\n</blockquote>\n<p>其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。</p>\n<h1 id=\"开辟\"><a href=\"#开辟\" class=\"headerlink\" title=\"开辟\"></a>开辟</h1><p>上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。</p>\n<p>重点来了，虚拟机，开辟区域。</p>\n<p>真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做<strong>指针碰撞（Bump the Pointer）</strong>与<strong>空闲链表（Free List）</strong>。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁<strong>CAS+失败重试</strong>，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是<strong>本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）</strong>。</p>\n<h1 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h1><p>​        关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。</p>\n<p>如何确定对象该不该被回收，</p>\n<p>历史垃圾回收器，</p>\n<p>G1，新的分区方式，打破传统</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>温故知新。jvm的自动内存管理在代码层面为我们省去了很多麻烦，在机器与代码之间有虚拟机执行编译后的字节码，虽然已经不太可能出现oom，但对于以后java的发展以及目前java运行机制的来说，熟悉jvm的内存管理是很有必要的。学过C++，语法中专门有开辟内存的语句……，虽然不用我们写这些，但起码说明了一些涉及内存的东西：开辟与回收。</p>","more":"<!-- toc -->\n\n<h1 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h1><p>在了解jvm如何帮我们处理内存之前，我们先回顾jvm对于内存管理的布局，或者说是<strong>运行时数据区</strong>。这里图就不贴了，想看的可以参考之前的一篇jvm概览，运行时数据区的各模块同理，这里主要回顾对象与数据区之间的联系，也就是对象的产生以及在内存中的布局。</p>\n<p>​        普通的对象如何产生？在java代码层面我们通过关键字<strong>new</strong>来创建对象，他会调用构造方法来构造，这样一个对象被创建出来了，又叫实例化（Initialize）。还有一个概念叫初始化，这两点在Spring源码中区分的特别清晰，对于一个解放<strong>new</strong>的框架来说这么做是没毛病的，面向对象中，对象是有属性的，简单来说初始化是创建对象，实例化是对象的属性赋值。我们代码写完是交由虚拟机处理，虚拟机处理的又是编译过后的class文件，所以对象如何创建以及创建后如何布局都是jvm要做的事了。创建后对象会有个生存周期吧，一直存在虚拟机装不下的……等等诸多围绕着对象的问题。</p>\n<p>​        jvm在读到new相关的指令后（我们知道new之后是类啊）会从方法区找类关的信息，看是否被加载，被加载后就开始为内存分配地方，换句话说，给一个对象分配多大的地方是确定的，而且是在类加载后就能确定。在哪里看类的相关信息呢，方法区，这是类加载的入口，通常要经过加载、解析、初始化等过程。创建后的对象如何存在于虚拟机中的呢？分为三部分：<strong>对象头，实例数据，对齐填充</strong>。其实对于后两个是容易理解的，首先来说对齐填充，在计算机世界中，充斥各种二进制的特征，尤其是2的整数倍，一来是方便运算，二来是节省空间；其次是实例数据，这个当然，我们创建了对象，对象得有属性，即实例变量。最后是这个对象头，是蛮抽象的，有什么用呢？从这个角度想：我可以new很多个对象，每个对象独一无二如何体现（每个属性都相同）？每个属性不同的对象我们好区分，虚拟机知道么，是不是得有标记？对象该被回收了虚拟机如何知道谁该被回收，考实力数据和对齐填充吗？显然不可能。所以，可以理解为对象头是辅助用的（地位绝对可以做star），拿来记录各种标记。</p>\n<h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>拿对象头来做各种标记是没错的，标记这么多，还是可以再分分类的：记录的归做一类，引用（查找）的做另一类。</p>\n<p>”打标记“这词儿我取的口语化，官方叫做<em>Mark Word</em>，用来存储自身的<em>运行时数据</em>，有那些呢？哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向时间戳等。</p>\n<p>另一类，引用，为什么这么叫呢，这是上面提到过的“创建那么多对象如何确定哪个是哪个”的查找问题，也就是<strong>指针</strong>。他的作用是确定这个实例对象是由哪个类创建出来的，例如，我们可以通过这个来找出对象的模板信息（即类的结构信息），但并不是所有虚拟机都是这样设计的，除了指针也可以用<strong>句柄</strong>。对象存在于方法中，通过各种逻辑实现对象之间的交互，在java中，除了基本数据类型就是对象的引用类型了，指针还好理解，句柄又是什么呢？可以理解为指针的中转站：</p>\n<blockquote>\n<p>reference -&gt; 句柄 -&gt;实例数据、类型数据</p>\n</blockquote>\n<p>其中实例数据与句柄均在堆中，类型数据位于方法区，reference位于java栈。这样做的坏处是每次访问对象不像指针那样简单地之间访问（对象头有指针，对象实例数据与对象头平级），而是会多一次开销。好处也不是没有，他与指针的方式的最大区别是将reference与实力数据、类型数据解耦了，即无论句柄到实例数据的关系如何修改，reference到句柄是稳定不变的。句柄到实例数据的引用为什么会变，频繁么？我觉得如果足够频繁才能凸显出句柄的优势。什么时候变？垃圾回收导致的对象移动。</p>\n<h1 id=\"开辟\"><a href=\"#开辟\" class=\"headerlink\" title=\"开辟\"></a>开辟</h1><p>上面说到对象的大小是在类加载后就能确定的，毕竟类结构信息就是一个模板，照着模板造出来的对象一定是整齐化一的，如何开辟空间、在哪里开辟？这是这部分要讨论的问题。我们知道垃圾回收的地点是堆，对象也是创建在堆中的，所以，每次创建对象，虚拟机都会在堆中给这个新生对象开辟一块区域。</p>\n<p>重点来了，虚拟机，开辟区域。</p>\n<p>真实的计算机中也会涉及到内存的问题，经典的数据结构有线性表和链表，我们都知道线性表随机访问与他连续存储的特点分不开，链表不同，因为内存是分散的，要链在一起一定要有个指针来标记下一个在哪。虚拟机不也得仿照真实的计算机不是么，不然为什么叫虚拟机。于是也有两种分配内存的方式，一种是连续的，一种是链式的。这里虚拟与真实的区别也是有的，虚拟的要考虑开辟后如何回收，如何回收取决与启动时如何配置垃圾回收策略，而垃圾回收的策略决定着内存是否完整，内存的完整与否决定对象分配是整块划分还是散着链式链接。专业的术语叫做<strong>指针碰撞（Bump the Pointer）</strong>与<strong>空闲链表（Free List）</strong>。如何分配内存确定了，还剩下一个问题是冲突，频繁移动指针引起的线程安全问题。关于锁，在操作系统中我们知道有轻锁与重锁，这里同样适用，但是这里更聪明一些，一个方法是使用了轻度锁<strong>CAS+失败重试</strong>，另一个是单独给线程分配一块内存，需要分配时让线程在自己的地方玩，玩完了重新分内存时再上锁处理并发。后一个方法中给线程分配出来的内存更专业的术语是<strong>本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）</strong>。</p>\n<h1 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h1><p>​        关于对象回收，之前一直在说垃圾回收，没错，没用的对象就成了垃圾。这里明显的问题就是如何知道对象该不该被回收，以及确定了回收对象后，回收的策略是什么。现在我们是站在巨人的肩膀上，以上帝视角看待这个问题，目前java的版本迭代更像是打了鸡血……，博主虽然从事java开发工作，但截至前接触java的时间不到两年，更是鲜有遇见过jvm崩溃的问题，所以以前的jvm垃圾回收器在步入历史长河的情况下，只作为了解，这部分更多是对现用和具有发展潜力的回收器如G1展开分析。</p>\n<p>如何确定对象该不该被回收，</p>\n<p>历史垃圾回收器，</p>\n<p>G1，新的分区方式，打破传统</p>"},{"title":"jvm","date":"2020-05-24T09:39:25.000Z","_content":"\nassociate with juc\n\n<!--more-->\n\n<!--toc-->\n\n# 系统图\n\n![Screenshot from 2020-06-04 20-11-48.png](https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png)\n\n- 灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收\n- 亮色代表存在垃圾回收\n\n# 类加载器\n\n经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。\n\n> Car.class -> Class Loader -> Car Class -> car1/car2/car3\n\nCar Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。\n\n![Screenshot from 2020-06-04 20-33-54.png](https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png)\n\n## 种类\n\n### 启动类加载器（Bootstrap）\n\n由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。\n\n### 扩展类加载器（Extension）\n\nJava编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。\n\n### 应用程序类加载器（AppClassLoader）\n\n我们编写程序时定义的类所用的加载器\n\n### 用户自定义加载器\n\n定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。\n\n## 双亲委派\n\n比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。\n\n**Bootstrap** --> **Extension** --> **Application**\n\n```java\npublic class String{\n    public static void main(String[] args){\n        System.out.println(\"hello world!\");\n    }\n}\n```\n\n> 在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。\n\n## 沙箱安全机制\n\n**note**: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。\n\n## 本地方法接口（Native Interface）\n\n融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。\n\n异构领域间通信发达，Socket通信或webService。\n\n### Native\n\n只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。\n\n### 本地方法栈\n\n装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。\n\n# PC寄存器\n\n实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。\n\n是当前线程所执行的字节码的行号指示器。\n\n# 栈\n\n- 不存在垃圾回收问题\n- ==线程私有==（想想加锁，不就在方法上/中加的么）\n\n也叫栈内存，**主管Java程序的运行**，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。\n\n## 存储\n\n在java中的方法装载在虚拟机的栈中叫栈帧。\n\n- Local Variables: 输入参数、输出参数以及方法内的变量\n\n  ```java\n  // 入参为 x, y， 输出为result，方法内变量为result，均在栈中。\n  public int add(int x, int y){\n      int result = 0;\n      result = x + y;\n      return result;\n  }\n  ```\n\n- Operand Stack: 记录出栈、入栈的操作\n\n- Frame Data: 包括类文件、方法等等\n\n## 运行\n\n栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。\n\n```java\n// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误\npublic static void m1(){\n    m1();\n}\n```\n\n\n\n每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。\n\n栈管运行，堆管存储。\n\n# 方法区\n\nclass文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是`永久代(PermGen space)`和`元空间(Metaspace)`。\n\n- 所有==线程共享==\n- 存在垃圾回收\n\n存储每个类的**结构信息**（模板）\n\n```java\npublic class Car{\n    int price = 1233435;\n    public park(){\n        System.out.println(\"stop ...\");\n    }\n}\n```\n\n例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。\n\n元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是**本机物理内存**。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。\n\n实例变量存在堆内存中，与方法区无关。i.e.\n\n```java\npublic class Demo{\n    public void hello(){}\n    public static void main(String[] args){\n        Demo demo = new Demo();\n        demo.hello();\n    }\n}\n```\n\n每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。\n\n# 方法区、栈、堆\n\n```java\nPerson person1 = new Person();\nPerson person2 = new Person();\n```\n\n左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。\n\n要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。\n\nhotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈-->堆-->方法区\n\n# 堆\n\n（Java7之前）\t一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。\n\n(Java8)\t永久区换成了元空间。\n\n物理上为新生区+养老区。\n\n## 堆内存\n\n逻辑上分为三部分：新生+养老+永久\n\n新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)\n\n养老区：Tenure Generation Space\n\n永久存储区：Permanent Space\n\n- Eden: 0space: 1space  = 8 : 1 : 1\n- Young : Old = 1 : 2\n\n## 静态\n\n实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。\n\n## 动态\n\nSurvivor 0 space: from区\n\nSurrivor 1 space: to区\n\n他们的位置不固定，每次GC之后位置会交换，空的为to区。\n\n1. Eden, SurvivorFrom copy to SurviviorTo\n2. clean up Eden, SurvivorFrom\n3. Swap SurvivorTo and SurvivorFrom\n\n## 永久代\n\n是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。\n\n## 调优\n\n```java\npublic static void main(String[] args){\n    // Returns the maximum amount of memory that the Java virtual machine will attempt to use.\n    long l = Runtime.getRuntime().maxMemory();\n\n    // Returns the total amount of memory in the Java virtual machine.\n    long l1 = Runtime.getRuntime().totalMemory();\n\n    // 1/4\n    System.out.println(\"(-xmx) MAX_MEMORY: \" + l + \"bytes, \" + (l / (double) 1024 / 1024 + \"MB\"));\n    \n    // 1/64\n    System.out.println(\"(-xms) TOTAL_MEMORY: \" + l1 + \"bytes, \" + (l1 / (double) 1024 / 1024 + \"MB\"));\n}\n```\n\n**note:** 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。\n\n> -XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）\n\n# GC\n\n- minor GC\n- major/full GC\n\nmajor GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。\n\n## 垃圾回收算法\n\n分代收集，根据各个代来使用\n\n### 引用计数法\n\n每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。\n\n### 复制算法（Copying）\n\nMinor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。\n\n因为存活率都很低，复制也没啥。\n\n### 标记清除法（Mark-Sweep）\n\nMajor GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。\n\n### 标记压缩（Mark-Compact）\n\nMark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。\n\n也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。\n\n# JMM\n\nJava的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（**包括实例字段、静态字段以及构成数组对象的元素**）的访问方式。\n\n在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，`工作内存`是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作\n\n内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。\n\n## violatile\n\njava虚拟机提供的轻量级的同步机制，乞丐版syncronized。\n\n- 保证可见性\n- 不保证原子性\n- 禁止指令重排\n\n\n\n# 总结\n\n这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于*native*以及便以后的*class*，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。\n\n\n\n","source":"_posts/jvm.md","raw":"---\ntitle: jvm\ndate: 2020-05-24 17:39:25\ncategories: JVM\ntags: summary\n---\n\nassociate with juc\n\n<!--more-->\n\n<!--toc-->\n\n# 系统图\n\n![Screenshot from 2020-06-04 20-11-48.png](https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png)\n\n- 灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收\n- 亮色代表存在垃圾回收\n\n# 类加载器\n\n经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。\n\n> Car.class -> Class Loader -> Car Class -> car1/car2/car3\n\nCar Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。\n\n![Screenshot from 2020-06-04 20-33-54.png](https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png)\n\n## 种类\n\n### 启动类加载器（Bootstrap）\n\n由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。\n\n### 扩展类加载器（Extension）\n\nJava编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。\n\n### 应用程序类加载器（AppClassLoader）\n\n我们编写程序时定义的类所用的加载器\n\n### 用户自定义加载器\n\n定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。\n\n## 双亲委派\n\n比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。\n\n**Bootstrap** --> **Extension** --> **Application**\n\n```java\npublic class String{\n    public static void main(String[] args){\n        System.out.println(\"hello world!\");\n    }\n}\n```\n\n> 在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。\n\n## 沙箱安全机制\n\n**note**: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。\n\n## 本地方法接口（Native Interface）\n\n融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。\n\n异构领域间通信发达，Socket通信或webService。\n\n### Native\n\n只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。\n\n### 本地方法栈\n\n装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。\n\n# PC寄存器\n\n实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。\n\n是当前线程所执行的字节码的行号指示器。\n\n# 栈\n\n- 不存在垃圾回收问题\n- ==线程私有==（想想加锁，不就在方法上/中加的么）\n\n也叫栈内存，**主管Java程序的运行**，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。\n\n## 存储\n\n在java中的方法装载在虚拟机的栈中叫栈帧。\n\n- Local Variables: 输入参数、输出参数以及方法内的变量\n\n  ```java\n  // 入参为 x, y， 输出为result，方法内变量为result，均在栈中。\n  public int add(int x, int y){\n      int result = 0;\n      result = x + y;\n      return result;\n  }\n  ```\n\n- Operand Stack: 记录出栈、入栈的操作\n\n- Frame Data: 包括类文件、方法等等\n\n## 运行\n\n栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。\n\n```java\n// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误\npublic static void m1(){\n    m1();\n}\n```\n\n\n\n每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。\n\n栈管运行，堆管存储。\n\n# 方法区\n\nclass文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是`永久代(PermGen space)`和`元空间(Metaspace)`。\n\n- 所有==线程共享==\n- 存在垃圾回收\n\n存储每个类的**结构信息**（模板）\n\n```java\npublic class Car{\n    int price = 1233435;\n    public park(){\n        System.out.println(\"stop ...\");\n    }\n}\n```\n\n例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。\n\n元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是**本机物理内存**。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。\n\n实例变量存在堆内存中，与方法区无关。i.e.\n\n```java\npublic class Demo{\n    public void hello(){}\n    public static void main(String[] args){\n        Demo demo = new Demo();\n        demo.hello();\n    }\n}\n```\n\n每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。\n\n# 方法区、栈、堆\n\n```java\nPerson person1 = new Person();\nPerson person2 = new Person();\n```\n\n左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。\n\n要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。\n\nhotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈-->堆-->方法区\n\n# 堆\n\n（Java7之前）\t一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。\n\n(Java8)\t永久区换成了元空间。\n\n物理上为新生区+养老区。\n\n## 堆内存\n\n逻辑上分为三部分：新生+养老+永久\n\n新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)\n\n养老区：Tenure Generation Space\n\n永久存储区：Permanent Space\n\n- Eden: 0space: 1space  = 8 : 1 : 1\n- Young : Old = 1 : 2\n\n## 静态\n\n实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。\n\n## 动态\n\nSurvivor 0 space: from区\n\nSurrivor 1 space: to区\n\n他们的位置不固定，每次GC之后位置会交换，空的为to区。\n\n1. Eden, SurvivorFrom copy to SurviviorTo\n2. clean up Eden, SurvivorFrom\n3. Swap SurvivorTo and SurvivorFrom\n\n## 永久代\n\n是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。\n\n## 调优\n\n```java\npublic static void main(String[] args){\n    // Returns the maximum amount of memory that the Java virtual machine will attempt to use.\n    long l = Runtime.getRuntime().maxMemory();\n\n    // Returns the total amount of memory in the Java virtual machine.\n    long l1 = Runtime.getRuntime().totalMemory();\n\n    // 1/4\n    System.out.println(\"(-xmx) MAX_MEMORY: \" + l + \"bytes, \" + (l / (double) 1024 / 1024 + \"MB\"));\n    \n    // 1/64\n    System.out.println(\"(-xms) TOTAL_MEMORY: \" + l1 + \"bytes, \" + (l1 / (double) 1024 / 1024 + \"MB\"));\n}\n```\n\n**note:** 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。\n\n> -XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）\n\n# GC\n\n- minor GC\n- major/full GC\n\nmajor GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。\n\n## 垃圾回收算法\n\n分代收集，根据各个代来使用\n\n### 引用计数法\n\n每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。\n\n### 复制算法（Copying）\n\nMinor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。\n\n因为存活率都很低，复制也没啥。\n\n### 标记清除法（Mark-Sweep）\n\nMajor GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。\n\n### 标记压缩（Mark-Compact）\n\nMark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。\n\n也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。\n\n# JMM\n\nJava的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（**包括实例字段、静态字段以及构成数组对象的元素**）的访问方式。\n\n在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，`工作内存`是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作\n\n内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。\n\n## violatile\n\njava虚拟机提供的轻量级的同步机制，乞丐版syncronized。\n\n- 保证可见性\n- 不保证原子性\n- 禁止指令重排\n\n\n\n# 总结\n\n这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于*native*以及便以后的*class*，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。\n\n\n\n","slug":"jvm","published":1,"updated":"2021-04-05T05:44:14.761Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8t001jts9q4grb3y0u","content":"<p>associate with juc</p>\n<span id=\"more\"></span>\n\n<!--toc-->\n\n<h1 id=\"系统图\"><a href=\"#系统图\" class=\"headerlink\" title=\"系统图\"></a>系统图</h1><p><img src=\"https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png\" alt=\"Screenshot from 2020-06-04 20-11-48.png\"></p>\n<ul>\n<li>灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收</li>\n<li>亮色代表存在垃圾回收</li>\n</ul>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。</p>\n<blockquote>\n<p>Car.class -&gt; Class Loader -&gt; Car Class -&gt; car1/car2/car3</p>\n</blockquote>\n<p>Car Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。</p>\n<p><img src=\"https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png\" alt=\"Screenshot from 2020-06-04 20-33-54.png\"></p>\n<h2 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h2><h3 id=\"启动类加载器（Bootstrap）\"><a href=\"#启动类加载器（Bootstrap）\" class=\"headerlink\" title=\"启动类加载器（Bootstrap）\"></a>启动类加载器（Bootstrap）</h3><p>由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。</p>\n<h3 id=\"扩展类加载器（Extension）\"><a href=\"#扩展类加载器（Extension）\" class=\"headerlink\" title=\"扩展类加载器（Extension）\"></a>扩展类加载器（Extension）</h3><p>Java编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。</p>\n<h3 id=\"应用程序类加载器（AppClassLoader）\"><a href=\"#应用程序类加载器（AppClassLoader）\" class=\"headerlink\" title=\"应用程序类加载器（AppClassLoader）\"></a>应用程序类加载器（AppClassLoader）</h3><p>我们编写程序时定义的类所用的加载器</p>\n<h3 id=\"用户自定义加载器\"><a href=\"#用户自定义加载器\" class=\"headerlink\" title=\"用户自定义加载器\"></a>用户自定义加载器</h3><p>定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。</p>\n<h2 id=\"双亲委派\"><a href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"></a>双亲委派</h2><p>比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。</p>\n<p><strong>Bootstrap</strong> –&gt; <strong>Extension</strong> –&gt; <strong>Application</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。</p>\n</blockquote>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p><strong>note</strong>: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。</p>\n<h2 id=\"本地方法接口（Native-Interface）\"><a href=\"#本地方法接口（Native-Interface）\" class=\"headerlink\" title=\"本地方法接口（Native Interface）\"></a>本地方法接口（Native Interface）</h2><p>融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。</p>\n<p>异构领域间通信发达，Socket通信或webService。</p>\n<h3 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h3><p>只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。</p>\n<h1 id=\"PC寄存器\"><a href=\"#PC寄存器\" class=\"headerlink\" title=\"PC寄存器\"></a>PC寄存器</h1><p>实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。</p>\n<p>是当前线程所执行的字节码的行号指示器。</p>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><ul>\n<li>不存在垃圾回收问题</li>\n<li>==线程私有==（想想加锁，不就在方法上/中加的么）</li>\n</ul>\n<p>也叫栈内存，<strong>主管Java程序的运行</strong>，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><p>在java中的方法装载在虚拟机的栈中叫栈帧。</p>\n<ul>\n<li><p>Local Variables: 输入参数、输出参数以及方法内的变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入参为 x, y， 输出为result，方法内变量为result，均在栈中。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    result = x + y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Operand Stack: 记录出栈、入栈的操作</p>\n</li>\n<li><p>Frame Data: 包括类文件、方法等等</p>\n</li>\n</ul>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">m1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    m1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。</p>\n<p>栈管运行，堆管存储。</p>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><p>class文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是<code>永久代(PermGen space)</code>和<code>元空间(Metaspace)</code>。</p>\n<ul>\n<li>所有==线程共享==</li>\n<li>存在垃圾回收</li>\n</ul>\n<p>存储每个类的<strong>结构信息</strong>（模板）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> price = <span class=\"number\">1233435</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">park</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;stop ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。</p>\n<p>元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是<strong>本机物理内存</strong>。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p>\n<p>实例变量存在堆内存中，与方法区无关。i.e.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。</p>\n<h1 id=\"方法区、栈、堆\"><a href=\"#方法区、栈、堆\" class=\"headerlink\" title=\"方法区、栈、堆\"></a>方法区、栈、堆</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person person2 = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p>左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。</p>\n<p>要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。</p>\n<p>hotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈–&gt;堆–&gt;方法区</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>（Java7之前）    一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p>\n<p>(Java8)    永久区换成了元空间。</p>\n<p>物理上为新生区+养老区。</p>\n<h2 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h2><p>逻辑上分为三部分：新生+养老+永久</p>\n<p>新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)</p>\n<p>养老区：Tenure Generation Space</p>\n<p>永久存储区：Permanent Space</p>\n<ul>\n<li>Eden: 0space: 1space  = 8 : 1 : 1</li>\n<li>Young : Old = 1 : 2</li>\n</ul>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。</p>\n<h2 id=\"动态\"><a href=\"#动态\" class=\"headerlink\" title=\"动态\"></a>动态</h2><p>Survivor 0 space: from区</p>\n<p>Surrivor 1 space: to区</p>\n<p>他们的位置不固定，每次GC之后位置会交换，空的为to区。</p>\n<ol>\n<li>Eden, SurvivorFrom copy to SurviviorTo</li>\n<li>clean up Eden, SurvivorFrom</li>\n<li>Swap SurvivorTo and SurvivorFrom</li>\n</ol>\n<h2 id=\"永久代\"><a href=\"#永久代\" class=\"headerlink\" title=\"永久代\"></a>永久代</h2><p>是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。</p>\n<h2 id=\"调优\"><a href=\"#调优\" class=\"headerlink\" title=\"调优\"></a>调优</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Returns the maximum amount of memory that the Java virtual machine will attempt to use.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l = Runtime.getRuntime().maxMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns the total amount of memory in the Java virtual machine.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l1 = Runtime.getRuntime().totalMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1/4</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xmx) MAX_MEMORY: &quot;</span> + l + <span class=\"string\">&quot;bytes, &quot;</span> + (l / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1/64</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xms) TOTAL_MEMORY: &quot;</span> + l1 + <span class=\"string\">&quot;bytes, &quot;</span> + (l1 / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。</p>\n<blockquote>\n<p>-XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）</p>\n</blockquote>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><ul>\n<li>minor GC</li>\n<li>major/full GC</li>\n</ul>\n<p>major GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。</p>\n<h2 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h2><p>分代收集，根据各个代来使用</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。</p>\n<h3 id=\"复制算法（Copying）\"><a href=\"#复制算法（Copying）\" class=\"headerlink\" title=\"复制算法（Copying）\"></a>复制算法（Copying）</h3><p>Minor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。</p>\n<p>因为存活率都很低，复制也没啥。</p>\n<h3 id=\"标记清除法（Mark-Sweep）\"><a href=\"#标记清除法（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除法（Mark-Sweep）\"></a>标记清除法（Mark-Sweep）</h3><p>Major GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。</p>\n<h3 id=\"标记压缩（Mark-Compact）\"><a href=\"#标记压缩（Mark-Compact）\" class=\"headerlink\" title=\"标记压缩（Mark-Compact）\"></a>标记压缩（Mark-Compact）</h3><p>Mark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。</p>\n<p>也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。</p>\n<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>Java的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（<strong>包括实例字段、静态字段以及构成数组对象的元素</strong>）的访问方式。</p>\n<p>在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，<code>工作内存</code>是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作</p>\n<p>内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p>\n<h2 id=\"violatile\"><a href=\"#violatile\" class=\"headerlink\" title=\"violatile\"></a>violatile</h2><p>java虚拟机提供的轻量级的同步机制，乞丐版syncronized。</p>\n<ul>\n<li>保证可见性</li>\n<li>不保证原子性</li>\n<li>禁止指令重排</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于<em>native</em>以及便以后的<em>class</em>，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>associate with juc</p>","more":"<!--toc-->\n\n<h1 id=\"系统图\"><a href=\"#系统图\" class=\"headerlink\" title=\"系统图\"></a>系统图</h1><p><img src=\"https://i.loli.net/2020/06/04/UQfq2lrGu9mLc4C.png\" alt=\"Screenshot from 2020-06-04 20-11-48.png\"></p>\n<ul>\n<li>灰色代表线程私有，占用的内存非常少，几乎不存在垃圾回收</li>\n<li>亮色代表存在垃圾回收</li>\n</ul>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>经过javac编译后，形成的xxx.class文件存在电脑硬盘上，通过类加载器装进JVM并初始化为xxx.Class文件（装载进虚拟机）。只负责加载class文件，将之装载后成为Class文件，放进方法区。</p>\n<blockquote>\n<p>Car.class -&gt; Class Loader -&gt; Car Class -&gt; car1/car2/car3</p>\n</blockquote>\n<p>Car Class是后面car1、car2、car3的模板，后面的三个car也是实例化的产物。</p>\n<p><img src=\"https://i.loli.net/2020/06/04/EYRbMN1fgIOuHBk.png\" alt=\"Screenshot from 2020-06-04 20-33-54.png\"></p>\n<h2 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h2><h3 id=\"启动类加载器（Bootstrap）\"><a href=\"#启动类加载器（Bootstrap）\" class=\"headerlink\" title=\"启动类加载器（Bootstrap）\"></a>启动类加载器（Bootstrap）</h3><p>由C++编写，默认加载一些编写程序比用的东西，比如Object, ArrayList, String等。</p>\n<h3 id=\"扩展类加载器（Extension）\"><a href=\"#扩展类加载器（Extension）\" class=\"headerlink\" title=\"扩展类加载器（Extension）\"></a>扩展类加载器（Extension）</h3><p>Java编写，除了启动类加载器加载核心的东西外，还需要Extension加载入javax等java扩展类。</p>\n<h3 id=\"应用程序类加载器（AppClassLoader）\"><a href=\"#应用程序类加载器（AppClassLoader）\" class=\"headerlink\" title=\"应用程序类加载器（AppClassLoader）\"></a>应用程序类加载器（AppClassLoader）</h3><p>我们编写程序时定义的类所用的加载器</p>\n<h3 id=\"用户自定义加载器\"><a href=\"#用户自定义加载器\" class=\"headerlink\" title=\"用户自定义加载器\"></a>用户自定义加载器</h3><p>定制化开发，不走默认的类加载顺序时，可以继承ClassLoader（抽象）。</p>\n<h2 id=\"双亲委派\"><a href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"></a>双亲委派</h2><p>比如如果需要使用A.java类，需要先去顶部Bootstrap寻找，找不到的话去Extension找，还没有的话去Application中找，还没有的话抛异常。</p>\n<p><strong>Bootstrap</strong> –&gt; <strong>Extension</strong> –&gt; <strong>Application</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在类java.lang.String中找不到main方法。因为先从Bootstrap中寻找。</p>\n</blockquote>\n<h2 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h2><p><strong>note</strong>: 保证个人编写的代码不污染出厂的jdk代码，并且不同类中使用的Object都是相同的。</p>\n<h2 id=\"本地方法接口（Native-Interface）\"><a href=\"#本地方法接口（Native-Interface）\" class=\"headerlink\" title=\"本地方法接口（Native Interface）\"></a>本地方法接口（Native Interface）</h2><p>融合不同的编程语言为Java所用（即C/C++），在内存中专门开辟了一块区域处理标记为native的代码。目前该方法使用的越来越少了，除非是与硬件相关的应用，如通过java驱动打印机，企业级应用少见。</p>\n<p>异构领域间通信发达，Socket通信或webService。</p>\n<h3 id=\"Native\"><a href=\"#Native\" class=\"headerlink\" title=\"Native\"></a>Native</h3><p>只是一个关键字。只有声明，没有实现，标记需要调用底层C语言函数库或系统。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>装native方法的栈。在内存中专门开辟了一块区域处理标记为native的代码，登记native方法，在Execution Engine执行时加载本地方法库。</p>\n<h1 id=\"PC寄存器\"><a href=\"#PC寄存器\" class=\"headerlink\" title=\"PC寄存器\"></a>PC寄存器</h1><p>实际是一个指针，线程私有，记录了方法之间的调用和执行情况，类似排班值日表。用来存储指向下一条指令的地址，即将要执行的指令代码。</p>\n<p>是当前线程所执行的字节码的行号指示器。</p>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><ul>\n<li>不存在垃圾回收问题</li>\n<li>==线程私有==（想想加锁，不就在方法上/中加的么）</li>\n</ul>\n<p>也叫栈内存，<strong>主管Java程序的运行</strong>，在线程创建时创建，线程结束时结束（释放栈内存）。基本类型的变量、对象的引用变量、实例方法都在栈空间中。</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><p>在java中的方法装载在虚拟机的栈中叫栈帧。</p>\n<ul>\n<li><p>Local Variables: 输入参数、输出参数以及方法内的变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入参为 x, y， 输出为result，方法内变量为result，均在栈中。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    result = x + y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Operand Stack: 记录出栈、入栈的操作</p>\n</li>\n<li><p>Frame Data: 包括类文件、方法等等</p>\n</li>\n</ul>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧，并被压入到栈中，执行完毕后弹出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法深度调用，把栈撑爆了。 Exception: StackOverflowError 属于错误</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">m1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    m1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调度直至执行完毕的过程，就对应着一个栈帧在虚拟机入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K～756K之间。</p>\n<p>栈管运行，堆管存储。</p>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><p>class文件被ClassLoader装载进JVM称为Class文件，其实是装进了方法区。方法区是规范，在不同的虚拟机里的实现不一样，最典型的是<code>永久代(PermGen space)</code>和<code>元空间(Metaspace)</code>。</p>\n<ul>\n<li>所有==线程共享==</li>\n<li>存在垃圾回收</li>\n</ul>\n<p>存储每个类的<strong>结构信息</strong>（模板）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> price = <span class=\"number\">1233435</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">park</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;stop ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。</p>\n<p>元空间与永久代最大的区别在于：永久代使用的是jvm的堆内存，但是java8以后的元空间并不在虚拟机中而是<strong>本机物理内存</strong>。因此，元空间的大小仅受本地内存限制，类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p>\n<p>实例变量存在堆内存中，与方法区无关。i.e.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次new之后都会产生一个hello方法以及变量demo，此时这个实例变量就存在堆（当然）。</p>\n<h1 id=\"方法区、栈、堆\"><a href=\"#方法区、栈、堆\" class=\"headerlink\" title=\"方法区、栈、堆\"></a>方法区、栈、堆</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person person2 = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p>左边的引用变量放在栈中，右边new出来的实例存放在堆中。堆中的实例指向方法区（保证两个不同的实例对象有同样的行为）。</p>\n<p>要保证person1与person2来自同一个类实例化且保持各自的行为，依靠方法区的“模板”。</p>\n<p>hotsopt是使用指针的方式访问对象：java堆中会存放类元数据的地址，类元数据即Class（类的结构信息）。栈中存放的则是对象的地址。即 栈–&gt;堆–&gt;方法区</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>（Java7之前）    一个Jvm实例只存在一个堆内存，堆内存的大小可以调节。类加载器读取了类文件后需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p>\n<p>(Java8)    永久区换成了元空间。</p>\n<p>物理上为新生区+养老区。</p>\n<h2 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h2><p>逻辑上分为三部分：新生+养老+永久</p>\n<p>新生区： Youg Generation Space (Eden Sapce + Survivor 0 space + Survivor 1 space)</p>\n<p>养老区：Tenure Generation Space</p>\n<p>永久存储区：Permanent Space</p>\n<ul>\n<li>Eden: 0space: 1space  = 8 : 1 : 1</li>\n<li>Young : Old = 1 : 2</li>\n</ul>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>实例化对象的整个生命周期都在新生区进行，最开始是在Eden Sapce,当满了之后会进行GC（垃圾回收），这时会清除大部分的垃圾，剩余的对象放入Survivior 0 space，当Eden Space和Survivor 0 space也满时，进行GC，幸存者放入Survivor 1 space，重复上一步，幸存者存入Tenure Genreration Space，重复上一步，也满时进行Full GC，重复上一步，再次满时，无处存储实例对象，会产生OutOfMemoryError(OOM)。</p>\n<h2 id=\"动态\"><a href=\"#动态\" class=\"headerlink\" title=\"动态\"></a>动态</h2><p>Survivor 0 space: from区</p>\n<p>Surrivor 1 space: to区</p>\n<p>他们的位置不固定，每次GC之后位置会交换，空的为to区。</p>\n<ol>\n<li>Eden, SurvivorFrom copy to SurviviorTo</li>\n<li>clean up Eden, SurvivorFrom</li>\n<li>Swap SurvivorTo and SurvivorFrom</li>\n</ol>\n<h2 id=\"永久代\"><a href=\"#永久代\" class=\"headerlink\" title=\"永久代\"></a>永久代</h2><p>是一个常驻内存区域，用于存放jdk自身所携带的Class、Interface的元数据，也就是说他存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭JVM才会释放此区域所占的内存。</p>\n<h2 id=\"调优\"><a href=\"#调优\" class=\"headerlink\" title=\"调优\"></a>调优</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Returns the maximum amount of memory that the Java virtual machine will attempt to use.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l = Runtime.getRuntime().maxMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns the total amount of memory in the Java virtual machine.</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> l1 = Runtime.getRuntime().totalMemory();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1/4</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xmx) MAX_MEMORY: &quot;</span> + l + <span class=\"string\">&quot;bytes, &quot;</span> + (l / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1/64</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;(-xms) TOTAL_MEMORY: &quot;</span> + l1 + <span class=\"string\">&quot;bytes, &quot;</span> + (l1 / (<span class=\"keyword\">double</span>) <span class=\"number\">1024</span> / <span class=\"number\">1024</span> + <span class=\"string\">&quot;MB&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 生产中会将最高值与最低值设置的一样大，避免应用程序争抢内存，产生峰谷。</p>\n<blockquote>\n<p>-XX:MaxTenuringThreshold 设置对象在新生代中存活的次数（java8默认且最高15）</p>\n</blockquote>\n<h1 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h1><ul>\n<li>minor GC</li>\n<li>major/full GC</li>\n</ul>\n<p>major GC的速度比minor GC慢得多（考虑下young区和old区的大小比）。</p>\n<h2 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h2><p>分代收集，根据各个代来使用</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>每次引用对象时会维护计数器，每次引用的时候会加1,如果是0的话会被回收，但是大量的计数器也会有消耗。最大的弊端还是循环引用。JVM一般不会用这种。</p>\n<h3 id=\"复制算法（Copying）\"><a href=\"#复制算法（Copying）\" class=\"headerlink\" title=\"复制算法（Copying）\"></a>复制算法（Copying）</h3><p>Minor GC使用的就是Copying。不会产生内存碎片，但是会耗费空间。</p>\n<p>因为存活率都很低，复制也没啥。</p>\n<h3 id=\"标记清除法（Mark-Sweep）\"><a href=\"#标记清除法（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除法（Mark-Sweep）\"></a>标记清除法（Mark-Sweep）</h3><p>Major GC使用的是Mark-Sweep，或者与下面的Mark-Compact混合实现。分为标记和清除两个阶段，先标记要回收的，然或再统一回收这些对象。对比上面的，没有复制-粘贴-清除，而是标记后清除，但是造成了内存碎片话（内存不连续），也没有Copying速度快（找出标记的需要进行扫描）。JVM为了空闲的内存还需要维持一个内存的空闲列表，又是一种开销。</p>\n<h3 id=\"标记压缩（Mark-Compact）\"><a href=\"#标记压缩（Mark-Compact）\" class=\"headerlink\" title=\"标记压缩（Mark-Compact）\"></a>标记压缩（Mark-Compact）</h3><p>Mark-Sweep-Compact，标记清除压缩算法，比上面的多了一步整理的过程（不会产生内存碎片），显然时间上消耗更多了（慢工出细活），多了移动对象的时间。</p>\n<p>也可以派生出另一种：多次GC后才进行压缩，减少移动对象的时间。</p>\n<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>Java的内存模型（Java Memory  Model)，本身是一种抽象的概念，并不真实存在，他描述的是一组规范，通过这组规范定义了程序中各个变量（<strong>包括实例字段、静态字段以及构成数组对象的元素</strong>）的访问方式。</p>\n<p>在操作系统中我们有学习过，线程是资源调度的最小单位，进程是资源最小的分配单位，但是线程还是拥有部分必要的资源，其中，<code>工作内存</code>是每个线程的私有数据区域。java内存模型中规定所有变量都存储在主内存，它是共享的内存区域，所有线程都可以访问，但是线程对变量的操作（如读、取、赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，换句话说，不能直接操作主内存中的变量，各个线程中的工作</p>\n<p>内存存储着主内存中的变量副本拷贝。因此，不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。</p>\n<h2 id=\"violatile\"><a href=\"#violatile\" class=\"headerlink\" title=\"violatile\"></a>violatile</h2><p>java虚拟机提供的轻量级的同步机制，乞丐版syncronized。</p>\n<ul>\n<li>保证可见性</li>\n<li>不保证原子性</li>\n<li>禁止指令重排</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这一篇是对整个jvm的概览，接触java有一年多了，想深入了解java，在代码层面会止步于<em>native</em>以及便以后的<em>class</em>，所以，jvm是一个突破后，只有深入理解了jvm才能理解java的运行机制。当然我的初衷并不是无缘无故地想去了解它，而是源于多线程编程，所以我是从jmm入坑的，了解完jmm又迫不及待地从头阅读，有种豁然开朗的感觉。不出意外jvm会出一个系列。</p>"},{"title":"linux-command-line","date":"2021-04-20T06:12:03.000Z","_content":"\n这篇总结一下linux常用命令，也就是bash命令。虽然一直用的Ubuntu，到现在也只熟悉几个常用的命令，对于生产环境来说是远远不够的，好在有条件熟悉，下面学习总结一下，遇到有意思的命令再补充。\n\n<!-- more -->\n\n这里将命令分为两大类，一类是系统相关的，例如磁盘存储、进程状态等，另一类是业务相关，例如查找、移动、复制文件等。\n\n<!-- toc -->\n\n# 系统\n\n1. 根据端口查看程序\n\n   有两种方式，可以用`netstat`或者`lsof`。\n\n   ```shell\n   lsof -i:8080 -- list openfiles\n   netstat -nlt | grep 8080\n   ```\n\n2. 系统中磁盘使用情况\n\n   ```shell\n   df -h\n   ```\n\n   \n\n# 业务\n\n这部分大都与**查找**有关，可以分为文件外查找与文件内查找。 \n\n## 文件外查找\n\n1. 根据名称查找某个目录下的文件\n\n   ```shell\n   find / -name xxx.md\n   ```\n\n2. 递归查找某个文件\n\n   ```shell\n   find . -name *.java\n   ```\n\n## 文件内查找\n\n1. 显示文件的后几行\n\n   ```shell\n   tail -n 10 xx.txt\n   ```\n\n2. 显示文件的前几行\n\n   ```shell\n   head -n 10 xx.txt\n   ```\n\n3. 在给定的文件中根据条件搜索字符串\n\n   ```shell\n   grep println Main.java\n   ```","source":"_posts/linux-command-line.md","raw":"---\ntitle: linux-command-line\ndate: 2021-04-20 14:12:03\ncategories: Linux\ntags: utils\n---\n\n这篇总结一下linux常用命令，也就是bash命令。虽然一直用的Ubuntu，到现在也只熟悉几个常用的命令，对于生产环境来说是远远不够的，好在有条件熟悉，下面学习总结一下，遇到有意思的命令再补充。\n\n<!-- more -->\n\n这里将命令分为两大类，一类是系统相关的，例如磁盘存储、进程状态等，另一类是业务相关，例如查找、移动、复制文件等。\n\n<!-- toc -->\n\n# 系统\n\n1. 根据端口查看程序\n\n   有两种方式，可以用`netstat`或者`lsof`。\n\n   ```shell\n   lsof -i:8080 -- list openfiles\n   netstat -nlt | grep 8080\n   ```\n\n2. 系统中磁盘使用情况\n\n   ```shell\n   df -h\n   ```\n\n   \n\n# 业务\n\n这部分大都与**查找**有关，可以分为文件外查找与文件内查找。 \n\n## 文件外查找\n\n1. 根据名称查找某个目录下的文件\n\n   ```shell\n   find / -name xxx.md\n   ```\n\n2. 递归查找某个文件\n\n   ```shell\n   find . -name *.java\n   ```\n\n## 文件内查找\n\n1. 显示文件的后几行\n\n   ```shell\n   tail -n 10 xx.txt\n   ```\n\n2. 显示文件的前几行\n\n   ```shell\n   head -n 10 xx.txt\n   ```\n\n3. 在给定的文件中根据条件搜索字符串\n\n   ```shell\n   grep println Main.java\n   ```","slug":"linux-command-line","published":1,"updated":"2021-05-22T13:37:57.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj8w001kts9q7b5gcd3i","content":"<p>这篇总结一下linux常用命令，也就是bash命令。虽然一直用的Ubuntu，到现在也只熟悉几个常用的命令，对于生产环境来说是远远不够的，好在有条件熟悉，下面学习总结一下，遇到有意思的命令再补充。</p>\n<span id=\"more\"></span>\n\n<p>这里将命令分为两大类，一类是系统相关的，例如磁盘存储、进程状态等，另一类是业务相关，例如查找、移动、复制文件等。</p>\n<!-- toc -->\n\n<h1 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h1><ol>\n<li><p>根据端口查看程序</p>\n<p>有两种方式，可以用<code>netstat</code>或者<code>lsof</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -i:8080 -- list openfiles</span><br><span class=\"line\">netstat -nlt | grep 8080</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>系统中磁盘使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -h</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h1 id=\"业务\"><a href=\"#业务\" class=\"headerlink\" title=\"业务\"></a>业务</h1><p>这部分大都与<strong>查找</strong>有关，可以分为文件外查找与文件内查找。 </p>\n<h2 id=\"文件外查找\"><a href=\"#文件外查找\" class=\"headerlink\" title=\"文件外查找\"></a>文件外查找</h2><ol>\n<li><p>根据名称查找某个目录下的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name xxx.md</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>递归查找某个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name *.java</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"文件内查找\"><a href=\"#文件内查找\" class=\"headerlink\" title=\"文件内查找\"></a>文件内查找</h2><ol>\n<li><p>显示文件的后几行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -n 10 xx.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示文件的前几行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head -n 10 xx.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在给定的文件中根据条件搜索字符串</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep println Main.java</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇总结一下linux常用命令，也就是bash命令。虽然一直用的Ubuntu，到现在也只熟悉几个常用的命令，对于生产环境来说是远远不够的，好在有条件熟悉，下面学习总结一下，遇到有意思的命令再补充。</p>","more":"<p>这里将命令分为两大类，一类是系统相关的，例如磁盘存储、进程状态等，另一类是业务相关，例如查找、移动、复制文件等。</p>\n<!-- toc -->\n\n<h1 id=\"系统\"><a href=\"#系统\" class=\"headerlink\" title=\"系统\"></a>系统</h1><ol>\n<li><p>根据端口查看程序</p>\n<p>有两种方式，可以用<code>netstat</code>或者<code>lsof</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsof -i:8080 -- list openfiles</span><br><span class=\"line\">netstat -nlt | grep 8080</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>系统中磁盘使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -h</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h1 id=\"业务\"><a href=\"#业务\" class=\"headerlink\" title=\"业务\"></a>业务</h1><p>这部分大都与<strong>查找</strong>有关，可以分为文件外查找与文件内查找。 </p>\n<h2 id=\"文件外查找\"><a href=\"#文件外查找\" class=\"headerlink\" title=\"文件外查找\"></a>文件外查找</h2><ol>\n<li><p>根据名称查找某个目录下的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name xxx.md</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>递归查找某个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name *.java</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"文件内查找\"><a href=\"#文件内查找\" class=\"headerlink\" title=\"文件内查找\"></a>文件内查找</h2><ol>\n<li><p>显示文件的后几行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -n 10 xx.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示文件的前几行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head -n 10 xx.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在给定的文件中根据条件搜索字符串</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep println Main.java</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"lock","date":"2020-07-20T13:46:41.000Z","_content":"\n锁跟多线程紧密相关，有复杂与简单之分。\n\n<!--more-->\n\n# 分类\n\n![image.png](https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png)\n\n# 乐观锁|悲观锁\n\n所谓乐观锁、悲观锁可以类比地看作**JVM里的方法区**，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？\n\n- 悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，`synchronized`关键字和`Lock的实现类`都是悲观锁。\n- 乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过**无锁编程**实现的乐观锁，最常用的就是`CAS算法`，Java原子类中的递增操作就是通过**CAS自旋实现**的。\n\n根据他们的概念，可以发现**悲观锁适合写操作多的场景**，**乐观锁适合读操作多的场景**，这样利于性能的优化提升。\n\n```java\n// synchronized\npublic synchronized void testMehthod(){\n    // do something...\n}\n\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock();\npublic void modifyPublicResources()){\n    try{\n        lock.lock();\n        // do something...\n    }finally{\n        lock.unlock();\n    }\n}\n\n// 乐观锁\nprivate AtomicInteger ai = new AtomicInteger();\natomicInteger.incrementAndGet(); // 执行自增1\n```\n\n\n\n# Compare And Swap\n\nCAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的**原子类**就是通过这种算法实现了乐观锁。算法涉及到三个操作数：\n\n- 需要读写的内存值V （已存在的值）\n- 进行比较的值A\n- 要写入的新值B\n\n当`V=A`时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n## AtomicInteger\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    // 获取并操作内存的数据\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    // 存储value在AtomicInteger中的偏移量\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\t// 存储AtomicInteger的int值\n    private volatile int value;\n```\n\n```java\npublic final int getAndIncrement() {\n    return unsafe.getAndAddInt(this, valueOffset, 1);\n}\n```\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n```\n\n```java\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n\n一目了然了吧，最终的`compareAndSwapInt`是`native`，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：\n\n- 看到`do-while`了吧，循环时间长会造成较大的CPU开销。\n\n**note:** ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A\"\n\n# 自旋锁|适应性自旋锁\n\n涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference [here](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)\n\n# 公平锁|非公平锁\n\n简而言之，公平锁是好好排队的，非公平锁是插队来的。\n\n在类`ReentrantLock`中，有一个内部类`Sync`，他是继承`AbstractQueuedSnchronizer`的，对锁的添加、释放等操作大部分都是在`Sync`实现的，他又有`FairSync`和`NonfairSync`两个子类。`ReentrantLock`默认使用非公平锁。\n\n# 独享锁|共享锁\n\n别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的`synchronized`和并发包中的`Lock`。\n\n共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。\n\n独享锁和共享锁也是通过AQS来实现的。具体参考类`ReentrantReadWriteLock`。类中有`ReadLock`和`WriteLock`两把锁，","source":"_posts/lock.md","raw":"---\ntitle: lock\ndate: 2020-07-20 21:46:41\ncategories: Java\ntags: lock\n---\n\n锁跟多线程紧密相关，有复杂与简单之分。\n\n<!--more-->\n\n# 分类\n\n![image.png](https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png)\n\n# 乐观锁|悲观锁\n\n所谓乐观锁、悲观锁可以类比地看作**JVM里的方法区**，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？\n\n- 悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，`synchronized`关键字和`Lock的实现类`都是悲观锁。\n- 乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过**无锁编程**实现的乐观锁，最常用的就是`CAS算法`，Java原子类中的递增操作就是通过**CAS自旋实现**的。\n\n根据他们的概念，可以发现**悲观锁适合写操作多的场景**，**乐观锁适合读操作多的场景**，这样利于性能的优化提升。\n\n```java\n// synchronized\npublic synchronized void testMehthod(){\n    // do something...\n}\n\n// ReentrantLock\nprivate ReentrantLock lock = new ReentrantLock();\npublic void modifyPublicResources()){\n    try{\n        lock.lock();\n        // do something...\n    }finally{\n        lock.unlock();\n    }\n}\n\n// 乐观锁\nprivate AtomicInteger ai = new AtomicInteger();\natomicInteger.incrementAndGet(); // 执行自增1\n```\n\n\n\n# Compare And Swap\n\nCAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的**原子类**就是通过这种算法实现了乐观锁。算法涉及到三个操作数：\n\n- 需要读写的内存值V （已存在的值）\n- 进行比较的值A\n- 要写入的新值B\n\n当`V=A`时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n## AtomicInteger\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    // 获取并操作内存的数据\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    // 存储value在AtomicInteger中的偏移量\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\t// 存储AtomicInteger的int值\n    private volatile int value;\n```\n\n```java\npublic final int getAndIncrement() {\n    return unsafe.getAndAddInt(this, valueOffset, 1);\n}\n```\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n```\n\n```java\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n\n一目了然了吧，最终的`compareAndSwapInt`是`native`，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：\n\n- 看到`do-while`了吧，循环时间长会造成较大的CPU开销。\n\n**note:** ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A\"\n\n# 自旋锁|适应性自旋锁\n\n涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference [here](https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect)\n\n# 公平锁|非公平锁\n\n简而言之，公平锁是好好排队的，非公平锁是插队来的。\n\n在类`ReentrantLock`中，有一个内部类`Sync`，他是继承`AbstractQueuedSnchronizer`的，对锁的添加、释放等操作大部分都是在`Sync`实现的，他又有`FairSync`和`NonfairSync`两个子类。`ReentrantLock`默认使用非公平锁。\n\n# 独享锁|共享锁\n\n别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的`synchronized`和并发包中的`Lock`。\n\n共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。\n\n独享锁和共享锁也是通过AQS来实现的。具体参考类`ReentrantReadWriteLock`。类中有`ReadLock`和`WriteLock`两把锁，","slug":"lock","published":1,"updated":"2021-03-28T10:20:02.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj90001pts9q34ee7at1","content":"<p>锁跟多线程紧密相关，有复杂与简单之分。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><p><img src=\"https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png\" alt=\"image.png\"></p>\n<h1 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁|悲观锁\"></a>乐观锁|悲观锁</h1><p>所谓乐观锁、悲观锁可以类比地看作<strong>JVM里的方法区</strong>，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？</p>\n<ul>\n<li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，<code>synchronized</code>关键字和<code>Lock的实现类</code>都是悲观锁。</li>\n<li>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过<strong>无锁编程</strong>实现的乐观锁，最常用的就是<code>CAS算法</code>，Java原子类中的递增操作就是通过<strong>CAS自旋实现</strong>的。</li>\n</ul>\n<p>根据他们的概念，可以发现<strong>悲观锁适合写操作多的场景</strong>，<strong>乐观锁适合读操作多的场景</strong>，这样利于性能的优化提升。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">testMehthod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReentrantLock</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">modifyPublicResources</span><span class=\"params\">()</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 乐观锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> AtomicInteger ai = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">atomicInteger.incrementAndGet(); <span class=\"comment\">// 执行自增1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Compare-And-Swap\"><a href=\"#Compare-And-Swap\" class=\"headerlink\" title=\"Compare And Swap\"></a>Compare And Swap</h1><p>CAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的<strong>原子类</strong>就是通过这种算法实现了乐观锁。算法涉及到三个操作数：</p>\n<ul>\n<li>需要读写的内存值V （已存在的值）</li>\n<li>进行比较的值A</li>\n<li>要写入的新值B</li>\n</ul>\n<p>当<code>V=A</code>时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<h2 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取并操作内存的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"comment\">// 存储value在AtomicInteger中的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 存储AtomicInteger的int值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>一目了然了吧，最终的<code>compareAndSwapInt</code>是<code>native</code>，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：</p>\n<ul>\n<li>看到<code>do-while</code>了吧，循环时间长会造成较大的CPU开销。</li>\n</ul>\n<p><strong>note:</strong> ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A”</p>\n<h1 id=\"自旋锁-适应性自旋锁\"><a href=\"#自旋锁-适应性自旋锁\" class=\"headerlink\" title=\"自旋锁|适应性自旋锁\"></a>自旋锁|适应性自旋锁</h1><p>涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference <a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect\">here</a></p>\n<h1 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁|非公平锁\"></a>公平锁|非公平锁</h1><p>简而言之，公平锁是好好排队的，非公平锁是插队来的。</p>\n<p>在类<code>ReentrantLock</code>中，有一个内部类<code>Sync</code>，他是继承<code>AbstractQueuedSnchronizer</code>的，对锁的添加、释放等操作大部分都是在<code>Sync</code>实现的，他又有<code>FairSync</code>和<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁。</p>\n<h1 id=\"独享锁-共享锁\"><a href=\"#独享锁-共享锁\" class=\"headerlink\" title=\"独享锁|共享锁\"></a>独享锁|共享锁</h1><p>别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的<code>synchronized</code>和并发包中的<code>Lock</code>。</p>\n<p>共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。</p>\n<p>独享锁和共享锁也是通过AQS来实现的。具体参考类<code>ReentrantReadWriteLock</code>。类中有<code>ReadLock</code>和<code>WriteLock</code>两把锁，</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>锁跟多线程紧密相关，有复杂与简单之分。</p>","more":"<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><p><img src=\"https://i.loli.net/2020/07/20/AwVJYTyQqzUpEPl.png\" alt=\"image.png\"></p>\n<h1 id=\"乐观锁-悲观锁\"><a href=\"#乐观锁-悲观锁\" class=\"headerlink\" title=\"乐观锁|悲观锁\"></a>乐观锁|悲观锁</h1><p>所谓乐观锁、悲观锁可以类比地看作<strong>JVM里的方法区</strong>，他们只是规范、概念，具体落地的话有不同的实现，所以不仅仅是java中，数据库中也有类似的概念。那么，什么是乐观锁、悲观锁呢？</p>\n<ul>\n<li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。在Java中，<code>synchronized</code>关键字和<code>Lock的实现类</code>都是悲观锁。</li>\n<li>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入；如果数据已经被其他线程更新，则做进一步的操作（报错、重试或其他等等）。在Java中，通过<strong>无锁编程</strong>实现的乐观锁，最常用的就是<code>CAS算法</code>，Java原子类中的递增操作就是通过<strong>CAS自旋实现</strong>的。</li>\n</ul>\n<p>根据他们的概念，可以发现<strong>悲观锁适合写操作多的场景</strong>，<strong>乐观锁适合读操作多的场景</strong>，这样利于性能的优化提升。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// synchronized</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">testMehthod</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReentrantLock</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">modifyPublicResources</span><span class=\"params\">()</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 乐观锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> AtomicInteger ai = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">atomicInteger.incrementAndGet(); <span class=\"comment\">// 执行自增1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Compare-And-Swap\"><a href=\"#Compare-And-Swap\" class=\"headerlink\" title=\"Compare And Swap\"></a>Compare And Swap</h1><p>CAS，比较与交换，是一种无锁算法，在不使用锁的情况下实现多线程之间的变量同步，java并发包中的<strong>原子类</strong>就是通过这种算法实现了乐观锁。算法涉及到三个操作数：</p>\n<ul>\n<li>需要读写的内存值V （已存在的值）</li>\n<li>进行比较的值A</li>\n<li>要写入的新值B</li>\n</ul>\n<p>当<code>V=A</code>时，CAS通过原子方式用新值B来更新V的值（其中“比较”与“更新”两个操作是一个原子），否则不执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<h2 id=\"AtomicInteger\"><a href=\"#AtomicInteger\" class=\"headerlink\" title=\"AtomicInteger\"></a>AtomicInteger</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取并操作内存的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"comment\">// 存储value在AtomicInteger中的偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 存储AtomicInteger的int值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>一目了然了吧，最终的<code>compareAndSwapInt</code>是<code>native</code>，所以整个”比较+更新“操作属于原子操作，在JDK通过CPU的cmpxchg指令去比较寄存器中的A和内存中的V。CAS虽然避开了锁，但是也有自身的瑕疵：</p>\n<ul>\n<li>看到<code>do-while</code>了吧，循环时间长会造成较大的CPU开销。</li>\n</ul>\n<p><strong>note:</strong> ABA问题，即原本是A，后来改成了B，然后又改成了A，这时用CAS去比较的话结果是什么呢？当然是false啦，每次更新时会加上版本号做标记，类似”1A-2B-3A”</p>\n<h1 id=\"自旋锁-适应性自旋锁\"><a href=\"#自旋锁-适应性自旋锁\" class=\"headerlink\" title=\"自旋锁|适应性自旋锁\"></a>自旋锁|适应性自旋锁</h1><p>涉及到线程的两个状态转换：阻塞、唤醒。这个操作需要操作系统来完成，且状态转换要耗费一定的处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。reference <a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect\">here</a></p>\n<h1 id=\"公平锁-非公平锁\"><a href=\"#公平锁-非公平锁\" class=\"headerlink\" title=\"公平锁|非公平锁\"></a>公平锁|非公平锁</h1><p>简而言之，公平锁是好好排队的，非公平锁是插队来的。</p>\n<p>在类<code>ReentrantLock</code>中，有一个内部类<code>Sync</code>，他是继承<code>AbstractQueuedSnchronizer</code>的，对锁的添加、释放等操作大部分都是在<code>Sync</code>实现的，他又有<code>FairSync</code>和<code>NonfairSync</code>两个子类。<code>ReentrantLock</code>默认使用非公平锁。</p>\n<h1 id=\"独享锁-共享锁\"><a href=\"#独享锁-共享锁\" class=\"headerlink\" title=\"独享锁|共享锁\"></a>独享锁|共享锁</h1><p>别被名字搞晕了！独享=排他=互斥锁，同《操作系统》中的相关概念。如果数据身上有了一把排他锁，那么其他线程就不能再对他施加任何锁，例如JDK中的<code>synchronized</code>和并发包中的<code>Lock</code>。</p>\n<p>共享锁是指数据身上有了共享锁，其他线程也可以在他身上加锁，只能加共享锁。获得共享锁的线程只能读数据，不能修改数据。</p>\n<p>独享锁和共享锁也是通过AQS来实现的。具体参考类<code>ReentrantReadWriteLock</code>。类中有<code>ReadLock</code>和<code>WriteLock</code>两把锁，</p>"},{"title":"mybatis autoconfiguration","date":"2021-03-09T12:48:57.000Z","_content":"\n这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 来源\n\n如果还记得之前的分析就会知道，SpringBoot会从`META-INF`目录下找`spring.factories`文件，并从中找`EnableAutoConfiguration`对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n```\n\n一共就两个类，第一个是语言相关的，会检测是否有*thymeleaf*、*framemarker*等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个`MybatisAutoConfiguration`配置类。\n\n# 自动装配\n\n通过这个类我们要弄清楚他自动装配了啥。\n\n```java\n@Configuration\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class}) // 路径下存在这两个类的class时生效\n@ConditionalOnSingleCandidate(DataSource.class) // 单个数据源生效\n@EnableConfigurationProperties({MybatisProperties.class}) // 启用mybatis配置文件的属性\n@AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class}) // 这两个类后自动配置\npublic class MybatisAutoConfiguration implements InitializingBean {\n    // ...\n}\n```\n\n## sqlSessionFactory\n\n```java\n@Bean\n@ConditionalOnMissingBean // 缺少这个bean时创建他\npublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n    // ...\n}\n```\n\nsqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的`MapperProperties`，会根据用户配置的信息来修改facotry的相关属性。\n\n## sqlSessionTemplate\n\n```java\n@Bean\n@ConditionalOnMissingBean // 同sqlSessionFactory\npublic SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n    ExecutorType executorType = this.properties.getExecutorType();\n    return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n}\n```\n\n这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定`executorType`来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中`executorType`这个属性，他通常有三个选择：\n\n- SIMPLE：为每个语句的执行创建一个预处理语句，基操\n- REUSE：复用预处理语句\n- BATCH：批量执行所有更新语句\n\n## MapperScannerRegistrarNotFoundConfiguration\n\n```java\n@Configuration\n@Import({MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class}) // 导入\n@ConditionalOnMissingBean({MapperFactoryBean.class, MapperScannerConfigurer.class}) // 缺少这两个类时生效\npublic static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {\n    public MapperScannerRegistrarNotFoundConfiguration() {\n    }\n\n    public void afterPropertiesSet() {\n        MybatisAutoConfiguration.logger.debug(\"Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.\");\n    }\n}\n```\n\n这个类导入了一个内部类，并且会在`MapperFactoryBean`和`MapperScannerConfigure.class`缺少时生效，这个大家就很熟悉了，**通常没有写*@MapperScan*时的异常就是在这里产生的**：\n\n```java\npublic class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {\n    private Class<T> mapperInterface;\n    private boolean addToConfig = true;\n\n    public MapperFactoryBean() {\n    }\n\n    public MapperFactoryBean(Class<T> mapperInterface) {\n        this.mapperInterface = mapperInterface;\n    }\n\n    protected void checkDaoConfig() {\n        super.checkDaoConfig();\n        Assert.notNull(this.mapperInterface, \"Property 'mapperInterface' is required\");\n        Configuration configuration = this.getSqlSession().getConfiguration();\n        // 如果开启了“添加配置”并且接口没有被添加过的话\n        if (this.addToConfig && !configuration.hasMapper(this.mapperInterface)) {\n            try {\n                // 往mybatis的配置类中添加接口\n                configuration.addMapper(this.mapperInterface);\n            } catch (Exception var6) {\n                this.logger.error(\"Error while adding the mapper '\" + this.mapperInterface + \"' to configuration.\", var6);\n                throw new IllegalArgumentException(var6);\n            } finally {\n                ErrorContext.instance().reset();\n            }\n        }\n\n    }\n    // ...\n}\n\n```\n\n总结一下，这个自动配置类主要做了以下工作：\n\n1. 启用配置文件\n2. 缺少sqlSessionFactory时创建该bean，依赖数据源dataSource\n3. 缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory\n4. 没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper\n\n以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有`mapperRegister`的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。","source":"_posts/mybatis-autoconfiguration.md","raw":"---\ntitle: mybatis autoconfiguration\ndate: 2021-03-09 20:48:57\ncategories: framework\ntags: mybatis\n---\n\n这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。\n\n<!-- more -->\n\n<!-- toc -->\n\n# 来源\n\n如果还记得之前的分析就会知道，SpringBoot会从`META-INF`目录下找`spring.factories`文件，并从中找`EnableAutoConfiguration`对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n```\n\n一共就两个类，第一个是语言相关的，会检测是否有*thymeleaf*、*framemarker*等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个`MybatisAutoConfiguration`配置类。\n\n# 自动装配\n\n通过这个类我们要弄清楚他自动装配了啥。\n\n```java\n@Configuration\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class}) // 路径下存在这两个类的class时生效\n@ConditionalOnSingleCandidate(DataSource.class) // 单个数据源生效\n@EnableConfigurationProperties({MybatisProperties.class}) // 启用mybatis配置文件的属性\n@AutoConfigureAfter({DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class}) // 这两个类后自动配置\npublic class MybatisAutoConfiguration implements InitializingBean {\n    // ...\n}\n```\n\n## sqlSessionFactory\n\n```java\n@Bean\n@ConditionalOnMissingBean // 缺少这个bean时创建他\npublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n    // ...\n}\n```\n\nsqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的`MapperProperties`，会根据用户配置的信息来修改facotry的相关属性。\n\n## sqlSessionTemplate\n\n```java\n@Bean\n@ConditionalOnMissingBean // 同sqlSessionFactory\npublic SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n    ExecutorType executorType = this.properties.getExecutorType();\n    return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n}\n```\n\n这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定`executorType`来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中`executorType`这个属性，他通常有三个选择：\n\n- SIMPLE：为每个语句的执行创建一个预处理语句，基操\n- REUSE：复用预处理语句\n- BATCH：批量执行所有更新语句\n\n## MapperScannerRegistrarNotFoundConfiguration\n\n```java\n@Configuration\n@Import({MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class}) // 导入\n@ConditionalOnMissingBean({MapperFactoryBean.class, MapperScannerConfigurer.class}) // 缺少这两个类时生效\npublic static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {\n    public MapperScannerRegistrarNotFoundConfiguration() {\n    }\n\n    public void afterPropertiesSet() {\n        MybatisAutoConfiguration.logger.debug(\"Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.\");\n    }\n}\n```\n\n这个类导入了一个内部类，并且会在`MapperFactoryBean`和`MapperScannerConfigure.class`缺少时生效，这个大家就很熟悉了，**通常没有写*@MapperScan*时的异常就是在这里产生的**：\n\n```java\npublic class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {\n    private Class<T> mapperInterface;\n    private boolean addToConfig = true;\n\n    public MapperFactoryBean() {\n    }\n\n    public MapperFactoryBean(Class<T> mapperInterface) {\n        this.mapperInterface = mapperInterface;\n    }\n\n    protected void checkDaoConfig() {\n        super.checkDaoConfig();\n        Assert.notNull(this.mapperInterface, \"Property 'mapperInterface' is required\");\n        Configuration configuration = this.getSqlSession().getConfiguration();\n        // 如果开启了“添加配置”并且接口没有被添加过的话\n        if (this.addToConfig && !configuration.hasMapper(this.mapperInterface)) {\n            try {\n                // 往mybatis的配置类中添加接口\n                configuration.addMapper(this.mapperInterface);\n            } catch (Exception var6) {\n                this.logger.error(\"Error while adding the mapper '\" + this.mapperInterface + \"' to configuration.\", var6);\n                throw new IllegalArgumentException(var6);\n            } finally {\n                ErrorContext.instance().reset();\n            }\n        }\n\n    }\n    // ...\n}\n\n```\n\n总结一下，这个自动配置类主要做了以下工作：\n\n1. 启用配置文件\n2. 缺少sqlSessionFactory时创建该bean，依赖数据源dataSource\n3. 缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory\n4. 没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper\n\n以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有`mapperRegister`的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。","slug":"mybatis-autoconfiguration","published":1,"updated":"2021-03-28T10:20:02.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj95001rts9qhezye8bf","content":"<p>这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h1><p>如果还记得之前的分析就会知道，SpringBoot会从<code>META-INF</code>目录下找<code>spring.factories</code>文件，并从中找<code>EnableAutoConfiguration</code>对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Auto Configure</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"attr\">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span></span><br></pre></td></tr></table></figure>\n\n<p>一共就两个类，第一个是语言相关的，会检测是否有<em>thymeleaf</em>、<em>framemarker</em>等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个<code>MybatisAutoConfiguration</code>配置类。</p>\n<h1 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h1><p>通过这个类我们要弄清楚他自动装配了啥。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span> <span class=\"comment\">// 路径下存在这两个类的class时生效</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnSingleCandidate(DataSource.class)</span> <span class=\"comment\">// 单个数据源生效</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span> <span class=\"comment\">// 启用mybatis配置文件的属性</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span> <span class=\"comment\">// 这两个类后自动配置</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisAutoConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"sqlSessionFactory\"><a href=\"#sqlSessionFactory\" class=\"headerlink\" title=\"sqlSessionFactory\"></a>sqlSessionFactory</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 缺少这个bean时创建他</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">(DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的<code>MapperProperties</code>，会根据用户配置的信息来修改facotry的相关属性。</p>\n<h2 id=\"sqlSessionTemplate\"><a href=\"#sqlSessionTemplate\" class=\"headerlink\" title=\"sqlSessionTemplate\"></a>sqlSessionTemplate</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 同sqlSessionFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">sqlSessionTemplate</span><span class=\"params\">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorType executorType = <span class=\"keyword\">this</span>.properties.getExecutorType();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorType != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory, executorType) : <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定<code>executorType</code>来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中<code>executorType</code>这个属性，他通常有三个选择：</p>\n<ul>\n<li>SIMPLE：为每个语句的执行创建一个预处理语句，基操</li>\n<li>REUSE：复用预处理语句</li>\n<li>BATCH：批量执行所有更新语句</li>\n</ul>\n<h2 id=\"MapperScannerRegistrarNotFoundConfiguration\"><a href=\"#MapperScannerRegistrarNotFoundConfiguration\" class=\"headerlink\" title=\"MapperScannerRegistrarNotFoundConfiguration\"></a>MapperScannerRegistrarNotFoundConfiguration</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span> <span class=\"comment\">// 导入</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span> <span class=\"comment\">// 缺少这两个类时生效</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MybatisAutoConfiguration.logger.debug(<span class=\"string\">&quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类导入了一个内部类，并且会在<code>MapperFactoryBean</code>和<code>MapperScannerConfigure.class</code>缺少时生效，这个大家就很熟悉了，<strong>通常没有写*@MapperScan*时的异常就是在这里产生的</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperFactoryBean</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">SqlSessionDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> addToConfig = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mapperInterface = mapperInterface;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">checkDaoConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.checkDaoConfig();</span><br><span class=\"line\">        Assert.notNull(<span class=\"keyword\">this</span>.mapperInterface, <span class=\"string\">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class=\"line\">        Configuration configuration = <span class=\"keyword\">this</span>.getSqlSession().getConfiguration();</span><br><span class=\"line\">        <span class=\"comment\">// 如果开启了“添加配置”并且接口没有被添加过的话</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class=\"keyword\">this</span>.mapperInterface)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 往mybatis的配置类中添加接口</span></span><br><span class=\"line\">                configuration.addMapper(<span class=\"keyword\">this</span>.mapperInterface);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var6) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.logger.error(<span class=\"string\">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class=\"keyword\">this</span>.mapperInterface + <span class=\"string\">&quot;&#x27; to configuration.&quot;</span>, var6);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(var6);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                ErrorContext.instance().reset();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结一下，这个自动配置类主要做了以下工作：</p>\n<ol>\n<li>启用配置文件</li>\n<li>缺少sqlSessionFactory时创建该bean，依赖数据源dataSource</li>\n<li>缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory</li>\n<li>没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper</li>\n</ol>\n<p>以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有<code>mapperRegister</code>的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这一篇我们来看mybatis在springboot环境下的自动装配。之前分析过SpringBoot对于Spring的自动装配，mybatis引入时作为一个starter，开箱即用的产品，自然也少不了，同时在springboot的大环境下，为了方便开发肯定也会遵循他的装配法则。</p>","more":"<!-- toc -->\n\n<h1 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h1><p>如果还记得之前的分析就会知道，SpringBoot会从<code>META-INF</code>目录下找<code>spring.factories</code>文件，并从中找<code>EnableAutoConfiguration</code>对应的值，这个值是一个以逗号分割开的全类名字符串，你配多少他加载多少。换句话说，如果没有导入mybatis，就不会有相关的配置。加载后会通过反射来获取类相关信息并进行配置。mybatis的自动装配内容非常少，我们来看下：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Auto Configure</span></span><br><span class=\"line\"><span class=\"meta\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\</span><br><span class=\"line\"><span class=\"attr\">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span></span><br></pre></td></tr></table></figure>\n\n<p>一共就两个类，第一个是语言相关的，会检测是否有<em>thymeleaf</em>、<em>framemarker</em>等web框架，如果有的话会配置相关的语法，目前项目大多前后分离，在此就不分析这部分啦，我们重点看看下面那个<code>MybatisAutoConfiguration</code>配置类。</p>\n<h1 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h1><p>通过这个类我们要弄清楚他自动装配了啥。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span> <span class=\"comment\">// 路径下存在这两个类的class时生效</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnSingleCandidate(DataSource.class)</span> <span class=\"comment\">// 单个数据源生效</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span> <span class=\"comment\">// 启用mybatis配置文件的属性</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span> <span class=\"comment\">// 这两个类后自动配置</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MybatisAutoConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"sqlSessionFactory\"><a href=\"#sqlSessionFactory\" class=\"headerlink\" title=\"sqlSessionFactory\"></a>sqlSessionFactory</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 缺少这个bean时创建他</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">(DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sqlSessionFactory是用来创建sqlSession的，我们知道，每次执行sql时都是以sqlSession为执行对象的，里面封装了增删改查等操作，要创建这个factory需要数据源，并且里面还用到了配置文件，就是上面注解中的<code>MapperProperties</code>，会根据用户配置的信息来修改facotry的相关属性。</p>\n<h2 id=\"sqlSessionTemplate\"><a href=\"#sqlSessionTemplate\" class=\"headerlink\" title=\"sqlSessionTemplate\"></a>sqlSessionTemplate</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean</span> <span class=\"comment\">// 同sqlSessionFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">sqlSessionTemplate</span><span class=\"params\">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorType executorType = <span class=\"keyword\">this</span>.properties.getExecutorType();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorType != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory, executorType) : <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个sqlSessionFactory的创建需要用到sqlSessionFactory，同时会根据用户有没有指定<code>executorType</code>来创建对应的sqlSessionTemplate。通过这个bean的名称可以知道他是一直种sqlSession的模板，而且还用到了配置文件中<code>executorType</code>这个属性，他通常有三个选择：</p>\n<ul>\n<li>SIMPLE：为每个语句的执行创建一个预处理语句，基操</li>\n<li>REUSE：复用预处理语句</li>\n<li>BATCH：批量执行所有更新语句</li>\n</ul>\n<h2 id=\"MapperScannerRegistrarNotFoundConfiguration\"><a href=\"#MapperScannerRegistrarNotFoundConfiguration\" class=\"headerlink\" title=\"MapperScannerRegistrarNotFoundConfiguration\"></a>MapperScannerRegistrarNotFoundConfiguration</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span> <span class=\"comment\">// 导入</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span> <span class=\"comment\">// 缺少这两个类时生效</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperScannerRegistrarNotFoundConfiguration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MybatisAutoConfiguration.logger.debug(<span class=\"string\">&quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类导入了一个内部类，并且会在<code>MapperFactoryBean</code>和<code>MapperScannerConfigure.class</code>缺少时生效，这个大家就很熟悉了，<strong>通常没有写*@MapperScan*时的异常就是在这里产生的</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapperFactoryBean</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">SqlSessionDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> addToConfig = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapperFactoryBean</span><span class=\"params\">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mapperInterface = mapperInterface;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">checkDaoConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.checkDaoConfig();</span><br><span class=\"line\">        Assert.notNull(<span class=\"keyword\">this</span>.mapperInterface, <span class=\"string\">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class=\"line\">        Configuration configuration = <span class=\"keyword\">this</span>.getSqlSession().getConfiguration();</span><br><span class=\"line\">        <span class=\"comment\">// 如果开启了“添加配置”并且接口没有被添加过的话</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class=\"keyword\">this</span>.mapperInterface)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 往mybatis的配置类中添加接口</span></span><br><span class=\"line\">                configuration.addMapper(<span class=\"keyword\">this</span>.mapperInterface);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var6) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.logger.error(<span class=\"string\">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class=\"keyword\">this</span>.mapperInterface + <span class=\"string\">&quot;&#x27; to configuration.&quot;</span>, var6);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(var6);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                ErrorContext.instance().reset();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结一下，这个自动配置类主要做了以下工作：</p>\n<ol>\n<li>启用配置文件</li>\n<li>缺少sqlSessionFactory时创建该bean，依赖数据源dataSource</li>\n<li>缺少sqlSessionTemplate时创建该bean，依赖sqlSessionFactory</li>\n<li>没有配置mapper文件扫描时注册异常bean，否则扫描并加载mapper</li>\n</ol>\n<p>以上是我们使用mybatis的基础，启用了配置文件，我们会加入mapper文件路径等配置信息，有了sqlSessionFactory就会创建sqlSessionTemplate，进而根据他获到mybatis的关键类Configuration，最后将获取到的mapper接口加入到配置类中，配置类是持有<code>mapperRegister</code>的，这个就好比一个mapper池，装载着所有的mapper接口，使用HashMap实现。</p>"},{"title":"mybatis sql resolution","date":"2021-03-07T11:03:54.000Z","_content":"\n承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。\n\n<!-- more -->\n\n<!-- toc -->\n\n```java\npublic class Test {\n\n    // 模拟的pojo\n    static class User {\n        int age;\n        int name;\n    }\n\n    public static void main(String[] args) {\n        // 核心就在这\n        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class<?>[]{UserMapper.class}, new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                // 获取到注解\n                Select annotation = method.getAnnotation(Select.class);\n                // 构建入参的映射\n                Map<String, Object> map = buildMethodArgNameMap(method, args);\n\n                System.out.println(map.toString());\n                if (annotation != null) {\n                    String[] value = annotation.value();\n                    String s = parseSql(value[0], map);\n                    System.out.println(s);\n                }\n                return null;\n            }\n        });\n        userMapper.selectUesList(2);\n    }\n\n    // 解析sql\n    public static String parseSql(String sql, Map<String, Object> map) {\n        StringBuilder sb = new StringBuilder();\n        int length = sql.length();\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (c == '#') {\n                int nextIndex = i + 1;\n                char nextChar = sql.charAt(nextIndex);\n                if (nextChar != '{') {\n                    throw new RuntimeException(\"sql写法错误，应该是 { \");\n                }\n                StringBuilder argSb = new StringBuilder();\n                i = parseSqlArg(argSb, sql, nextIndex);\n                String argName = argSb.toString();\n                Object argValue = map.get(argName);\n                sb.append(argValue.toString());\n                continue;\n            }\n            sb.append(c);\n        }\n\n        // 返回解析后拼接过的sql\n        return sb.toString();\n    }\n\n    /**\n     * 这里应该是解析出{}中的的东西\n     */\n    private static int parseSqlArg(StringBuilder argSb, String sql, int nextIndex) {\n        for (int i = nextIndex + 1; i < sql.length(); i++) {\n            char c = sql.charAt(i);\n            if (c != '}') {\n                argSb.append(c);\n            } else {\n                return i;\n            }\n        }\n        throw new RuntimeException(\"sql写法错误，应该是 } \");\n    }\n\n    /**\n     * 解析传入的参数\n     *\n     * @param method method\n     * @param args   参数\n     * @return 解析后的参数\n     */\n    public static Map<String, Object> buildMethodArgNameMap(Method method, Object[] args) {\n        Map<String, Object> map = new HashMap<>(6);\n        // 方法的入参，例如：Integer id, args是实际的入参值，如 6\n        Parameter[] parameters = method.getParameters();\n        for (int i = 0; i < parameters.length; i++) {\n            map.put(parameters[i].getName(), args[i]);\n        }\n        return map;\n    }\n}\n\n\ninterface UserMapper {\n\n    @Select(\"select * from User where id = #{id}\")\n    List<Test.User> selectUesList(Integer id);\n}\t\n```\n\n以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：![mybatis_structure.jpg](https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg)\n\n我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用`#{}`括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。","source":"_posts/mybatis-sql-resolution.md","raw":"---\ntitle: mybatis sql resolution\ndate: 2021-03-07 19:03:54\ncategories: framework\ntags: mybatis\n---\n\n承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。\n\n<!-- more -->\n\n<!-- toc -->\n\n```java\npublic class Test {\n\n    // 模拟的pojo\n    static class User {\n        int age;\n        int name;\n    }\n\n    public static void main(String[] args) {\n        // 核心就在这\n        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), new Class<?>[]{UserMapper.class}, new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                // 获取到注解\n                Select annotation = method.getAnnotation(Select.class);\n                // 构建入参的映射\n                Map<String, Object> map = buildMethodArgNameMap(method, args);\n\n                System.out.println(map.toString());\n                if (annotation != null) {\n                    String[] value = annotation.value();\n                    String s = parseSql(value[0], map);\n                    System.out.println(s);\n                }\n                return null;\n            }\n        });\n        userMapper.selectUesList(2);\n    }\n\n    // 解析sql\n    public static String parseSql(String sql, Map<String, Object> map) {\n        StringBuilder sb = new StringBuilder();\n        int length = sql.length();\n        for (int i = 0; i < length; i++) {\n            char c = sql.charAt(i);\n            if (c == '#') {\n                int nextIndex = i + 1;\n                char nextChar = sql.charAt(nextIndex);\n                if (nextChar != '{') {\n                    throw new RuntimeException(\"sql写法错误，应该是 { \");\n                }\n                StringBuilder argSb = new StringBuilder();\n                i = parseSqlArg(argSb, sql, nextIndex);\n                String argName = argSb.toString();\n                Object argValue = map.get(argName);\n                sb.append(argValue.toString());\n                continue;\n            }\n            sb.append(c);\n        }\n\n        // 返回解析后拼接过的sql\n        return sb.toString();\n    }\n\n    /**\n     * 这里应该是解析出{}中的的东西\n     */\n    private static int parseSqlArg(StringBuilder argSb, String sql, int nextIndex) {\n        for (int i = nextIndex + 1; i < sql.length(); i++) {\n            char c = sql.charAt(i);\n            if (c != '}') {\n                argSb.append(c);\n            } else {\n                return i;\n            }\n        }\n        throw new RuntimeException(\"sql写法错误，应该是 } \");\n    }\n\n    /**\n     * 解析传入的参数\n     *\n     * @param method method\n     * @param args   参数\n     * @return 解析后的参数\n     */\n    public static Map<String, Object> buildMethodArgNameMap(Method method, Object[] args) {\n        Map<String, Object> map = new HashMap<>(6);\n        // 方法的入参，例如：Integer id, args是实际的入参值，如 6\n        Parameter[] parameters = method.getParameters();\n        for (int i = 0; i < parameters.length; i++) {\n            map.put(parameters[i].getName(), args[i]);\n        }\n        return map;\n    }\n}\n\n\ninterface UserMapper {\n\n    @Select(\"select * from User where id = #{id}\")\n    List<Test.User> selectUesList(Integer id);\n}\t\n```\n\n以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：![mybatis_structure.jpg](https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg)\n\n我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用`#{}`括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。","slug":"mybatis-sql-resolution","published":1,"updated":"2021-04-05T05:44:14.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj97001vts9qh31bfh8b","content":"<p>承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟的pojo</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 核心就在这</span></span><br><span class=\"line\">        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;UserMapper.class&#125;, <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取到注解</span></span><br><span class=\"line\">                Select annotation = method.getAnnotation(Select.class);</span><br><span class=\"line\">                <span class=\"comment\">// 构建入参的映射</span></span><br><span class=\"line\">                Map&lt;String, Object&gt; map = buildMethodArgNameMap(method, args);</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(map.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String[] value = annotation.value();</span><br><span class=\"line\">                    String s = parseSql(value[<span class=\"number\">0</span>], map);</span><br><span class=\"line\">                    System.out.println(s);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        userMapper.selectUesList(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析sql</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseSql</span><span class=\"params\">(String sql, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = sql.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nextIndex = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> nextChar = sql.charAt(nextIndex);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextChar != <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#123; &quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                StringBuilder argSb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                i = parseSqlArg(argSb, sql, nextIndex);</span><br><span class=\"line\">                String argName = argSb.toString();</span><br><span class=\"line\">                Object argValue = map.get(argName);</span><br><span class=\"line\">                sb.append(argValue.toString());</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sb.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回解析后拼接过的sql</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里应该是解析出&#123;&#125;中的的东西</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parseSqlArg</span><span class=\"params\">(StringBuilder argSb, String sql, <span class=\"keyword\">int</span> nextIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex + <span class=\"number\">1</span>; i &lt; sql.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"string\">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class=\"line\">                argSb.append(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#125; &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解析传入的参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method method</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 解析后的参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, Object&gt; <span class=\"title\">buildMethodArgNameMap</span><span class=\"params\">(Method method, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 方法的入参，例如：Integer id, args是实际的入参值，如 6</span></span><br><span class=\"line\">        Parameter[] parameters = method.getParameters();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class=\"line\">            map.put(parameters[i].getName(), args[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Select(&quot;select * from User where id = #&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    List&lt;Test.User&gt; selectUesList(Integer id);</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：<img src=\"https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg\" alt=\"mybatis_structure.jpg\"></p>\n<p>我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用<code>#&#123;&#125;</code>括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>承接去年记录的mybatis，从架构和源码的角度剖析mybatis。从整个项目工程来看他比spring小得多，因此代码更易读。使用他时，通常我们要做的就是编写sql和接口，这篇首先从sql解析开始。</p>","more":"<!-- toc -->\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟的pojo</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 核心就在这</span></span><br><span class=\"line\">        UserMapper userMapper = (UserMapper) Proxy.newProxyInstance(Test.class.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;UserMapper.class&#125;, <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取到注解</span></span><br><span class=\"line\">                Select annotation = method.getAnnotation(Select.class);</span><br><span class=\"line\">                <span class=\"comment\">// 构建入参的映射</span></span><br><span class=\"line\">                Map&lt;String, Object&gt; map = buildMethodArgNameMap(method, args);</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(map.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (annotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    String[] value = annotation.value();</span><br><span class=\"line\">                    String s = parseSql(value[<span class=\"number\">0</span>], map);</span><br><span class=\"line\">                    System.out.println(s);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        userMapper.selectUesList(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析sql</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseSql</span><span class=\"params\">(String sql, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = sql.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nextIndex = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> nextChar = sql.charAt(nextIndex);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nextChar != <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#123; &quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                StringBuilder argSb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">                i = parseSqlArg(argSb, sql, nextIndex);</span><br><span class=\"line\">                String argName = argSb.toString();</span><br><span class=\"line\">                Object argValue = map.get(argName);</span><br><span class=\"line\">                sb.append(argValue.toString());</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sb.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回解析后拼接过的sql</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里应该是解析出&#123;&#125;中的的东西</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parseSqlArg</span><span class=\"params\">(StringBuilder argSb, String sql, <span class=\"keyword\">int</span> nextIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex + <span class=\"number\">1</span>; i &lt; sql.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = sql.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"string\">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class=\"line\">                argSb.append(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;sql写法错误，应该是 &#125; &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解析传入的参数</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method method</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args   参数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 解析后的参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, Object&gt; <span class=\"title\">buildMethodArgNameMap</span><span class=\"params\">(Method method, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 方法的入参，例如：Integer id, args是实际的入参值，如 6</span></span><br><span class=\"line\">        Parameter[] parameters = method.getParameters();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class=\"line\">            map.put(parameters[i].getName(), args[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Select(&quot;select * from User where id = #&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    List&lt;Test.User&gt; selectUesList(Integer id);</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>以上只是模拟mybatis架构中的解析sql的部分，真正的解析还是比较复杂的，要考虑很多种情况，但是原理是一样，都离不开动态代理。下面我们看看他的架构设计图（非官方）：<img src=\"https://i.loli.net/2021/03/07/cPamMLRFU4xHXu8.jpg\" alt=\"mybatis_structure.jpg\"></p>\n<p>我们从这个角度去想：如何用sql去跟数据库交互？如何动态地去用sql与数据库交互？站在现在看过去，mybatis实现了这一点，如何做的？利用接口来实现，有两种方式：在接口上用注释来写或者写在xml文件里需要替换的地方用<code>#&#123;&#125;</code>括起来，在需要的地方调用接口的方法并把值传进去，我们要做的就只有这些，其他的mybatis帮我们做了。我们来看看他都做了什么，首先就是映射关系，把传入的值替换到sql语句并拼接起来、查询的结果映射到想要的对象上；管理sql与数据库的交互。这两个是最基本的，其次，还可以做些优化，比如缓存，频繁地查询某个sql可以将结果存起来；扩展性，对结果统一处理等。</p>"},{"title":"mybatis_preview","date":"2020-08-05T14:21:19.000Z","_content":"\nMybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。\n\n<!--more-->\n\n# 流程\n\n```flow\nstart=>start: start\nconfig=>operation: mybatis-config.xml\nbuild=>operation: SqlSessionFactoryBuilder\nfactory=>operation: SqlSessionFactory\nsession=>parallel: SqlSession\nmapper=>operation: Sql Mapper\nend=>end: end\n\nstart->config->build->factory->session\nsession(path1,)->end\nsession(path2,right)->mapper->end\n```\n\n对于`SqlSessionFactoryBuilder`来说，作用是创建`SqlSessionFactory`，一旦创建完工厂就没用了，所以是作为**局部变量**；而对于`SqlSessionFactory`，可以把它看作*连接池*，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建`SqlSession` 。创建`SqlSession`后用来链接数据库，每个session被看作是请求数据库，他是**线程不安全**的，每个线程都应有自己的session，不共享，所以最佳作用域是**方法域**，即每次与数据库交互都创建一个`SqlSession`，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。\n\n## 属性名与数据库表字段名\n\n当pojo中的实例变量与数据库字段中不一致时，可以使用`resultMap`来解决，即**结果集映射**。\n\n也常用`resultType`，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来`resultMap`时可以去掉`resultType`属性。\n\n## 日志工厂\n\nmybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！\n\n```xml\n<settings>\n\t<setting name=\"logImpl\" value=\"log4j\"/>\n</settings>\n```\n\n## 分页\n\nmybatis支持分页，有`limit`和`rowBounts`两个方法。区别是前者在sql中实现，后者面向对象。\n\n```sql\nselect * from USER limit #{index},#{size}\n```\n\n# 缓存\n\n默认定义了两级缓存：一级缓存、二级缓存\n\n## 一级缓存\n\n默认开启，在session的`close`之前都有效，如果是查询相同的数据，直接在缓存中拿。\n\n## 二级缓存\n\n需要手动开启和配置，基于`namespace`级别，有`Cache`接口来自定义实现。\n","source":"_posts/mybatis_preview.md","raw":"---\ntitle: mybatis_preview\ndate: 2020-08-05 22:21:19\ncategories: framework\ntags: mybatis\n---\n\nMybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。\n\n<!--more-->\n\n# 流程\n\n```flow\nstart=>start: start\nconfig=>operation: mybatis-config.xml\nbuild=>operation: SqlSessionFactoryBuilder\nfactory=>operation: SqlSessionFactory\nsession=>parallel: SqlSession\nmapper=>operation: Sql Mapper\nend=>end: end\n\nstart->config->build->factory->session\nsession(path1,)->end\nsession(path2,right)->mapper->end\n```\n\n对于`SqlSessionFactoryBuilder`来说，作用是创建`SqlSessionFactory`，一旦创建完工厂就没用了，所以是作为**局部变量**；而对于`SqlSessionFactory`，可以把它看作*连接池*，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建`SqlSession` 。创建`SqlSession`后用来链接数据库，每个session被看作是请求数据库，他是**线程不安全**的，每个线程都应有自己的session，不共享，所以最佳作用域是**方法域**，即每次与数据库交互都创建一个`SqlSession`，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。\n\n## 属性名与数据库表字段名\n\n当pojo中的实例变量与数据库字段中不一致时，可以使用`resultMap`来解决，即**结果集映射**。\n\n也常用`resultType`，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来`resultMap`时可以去掉`resultType`属性。\n\n## 日志工厂\n\nmybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！\n\n```xml\n<settings>\n\t<setting name=\"logImpl\" value=\"log4j\"/>\n</settings>\n```\n\n## 分页\n\nmybatis支持分页，有`limit`和`rowBounts`两个方法。区别是前者在sql中实现，后者面向对象。\n\n```sql\nselect * from USER limit #{index},#{size}\n```\n\n# 缓存\n\n默认定义了两级缓存：一级缓存、二级缓存\n\n## 一级缓存\n\n默认开启，在session的`close`之前都有效，如果是查询相同的数据，直接在缓存中拿。\n\n## 二级缓存\n\n需要手动开启和配置，基于`namespace`级别，有`Cache`接口来自定义实现。\n","slug":"mybatis_preview","published":1,"updated":"2021-03-28T10:20:02.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9a001xts9q5znub0t3","content":"<p>Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">config&#x3D;&gt;operation: mybatis-config.xml</span><br><span class=\"line\">build&#x3D;&gt;operation: SqlSessionFactoryBuilder</span><br><span class=\"line\">factory&#x3D;&gt;operation: SqlSessionFactory</span><br><span class=\"line\">session&#x3D;&gt;parallel: SqlSession</span><br><span class=\"line\">mapper&#x3D;&gt;operation: Sql Mapper</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;config-&gt;build-&gt;factory-&gt;session</span><br><span class=\"line\">session(path1,)-&gt;end</span><br><span class=\"line\">session(path2,right)-&gt;mapper-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>SqlSessionFactoryBuilder</code>来说，作用是创建<code>SqlSessionFactory</code>，一旦创建完工厂就没用了，所以是作为<strong>局部变量</strong>；而对于<code>SqlSessionFactory</code>，可以把它看作<em>连接池</em>，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建<code>SqlSession</code> 。创建<code>SqlSession</code>后用来链接数据库，每个session被看作是请求数据库，他是<strong>线程不安全</strong>的，每个线程都应有自己的session，不共享，所以最佳作用域是<strong>方法域</strong>，即每次与数据库交互都创建一个<code>SqlSession</code>，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。</p>\n<h2 id=\"属性名与数据库表字段名\"><a href=\"#属性名与数据库表字段名\" class=\"headerlink\" title=\"属性名与数据库表字段名\"></a>属性名与数据库表字段名</h2><p>当pojo中的实例变量与数据库字段中不一致时，可以使用<code>resultMap</code>来解决，即<strong>结果集映射</strong>。</p>\n<p>也常用<code>resultType</code>，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来<code>resultMap</code>时可以去掉<code>resultType</code>属性。</p>\n<h2 id=\"日志工厂\"><a href=\"#日志工厂\" class=\"headerlink\" title=\"日志工厂\"></a>日志工厂</h2><p>mybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logImpl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;log4j&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h2><p>mybatis支持分页，有<code>limit</code>和<code>rowBounts</code>两个方法。区别是前者在sql中实现，后者面向对象。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from USER limit #&#123;index&#125;,#&#123;size&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><p>默认定义了两级缓存：一级缓存、二级缓存</p>\n<h2 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h2><p>默认开启，在session的<code>close</code>之前都有效，如果是查询相同的数据，直接在缓存中拿。</p>\n<h2 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h2><p>需要手动开启和配置，基于<code>namespace</code>级别，有<code>Cache</code>接口来自定义实现。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>Mybatis帮助我们提升与数据库交互的效率，简化了JDBC的样板代码。</p>","more":"<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">config&#x3D;&gt;operation: mybatis-config.xml</span><br><span class=\"line\">build&#x3D;&gt;operation: SqlSessionFactoryBuilder</span><br><span class=\"line\">factory&#x3D;&gt;operation: SqlSessionFactory</span><br><span class=\"line\">session&#x3D;&gt;parallel: SqlSession</span><br><span class=\"line\">mapper&#x3D;&gt;operation: Sql Mapper</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;config-&gt;build-&gt;factory-&gt;session</span><br><span class=\"line\">session(path1,)-&gt;end</span><br><span class=\"line\">session(path2,right)-&gt;mapper-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>SqlSessionFactoryBuilder</code>来说，作用是创建<code>SqlSessionFactory</code>，一旦创建完工厂就没用了，所以是作为<strong>局部变量</strong>；而对于<code>SqlSessionFactory</code>，可以把它看作<em>连接池</em>，应该一直运行，不应重复创建、销毁或另建实例（单例模式登场），否则浪费资源，他可以创建<code>SqlSession</code> 。创建<code>SqlSession</code>后用来链接数据库，每个session被看作是请求数据库，他是<strong>线程不安全</strong>的，每个线程都应有自己的session，不共享，所以最佳作用域是<strong>方法域</strong>，即每次与数据库交互都创建一个<code>SqlSession</code>，用完关闭（关闭是为了释放资源给别的线程使用，否则并发大了容易宕机）。</p>\n<h2 id=\"属性名与数据库表字段名\"><a href=\"#属性名与数据库表字段名\" class=\"headerlink\" title=\"属性名与数据库表字段名\"></a>属性名与数据库表字段名</h2><p>当pojo中的实例变量与数据库字段中不一致时，可以使用<code>resultMap</code>来解决，即<strong>结果集映射</strong>。</p>\n<p>也常用<code>resultType</code>，但是他是简单地将所有列映射到HashMap中的key上，很单一，不适合处理复杂情况，而map可以更加灵活地处理情况。用来<code>resultMap</code>时可以去掉<code>resultType</code>属性。</p>\n<h2 id=\"日志工厂\"><a href=\"#日志工厂\" class=\"headerlink\" title=\"日志工厂\"></a>日志工厂</h2><p>mybatis会默认去寻找日志框架，配置后会有sql信息输出，十分有用！</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logImpl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;log4j&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"分页\"><a href=\"#分页\" class=\"headerlink\" title=\"分页\"></a>分页</h2><p>mybatis支持分页，有<code>limit</code>和<code>rowBounts</code>两个方法。区别是前者在sql中实现，后者面向对象。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from USER limit #&#123;index&#125;,#&#123;size&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><p>默认定义了两级缓存：一级缓存、二级缓存</p>\n<h2 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h2><p>默认开启，在session的<code>close</code>之前都有效，如果是查询相同的数据，直接在缓存中拿。</p>\n<h2 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h2><p>需要手动开启和配置，基于<code>namespace</code>级别，有<code>Cache</code>接口来自定义实现。</p>"},{"title":"nginx","date":"2019-11-02T14:53:32.000Z","_content":"# NIGNX\n\n*Nginx* (engine x) 是一个高性能的HTTP和**反向代理**web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n\n它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。\n\n特点：\n\n- 反向代理\n- 负载均衡\n- 动静分离\n- 高可用\n\n\n\n## 反向代理\n\n客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。\n\n## 正向代理\n\n如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）\n\n正向访问需要在浏览器配置代理服务器。\n\n\n\n## 负载均衡\n\n单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。\n\n\n\n## 动静分离\n\n为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。\n\n静态资源：html, css, js\n\n动态资源：jsp, servlet\n\n## 操作\n\n### 常用命令\n\n前提条件：进入nginx目录\n\n/usr/localnginx/sbin\n\n- 查看nginx版本号\n- 启动\n- 关闭\n- 重新加载nginx\n\n[referenct](https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng)\n\n# 配置\n\n1. 配置EPEL源\n\n   ```bash\n   sudo yum install -y epel-release\n   sudo yum -y update\n   ```\n\n2. 安装nginx\n\n   ```bash\n   sudo yum instll -y nginx\n   ```\n\n   安装成功后：\n\n   `默认网站目录`：_/usr/share/nginx/html_\n\n   `默认的配置文件为`：_/etc/nginx/nginx.conf_\n\n   `自定义配置文件目录为`：_/etc/nginx/conf.d/_\n\n3. 开启端口80和443\n\n   如果关闭了防火墙，直接略过。\n\n   ```bash\n   sudo firewall-cmd --permanent --zone=public --add-service=http\n   sudo firewall-cmd --permanent --zone=public --add-service=https\n   sudo firewall-cmd --reload\n   ```\n\n4. 命令\n\n   - 启动\n\n     ```bash\n     systemctl start nginx\n     ```\n\n   - 停止\n\n     ```bash\n     systemctl stop nginx\n     ```\n\n   - 重启\n\n     ```bash\n     systemctl restart nginx\n     ```\n\n   - 查看状态\n\n     ```bash\n     systemctl status nginx\n     ```\n\n   - 启用开机启动\n\n     ```bash\n     systemctl enable nginx\n     ```\n\n     测试的时候，直接`nginx`命令即可，方便调试，调试时使用：\n\n     ```bash\n     nginx -t\n     ```\n\n     ```bash\n     nginx -s reload\n     ```\n\n     \n\n   - 禁止开机启动\n\n     ```bash\n     systemctl disbale nginx\n     ```\n\n5. https\n\n   1. 关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。\n\n   3. 拷贝证书至nginx\n   \n      domain为个人域名。\n   \n      ```bash\n   mkdir -p /etc/nginx/ssl\n      \n   acme.sh --install-cert -d domain \\\n      --key-file       /etc/nginx/ssl/domain.key  \\\n      --fullchain-file /etc/nginx/ssl/domain.cer \\\n      --reloadcmd     \"service nginx force-reload\"\n      ```\n   \n6. 配置nginx\n\n   删除**/etc/nginx/nginx.conf**中的server部分代码\n\n   ```markdown\n   server{\n   ...\n   }\n   ```\n\n   在**/etc/nginx/conf.d**创建自定义配置文件夹**default.conf**\n\n   ```properties\n   server {\n       listen 80;\n       listen 443 ssl;\n       server_name  domain www.domain;\n       location / {\n            root /usr/share/nginx/html;\n            index  index.html index.htm;\n        }\n   \n       ssl_certificate /etc/nginx/ssl/domain.crt;\n       ssl_certificate_key /etc/nginx/ssl/domain.key;\n       ssl_session_timeout  5m;\n       ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n       ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;\n       ssl_prefer_server_ciphers  on;\n   \n       error_page 497  https://$host$uri?$args;\n   }\n   ```\n   \n\n   \n\n   \n","source":"_posts/nginx.md","raw":"---\ntitle: nginx\ndate: 2019-11-02 22:53:32\ncategories: Network\ntags: network\n---\n# NIGNX\n\n*Nginx* (engine x) 是一个高性能的HTTP和**反向代理**web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n\n它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。\n\n特点：\n\n- 反向代理\n- 负载均衡\n- 动静分离\n- 高可用\n\n\n\n## 反向代理\n\n客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。\n\n## 正向代理\n\n如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）\n\n正向访问需要在浏览器配置代理服务器。\n\n\n\n## 负载均衡\n\n单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。\n\n\n\n## 动静分离\n\n为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。\n\n静态资源：html, css, js\n\n动态资源：jsp, servlet\n\n## 操作\n\n### 常用命令\n\n前提条件：进入nginx目录\n\n/usr/localnginx/sbin\n\n- 查看nginx版本号\n- 启动\n- 关闭\n- 重新加载nginx\n\n[referenct](https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng)\n\n# 配置\n\n1. 配置EPEL源\n\n   ```bash\n   sudo yum install -y epel-release\n   sudo yum -y update\n   ```\n\n2. 安装nginx\n\n   ```bash\n   sudo yum instll -y nginx\n   ```\n\n   安装成功后：\n\n   `默认网站目录`：_/usr/share/nginx/html_\n\n   `默认的配置文件为`：_/etc/nginx/nginx.conf_\n\n   `自定义配置文件目录为`：_/etc/nginx/conf.d/_\n\n3. 开启端口80和443\n\n   如果关闭了防火墙，直接略过。\n\n   ```bash\n   sudo firewall-cmd --permanent --zone=public --add-service=http\n   sudo firewall-cmd --permanent --zone=public --add-service=https\n   sudo firewall-cmd --reload\n   ```\n\n4. 命令\n\n   - 启动\n\n     ```bash\n     systemctl start nginx\n     ```\n\n   - 停止\n\n     ```bash\n     systemctl stop nginx\n     ```\n\n   - 重启\n\n     ```bash\n     systemctl restart nginx\n     ```\n\n   - 查看状态\n\n     ```bash\n     systemctl status nginx\n     ```\n\n   - 启用开机启动\n\n     ```bash\n     systemctl enable nginx\n     ```\n\n     测试的时候，直接`nginx`命令即可，方便调试，调试时使用：\n\n     ```bash\n     nginx -t\n     ```\n\n     ```bash\n     nginx -s reload\n     ```\n\n     \n\n   - 禁止开机启动\n\n     ```bash\n     systemctl disbale nginx\n     ```\n\n5. https\n\n   1. 关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。\n\n   3. 拷贝证书至nginx\n   \n      domain为个人域名。\n   \n      ```bash\n   mkdir -p /etc/nginx/ssl\n      \n   acme.sh --install-cert -d domain \\\n      --key-file       /etc/nginx/ssl/domain.key  \\\n      --fullchain-file /etc/nginx/ssl/domain.cer \\\n      --reloadcmd     \"service nginx force-reload\"\n      ```\n   \n6. 配置nginx\n\n   删除**/etc/nginx/nginx.conf**中的server部分代码\n\n   ```markdown\n   server{\n   ...\n   }\n   ```\n\n   在**/etc/nginx/conf.d**创建自定义配置文件夹**default.conf**\n\n   ```properties\n   server {\n       listen 80;\n       listen 443 ssl;\n       server_name  domain www.domain;\n       location / {\n            root /usr/share/nginx/html;\n            index  index.html index.htm;\n        }\n   \n       ssl_certificate /etc/nginx/ssl/domain.crt;\n       ssl_certificate_key /etc/nginx/ssl/domain.key;\n       ssl_session_timeout  5m;\n       ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n       ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;\n       ssl_prefer_server_ciphers  on;\n   \n       error_page 497  https://$host$uri?$args;\n   }\n   ```\n   \n\n   \n\n   \n","slug":"nginx","published":1,"updated":"2021-03-28T10:20:02.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9e0021ts9qfm70frf4","content":"<h1 id=\"NIGNX\"><a href=\"#NIGNX\" class=\"headerlink\" title=\"NIGNX\"></a>NIGNX</h1><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和<strong>反向代理</strong>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>\n<p>它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p>\n<p>特点：</p>\n<ul>\n<li>反向代理</li>\n<li>负载均衡</li>\n<li>动静分离</li>\n<li>高可用</li>\n</ul>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）</p>\n<p>正向访问需要在浏览器配置代理服务器。</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。</p>\n<p>静态资源：html, css, js</p>\n<p>动态资源：jsp, servlet</p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>前提条件：进入nginx目录</p>\n<p>/usr/localnginx/sbin</p>\n<ul>\n<li>查看nginx版本号</li>\n<li>启动</li>\n<li>关闭</li>\n<li>重新加载nginx</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng\">referenct</a></p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><ol>\n<li><p>配置EPEL源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y epel-release</span><br><span class=\"line\">sudo yum -y update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装nginx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum instll -y nginx</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后：</p>\n<p><code>默认网站目录</code>：<em>/usr/share/nginx/html</em></p>\n<p><code>默认的配置文件为</code>：<em>/etc/nginx/nginx.conf</em></p>\n<p><code>自定义配置文件目录为</code>：<em>/etc/nginx/conf.d/</em></p>\n</li>\n<li><p>开启端口80和443</p>\n<p>如果关闭了防火墙，直接略过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启用开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nginx</span><br></pre></td></tr></table></figure>\n\n<p>测试的时候，直接<code>nginx</code>命令即可，方便调试，调试时使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>禁止开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl disbale nginx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>https</p>\n<ol>\n<li><p>关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。</p>\n</li>\n<li><p>拷贝证书至nginx</p>\n<p>domain为个人域名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /etc/nginx/ssl</span><br><span class=\"line\">   </span><br><span class=\"line\">acme.sh --install-cert -d domain \\</span><br><span class=\"line\">   --key-file       /etc/nginx/ssl/domain.key  \\</span><br><span class=\"line\">   --fullchain-file /etc/nginx/ssl/domain.cer \\</span><br><span class=\"line\">   --reloadcmd     <span class=\"string\">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>配置nginx</p>\n<p>删除**/etc/nginx/nginx.conf**中的server部分代码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在**/etc/nginx/conf.d<strong>创建自定义配置文件夹</strong>default.conf**</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">80;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">443 ssl;</span></span><br><span class=\"line\">    <span class=\"attr\">server_name</span>  <span class=\"string\">domain www.domain;</span></span><br><span class=\"line\">    <span class=\"attr\">location</span> <span class=\"string\">/ &#123;</span></span><br><span class=\"line\">         <span class=\"attr\">root</span> <span class=\"string\">/usr/share/nginx/html;</span></span><br><span class=\"line\">         <span class=\"attr\">index</span>  <span class=\"string\">index.html index.htm;</span></span><br><span class=\"line\">     <span class=\"attr\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate</span> <span class=\"string\">/etc/nginx/ssl/domain.crt;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate_key</span> <span class=\"string\">/etc/nginx/ssl/domain.key;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_session_timeout</span>  <span class=\"string\">5m;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_protocols</span> <span class=\"string\">TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_ciphers</span> <span class=\"string\">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_prefer_server_ciphers</span>  <span class=\"string\">on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">error_page</span> <span class=\"string\">497  https://$host$uri?$args;</span></span><br><span class=\"line\"><span class=\"attr\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n</li>\n</ol>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<h1 id=\"NIGNX\"><a href=\"#NIGNX\" class=\"headerlink\" title=\"NIGNX\"></a>NIGNX</h1><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和<strong>反向代理</strong>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>\n<p>它是一款轻量级的Web服务器反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p>\n<p>特点：</p>\n<ul>\n<li>反向代理</li>\n<li>负载均衡</li>\n<li>动静分离</li>\n<li>高可用</li>\n</ul>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器的目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>如果把局域网外的Internet比作资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称作正向代理。（nginx还可以用作正向代理来进行上网功能。）</p>\n<p>正向访问需要在浏览器配置代理服务器。</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>单个服务器解决不了问题，我们增加服务器的数量，然后将请求分发到各个服务上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。静态资源和动态资源分开部署放置两台不同的服务器。</p>\n<p>静态资源：html, css, js</p>\n<p>动态资源：jsp, servlet</p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>前提条件：进入nginx目录</p>\n<p>/usr/localnginx/sbin</p>\n<ul>\n<li>查看nginx版本号</li>\n<li>启动</li>\n<li>关闭</li>\n<li>重新加载nginx</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s/PeNWaCDf_6gp2fCQa0Gvng\">referenct</a></p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><ol>\n<li><p>配置EPEL源</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y epel-release</span><br><span class=\"line\">sudo yum -y update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装nginx</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum instll -y nginx</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后：</p>\n<p><code>默认网站目录</code>：<em>/usr/share/nginx/html</em></p>\n<p><code>默认的配置文件为</code>：<em>/etc/nginx/nginx.conf</em></p>\n<p><code>自定义配置文件目录为</code>：<em>/etc/nginx/conf.d/</em></p>\n</li>\n<li><p>开启端口80和443</p>\n<p>如果关闭了防火墙，直接略过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class=\"line\">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>停止</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启用开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nginx</span><br></pre></td></tr></table></figure>\n\n<p>测试的时候，直接<code>nginx</code>命令即可，方便调试，调试时使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>禁止开机启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl disbale nginx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>https</p>\n<ol>\n<li><p>关于https的相关证书，可以从阿里云控制台获取（因为我租用的是阿里云服务器）。</p>\n</li>\n<li><p>拷贝证书至nginx</p>\n<p>domain为个人域名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /etc/nginx/ssl</span><br><span class=\"line\">   </span><br><span class=\"line\">acme.sh --install-cert -d domain \\</span><br><span class=\"line\">   --key-file       /etc/nginx/ssl/domain.key  \\</span><br><span class=\"line\">   --fullchain-file /etc/nginx/ssl/domain.cer \\</span><br><span class=\"line\">   --reloadcmd     <span class=\"string\">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>配置nginx</p>\n<p>删除**/etc/nginx/nginx.conf**中的server部分代码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在**/etc/nginx/conf.d<strong>创建自定义配置文件夹</strong>default.conf**</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">80;</span></span><br><span class=\"line\">    <span class=\"attr\">listen</span> <span class=\"string\">443 ssl;</span></span><br><span class=\"line\">    <span class=\"attr\">server_name</span>  <span class=\"string\">domain www.domain;</span></span><br><span class=\"line\">    <span class=\"attr\">location</span> <span class=\"string\">/ &#123;</span></span><br><span class=\"line\">         <span class=\"attr\">root</span> <span class=\"string\">/usr/share/nginx/html;</span></span><br><span class=\"line\">         <span class=\"attr\">index</span>  <span class=\"string\">index.html index.htm;</span></span><br><span class=\"line\">     <span class=\"attr\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate</span> <span class=\"string\">/etc/nginx/ssl/domain.crt;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_certificate_key</span> <span class=\"string\">/etc/nginx/ssl/domain.key;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_session_timeout</span>  <span class=\"string\">5m;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_protocols</span> <span class=\"string\">TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_ciphers</span> <span class=\"string\">ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;</span></span><br><span class=\"line\">    <span class=\"attr\">ssl_prefer_server_ciphers</span>  <span class=\"string\">on;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">error_page</span> <span class=\"string\">497  https://$host$uri?$args;</span></span><br><span class=\"line\"><span class=\"attr\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n</li>\n</ol>\n"},{"title":"observer","date":"2020-06-12T09:12:38.000Z","_content":"\n观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？\n\n<!--more-->\n\n一个好的设计模式能拯救一堆代码。\n\n# 场景\n\n设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。\n\n```java\npublic class WeatherData(){\n    getTemperature(){};\n    getHumidity(){};\n    \n    /**\n    * 一旦气象更新，此方法会被调用。\n    */\n    measuremetnsChanged(){\n        // our codes go here\n    };\n}\n```\n\n如果直接在`measuremetnsChanged`这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。\n\n```java\npublic void measuremetnsChanged(){\n    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    ......\n}\n```\n\n# 观察者模式\n\n先看看我们平时是怎么浏览微信订阅号消息：\n\n首先整个流程应该有两个参与者\n\n- 订阅号运营者\n- 订阅者\n\n订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。\n\n那么观察者模式也类似：\n\n> 订阅号运营者+订阅者=观察者模式\n\n不一样的是名称，订阅号运营者改为“subject\"（主题），订阅者改为”observer\"（观察者）。\n\n由于一个主题可以被多个观察者订阅，所以，它实现了对象之间**一对多**；同时，这种对象设计也让主题和观察者之间**松耦合**.\n\n对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。\n\n## 实现\n\n![Screenshot from 2020-06-12 18-03-04.png](https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png)\n\n我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。\n\n```java\npublic CurrentConditionsDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    weatherData.registerObserver(this);\n}\n```\n\n以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。\n\n完整代码参考：[项目传送门](https://github.com/Sebastian-Getts/designPatternsPractice)\n\n## 原理\n\n虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。\n\n# 应用\n\n观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。","source":"_posts/observer.md","raw":"---\ntitle: observer\ndate: 2020-06-12 17:12:38\ncategories: DesignPatterns\ntags: design_patterns\n---\n\n观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？\n\n<!--more-->\n\n一个好的设计模式能拯救一堆代码。\n\n# 场景\n\n设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。\n\n```java\npublic class WeatherData(){\n    getTemperature(){};\n    getHumidity(){};\n    \n    /**\n    * 一旦气象更新，此方法会被调用。\n    */\n    measuremetnsChanged(){\n        // our codes go here\n    };\n}\n```\n\n如果直接在`measuremetnsChanged`这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。\n\n```java\npublic void measuremetnsChanged(){\n    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());\n    ......\n}\n```\n\n# 观察者模式\n\n先看看我们平时是怎么浏览微信订阅号消息：\n\n首先整个流程应该有两个参与者\n\n- 订阅号运营者\n- 订阅者\n\n订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。\n\n那么观察者模式也类似：\n\n> 订阅号运营者+订阅者=观察者模式\n\n不一样的是名称，订阅号运营者改为“subject\"（主题），订阅者改为”observer\"（观察者）。\n\n由于一个主题可以被多个观察者订阅，所以，它实现了对象之间**一对多**；同时，这种对象设计也让主题和观察者之间**松耦合**.\n\n对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。\n\n## 实现\n\n![Screenshot from 2020-06-12 18-03-04.png](https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png)\n\n我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。\n\n```java\npublic CurrentConditionsDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    weatherData.registerObserver(this);\n}\n```\n\n以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。\n\n完整代码参考：[项目传送门](https://github.com/Sebastian-Getts/designPatternsPractice)\n\n## 原理\n\n虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。\n\n# 应用\n\n观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。","slug":"observer","published":1,"updated":"2021-03-28T10:20:02.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9g0024ts9qcbvka96y","content":"<p>观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？</p>\n<span id=\"more\"></span>\n\n<p>一个好的设计模式能拯救一堆代码。</p>\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">WeatherData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    getTemperature()&#123;&#125;;</span><br><span class=\"line\">    getHumidity()&#123;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 一旦气象更新，此方法会被调用。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    measuremetnsChanged()&#123;</span><br><span class=\"line\">        <span class=\"comment\">// our codes go here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果直接在<code>measuremetnsChanged</code>这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measuremetnsChanged</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>先看看我们平时是怎么浏览微信订阅号消息：</p>\n<p>首先整个流程应该有两个参与者</p>\n<ul>\n<li>订阅号运营者</li>\n<li>订阅者</li>\n</ul>\n<p>订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。</p>\n<p>那么观察者模式也类似：</p>\n<blockquote>\n<p>订阅号运营者+订阅者=观察者模式</p>\n</blockquote>\n<p>不一样的是名称，订阅号运营者改为“subject”（主题），订阅者改为”observer”（观察者）。</p>\n<p>由于一个主题可以被多个观察者订阅，所以，它实现了对象之间<strong>一对多</strong>；同时，这种对象设计也让主题和观察者之间<strong>松耦合</strong>.</p>\n<p>对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><img src=\"https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png\" alt=\"Screenshot from 2020-06-12 18-03-04.png\"></p>\n<p>我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Subject weatherData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weatherData = weatherData;</span><br><span class=\"line\">    weatherData.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。</p>\n<p>完整代码参考：<a href=\"https://github.com/Sebastian-Getts/designPatternsPractice\">项目传送门</a></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>观察者模式，融入一个场景的话就是观察者能够及时的知晓被观察者的动态。换句话说，改变常规的获取信息的方式，就是被观察者的每次动态推送到观察者。有咩有MQ的味道？</p>","more":"<p>一个好的设计模式能拯救一堆代码。</p>\n<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>设计一个应用：气象站检测到数据，显示装置应及时显示数据，气象站提供了一组API。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">WeatherData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    getTemperature()&#123;&#125;;</span><br><span class=\"line\">    getHumidity()&#123;&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 一旦气象更新，此方法会被调用。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    measuremetnsChanged()&#123;</span><br><span class=\"line\">        <span class=\"comment\">// our codes go here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果直接在<code>measuremetnsChanged</code>这个方法里写参数的更新，那么毫无疑问，违反了基本的编码常识：面向接口编程与松耦合。在后续更改显示装置代码的话，还得修改程序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measuremetnsChanged</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    currentConditionsDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    forecastDisplay.update(getTemperature(), getHumiditiy(), getPressure());</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>先看看我们平时是怎么浏览微信订阅号消息：</p>\n<p>首先整个流程应该有两个参与者</p>\n<ul>\n<li>订阅号运营者</li>\n<li>订阅者</li>\n</ul>\n<p>订阅号运营者需要关心的是如何高质量完成推文，订阅者关心的是能否收到推文（前提是订阅了）。在微信上，我们只需要订阅感兴趣的订阅号，微信方就会实现推送订阅号的推文，运营者和订阅者只需专注于自己的事情就好。</p>\n<p>那么观察者模式也类似：</p>\n<blockquote>\n<p>订阅号运营者+订阅者=观察者模式</p>\n</blockquote>\n<p>不一样的是名称，订阅号运营者改为“subject”（主题），订阅者改为”observer”（观察者）。</p>\n<p>由于一个主题可以被多个观察者订阅，所以，它实现了对象之间<strong>一对多</strong>；同时，这种对象设计也让主题和观察者之间<strong>松耦合</strong>.</p>\n<p>对于主题，只知道观察者实现了某个接口（observer），不需要知道观察者的具体类型、做了什么，而且，任何时候都可以添加/删除观察者，因为主题唯一依赖的是一个实现observer接口的对象列表。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><img src=\"https://i.loli.net/2020/06/12/cwTWVXNpIQ5ebGo.png\" alt=\"Screenshot from 2020-06-12 18-03-04.png\"></p>\n<p>我们为subject定义一个接口，这样，无论有多少个主题，实现subject就可以了。对于观察者，除了要实现Observer接口外，有参构造函数必须要传入一个特定的主题，这样观察者才有意义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Subject weatherData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weatherData = weatherData;</span><br><span class=\"line\">    weatherData.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上是手动实现了观察者模式所需的api，事实上，java的util包中内置了观察者模式。只不过不是接口，而是类，使用时需要继承它，如果想同时实现它和另外一个父类就无法做到了，一定程度上限制了它的复用。所以还是根据业务手动创建观察者模式，并不难。</p>\n<p>完整代码参考：<a href=\"https://github.com/Sebastian-Getts/designPatternsPractice\">项目传送门</a></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>虽然类似订阅，但是主观对象是不同的！！！比如微信订阅号，是否接收通知（是否订阅）是由订阅者来决定的，而在观察者模式当中，主观对象是主题，这就好比订阅的后半段。观察者模式的主动权不在观察者，而在于“想让谁观察”的主题：在一个具体的类实现了主题接口后，他能决定在自己有变化时通知谁，所以实现主题与观察者之间的耦合是在观察者接口中的注册方法。可以在主题中实现一个数组，用于保存观察者，在主题有变化时遍历数组中的观察者，实现通知。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>观察者模式在JavaBeans、Swing和RMI中都实现了观察者模式。</p>"},{"title":"predict the winner","date":"2021-05-14T07:59:32.000Z","_content":"\n这是一道关于选择的问题，来源于[LeetCode]([Predict the Winner - LeetCode](https://leetcode.com/problems/predict-the-winner/))，一道很有意思的题目，这篇blog记录了从暴力逐步优化到dp的过程。\n\n<!-- more -->\n\n# 题目\n\n简单说下题目，详细的数量限制等条件可以参照题目网站。\n\n两个选手，从一个池中选取数字，选的时候只能从两端拿，并且每个人都是按照最优的方式。数字的大小代表得分，问最后一号选手的得分是否可以大于二号选手。\n\n例1. 有数组{1，5，2}，无论一号选手选择1还是2，最后二号选手都将选择5并且获胜。\n\n例2，有数组{1, 5, 233, 7}，一号选手可以通过一定的策略获取到233，所以一号选手可以获胜。\n\n# 分析\n\n如何下手呢？首先啊，涉及到策略，一味地贪心法是不可取的，我们可以枚举出所有的可能性，并且自下而上地选择最优。对于一号选手来说，可选的数字下标为i，j，那么有两种情况：\n\n1. 选择i，此时二号选手也有两种情况可选：i+1，j。如果选择i+1，一号就剩下i+2或j；如果选择j，一号就剩下i+1或j-1，对于一号选手来说，可以获取的分数有两种情况（取min是因为二号选手获取最优解，那对 一号选手来说获取的就是最小值）\n   - score.i + min(score.i+1, score.j-1)。二号选手选取了j\n   - score.i + min(score.i+2, score.j)。二号选手选取了i\n2. 选择j，此时二号选手的可选情况为：i，j-1。如果选择i，一号剩下i+1或j-1；如果选择j-1，一号剩下i+1，j-2，对一号选手来说，同上：\n   - score.j + min(score.i+1, j-1)。二号选手选取了i\n   - score.j + min(score.i, score.j-2)。二号选手选取了j\n\n对于一号选手来说，也是择优，所以最终的结果是Math.max(两种情况)，最后与二号选手的的得分相比较。\n\n## 法一\n\n```java\npublic boolean predictWinner(int[] nums){\n    int total = 0;\n    for(int num : nums) total += num;\n    int firstPlayer = helper(nums, 0, nums.length-1);\n    \n    return firstPlayer >= total - firstPlayer;\n}\n\nprivate int helper(int[] nums, int i, int j){\n    if(i > j) return 0;\n    if(i == j) return nums[i];\n    \n    return Math.max(\n    \tnums[i] + Math.min(helper(nums, i+1, j-1), helper(nums, i+2, j)),\n        nums[j] + Math.min(helper(nums, i+1, j-1), helper(nums, i, j-2))\n    );\n}\n```\n\n对于如何一组数字来说，都是可以拆解成更小的问题，例如上面的{1,5,2}，可以看作是{1,5}的扩展版本，所以，有了上面的方程，可以引入备忘录来代替重复的计算，减少递归深度。\n\n## 法二\n\n```java\npublic boolean predictWinner(int[] nums){\n    int total = 0;\n    for(int num : nums) total += num;\n    int len = nums.length;\n    int[][] memo = new int[len][len];\n    Arrays.fill(memo, -1);\n    int firstPlayer = helper(nums, 0, len-1, memo);\n    \n    return firstPlayer >= total - firstPlayer;\n}\n\nprivate int helper(int[] nums, int i, int j){\n    if(i > j) return 0;\n    if(i == j) return nums[i];\n    if(memo[i][j] != -1) return memo[i][j];\n    int score = Math.max(\n    \tnums[i] + Math.min(helper(nums, i+1, j-1, memo), helper(nums, i+2, j, memo)),\n        nums[j] + Math.min(helper(nums, i+1, j-1, memo), helper(nums, i, j-2, memo))\n    );\n    memo[i][j] = score;\n    \n    return score;\n}\n```\n\n","source":"_posts/predict-the-winner.md","raw":"---\ntitle: predict the winner\ndate: 2021-05-14 15:59:32\ncategories: Leetcode\ntags: dp\n---\n\n这是一道关于选择的问题，来源于[LeetCode]([Predict the Winner - LeetCode](https://leetcode.com/problems/predict-the-winner/))，一道很有意思的题目，这篇blog记录了从暴力逐步优化到dp的过程。\n\n<!-- more -->\n\n# 题目\n\n简单说下题目，详细的数量限制等条件可以参照题目网站。\n\n两个选手，从一个池中选取数字，选的时候只能从两端拿，并且每个人都是按照最优的方式。数字的大小代表得分，问最后一号选手的得分是否可以大于二号选手。\n\n例1. 有数组{1，5，2}，无论一号选手选择1还是2，最后二号选手都将选择5并且获胜。\n\n例2，有数组{1, 5, 233, 7}，一号选手可以通过一定的策略获取到233，所以一号选手可以获胜。\n\n# 分析\n\n如何下手呢？首先啊，涉及到策略，一味地贪心法是不可取的，我们可以枚举出所有的可能性，并且自下而上地选择最优。对于一号选手来说，可选的数字下标为i，j，那么有两种情况：\n\n1. 选择i，此时二号选手也有两种情况可选：i+1，j。如果选择i+1，一号就剩下i+2或j；如果选择j，一号就剩下i+1或j-1，对于一号选手来说，可以获取的分数有两种情况（取min是因为二号选手获取最优解，那对 一号选手来说获取的就是最小值）\n   - score.i + min(score.i+1, score.j-1)。二号选手选取了j\n   - score.i + min(score.i+2, score.j)。二号选手选取了i\n2. 选择j，此时二号选手的可选情况为：i，j-1。如果选择i，一号剩下i+1或j-1；如果选择j-1，一号剩下i+1，j-2，对一号选手来说，同上：\n   - score.j + min(score.i+1, j-1)。二号选手选取了i\n   - score.j + min(score.i, score.j-2)。二号选手选取了j\n\n对于一号选手来说，也是择优，所以最终的结果是Math.max(两种情况)，最后与二号选手的的得分相比较。\n\n## 法一\n\n```java\npublic boolean predictWinner(int[] nums){\n    int total = 0;\n    for(int num : nums) total += num;\n    int firstPlayer = helper(nums, 0, nums.length-1);\n    \n    return firstPlayer >= total - firstPlayer;\n}\n\nprivate int helper(int[] nums, int i, int j){\n    if(i > j) return 0;\n    if(i == j) return nums[i];\n    \n    return Math.max(\n    \tnums[i] + Math.min(helper(nums, i+1, j-1), helper(nums, i+2, j)),\n        nums[j] + Math.min(helper(nums, i+1, j-1), helper(nums, i, j-2))\n    );\n}\n```\n\n对于如何一组数字来说，都是可以拆解成更小的问题，例如上面的{1,5,2}，可以看作是{1,5}的扩展版本，所以，有了上面的方程，可以引入备忘录来代替重复的计算，减少递归深度。\n\n## 法二\n\n```java\npublic boolean predictWinner(int[] nums){\n    int total = 0;\n    for(int num : nums) total += num;\n    int len = nums.length;\n    int[][] memo = new int[len][len];\n    Arrays.fill(memo, -1);\n    int firstPlayer = helper(nums, 0, len-1, memo);\n    \n    return firstPlayer >= total - firstPlayer;\n}\n\nprivate int helper(int[] nums, int i, int j){\n    if(i > j) return 0;\n    if(i == j) return nums[i];\n    if(memo[i][j] != -1) return memo[i][j];\n    int score = Math.max(\n    \tnums[i] + Math.min(helper(nums, i+1, j-1, memo), helper(nums, i+2, j, memo)),\n        nums[j] + Math.min(helper(nums, i+1, j-1, memo), helper(nums, i, j-2, memo))\n    );\n    memo[i][j] = score;\n    \n    return score;\n}\n```\n\n","slug":"predict-the-winner","published":1,"updated":"2021-05-14T08:39:56.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9j0027ts9q3oae30l7","content":"<p>这是一道关于选择的问题，来源于[LeetCode](<a href=\"https://leetcode.com/problems/predict-the-winner/\">Predict the Winner - LeetCode</a>)，一道很有意思的题目，这篇blog记录了从暴力逐步优化到dp的过程。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>简单说下题目，详细的数量限制等条件可以参照题目网站。</p>\n<p>两个选手，从一个池中选取数字，选的时候只能从两端拿，并且每个人都是按照最优的方式。数字的大小代表得分，问最后一号选手的得分是否可以大于二号选手。</p>\n<p>例1. 有数组{1，5，2}，无论一号选手选择1还是2，最后二号选手都将选择5并且获胜。</p>\n<p>例2，有数组{1, 5, 233, 7}，一号选手可以通过一定的策略获取到233，所以一号选手可以获胜。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>如何下手呢？首先啊，涉及到策略，一味地贪心法是不可取的，我们可以枚举出所有的可能性，并且自下而上地选择最优。对于一号选手来说，可选的数字下标为i，j，那么有两种情况：</p>\n<ol>\n<li>选择i，此时二号选手也有两种情况可选：i+1，j。如果选择i+1，一号就剩下i+2或j；如果选择j，一号就剩下i+1或j-1，对于一号选手来说，可以获取的分数有两种情况（取min是因为二号选手获取最优解，那对 一号选手来说获取的就是最小值）<ul>\n<li>score.i + min(score.i+1, score.j-1)。二号选手选取了j</li>\n<li>score.i + min(score.i+2, score.j)。二号选手选取了i</li>\n</ul>\n</li>\n<li>选择j，此时二号选手的可选情况为：i，j-1。如果选择i，一号剩下i+1或j-1；如果选择j-1，一号剩下i+1，j-2，对一号选手来说，同上：<ul>\n<li>score.j + min(score.i+1, j-1)。二号选手选取了i</li>\n<li>score.j + min(score.i, score.j-2)。二号选手选取了j</li>\n</ul>\n</li>\n</ol>\n<p>对于一号选手来说，也是择优，所以最终的结果是Math.max(两种情况)，最后与二号选手的的得分相比较。</p>\n<h2 id=\"法一\"><a href=\"#法一\" class=\"headerlink\" title=\"法一\"></a>法一</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">predictWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) total += num;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> firstPlayer = helper(nums, <span class=\"number\">0</span>, nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstPlayer &gt;= total - firstPlayer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; j) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == j) <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(</span><br><span class=\"line\">    \tnums[i] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>), helper(nums, i+<span class=\"number\">2</span>, j)),</span><br><span class=\"line\">        nums[j] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>), helper(nums, i, j-<span class=\"number\">2</span>))</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于如何一组数字来说，都是可以拆解成更小的问题，例如上面的{1,5,2}，可以看作是{1,5}的扩展版本，所以，有了上面的方程，可以引入备忘录来代替重复的计算，减少递归深度。</p>\n<h2 id=\"法二\"><a href=\"#法二\" class=\"headerlink\" title=\"法二\"></a>法二</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">predictWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) total += num;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] memo = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len][len];</span><br><span class=\"line\">    Arrays.fill(memo, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> firstPlayer = helper(nums, <span class=\"number\">0</span>, len-<span class=\"number\">1</span>, memo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstPlayer &gt;= total - firstPlayer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; j) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == j) <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(memo[i][j] != -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> memo[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> score = Math.max(</span><br><span class=\"line\">    \tnums[i] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>, memo), helper(nums, i+<span class=\"number\">2</span>, j, memo)),</span><br><span class=\"line\">        nums[j] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>, memo), helper(nums, i, j-<span class=\"number\">2</span>, memo))</span><br><span class=\"line\">    );</span><br><span class=\"line\">    memo[i][j] = score;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> score;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这是一道关于选择的问题，来源于[LeetCode](<a href=\"https://leetcode.com/problems/predict-the-winner/\">Predict the Winner - LeetCode</a>)，一道很有意思的题目，这篇blog记录了从暴力逐步优化到dp的过程。</p>","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>简单说下题目，详细的数量限制等条件可以参照题目网站。</p>\n<p>两个选手，从一个池中选取数字，选的时候只能从两端拿，并且每个人都是按照最优的方式。数字的大小代表得分，问最后一号选手的得分是否可以大于二号选手。</p>\n<p>例1. 有数组{1，5，2}，无论一号选手选择1还是2，最后二号选手都将选择5并且获胜。</p>\n<p>例2，有数组{1, 5, 233, 7}，一号选手可以通过一定的策略获取到233，所以一号选手可以获胜。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>如何下手呢？首先啊，涉及到策略，一味地贪心法是不可取的，我们可以枚举出所有的可能性，并且自下而上地选择最优。对于一号选手来说，可选的数字下标为i，j，那么有两种情况：</p>\n<ol>\n<li>选择i，此时二号选手也有两种情况可选：i+1，j。如果选择i+1，一号就剩下i+2或j；如果选择j，一号就剩下i+1或j-1，对于一号选手来说，可以获取的分数有两种情况（取min是因为二号选手获取最优解，那对 一号选手来说获取的就是最小值）<ul>\n<li>score.i + min(score.i+1, score.j-1)。二号选手选取了j</li>\n<li>score.i + min(score.i+2, score.j)。二号选手选取了i</li>\n</ul>\n</li>\n<li>选择j，此时二号选手的可选情况为：i，j-1。如果选择i，一号剩下i+1或j-1；如果选择j-1，一号剩下i+1，j-2，对一号选手来说，同上：<ul>\n<li>score.j + min(score.i+1, j-1)。二号选手选取了i</li>\n<li>score.j + min(score.i, score.j-2)。二号选手选取了j</li>\n</ul>\n</li>\n</ol>\n<p>对于一号选手来说，也是择优，所以最终的结果是Math.max(两种情况)，最后与二号选手的的得分相比较。</p>\n<h2 id=\"法一\"><a href=\"#法一\" class=\"headerlink\" title=\"法一\"></a>法一</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">predictWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) total += num;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> firstPlayer = helper(nums, <span class=\"number\">0</span>, nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstPlayer &gt;= total - firstPlayer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; j) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == j) <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(</span><br><span class=\"line\">    \tnums[i] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>), helper(nums, i+<span class=\"number\">2</span>, j)),</span><br><span class=\"line\">        nums[j] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>), helper(nums, i, j-<span class=\"number\">2</span>))</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于如何一组数字来说，都是可以拆解成更小的问题，例如上面的{1,5,2}，可以看作是{1,5}的扩展版本，所以，有了上面的方程，可以引入备忘录来代替重复的计算，减少递归深度。</p>\n<h2 id=\"法二\"><a href=\"#法二\" class=\"headerlink\" title=\"法二\"></a>法二</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">predictWinner</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) total += num;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[][] memo = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len][len];</span><br><span class=\"line\">    Arrays.fill(memo, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> firstPlayer = helper(nums, <span class=\"number\">0</span>, len-<span class=\"number\">1</span>, memo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstPlayer &gt;= total - firstPlayer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &gt; j) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == j) <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(memo[i][j] != -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> memo[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> score = Math.max(</span><br><span class=\"line\">    \tnums[i] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>, memo), helper(nums, i+<span class=\"number\">2</span>, j, memo)),</span><br><span class=\"line\">        nums[j] + Math.min(helper(nums, i+<span class=\"number\">1</span>, j-<span class=\"number\">1</span>, memo), helper(nums, i, j-<span class=\"number\">2</span>, memo))</span><br><span class=\"line\">    );</span><br><span class=\"line\">    memo[i][j] = score;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> score;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"redis","date":"2020-06-09T13:54:01.000Z","_content":"\n常用redis，深入了解redis的性能和瓶颈。[reference](https://github.com/antirez/redis)\n\n<!--more-->\n\n# 介绍\n\nredis: **内存**中的数据结构存储系统，可以用作**数据库**、**缓存**和**消息中间件**，nosql的一种。\n\n## nosql\n\n关系型数据库不够用，出来了nosql。。。\n\n1. 一开始单体应用，小用户量能承受。但是当体量变大时：\n   - 数据量大\n   - 数据的索引大\n   - 访问量大\n2. 读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层**memcache**缓存\n3. 集群（水平拆分）：上面的读写分离copy多份。\n\nmysql早些年使用的是MyISAM引擎，特性是**表锁**（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了**行锁**。\n\n不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。\n\n### 特点\n\n1. 易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。\n2. 大数据量也高性能（写8万次/秒，读11万次/秒）\n3. 多样型，不需要事先设计数据库\n4. 没有固定的查询语言；最终一致性\n5. 键值对存储，列存储，文档存储，图形存储库（社交）\n6. 高性能、高可用、高可扩\n7. CAP、BASE，异地多活\n8. 多样、实时、并发（Volume, Variety, Veiocity）\n\n与关系型一起使用。\n\n商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）\n\n商品的基本信息（价格、商家、名称）：MySQL\n\n图片：FastDFS, GFS, HDFS, OSS...\n\n商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）\n\n==没有什么不是加以层解决不了的==： 统一服务层。\n\n### 文档型数据库\n\nMongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。\n\n### KV键值对\n\nRedis，Tair\n\n### 列存储数据库\n\nHBase（大数据）\n\n分布式文件系统\n\n### 图\n\n类似知识图谱，不是存储图形。主要用于存储社交网络。\n\nNeo4j，InfoGrid。\n\n# Redis\n\nRemote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。\n\n- 内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）\n- 计时器、计数器（浏览量）\n\n## 测试\n\n安装后自带的测试工具\n\n```bash\nredis-benchmark -h localhost -p 6379 -100 -n 100000\n```\n\n## 基础\n\n默认16个数据库且使用的是第0个。 \n\n### GEOSPATIAL\n\n地理位置，不仅仅是GET、SET！根据经纬度获取距离。\n\n## springboot集成\n\n版本<2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。\n\n版本>2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。\n\n## rdb\n\n为什么会有这个rdb？\n\nredis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。\n\n```flow\nstart=>start: start\nend=>end: end\ncondition=>condition: 触发rdb\nrdbfile=>inputoutput: dump.rdb\noperation=>operation: go on dealing with\n\nstart->condition\ncondition(yes)->rdbfile->end\ncondition(no)->operation->end\n```\n\n#### 触发机制\n\n1. save的规则\n2. 执行flushall\n3. 退出redis\n\n产生备份，会自动生成一个dump.rdb\n\n#### 用rdb恢复\n\n```bash\nconfig get dir\n```\n\n#### 优点：\n\n1. 适合大数据\n2. 对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）\n\n#### 缺点：\n\n1. 需要一定的时间间隔进程操作\n2. fork进程的时候会占用一定的内容空间\n\n## AOF\n\nAppend Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。\n\n- 大数据的情况下效率会比较低。\n- 默认是不开启的。\n\n开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。\n\n修复aof文件 `redis-check-aof --fix`\n\n### 优点：\n\n1. 每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据\n2. 从不同步效率最高\n\n### 缺点：\n\n1. 相对于数据文件，aof远大于rdb，修复的速度比rdb慢\n2. 默认是rdb，效率自然高于aof。\n\n**与rdb混合使用**\n\n## 主从复制\n\n将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。\n\n作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石\n\nreids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。\n\n默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。\n\n### 环境配置\n\n```shell\ninfo replication # 查看当前库的信息\n```\n\n一般情况下只用配置从机即可。\n\n```shell\nSLAVEOF ip:port # ip:port为主机\n```\n\n上面的是命令配置，只是暂时的。**实际生产应该修改配置文件**，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。\n\n#### 如果主机宕机了呢？\n\n默认情况下，主机挂了以后，用`info replication`查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。\n\n更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。\n\n- 全量复制 master将整个数据传送到slaver\n- 增量复制\n\n只要重新链接master，一次全量复制将被自动执行\n\n### 哨兵模式\n\nSentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。\n\n哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）\n\n#### 优点\n\n1. 集群\n2. 主从切换\n\n#### 缺点\n\n1. 不方便在线扩容，一旦到达上线。\n2. 配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。\n\n## redis异常处理\n\n### 缓存穿透（一直查询不到）\n\n```flow\nstart=>start: request\nend=>end: response\ncondition=>condition: redis缓存中是否存在\nop1=>operation: select in mysql\nstart->condition\ncondition(yes)->end\ncondition(no)->op1->end\n```\n\n如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。\n\n#### 布隆过滤器\n\n它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力\n\n#### 缓存空对象\n\n### 缓存击穿（量太大，缓存过期）\n\n活力集中在一个点（一个热评的点，如微博）。\n\n#### 加互斥锁\n\n#### 设置热点数据永不过期\n\n### 缓存雪崩\n\n在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。\n\n#### redis高可用\n\n#### 限流降级\n\n#### 数据预热\n\n正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。\n\n","source":"_posts/redis.md","raw":"---\ntitle: redis\ndate: 2020-06-09 21:54:01\ncategories: DB\ntags: \n- redis\n- nosql\n---\n\n常用redis，深入了解redis的性能和瓶颈。[reference](https://github.com/antirez/redis)\n\n<!--more-->\n\n# 介绍\n\nredis: **内存**中的数据结构存储系统，可以用作**数据库**、**缓存**和**消息中间件**，nosql的一种。\n\n## nosql\n\n关系型数据库不够用，出来了nosql。。。\n\n1. 一开始单体应用，小用户量能承受。但是当体量变大时：\n   - 数据量大\n   - 数据的索引大\n   - 访问量大\n2. 读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层**memcache**缓存\n3. 集群（水平拆分）：上面的读写分离copy多份。\n\nmysql早些年使用的是MyISAM引擎，特性是**表锁**（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了**行锁**。\n\n不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。\n\n### 特点\n\n1. 易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。\n2. 大数据量也高性能（写8万次/秒，读11万次/秒）\n3. 多样型，不需要事先设计数据库\n4. 没有固定的查询语言；最终一致性\n5. 键值对存储，列存储，文档存储，图形存储库（社交）\n6. 高性能、高可用、高可扩\n7. CAP、BASE，异地多活\n8. 多样、实时、并发（Volume, Variety, Veiocity）\n\n与关系型一起使用。\n\n商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）\n\n商品的基本信息（价格、商家、名称）：MySQL\n\n图片：FastDFS, GFS, HDFS, OSS...\n\n商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）\n\n==没有什么不是加以层解决不了的==： 统一服务层。\n\n### 文档型数据库\n\nMongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。\n\n### KV键值对\n\nRedis，Tair\n\n### 列存储数据库\n\nHBase（大数据）\n\n分布式文件系统\n\n### 图\n\n类似知识图谱，不是存储图形。主要用于存储社交网络。\n\nNeo4j，InfoGrid。\n\n# Redis\n\nRemote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。\n\n- 内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）\n- 计时器、计数器（浏览量）\n\n## 测试\n\n安装后自带的测试工具\n\n```bash\nredis-benchmark -h localhost -p 6379 -100 -n 100000\n```\n\n## 基础\n\n默认16个数据库且使用的是第0个。 \n\n### GEOSPATIAL\n\n地理位置，不仅仅是GET、SET！根据经纬度获取距离。\n\n## springboot集成\n\n版本<2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。\n\n版本>2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。\n\n## rdb\n\n为什么会有这个rdb？\n\nredis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。\n\n```flow\nstart=>start: start\nend=>end: end\ncondition=>condition: 触发rdb\nrdbfile=>inputoutput: dump.rdb\noperation=>operation: go on dealing with\n\nstart->condition\ncondition(yes)->rdbfile->end\ncondition(no)->operation->end\n```\n\n#### 触发机制\n\n1. save的规则\n2. 执行flushall\n3. 退出redis\n\n产生备份，会自动生成一个dump.rdb\n\n#### 用rdb恢复\n\n```bash\nconfig get dir\n```\n\n#### 优点：\n\n1. 适合大数据\n2. 对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）\n\n#### 缺点：\n\n1. 需要一定的时间间隔进程操作\n2. fork进程的时候会占用一定的内容空间\n\n## AOF\n\nAppend Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。\n\n- 大数据的情况下效率会比较低。\n- 默认是不开启的。\n\n开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。\n\n修复aof文件 `redis-check-aof --fix`\n\n### 优点：\n\n1. 每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据\n2. 从不同步效率最高\n\n### 缺点：\n\n1. 相对于数据文件，aof远大于rdb，修复的速度比rdb慢\n2. 默认是rdb，效率自然高于aof。\n\n**与rdb混合使用**\n\n## 主从复制\n\n将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。\n\n作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石\n\nreids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。\n\n默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。\n\n### 环境配置\n\n```shell\ninfo replication # 查看当前库的信息\n```\n\n一般情况下只用配置从机即可。\n\n```shell\nSLAVEOF ip:port # ip:port为主机\n```\n\n上面的是命令配置，只是暂时的。**实际生产应该修改配置文件**，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。\n\n#### 如果主机宕机了呢？\n\n默认情况下，主机挂了以后，用`info replication`查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。\n\n更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。\n\n- 全量复制 master将整个数据传送到slaver\n- 增量复制\n\n只要重新链接master，一次全量复制将被自动执行\n\n### 哨兵模式\n\nSentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。\n\n哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）\n\n#### 优点\n\n1. 集群\n2. 主从切换\n\n#### 缺点\n\n1. 不方便在线扩容，一旦到达上线。\n2. 配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。\n\n## redis异常处理\n\n### 缓存穿透（一直查询不到）\n\n```flow\nstart=>start: request\nend=>end: response\ncondition=>condition: redis缓存中是否存在\nop1=>operation: select in mysql\nstart->condition\ncondition(yes)->end\ncondition(no)->op1->end\n```\n\n如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。\n\n#### 布隆过滤器\n\n它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力\n\n#### 缓存空对象\n\n### 缓存击穿（量太大，缓存过期）\n\n活力集中在一个点（一个热评的点，如微博）。\n\n#### 加互斥锁\n\n#### 设置热点数据永不过期\n\n### 缓存雪崩\n\n在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。\n\n#### redis高可用\n\n#### 限流降级\n\n#### 数据预热\n\n正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。\n\n","slug":"redis","published":1,"updated":"2021-03-28T10:20:02.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9m002bts9qbz0cgr1z","content":"<p>常用redis，深入了解redis的性能和瓶颈。<a href=\"https://github.com/antirez/redis\">reference</a></p>\n<span id=\"more\"></span>\n\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>redis: <strong>内存</strong>中的数据结构存储系统，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>，nosql的一种。</p>\n<h2 id=\"nosql\"><a href=\"#nosql\" class=\"headerlink\" title=\"nosql\"></a>nosql</h2><p>关系型数据库不够用，出来了nosql。。。</p>\n<ol>\n<li>一开始单体应用，小用户量能承受。但是当体量变大时：<ul>\n<li>数据量大</li>\n<li>数据的索引大</li>\n<li>访问量大</li>\n</ul>\n</li>\n<li>读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层<strong>memcache</strong>缓存</li>\n<li>集群（水平拆分）：上面的读写分离copy多份。</li>\n</ol>\n<p>mysql早些年使用的是MyISAM引擎，特性是<strong>表锁</strong>（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了<strong>行锁</strong>。</p>\n<p>不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。</li>\n<li>大数据量也高性能（写8万次/秒，读11万次/秒）</li>\n<li>多样型，不需要事先设计数据库</li>\n<li>没有固定的查询语言；最终一致性</li>\n<li>键值对存储，列存储，文档存储，图形存储库（社交）</li>\n<li>高性能、高可用、高可扩</li>\n<li>CAP、BASE，异地多活</li>\n<li>多样、实时、并发（Volume, Variety, Veiocity）</li>\n</ol>\n<p>与关系型一起使用。</p>\n<p>商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）</p>\n<p>商品的基本信息（价格、商家、名称）：MySQL</p>\n<p>图片：FastDFS, GFS, HDFS, OSS…</p>\n<p>商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）</p>\n<p>==没有什么不是加以层解决不了的==： 统一服务层。</p>\n<h3 id=\"文档型数据库\"><a href=\"#文档型数据库\" class=\"headerlink\" title=\"文档型数据库\"></a>文档型数据库</h3><p>MongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。</p>\n<h3 id=\"KV键值对\"><a href=\"#KV键值对\" class=\"headerlink\" title=\"KV键值对\"></a>KV键值对</h3><p>Redis，Tair</p>\n<h3 id=\"列存储数据库\"><a href=\"#列存储数据库\" class=\"headerlink\" title=\"列存储数据库\"></a>列存储数据库</h3><p>HBase（大数据）</p>\n<p>分布式文件系统</p>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>类似知识图谱，不是存储图形。主要用于存储社交网络。</p>\n<p>Neo4j，InfoGrid。</p>\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><p>Remote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。</p>\n<ul>\n<li>内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）</li>\n<li>计时器、计数器（浏览量）</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>安装后自带的测试工具</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-benchmark -h localhost -p 6379 -100 -n 100000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>默认16个数据库且使用的是第0个。 </p>\n<h3 id=\"GEOSPATIAL\"><a href=\"#GEOSPATIAL\" class=\"headerlink\" title=\"GEOSPATIAL\"></a>GEOSPATIAL</h3><p>地理位置，不仅仅是GET、SET！根据经纬度获取距离。</p>\n<h2 id=\"springboot集成\"><a href=\"#springboot集成\" class=\"headerlink\" title=\"springboot集成\"></a>springboot集成</h2><p>版本&lt;2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。</p>\n<p>版本&gt;2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p>\n<h2 id=\"rdb\"><a href=\"#rdb\" class=\"headerlink\" title=\"rdb\"></a>rdb</h2><p>为什么会有这个rdb？</p>\n<p>redis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\">condition&#x3D;&gt;condition: 触发rdb</span><br><span class=\"line\">rdbfile&#x3D;&gt;inputoutput: dump.rdb</span><br><span class=\"line\">operation&#x3D;&gt;operation: go on dealing with</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;rdbfile-&gt;end</span><br><span class=\"line\">condition(no)-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"触发机制\"><a href=\"#触发机制\" class=\"headerlink\" title=\"触发机制\"></a>触发机制</h4><ol>\n<li>save的规则</li>\n<li>执行flushall</li>\n<li>退出redis</li>\n</ol>\n<p>产生备份，会自动生成一个dump.rdb</p>\n<h4 id=\"用rdb恢复\"><a href=\"#用rdb恢复\" class=\"headerlink\" title=\"用rdb恢复\"></a>用rdb恢复</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config get dir</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li>适合大数据</li>\n<li>对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li>需要一定的时间间隔进程操作</li>\n<li>fork进程的时候会占用一定的内容空间</li>\n</ol>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2><p>Append Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。</p>\n<ul>\n<li>大数据的情况下效率会比较低。</li>\n<li>默认是不开启的。</li>\n</ul>\n<p>开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。</p>\n<p>修复aof文件 <code>redis-check-aof --fix</code></p>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据</li>\n<li>从不同步效率最高</li>\n</ol>\n<h3 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>相对于数据文件，aof远大于rdb，修复的速度比rdb慢</li>\n<li>默认是rdb，效率自然高于aof。</li>\n</ol>\n<p><strong>与rdb混合使用</strong></p>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。</p>\n<p>作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石</p>\n<p>reids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。</p>\n<p>默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。</p>\n<h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info replication # 查看当前库的信息</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下只用配置从机即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SLAVEOF ip:port # ip:port为主机</span><br></pre></td></tr></table></figure>\n\n<p>上面的是命令配置，只是暂时的。<strong>实际生产应该修改配置文件</strong>，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。</p>\n<h4 id=\"如果主机宕机了呢？\"><a href=\"#如果主机宕机了呢？\" class=\"headerlink\" title=\"如果主机宕机了呢？\"></a>如果主机宕机了呢？</h4><p>默认情况下，主机挂了以后，用<code>info replication</code>查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。</p>\n<p>更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。</p>\n<ul>\n<li>全量复制 master将整个数据传送到slaver</li>\n<li>增量复制</li>\n</ul>\n<p>只要重新链接master，一次全量复制将被自动执行</p>\n<h3 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h3><p>Sentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p>\n<p>哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>集群</li>\n<li>主从切换</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>不方便在线扩容，一旦到达上线。</li>\n<li>配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。</li>\n</ol>\n<h2 id=\"redis异常处理\"><a href=\"#redis异常处理\" class=\"headerlink\" title=\"redis异常处理\"></a>redis异常处理</h2><h3 id=\"缓存穿透（一直查询不到）\"><a href=\"#缓存穿透（一直查询不到）\" class=\"headerlink\" title=\"缓存穿透（一直查询不到）\"></a>缓存穿透（一直查询不到）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: request</span><br><span class=\"line\">end&#x3D;&gt;end: response</span><br><span class=\"line\">condition&#x3D;&gt;condition: redis缓存中是否存在</span><br><span class=\"line\">op1&#x3D;&gt;operation: select in mysql</span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;end</span><br><span class=\"line\">condition(no)-&gt;op1-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。</p>\n<h4 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h4><p>它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力</p>\n<h4 id=\"缓存空对象\"><a href=\"#缓存空对象\" class=\"headerlink\" title=\"缓存空对象\"></a>缓存空对象</h4><h3 id=\"缓存击穿（量太大，缓存过期）\"><a href=\"#缓存击穿（量太大，缓存过期）\" class=\"headerlink\" title=\"缓存击穿（量太大，缓存过期）\"></a>缓存击穿（量太大，缓存过期）</h3><p>活力集中在一个点（一个热评的点，如微博）。</p>\n<h4 id=\"加互斥锁\"><a href=\"#加互斥锁\" class=\"headerlink\" title=\"加互斥锁\"></a>加互斥锁</h4><h4 id=\"设置热点数据永不过期\"><a href=\"#设置热点数据永不过期\" class=\"headerlink\" title=\"设置热点数据永不过期\"></a>设置热点数据永不过期</h4><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。</p>\n<h4 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h4><h4 id=\"限流降级\"><a href=\"#限流降级\" class=\"headerlink\" title=\"限流降级\"></a>限流降级</h4><h4 id=\"数据预热\"><a href=\"#数据预热\" class=\"headerlink\" title=\"数据预热\"></a>数据预热</h4><p>正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>常用redis，深入了解redis的性能和瓶颈。<a href=\"https://github.com/antirez/redis\">reference</a></p>","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>redis: <strong>内存</strong>中的数据结构存储系统，可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>，nosql的一种。</p>\n<h2 id=\"nosql\"><a href=\"#nosql\" class=\"headerlink\" title=\"nosql\"></a>nosql</h2><p>关系型数据库不够用，出来了nosql。。。</p>\n<ol>\n<li>一开始单体应用，小用户量能承受。但是当体量变大时：<ul>\n<li>数据量大</li>\n<li>数据的索引大</li>\n<li>访问量大</li>\n</ul>\n</li>\n<li>读写分离思想（垂直拆分），写一个库，其他库从这个库做同步，但是数据库大部分其实都是读，把刚查到的进行缓存，这样下一个要查且数据没变的话就用缓存中的数据。 添加一层<strong>memcache</strong>缓存</li>\n<li>集群（水平拆分）：上面的读写分离copy多份。</li>\n</ol>\n<p>mysql早些年使用的是MyISAM引擎，特性是<strong>表锁</strong>（查询某个数据会将整个表锁起来，高并发下性能下滑），现在使用的是Innodb，改为了<strong>行锁</strong>。</p>\n<p>不能用mysql做实时存储和访问、个人信息、地理位置（如微信热门10万+的文章记录等）。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>易于扩展，数据间没有关系（key value键值对），好比java面向接口，便于解偶。</li>\n<li>大数据量也高性能（写8万次/秒，读11万次/秒）</li>\n<li>多样型，不需要事先设计数据库</li>\n<li>没有固定的查询语言；最终一致性</li>\n<li>键值对存储，列存储，文档存储，图形存储库（社交）</li>\n<li>高性能、高可用、高可扩</li>\n<li>CAP、BASE，异地多活</li>\n<li>多样、实时、并发（Volume, Variety, Veiocity）</li>\n</ol>\n<p>与关系型一起使用。</p>\n<p>商品的描述、评论（文字比较多的）：文档型数据库（MongoDB）</p>\n<p>商品的基本信息（价格、商家、名称）：MySQL</p>\n<p>图片：FastDFS, GFS, HDFS, OSS…</p>\n<p>商品热门的波段信息：内存数据库（Redis，Tair，Memcache……）</p>\n<p>==没有什么不是加以层解决不了的==： 统一服务层。</p>\n<h3 id=\"文档型数据库\"><a href=\"#文档型数据库\" class=\"headerlink\" title=\"文档型数据库\"></a>文档型数据库</h3><p>MongoDB，介于关系型和非关系型数据库中的中间产品，非关系型数据库中功能最丰富的。</p>\n<h3 id=\"KV键值对\"><a href=\"#KV键值对\" class=\"headerlink\" title=\"KV键值对\"></a>KV键值对</h3><p>Redis，Tair</p>\n<h3 id=\"列存储数据库\"><a href=\"#列存储数据库\" class=\"headerlink\" title=\"列存储数据库\"></a>列存储数据库</h3><p>HBase（大数据）</p>\n<p>分布式文件系统</p>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>类似知识图谱，不是存储图形。主要用于存储社交网络。</p>\n<p>Neo4j，InfoGrid。</p>\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><p>Remote Dictionary Server. C语言编写的。免费，开源，提供多种语言的api。</p>\n<ul>\n<li>内存存储、持久化，但是内存是断电即失，所以持久化很重要（rdb、aof）</li>\n<li>计时器、计数器（浏览量）</li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>安装后自带的测试工具</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-benchmark -h localhost -p 6379 -100 -n 100000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>默认16个数据库且使用的是第0个。 </p>\n<h3 id=\"GEOSPATIAL\"><a href=\"#GEOSPATIAL\" class=\"headerlink\" title=\"GEOSPATIAL\"></a>GEOSPATIAL</h3><p>地理位置，不仅仅是GET、SET！根据经纬度获取距离。</p>\n<h2 id=\"springboot集成\"><a href=\"#springboot集成\" class=\"headerlink\" title=\"springboot集成\"></a>springboot集成</h2><p>版本&lt;2.0 底层使用的jedis，BIO，直连数据库，多线程下不安全，优化方式是jedis pool连接池。</p>\n<p>版本&gt;2.0 底层使用的lettuce，NIO，采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况。</p>\n<h2 id=\"rdb\"><a href=\"#rdb\" class=\"headerlink\" title=\"rdb\"></a>rdb</h2><p>为什么会有这个rdb？</p>\n<p>redis的高速查询来源于它的内存存储，由于内存断电即失，可以把rdb作为备份来弥补这个不足。所以rdb即redis databse。但是也不是每次操作都保存，否则性能急速降低，这也带来另一个问题，即最后一个/批操作不会被保存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: start</span><br><span class=\"line\">end&#x3D;&gt;end: end</span><br><span class=\"line\">condition&#x3D;&gt;condition: 触发rdb</span><br><span class=\"line\">rdbfile&#x3D;&gt;inputoutput: dump.rdb</span><br><span class=\"line\">operation&#x3D;&gt;operation: go on dealing with</span><br><span class=\"line\"></span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;rdbfile-&gt;end</span><br><span class=\"line\">condition(no)-&gt;operation-&gt;end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"触发机制\"><a href=\"#触发机制\" class=\"headerlink\" title=\"触发机制\"></a>触发机制</h4><ol>\n<li>save的规则</li>\n<li>执行flushall</li>\n<li>退出redis</li>\n</ol>\n<p>产生备份，会自动生成一个dump.rdb</p>\n<h4 id=\"用rdb恢复\"><a href=\"#用rdb恢复\" class=\"headerlink\" title=\"用rdb恢复\"></a>用rdb恢复</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config get dir</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li>适合大数据</li>\n<li>对数据完整性要求不高（比如90srdb一次，60s的时候宕机，就会造成数据丢失）</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li>需要一定的时间间隔进程操作</li>\n<li>fork进程的时候会占用一定的内容空间</li>\n</ol>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2><p>Append Only File， 将我们的所有命令都记录下来，相当于history，恢复的时候再追加。这是另一种恢复的方法。</p>\n<ul>\n<li>大数据的情况下效率会比较低。</li>\n<li>默认是不开启的。</li>\n</ul>\n<p>开启后会记录操作记录，关闭redis的时候会产生aof文件，如果恶意篡改，redis无法正常启动。</p>\n<p>修复aof文件 <code>redis-check-aof --fix</code></p>\n<h3 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>每次修改都同步，文件的完整性更好，默认每秒同步一次，可能会丢失一秒的数据</li>\n<li>从不同步效率最高</li>\n</ol>\n<h3 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>相对于数据文件，aof远大于rdb，修复的速度比rdb慢</li>\n<li>默认是rdb，效率自然高于aof。</li>\n</ol>\n<p><strong>与rdb混合使用</strong></p>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>将一台redis服务器的数据复制到其他的redis服务器，前者称为主节点，后者称为从结点。</p>\n<p>作用：数据冗余、故障恢复、负载均衡（读写分离）、高可用（集群）基石</p>\n<p>reids的容量有限，机器的内存不可能全部用来给redis做存储内存，最大不应该超过20G。</p>\n<p>默认情况下每台redis都是主节点；一个主节点可以有多个从结点，但是一个从结点只能有一个主节点。</p>\n<h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info replication # 查看当前库的信息</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下只用配置从机即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SLAVEOF ip:port # ip:port为主机</span><br></pre></td></tr></table></figure>\n\n<p>上面的是命令配置，只是暂时的。<strong>实际生产应该修改配置文件</strong>，在文件中写主机的地址和密码，主机负责写，从机负责读，主机的所有数据会自动被从机保存。</p>\n<h4 id=\"如果主机宕机了呢？\"><a href=\"#如果主机宕机了呢？\" class=\"headerlink\" title=\"如果主机宕机了呢？\"></a>如果主机宕机了呢？</h4><p>默认情况下，主机挂了以后，用<code>info replication</code>查看剩余机器，从机运行正常，但是没有写操作了。主机恢复后，仍旧正常主从复制。考虑到主机要人工手动恢复、排查故障，仍旧会影响业务。</p>\n<p>更好的情况是，默认从剩余的从机中选择一个作为主机，继续完成写操作。</p>\n<ul>\n<li>全量复制 master将整个数据传送到slaver</li>\n<li>增量复制</li>\n</ul>\n<p>只要重新链接master，一次全量复制将被自动执行</p>\n<h3 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h3><p>Sentinel（Redis2.8起）后台监控主机是否故障，如果故障了根据投票数自动将从库转为主库。</p>\n<p>哨兵是一个独立的进程。通过发送命令，等待Redis服务器响应，从而监控运行的多个redis实例。为了防止哨兵挂了，还要配置哨兵集群。（如果一主二从，正常应该启动六个进程，加上哨兵的话）</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>集群</li>\n<li>主从切换</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>不方便在线扩容，一旦到达上线。</li>\n<li>配置麻烦（配置文件的内容很多）。简单的话可以只启动一个哨兵监控主机，会自动检测到从机。</li>\n</ol>\n<h2 id=\"redis异常处理\"><a href=\"#redis异常处理\" class=\"headerlink\" title=\"redis异常处理\"></a>redis异常处理</h2><h3 id=\"缓存穿透（一直查询不到）\"><a href=\"#缓存穿透（一直查询不到）\" class=\"headerlink\" title=\"缓存穿透（一直查询不到）\"></a>缓存穿透（一直查询不到）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start&#x3D;&gt;start: request</span><br><span class=\"line\">end&#x3D;&gt;end: response</span><br><span class=\"line\">condition&#x3D;&gt;condition: redis缓存中是否存在</span><br><span class=\"line\">op1&#x3D;&gt;operation: select in mysql</span><br><span class=\"line\">start-&gt;condition</span><br><span class=\"line\">condition(yes)-&gt;end</span><br><span class=\"line\">condition(no)-&gt;op1-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>如果请求量非常大，redis相当于空白，都去请求到dao层，redis的作用就没了。</p>\n<h4 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h4><p>它是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，避免了对底层存储系统的查询压力</p>\n<h4 id=\"缓存空对象\"><a href=\"#缓存空对象\" class=\"headerlink\" title=\"缓存空对象\"></a>缓存空对象</h4><h3 id=\"缓存击穿（量太大，缓存过期）\"><a href=\"#缓存击穿（量太大，缓存过期）\" class=\"headerlink\" title=\"缓存击穿（量太大，缓存过期）\"></a>缓存击穿（量太大，缓存过期）</h3><p>活力集中在一个点（一个热评的点，如微博）。</p>\n<h4 id=\"加互斥锁\"><a href=\"#加互斥锁\" class=\"headerlink\" title=\"加互斥锁\"></a>加互斥锁</h4><h4 id=\"设置热点数据永不过期\"><a href=\"#设置热点数据永不过期\" class=\"headerlink\" title=\"设置热点数据永不过期\"></a>设置热点数据永不过期</h4><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>在某一个时间段，缓存集中过期失效，可能瞬间把数据库压跨。</p>\n<h4 id=\"redis高可用\"><a href=\"#redis高可用\" class=\"headerlink\" title=\"redis高可用\"></a>redis高可用</h4><h4 id=\"限流降级\"><a href=\"#限流降级\" class=\"headerlink\" title=\"限流降级\"></a>限流降级</h4><h4 id=\"数据预热\"><a href=\"#数据预热\" class=\"headerlink\" title=\"数据预热\"></a>数据预热</h4><p>正式部署前先把可能的数据访问一遍（加入缓存），设置不同的过期时间，让缓存失效的时间尽可能平均。</p>"},{"title":"search suggestions system","date":"2021-05-31T14:54:11.000Z","_content":"\n来源于5月”每日一题“板块中最后一天的一道题，乍一看应该是用`Trie`，但是实现起来有些复杂，没有其他更好的思路，然后评论区一看，又被Lee神的代码震撼到了。\n\n<!-- more -->\n\n# TreeMap\n\nQ: 根据输入的目标词，每输入一个字符，就从提供的词组中找出最符合规则的三个词（最多三个）。详情[戳这]([Explore - LeetCode](https://leetcode.com/explore/challenge/card/may-leetcoding-challenge-2021/602/week-5-may-29th-may-31st/3762/))。\n\nA: 最大的功臣就是treemap了。首先来了解一下他的常用的、易混淆的API，如`higherKey`与`ceilingKey`的区别，前者是寻找大于当前key的key，后者是寻找大于等于当前key的key。`lowerKey`和`floorKey`同理。\n\n```java\npublic List<List<String>> suggestedProducts(String[] products, String searchWord) {\n    List<List<String>> res = new ArrayList<>();\n    TreeMap<String, Integer> map = new TreeMap<>();\n    Arrays.sort(products);\n    List<String> productList = Arrays.asList(products);\n    for(int i= 0; i<products.length; i++){\n        map.put(products[i], i);\n    }\n    String key = \"\";\n    for(char c : searchWord.toCharArray()){\n        key += c;\n        String ceiling = map.ceilingKey(key);\n        // 只要大于'z'的任意字符都可以\n        String floor = map.floorKey(key + \"~\");\n        // 当前字符都匹配不到，后续更不可能了\n        if(ceiling == null || floor == null) break;\n        // Math防止越界，map.get(floor)+1就是囊括了最后一个元素的极限\n        res.add(productList.subList(map.get(ceiling), Math.min(map.get(ceiling) + 3, map.get(floor) + 1)));\n    }\n    while(res.size() < searchWord.length()) res.add(new ArrayList<>());\n\n    return res;\n}\n```\n\n","source":"_posts/search-suggestions-system.md","raw":"---\ntitle: search suggestions system\ndate: 2021-05-31 22:54:11\ncategories: LeetCode\ntags: treeMap trie\n---\n\n来源于5月”每日一题“板块中最后一天的一道题，乍一看应该是用`Trie`，但是实现起来有些复杂，没有其他更好的思路，然后评论区一看，又被Lee神的代码震撼到了。\n\n<!-- more -->\n\n# TreeMap\n\nQ: 根据输入的目标词，每输入一个字符，就从提供的词组中找出最符合规则的三个词（最多三个）。详情[戳这]([Explore - LeetCode](https://leetcode.com/explore/challenge/card/may-leetcoding-challenge-2021/602/week-5-may-29th-may-31st/3762/))。\n\nA: 最大的功臣就是treemap了。首先来了解一下他的常用的、易混淆的API，如`higherKey`与`ceilingKey`的区别，前者是寻找大于当前key的key，后者是寻找大于等于当前key的key。`lowerKey`和`floorKey`同理。\n\n```java\npublic List<List<String>> suggestedProducts(String[] products, String searchWord) {\n    List<List<String>> res = new ArrayList<>();\n    TreeMap<String, Integer> map = new TreeMap<>();\n    Arrays.sort(products);\n    List<String> productList = Arrays.asList(products);\n    for(int i= 0; i<products.length; i++){\n        map.put(products[i], i);\n    }\n    String key = \"\";\n    for(char c : searchWord.toCharArray()){\n        key += c;\n        String ceiling = map.ceilingKey(key);\n        // 只要大于'z'的任意字符都可以\n        String floor = map.floorKey(key + \"~\");\n        // 当前字符都匹配不到，后续更不可能了\n        if(ceiling == null || floor == null) break;\n        // Math防止越界，map.get(floor)+1就是囊括了最后一个元素的极限\n        res.add(productList.subList(map.get(ceiling), Math.min(map.get(ceiling) + 3, map.get(floor) + 1)));\n    }\n    while(res.size() < searchWord.length()) res.add(new ArrayList<>());\n\n    return res;\n}\n```\n\n","slug":"search-suggestions-system","published":1,"updated":"2021-06-01T01:32:49.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9p002fts9q7r2kfvec","content":"<p>来源于5月”每日一题“板块中最后一天的一道题，乍一看应该是用<code>Trie</code>，但是实现起来有些复杂，没有其他更好的思路，然后评论区一看，又被Lee神的代码震撼到了。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h1><p>Q: 根据输入的目标词，每输入一个字符，就从提供的词组中找出最符合规则的三个词（最多三个）。详情[戳这](<a href=\"https://leetcode.com/explore/challenge/card/may-leetcoding-challenge-2021/602/week-5-may-29th-may-31st/3762/\">Explore - LeetCode</a>)。</p>\n<p>A: 最大的功臣就是treemap了。首先来了解一下他的常用的、易混淆的API，如<code>higherKey</code>与<code>ceilingKey</code>的区别，前者是寻找大于当前key的key，后者是寻找大于等于当前key的key。<code>lowerKey</code>和<code>floorKey</code>同理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class=\"line\">    List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    TreeMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\">    Arrays.sort(products);</span><br><span class=\"line\">    List&lt;String&gt; productList = Arrays.asList(products);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i= <span class=\"number\">0</span>; i&lt;products.length; i++)&#123;</span><br><span class=\"line\">        map.put(products[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String key = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : searchWord.toCharArray())&#123;</span><br><span class=\"line\">        key += c;</span><br><span class=\"line\">        String ceiling = map.ceilingKey(key);</span><br><span class=\"line\">        <span class=\"comment\">// 只要大于&#x27;z&#x27;的任意字符都可以</span></span><br><span class=\"line\">        String floor = map.floorKey(key + <span class=\"string\">&quot;~&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当前字符都匹配不到，后续更不可能了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ceiling == <span class=\"keyword\">null</span> || floor == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Math防止越界，map.get(floor)+1就是囊括了最后一个元素的极限</span></span><br><span class=\"line\">        res.add(productList.subList(map.get(ceiling), Math.min(map.get(ceiling) + <span class=\"number\">3</span>, map.get(floor) + <span class=\"number\">1</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(res.size() &lt; searchWord.length()) res.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>来源于5月”每日一题“板块中最后一天的一道题，乍一看应该是用<code>Trie</code>，但是实现起来有些复杂，没有其他更好的思路，然后评论区一看，又被Lee神的代码震撼到了。</p>","more":"<h1 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h1><p>Q: 根据输入的目标词，每输入一个字符，就从提供的词组中找出最符合规则的三个词（最多三个）。详情[戳这](<a href=\"https://leetcode.com/explore/challenge/card/may-leetcoding-challenge-2021/602/week-5-may-29th-may-31st/3762/\">Explore - LeetCode</a>)。</p>\n<p>A: 最大的功臣就是treemap了。首先来了解一下他的常用的、易混淆的API，如<code>higherKey</code>与<code>ceilingKey</code>的区别，前者是寻找大于当前key的key，后者是寻找大于等于当前key的key。<code>lowerKey</code>和<code>floorKey</code>同理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class=\"line\">    List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    TreeMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\">    Arrays.sort(products);</span><br><span class=\"line\">    List&lt;String&gt; productList = Arrays.asList(products);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i= <span class=\"number\">0</span>; i&lt;products.length; i++)&#123;</span><br><span class=\"line\">        map.put(products[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String key = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : searchWord.toCharArray())&#123;</span><br><span class=\"line\">        key += c;</span><br><span class=\"line\">        String ceiling = map.ceilingKey(key);</span><br><span class=\"line\">        <span class=\"comment\">// 只要大于&#x27;z&#x27;的任意字符都可以</span></span><br><span class=\"line\">        String floor = map.floorKey(key + <span class=\"string\">&quot;~&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当前字符都匹配不到，后续更不可能了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ceiling == <span class=\"keyword\">null</span> || floor == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Math防止越界，map.get(floor)+1就是囊括了最后一个元素的极限</span></span><br><span class=\"line\">        res.add(productList.subList(map.get(ceiling), Math.min(map.get(ceiling) + <span class=\"number\">3</span>, map.get(floor) + <span class=\"number\">1</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(res.size() &lt; searchWord.length()) res.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Springboot-servlet","date":"2021-02-28T14:01:17.000Z","_content":"\n这篇探究SpringBoot的内置servlet容器。\n\n<!-- more -->\n\n<!-- toc -->\n\n自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。\n\n# 入口\n\n之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫`onRefresh()`的方法，用到了**模板方法**，让子类复写来完成特定工作的，之前也提到过，在类`SpringApplication`初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被`ServletWebServerApplicationContext`重写：\n\n```java\n@Override\nprotected void onRefresh() {\n    super.onRefresh();\n    try {\n        // 创建web服务器！\n        createWebServer();\n    }\n    catch (Throwable ex) {\n        throw new ApplicationContextException(\"Unable to start web server\", ex);\n    }\n}\n```\n\n\n\n# 创建服务\n\n入口找到后，接下来我们分析他是如何创建的：\n\n```java\nprivate void createWebServer() {\n    // volatile标志的引用\n    WebServer webServer = this.webServer;\n    // 从抽象类（父类）中获取servlet容器\n    ServletContext servletContext = getServletContext();\n    // 判断获取到的容器是否为null\n    if (webServer == null && servletContext == null) {\n        // 为null就从web服务器工厂建一个\n        ServletWebServerFactory factory = getWebServerFactory();\n        // 从这里获取到web服务器！入参还有初始化器！\n        this.webServer = factory.getWebServer(getSelfInitializer());\n        getBeanFactory().registerSingleton(\"webServerGracefulShutdown\",\n                                           new WebServerGracefulShutdownLifecycle(this.webServer));\n        getBeanFactory().registerSingleton(\"webServerStartStop\",\n                                           new WebServerStartStopLifecycle(this, this.webServer));\n    }\n    // 不为null就启动它\n    else if (servletContext != null) {\n        try {\n            getSelfInitializer().onStartup(servletContext);\n        }\n        catch (ServletException ex) {\n            throw new ApplicationContextException(\"Cannot initialize servlet context\", ex);\n        }\n    }\n    initPropertySources();\n}\n```\n\n## getWebServerFactory\n\n工厂哪里来？回顾之前的就可以猜到，SPI！\n\n```java\nprotected ServletWebServerFactory getWebServerFactory() {\n    // Use bean names so that we don't consider the hierarchy\n    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);\n    if (beanNames.length == 0) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to missing \"\n                                              + \"ServletWebServerFactory bean.\");\n    }\n    if (beanNames.length > 1) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to multiple \"\n                                              + \"ServletWebServerFactory beans : \" + StringUtils.arrayToCommaDelimitedString(beanNames));\n    }\n    return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);\n}\n```\n\n## getSelfInitializer\n\n看看如何获取到初始化器：\n\n```java\nprivate org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {\n    return this::selfInitialize;\n}\n```\n\n这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。\n\n# getWebServer\n\n```java\npublic WebServer getWebServer(ServletContextInitializer... initializers) {\n    if (this.disableMBeanRegistry) {\n        Registry.disableRegistry();\n    }\n    // 创建tomcat实例\n    Tomcat tomcat = new Tomcat();\n    File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");\n    // 设置属性\n    tomcat.setBaseDir(baseDir.getAbsolutePath());\n    Connector connector = new Connector(this.protocol);\n    connector.setThrowOnFailure(true);\n    tomcat.getService().addConnector(connector);\n    customizeConnector(connector);\n    tomcat.setConnector(connector);\n    tomcat.getHost().setAutoDeploy(false);\n    configureEngine(tomcat.getEngine());\n    for (Connector additionalConnector : this.additionalTomcatConnectors) {\n        tomcat.getService().addConnector(additionalConnector);\n    }\n    // 准备\n    prepareContext(tomcat.getHost(), initializers);\n    // 获取\n    return getTomcatWebServer(tomcat);\n}\n```\n\n我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:\n\n```java\nprotected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {\n    // 继续调用有有参方法\n    return new TomcatWebServer(tomcat, getPort() >= 0, getShutdown());\n}\n```\n\n```java\npublic TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) {\n    Assert.notNull(tomcat, \"Tomcat Server must not be null\");\n    this.tomcat = tomcat;\n    this.autoStart = autoStart;\n    this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(tomcat) : null;\n    // 初始化\n    initialize();\n}\n\nprivate void initialize() throws WebServerException {\n    logger.info(\"Tomcat initialized with port(s): \" + getPortsDescription(false));\n    synchronized (this.monitor) {\n        try {\n            addInstanceIdToEngineName();\n\n            Context context = findContext();\n            context.addLifecycleListener((event) -> {\n                if (context.equals(event.getSource()) && Lifecycle.START_EVENT.equals(event.getType())) {\n                    // Remove service connectors so that protocol binding doesn't\n                    // happen when the service is started.\n                    removeServiceConnectors();\n                }\n            });\n\n            // Start the server to trigger initialization listeners\n            this.tomcat.start();\n\n            // We can re-throw failure exception directly in the main thread\n            rethrowDeferredStartupExceptions();\n\n            try {\n                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());\n            }\n            catch (NamingException ex) {\n                // Naming is not enabled. Continue\n            }\n\n            // Unlike Jetty, all Tomcat threads are daemon threads. We create a\n            // blocking non-daemon to stop immediate shutdown\n            startDaemonAwaitThread();\n        }\n        catch (Exception ex) {\n            stopSilently();\n            destroySilently();\n            throw new WebServerException(\"Unable to start embedded Tomcat\", ex);\n        }\n    }\n}\n```\n\n在上面的初始化的方法中，我们找到了启动的地方。","source":"_posts/springboot-servlet.md","raw":"---\ntitle: Springboot-servlet\ndate: 2021-02-28 22:01:17\ncategories: springboot\ntags: source\n---\n\n这篇探究SpringBoot的内置servlet容器。\n\n<!-- more -->\n\n<!-- toc -->\n\n自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。\n\n# 入口\n\n之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫`onRefresh()`的方法，用到了**模板方法**，让子类复写来完成特定工作的，之前也提到过，在类`SpringApplication`初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被`ServletWebServerApplicationContext`重写：\n\n```java\n@Override\nprotected void onRefresh() {\n    super.onRefresh();\n    try {\n        // 创建web服务器！\n        createWebServer();\n    }\n    catch (Throwable ex) {\n        throw new ApplicationContextException(\"Unable to start web server\", ex);\n    }\n}\n```\n\n\n\n# 创建服务\n\n入口找到后，接下来我们分析他是如何创建的：\n\n```java\nprivate void createWebServer() {\n    // volatile标志的引用\n    WebServer webServer = this.webServer;\n    // 从抽象类（父类）中获取servlet容器\n    ServletContext servletContext = getServletContext();\n    // 判断获取到的容器是否为null\n    if (webServer == null && servletContext == null) {\n        // 为null就从web服务器工厂建一个\n        ServletWebServerFactory factory = getWebServerFactory();\n        // 从这里获取到web服务器！入参还有初始化器！\n        this.webServer = factory.getWebServer(getSelfInitializer());\n        getBeanFactory().registerSingleton(\"webServerGracefulShutdown\",\n                                           new WebServerGracefulShutdownLifecycle(this.webServer));\n        getBeanFactory().registerSingleton(\"webServerStartStop\",\n                                           new WebServerStartStopLifecycle(this, this.webServer));\n    }\n    // 不为null就启动它\n    else if (servletContext != null) {\n        try {\n            getSelfInitializer().onStartup(servletContext);\n        }\n        catch (ServletException ex) {\n            throw new ApplicationContextException(\"Cannot initialize servlet context\", ex);\n        }\n    }\n    initPropertySources();\n}\n```\n\n## getWebServerFactory\n\n工厂哪里来？回顾之前的就可以猜到，SPI！\n\n```java\nprotected ServletWebServerFactory getWebServerFactory() {\n    // Use bean names so that we don't consider the hierarchy\n    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);\n    if (beanNames.length == 0) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to missing \"\n                                              + \"ServletWebServerFactory bean.\");\n    }\n    if (beanNames.length > 1) {\n        throw new ApplicationContextException(\"Unable to start ServletWebServerApplicationContext due to multiple \"\n                                              + \"ServletWebServerFactory beans : \" + StringUtils.arrayToCommaDelimitedString(beanNames));\n    }\n    return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);\n}\n```\n\n## getSelfInitializer\n\n看看如何获取到初始化器：\n\n```java\nprivate org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {\n    return this::selfInitialize;\n}\n```\n\n这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。\n\n# getWebServer\n\n```java\npublic WebServer getWebServer(ServletContextInitializer... initializers) {\n    if (this.disableMBeanRegistry) {\n        Registry.disableRegistry();\n    }\n    // 创建tomcat实例\n    Tomcat tomcat = new Tomcat();\n    File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");\n    // 设置属性\n    tomcat.setBaseDir(baseDir.getAbsolutePath());\n    Connector connector = new Connector(this.protocol);\n    connector.setThrowOnFailure(true);\n    tomcat.getService().addConnector(connector);\n    customizeConnector(connector);\n    tomcat.setConnector(connector);\n    tomcat.getHost().setAutoDeploy(false);\n    configureEngine(tomcat.getEngine());\n    for (Connector additionalConnector : this.additionalTomcatConnectors) {\n        tomcat.getService().addConnector(additionalConnector);\n    }\n    // 准备\n    prepareContext(tomcat.getHost(), initializers);\n    // 获取\n    return getTomcatWebServer(tomcat);\n}\n```\n\n我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:\n\n```java\nprotected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {\n    // 继续调用有有参方法\n    return new TomcatWebServer(tomcat, getPort() >= 0, getShutdown());\n}\n```\n\n```java\npublic TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) {\n    Assert.notNull(tomcat, \"Tomcat Server must not be null\");\n    this.tomcat = tomcat;\n    this.autoStart = autoStart;\n    this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(tomcat) : null;\n    // 初始化\n    initialize();\n}\n\nprivate void initialize() throws WebServerException {\n    logger.info(\"Tomcat initialized with port(s): \" + getPortsDescription(false));\n    synchronized (this.monitor) {\n        try {\n            addInstanceIdToEngineName();\n\n            Context context = findContext();\n            context.addLifecycleListener((event) -> {\n                if (context.equals(event.getSource()) && Lifecycle.START_EVENT.equals(event.getType())) {\n                    // Remove service connectors so that protocol binding doesn't\n                    // happen when the service is started.\n                    removeServiceConnectors();\n                }\n            });\n\n            // Start the server to trigger initialization listeners\n            this.tomcat.start();\n\n            // We can re-throw failure exception directly in the main thread\n            rethrowDeferredStartupExceptions();\n\n            try {\n                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());\n            }\n            catch (NamingException ex) {\n                // Naming is not enabled. Continue\n            }\n\n            // Unlike Jetty, all Tomcat threads are daemon threads. We create a\n            // blocking non-daemon to stop immediate shutdown\n            startDaemonAwaitThread();\n        }\n        catch (Exception ex) {\n            stopSilently();\n            destroySilently();\n            throw new WebServerException(\"Unable to start embedded Tomcat\", ex);\n        }\n    }\n}\n```\n\n在上面的初始化的方法中，我们找到了启动的地方。","slug":"springboot-servlet","published":1,"updated":"2021-03-28T10:20:02.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9s002its9q04kw2hw0","content":"<p>这篇探究SpringBoot的内置servlet容器。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<p>自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。</p>\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫<code>onRefresh()</code>的方法，用到了<strong>模板方法</strong>，让子类复写来完成特定工作的，之前也提到过，在类<code>SpringApplication</code>初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被<code>ServletWebServerApplicationContext</code>重写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRefresh();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建web服务器！</span></span><br><span class=\"line\">        createWebServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"创建服务\"><a href=\"#创建服务\" class=\"headerlink\" title=\"创建服务\"></a>创建服务</h1><p>入口找到后，接下来我们分析他是如何创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createWebServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// volatile标志的引用</span></span><br><span class=\"line\">    WebServer webServer = <span class=\"keyword\">this</span>.webServer;</span><br><span class=\"line\">    <span class=\"comment\">// 从抽象类（父类）中获取servlet容器</span></span><br><span class=\"line\">    ServletContext servletContext = getServletContext();</span><br><span class=\"line\">    <span class=\"comment\">// 判断获取到的容器是否为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (webServer == <span class=\"keyword\">null</span> &amp;&amp; servletContext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为null就从web服务器工厂建一个</span></span><br><span class=\"line\">        ServletWebServerFactory factory = getWebServerFactory();</span><br><span class=\"line\">        <span class=\"comment\">// 从这里获取到web服务器！入参还有初始化器！</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerGracefulShutdownLifecycle(<span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerStartStop&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerStartStopLifecycle(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为null就启动它</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (servletContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            getSelfInitializer().onStartup(servletContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initPropertySources();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getWebServerFactory\"><a href=\"#getWebServerFactory\" class=\"headerlink\" title=\"getWebServerFactory\"></a>getWebServerFactory</h2><p>工厂哪里来？回顾之前的就可以猜到，SPI！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ServletWebServerFactory <span class=\"title\">getWebServerFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use bean names so that we don&#x27;t consider the hierarchy</span></span><br><span class=\"line\">    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory bean.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory beans : &quot;</span> + StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getBeanFactory().getBean(beanNames[<span class=\"number\">0</span>], ServletWebServerFactory.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getSelfInitializer\"><a href=\"#getSelfInitializer\" class=\"headerlink\" title=\"getSelfInitializer\"></a>getSelfInitializer</h2><p>看看如何获取到初始化器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> org.springframework.boot.web.servlet.<span class=\"function\">ServletContextInitializer <span class=\"title\">getSelfInitializer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>::selfInitialize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。</p>\n<h1 id=\"getWebServer\"><a href=\"#getWebServer\" class=\"headerlink\" title=\"getWebServer\"></a>getWebServer</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebServer <span class=\"title\">getWebServer</span><span class=\"params\">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.disableMBeanRegistry) &#123;</span><br><span class=\"line\">        Registry.disableRegistry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建tomcat实例</span></span><br><span class=\"line\">    Tomcat tomcat = <span class=\"keyword\">new</span> Tomcat();</span><br><span class=\"line\">    File baseDir = (<span class=\"keyword\">this</span>.baseDirectory != <span class=\"keyword\">null</span>) ? <span class=\"keyword\">this</span>.baseDirectory : createTempDir(<span class=\"string\">&quot;tomcat&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class=\"line\">    Connector connector = <span class=\"keyword\">new</span> Connector(<span class=\"keyword\">this</span>.protocol);</span><br><span class=\"line\">    connector.setThrowOnFailure(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    tomcat.getService().addConnector(connector);</span><br><span class=\"line\">    customizeConnector(connector);</span><br><span class=\"line\">    tomcat.setConnector(connector);</span><br><span class=\"line\">    tomcat.getHost().setAutoDeploy(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    configureEngine(tomcat.getEngine());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Connector additionalConnector : <span class=\"keyword\">this</span>.additionalTomcatConnectors) &#123;</span><br><span class=\"line\">        tomcat.getService().addConnector(additionalConnector);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 准备</span></span><br><span class=\"line\">    prepareContext(tomcat.getHost(), initializers);</span><br><span class=\"line\">    <span class=\"comment\">// 获取</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTomcatWebServer(tomcat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> TomcatWebServer <span class=\"title\">getTomcatWebServer</span><span class=\"params\">(Tomcat tomcat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 继续调用有有参方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class=\"number\">0</span>, getShutdown());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TomcatWebServer</span><span class=\"params\">(Tomcat tomcat, <span class=\"keyword\">boolean</span> autoStart, Shutdown shutdown)</span> </span>&#123;</span><br><span class=\"line\">    Assert.notNull(tomcat, <span class=\"string\">&quot;Tomcat Server must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tomcat = tomcat;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.autoStart = autoStart;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? <span class=\"keyword\">new</span> GracefulShutdown(tomcat) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> WebServerException </span>&#123;</span><br><span class=\"line\">    logger.info(<span class=\"string\">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class=\"keyword\">false</span>));</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.monitor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            addInstanceIdToEngineName();</span><br><span class=\"line\"></span><br><span class=\"line\">            Context context = findContext();</span><br><span class=\"line\">            context.addLifecycleListener((event) -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class=\"line\">                    <span class=\"comment\">// happen when the service is started.</span></span><br><span class=\"line\">                    removeServiceConnectors();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start the server to trigger initialization listeners</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tomcat.start();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// We can re-throw failure exception directly in the main thread</span></span><br><span class=\"line\">            rethrowDeferredStartupExceptions();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (NamingException ex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Naming is not enabled. Continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class=\"line\">            <span class=\"comment\">// blocking non-daemon to stop immediate shutdown</span></span><br><span class=\"line\">            startDaemonAwaitThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            stopSilently();</span><br><span class=\"line\">            destroySilently();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> WebServerException(<span class=\"string\">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的初始化的方法中，我们找到了启动的地方。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇探究SpringBoot的内置servlet容器。</p>","more":"<!-- toc -->\n\n<p>自打接触java web项目以来，使用的绝大多数情况都是内置的tomcat，还没好好整tomcat，他就被内置了。这篇看看他是如何被放入springboot并启动的。</p>\n<h1 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h1><p>之前有分析过springBoot的refresh方法，里面又有十几个方法，其中有一个名叫<code>onRefresh()</code>的方法，用到了<strong>模板方法</strong>，让子类复写来完成特定工作的，之前也提到过，在类<code>SpringApplication</code>初始化时就会根据class文件判断程序的类型，现在我们假设引入了web环境，那么这个方法就会被<code>ServletWebServerApplicationContext</code>重写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRefresh();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建web服务器！</span></span><br><span class=\"line\">        createWebServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"创建服务\"><a href=\"#创建服务\" class=\"headerlink\" title=\"创建服务\"></a>创建服务</h1><p>入口找到后，接下来我们分析他是如何创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createWebServer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// volatile标志的引用</span></span><br><span class=\"line\">    WebServer webServer = <span class=\"keyword\">this</span>.webServer;</span><br><span class=\"line\">    <span class=\"comment\">// 从抽象类（父类）中获取servlet容器</span></span><br><span class=\"line\">    ServletContext servletContext = getServletContext();</span><br><span class=\"line\">    <span class=\"comment\">// 判断获取到的容器是否为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (webServer == <span class=\"keyword\">null</span> &amp;&amp; servletContext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为null就从web服务器工厂建一个</span></span><br><span class=\"line\">        ServletWebServerFactory factory = getWebServerFactory();</span><br><span class=\"line\">        <span class=\"comment\">// 从这里获取到web服务器！入参还有初始化器！</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerGracefulShutdownLifecycle(<span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">        getBeanFactory().registerSingleton(<span class=\"string\">&quot;webServerStartStop&quot;</span>,</span><br><span class=\"line\">                                           <span class=\"keyword\">new</span> WebServerStartStopLifecycle(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>.webServer));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不为null就启动它</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (servletContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            getSelfInitializer().onStartup(servletContext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    initPropertySources();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getWebServerFactory\"><a href=\"#getWebServerFactory\" class=\"headerlink\" title=\"getWebServerFactory\"></a>getWebServerFactory</h2><p>工厂哪里来？回顾之前的就可以猜到，SPI！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ServletWebServerFactory <span class=\"title\">getWebServerFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use bean names so that we don&#x27;t consider the hierarchy</span></span><br><span class=\"line\">    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory bean.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanNames.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;</span></span><br><span class=\"line\">                                              + <span class=\"string\">&quot;ServletWebServerFactory beans : &quot;</span> + StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getBeanFactory().getBean(beanNames[<span class=\"number\">0</span>], ServletWebServerFactory.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"getSelfInitializer\"><a href=\"#getSelfInitializer\" class=\"headerlink\" title=\"getSelfInitializer\"></a>getSelfInitializer</h2><p>看看如何获取到初始化器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> org.springframework.boot.web.servlet.<span class=\"function\">ServletContextInitializer <span class=\"title\">getSelfInitializer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>::selfInitialize;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里会获取到初始化器，这些初始化器就相当与一个个的配置，只是目前没有去配置那个容器对象，在等一个触发的时机。</p>\n<h1 id=\"getWebServer\"><a href=\"#getWebServer\" class=\"headerlink\" title=\"getWebServer\"></a>getWebServer</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebServer <span class=\"title\">getWebServer</span><span class=\"params\">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.disableMBeanRegistry) &#123;</span><br><span class=\"line\">        Registry.disableRegistry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建tomcat实例</span></span><br><span class=\"line\">    Tomcat tomcat = <span class=\"keyword\">new</span> Tomcat();</span><br><span class=\"line\">    File baseDir = (<span class=\"keyword\">this</span>.baseDirectory != <span class=\"keyword\">null</span>) ? <span class=\"keyword\">this</span>.baseDirectory : createTempDir(<span class=\"string\">&quot;tomcat&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class=\"line\">    Connector connector = <span class=\"keyword\">new</span> Connector(<span class=\"keyword\">this</span>.protocol);</span><br><span class=\"line\">    connector.setThrowOnFailure(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    tomcat.getService().addConnector(connector);</span><br><span class=\"line\">    customizeConnector(connector);</span><br><span class=\"line\">    tomcat.setConnector(connector);</span><br><span class=\"line\">    tomcat.getHost().setAutoDeploy(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    configureEngine(tomcat.getEngine());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Connector additionalConnector : <span class=\"keyword\">this</span>.additionalTomcatConnectors) &#123;</span><br><span class=\"line\">        tomcat.getService().addConnector(additionalConnector);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 准备</span></span><br><span class=\"line\">    prepareContext(tomcat.getHost(), initializers);</span><br><span class=\"line\">    <span class=\"comment\">// 获取</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTomcatWebServer(tomcat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们主要来看如何获取tomcat的，这里入参传入了tomcat的一个引用:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> TomcatWebServer <span class=\"title\">getTomcatWebServer</span><span class=\"params\">(Tomcat tomcat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 继续调用有有参方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class=\"number\">0</span>, getShutdown());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TomcatWebServer</span><span class=\"params\">(Tomcat tomcat, <span class=\"keyword\">boolean</span> autoStart, Shutdown shutdown)</span> </span>&#123;</span><br><span class=\"line\">    Assert.notNull(tomcat, <span class=\"string\">&quot;Tomcat Server must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tomcat = tomcat;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.autoStart = autoStart;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? <span class=\"keyword\">new</span> GracefulShutdown(tomcat) : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> WebServerException </span>&#123;</span><br><span class=\"line\">    logger.info(<span class=\"string\">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class=\"keyword\">false</span>));</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.monitor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            addInstanceIdToEngineName();</span><br><span class=\"line\"></span><br><span class=\"line\">            Context context = findContext();</span><br><span class=\"line\">            context.addLifecycleListener((event) -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Remove service connectors so that protocol binding doesn&#x27;t</span></span><br><span class=\"line\">                    <span class=\"comment\">// happen when the service is started.</span></span><br><span class=\"line\">                    removeServiceConnectors();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start the server to trigger initialization listeners</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.tomcat.start();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// We can re-throw failure exception directly in the main thread</span></span><br><span class=\"line\">            rethrowDeferredStartupExceptions();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (NamingException ex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Naming is not enabled. Continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class=\"line\">            <span class=\"comment\">// blocking non-daemon to stop immediate shutdown</span></span><br><span class=\"line\">            startDaemonAwaitThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            stopSilently();</span><br><span class=\"line\">            destroySilently();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> WebServerException(<span class=\"string\">&quot;Unable to start embedded Tomcat&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的初始化的方法中，我们找到了启动的地方。</p>"},{"title":"springmvc-argument","date":"2021-04-07T04:20:01.000Z","_content":"\n这一篇承接上面的handlerMapping，在通过request获取到handlerExecutionChain和handler之后的处理操作，实际上不同的handlerMapping映射出来的东西是不一样的，adapter在这里的作用是用handler得到对应的视图方法。\n\n<!-- more -->\n\n<!-- toc -->\n\n# HandlerAdapter\n\n```java\npublic interface HandlerAdapter {\n\n    // 判断是否支持该handler\n    boolean supports(Object handler);\n\n    // 通过handler返回modelAndView\n    @Nullable\n    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;\n\n    long getLastModified(HttpServletRequest request, Object handler);\n\n}\n```\n\n我们可以看到该接口的一个方法*handle*就是通过handler返回对应的modelAndView。那么这个接口及实现类是何时加载的呢？记得在第一篇有分析过实例化时的准备工作吗，那里有一些模板方法，其中就有关于初始化这个handlerAdapter的：\n\n```java\nprotected void initStrategies(ApplicationContext context) {\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n    initHandlerMappings(context);\n    // 初始化handlerAdapter\n    initHandlerAdapters(context);\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n}\n```\n\n```java\nprivate void initHandlerAdapters(ApplicationContext context) {\n    this.handlerAdapters = null;\n\n    if (this.detectAllHandlerAdapters) {\n        // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.\n        Map<String, HandlerAdapter> matchingBeans =\n            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n        if (!matchingBeans.isEmpty()) {\n            this.handlerAdapters = new ArrayList<>(matchingBeans.values());\n            // We keep HandlerAdapters in sorted order.\n            AnnotationAwareOrderComparator.sort(this.handlerAdapters);\n        }\n    }\n    else {\n        try {\n            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);\n            this.handlerAdapters = Collections.singletonList(ha);\n        }\n        catch (NoSuchBeanDefinitionException ex) {\n            // Ignore, we'll add a default HandlerAdapter later.\n        }\n    }\n\n    // Ensure we have at least some HandlerAdapters, by registering\n    // default HandlerAdapters if no other adapters are found.\n    if (this.handlerAdapters == null) {\n        this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"No HandlerAdapters declared for servlet '\" + getServletName() +\n                         \"': using default strategies from DispatcherServlet.properties\");\n        }\n    }\n}\n```\n\n## 实现类\n\nhandlerAdapter有几个简单的实现类可以看下：\n\n```java\n// 这是默认的实现方式\npublic class SimpleControllerHandlerAdapter implements HandlerAdapter {\n\n    @Override\n    public boolean supports(Object handler) {\n        return (handler instanceof Controller);\n    }\n\n    @Override\n    @Nullable\n    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n        // 会调用controller的handlerRequest\n        return ((Controller) handler).handleRequest(request, response);\n    }\n}\n```\n\n```java\npublic class SimpleServletHandlerAdapter implements HandlerAdapter {\n\n    @Override\n    public boolean supports(Object handler) {\n        return (handler instanceof Servlet);\n    }\n\n    @Override\n    @Nullable\n    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n        ((Servlet) handler).service(request, response);\n        return null;\n    }\n}\n```\n\n他的实现类大都像上面的一样支持某种类型的handler，但我们最常用的是`RequestMappingHandlerAdapter`，他是专门用来处理标记了*@RequestMapping*注解的HandlerMethod。\n\n# 参数处理\n\n之前有提到dispatcherServlet中，通过*doDispatch*来处理请求，里面通过reqeust获取到对应的adapter并且调用adapter里面的方法来处理：\n\n```java\n// Determine handler adapter for the current request.\nHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n// Actually invoke the handler.\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n*handle*方法是接口HandlerAdapter的抽象实现类中的**final**方法:\n\n```java\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n    throws Exception {\n    // 交由子类实现，也就是RequestMappingHandlerAdapter\n    return handleInternal(request, response, (HandlerMethod) handler);\n}\n```\n\n最终处理的是invokeHandlerMethod，在这里会为equest创建一个`ServletInvocableHandlerMethod`，也就是说，对于向后端请求服务的request，实际处理的是用`ServletInvocableHandlerMethod`将request包裹之后的，在配置过一些属性后会将它作为入参，继续执行*invokeAndHandle*方法。\n\n## invokeAndHandle\n\n```java\n// 处理请求与返回\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n                            Object... providedArgs) throws Exception {\n\n    // 请求\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n    setResponseStatus(webRequest);\n\n    if (returnValue == null) {\n        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n            disableContentCachingIfNecessary(webRequest);\n            mavContainer.setRequestHandled(true);\n            return;\n        }\n    }\n    else if (StringUtils.hasText(getResponseStatusReason())) {\n        mavContainer.setRequestHandled(true);\n        return;\n    }\n\n    mavContainer.setRequestHandled(false);\n    Assert.state(this.returnValueHandlers != null, \"No return value handlers\");\n    try {\n        // 返回\n        this.returnValueHandlers.handleReturnValue(\n            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n    }\n    catch (Exception ex) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(formatErrorForReturnValue(returnValue), ex);\n        }\n        throw ex;\n    }\n}\n```\n\n# 小结\n\n简而言之，请求（handlerMethod）由特定的adapter处理，比如*RequestMappingHandlerAdapter*，他会继续被封装成*ServletInvocableHandlerMethod*。","source":"_posts/springmvc-argument.md","raw":"---\ntitle: springmvc-argument\ndate: 2021-04-07 12:20:01\ncategories: springmvc\ntags: source\n---\n\n这一篇承接上面的handlerMapping，在通过request获取到handlerExecutionChain和handler之后的处理操作，实际上不同的handlerMapping映射出来的东西是不一样的，adapter在这里的作用是用handler得到对应的视图方法。\n\n<!-- more -->\n\n<!-- toc -->\n\n# HandlerAdapter\n\n```java\npublic interface HandlerAdapter {\n\n    // 判断是否支持该handler\n    boolean supports(Object handler);\n\n    // 通过handler返回modelAndView\n    @Nullable\n    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;\n\n    long getLastModified(HttpServletRequest request, Object handler);\n\n}\n```\n\n我们可以看到该接口的一个方法*handle*就是通过handler返回对应的modelAndView。那么这个接口及实现类是何时加载的呢？记得在第一篇有分析过实例化时的准备工作吗，那里有一些模板方法，其中就有关于初始化这个handlerAdapter的：\n\n```java\nprotected void initStrategies(ApplicationContext context) {\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n    initHandlerMappings(context);\n    // 初始化handlerAdapter\n    initHandlerAdapters(context);\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n}\n```\n\n```java\nprivate void initHandlerAdapters(ApplicationContext context) {\n    this.handlerAdapters = null;\n\n    if (this.detectAllHandlerAdapters) {\n        // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.\n        Map<String, HandlerAdapter> matchingBeans =\n            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n        if (!matchingBeans.isEmpty()) {\n            this.handlerAdapters = new ArrayList<>(matchingBeans.values());\n            // We keep HandlerAdapters in sorted order.\n            AnnotationAwareOrderComparator.sort(this.handlerAdapters);\n        }\n    }\n    else {\n        try {\n            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);\n            this.handlerAdapters = Collections.singletonList(ha);\n        }\n        catch (NoSuchBeanDefinitionException ex) {\n            // Ignore, we'll add a default HandlerAdapter later.\n        }\n    }\n\n    // Ensure we have at least some HandlerAdapters, by registering\n    // default HandlerAdapters if no other adapters are found.\n    if (this.handlerAdapters == null) {\n        this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"No HandlerAdapters declared for servlet '\" + getServletName() +\n                         \"': using default strategies from DispatcherServlet.properties\");\n        }\n    }\n}\n```\n\n## 实现类\n\nhandlerAdapter有几个简单的实现类可以看下：\n\n```java\n// 这是默认的实现方式\npublic class SimpleControllerHandlerAdapter implements HandlerAdapter {\n\n    @Override\n    public boolean supports(Object handler) {\n        return (handler instanceof Controller);\n    }\n\n    @Override\n    @Nullable\n    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n        // 会调用controller的handlerRequest\n        return ((Controller) handler).handleRequest(request, response);\n    }\n}\n```\n\n```java\npublic class SimpleServletHandlerAdapter implements HandlerAdapter {\n\n    @Override\n    public boolean supports(Object handler) {\n        return (handler instanceof Servlet);\n    }\n\n    @Override\n    @Nullable\n    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n        ((Servlet) handler).service(request, response);\n        return null;\n    }\n}\n```\n\n他的实现类大都像上面的一样支持某种类型的handler，但我们最常用的是`RequestMappingHandlerAdapter`，他是专门用来处理标记了*@RequestMapping*注解的HandlerMethod。\n\n# 参数处理\n\n之前有提到dispatcherServlet中，通过*doDispatch*来处理请求，里面通过reqeust获取到对应的adapter并且调用adapter里面的方法来处理：\n\n```java\n// Determine handler adapter for the current request.\nHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n// Actually invoke the handler.\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n*handle*方法是接口HandlerAdapter的抽象实现类中的**final**方法:\n\n```java\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n    throws Exception {\n    // 交由子类实现，也就是RequestMappingHandlerAdapter\n    return handleInternal(request, response, (HandlerMethod) handler);\n}\n```\n\n最终处理的是invokeHandlerMethod，在这里会为equest创建一个`ServletInvocableHandlerMethod`，也就是说，对于向后端请求服务的request，实际处理的是用`ServletInvocableHandlerMethod`将request包裹之后的，在配置过一些属性后会将它作为入参，继续执行*invokeAndHandle*方法。\n\n## invokeAndHandle\n\n```java\n// 处理请求与返回\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n                            Object... providedArgs) throws Exception {\n\n    // 请求\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n    setResponseStatus(webRequest);\n\n    if (returnValue == null) {\n        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n            disableContentCachingIfNecessary(webRequest);\n            mavContainer.setRequestHandled(true);\n            return;\n        }\n    }\n    else if (StringUtils.hasText(getResponseStatusReason())) {\n        mavContainer.setRequestHandled(true);\n        return;\n    }\n\n    mavContainer.setRequestHandled(false);\n    Assert.state(this.returnValueHandlers != null, \"No return value handlers\");\n    try {\n        // 返回\n        this.returnValueHandlers.handleReturnValue(\n            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n    }\n    catch (Exception ex) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(formatErrorForReturnValue(returnValue), ex);\n        }\n        throw ex;\n    }\n}\n```\n\n# 小结\n\n简而言之，请求（handlerMethod）由特定的adapter处理，比如*RequestMappingHandlerAdapter*，他会继续被封装成*ServletInvocableHandlerMethod*。","slug":"springmvc-argument","published":1,"updated":"2021-04-25T14:17:51.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9v002lts9qfwpdcq4f","content":"<p>这一篇承接上面的handlerMapping，在通过request获取到handlerExecutionChain和handler之后的处理操作，实际上不同的handlerMapping映射出来的东西是不一样的，adapter在这里的作用是用handler得到对应的视图方法。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"HandlerAdapter\"><a href=\"#HandlerAdapter\" class=\"headerlink\" title=\"HandlerAdapter\"></a>HandlerAdapter</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断是否支持该handler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Object handler)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过handler返回modelAndView</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getLastModified</span><span class=\"params\">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到该接口的一个方法<em>handle</em>就是通过handler返回对应的modelAndView。那么这个接口及实现类是何时加载的呢？记得在第一篇有分析过实例化时的准备工作吗，那里有一些模板方法，其中就有关于初始化这个handlerAdapter的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initStrategies</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    initMultipartResolver(context);</span><br><span class=\"line\">    initLocaleResolver(context);</span><br><span class=\"line\">    initThemeResolver(context);</span><br><span class=\"line\">    initHandlerMappings(context);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化handlerAdapter</span></span><br><span class=\"line\">    initHandlerAdapters(context);</span><br><span class=\"line\">    initHandlerExceptionResolvers(context);</span><br><span class=\"line\">    initRequestToViewNameTranslator(context);</span><br><span class=\"line\">    initViewResolvers(context);</span><br><span class=\"line\">    initFlashMapManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initHandlerAdapters</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handlerAdapters = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.detectAllHandlerAdapters) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.</span></span><br><span class=\"line\">        Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class=\"line\">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.handlerAdapters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class=\"line\">            <span class=\"comment\">// We keep HandlerAdapters in sorted order.</span></span><br><span class=\"line\">            AnnotationAwareOrderComparator.sort(<span class=\"keyword\">this</span>.handlerAdapters);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Ignore, we&#x27;ll add a default HandlerAdapter later.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Ensure we have at least some HandlerAdapters, by registering</span></span><br><span class=\"line\">    <span class=\"comment\">// default HandlerAdapters if no other adapters are found.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handlerAdapters == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">            logger.trace(<span class=\"string\">&quot;No HandlerAdapters declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class=\"line\">                         <span class=\"string\">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现类\"><a href=\"#实现类\" class=\"headerlink\" title=\"实现类\"></a>实现类</h2><p>handlerAdapter有几个简单的实现类可以看下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是默认的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleControllerHandlerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Object handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (handler <span class=\"keyword\">instanceof</span> Controller);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 会调用controller的handlerRequest</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServletHandlerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Object handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (handler <span class=\"keyword\">instanceof</span> Servlet);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ((Servlet) handler).service(request, response);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他的实现类大都像上面的一样支持某种类型的handler，但我们最常用的是<code>RequestMappingHandlerAdapter</code>，他是专门用来处理标记了*@RequestMapping*注解的HandlerMethod。</p>\n<h1 id=\"参数处理\"><a href=\"#参数处理\" class=\"headerlink\" title=\"参数处理\"></a>参数处理</h1><p>之前有提到dispatcherServlet中，通过<em>doDispatch</em>来处理请求，里面通过reqeust获取到对应的adapter并且调用adapter里面的方法来处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Determine handler adapter for the current request.</span></span><br><span class=\"line\">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class=\"line\"><span class=\"comment\">// Actually invoke the handler.</span></span><br><span class=\"line\">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>\n\n<p><em>handle</em>方法是接口HandlerAdapter的抽象实现类中的<strong>final</strong>方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 交由子类实现，也就是RequestMappingHandlerAdapter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终处理的是invokeHandlerMethod，在这里会为equest创建一个<code>ServletInvocableHandlerMethod</code>，也就是说，对于向后端请求服务的request，实际处理的是用<code>ServletInvocableHandlerMethod</code>将request包裹之后的，在配置过一些属性后会将它作为入参，继续执行<em>invokeAndHandle</em>方法。</p>\n<h2 id=\"invokeAndHandle\"><a href=\"#invokeAndHandle\" class=\"headerlink\" title=\"invokeAndHandle\"></a>invokeAndHandle</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理请求与返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeAndHandle</span><span class=\"params\">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            Object... providedArgs)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 请求</span></span><br><span class=\"line\">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class=\"line\">    setResponseStatus(webRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (returnValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class=\"keyword\">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class=\"line\">            disableContentCachingIfNecessary(webRequest);</span><br><span class=\"line\">            mavContainer.setRequestHandled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class=\"line\">        mavContainer.setRequestHandled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mavContainer.setRequestHandled(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    Assert.state(<span class=\"keyword\">this</span>.returnValueHandlers != <span class=\"keyword\">null</span>, <span class=\"string\">&quot;No return value handlers&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class=\"line\">            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>简而言之，请求（handlerMethod）由特定的adapter处理，比如<em>RequestMappingHandlerAdapter</em>，他会继续被封装成<em>ServletInvocableHandlerMethod</em>。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这一篇承接上面的handlerMapping，在通过request获取到handlerExecutionChain和handler之后的处理操作，实际上不同的handlerMapping映射出来的东西是不一样的，adapter在这里的作用是用handler得到对应的视图方法。</p>","more":"<!-- toc -->\n\n<h1 id=\"HandlerAdapter\"><a href=\"#HandlerAdapter\" class=\"headerlink\" title=\"HandlerAdapter\"></a>HandlerAdapter</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断是否支持该handler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Object handler)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过handler返回modelAndView</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getLastModified</span><span class=\"params\">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到该接口的一个方法<em>handle</em>就是通过handler返回对应的modelAndView。那么这个接口及实现类是何时加载的呢？记得在第一篇有分析过实例化时的准备工作吗，那里有一些模板方法，其中就有关于初始化这个handlerAdapter的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initStrategies</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    initMultipartResolver(context);</span><br><span class=\"line\">    initLocaleResolver(context);</span><br><span class=\"line\">    initThemeResolver(context);</span><br><span class=\"line\">    initHandlerMappings(context);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化handlerAdapter</span></span><br><span class=\"line\">    initHandlerAdapters(context);</span><br><span class=\"line\">    initHandlerExceptionResolvers(context);</span><br><span class=\"line\">    initRequestToViewNameTranslator(context);</span><br><span class=\"line\">    initViewResolvers(context);</span><br><span class=\"line\">    initFlashMapManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initHandlerAdapters</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handlerAdapters = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.detectAllHandlerAdapters) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.</span></span><br><span class=\"line\">        Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class=\"line\">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.handlerAdapters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class=\"line\">            <span class=\"comment\">// We keep HandlerAdapters in sorted order.</span></span><br><span class=\"line\">            AnnotationAwareOrderComparator.sort(<span class=\"keyword\">this</span>.handlerAdapters);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Ignore, we&#x27;ll add a default HandlerAdapter later.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Ensure we have at least some HandlerAdapters, by registering</span></span><br><span class=\"line\">    <span class=\"comment\">// default HandlerAdapters if no other adapters are found.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handlerAdapters == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">            logger.trace(<span class=\"string\">&quot;No HandlerAdapters declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class=\"line\">                         <span class=\"string\">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现类\"><a href=\"#实现类\" class=\"headerlink\" title=\"实现类\"></a>实现类</h2><p>handlerAdapter有几个简单的实现类可以看下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是默认的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleControllerHandlerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Object handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (handler <span class=\"keyword\">instanceof</span> Controller);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 会调用controller的handlerRequest</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleServletHandlerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Object handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (handler <span class=\"keyword\">instanceof</span> Servlet);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ((Servlet) handler).service(request, response);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>他的实现类大都像上面的一样支持某种类型的handler，但我们最常用的是<code>RequestMappingHandlerAdapter</code>，他是专门用来处理标记了*@RequestMapping*注解的HandlerMethod。</p>\n<h1 id=\"参数处理\"><a href=\"#参数处理\" class=\"headerlink\" title=\"参数处理\"></a>参数处理</h1><p>之前有提到dispatcherServlet中，通过<em>doDispatch</em>来处理请求，里面通过reqeust获取到对应的adapter并且调用adapter里面的方法来处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Determine handler adapter for the current request.</span></span><br><span class=\"line\">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class=\"line\"><span class=\"comment\">// Actually invoke the handler.</span></span><br><span class=\"line\">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>\n\n<p><em>handle</em>方法是接口HandlerAdapter的抽象实现类中的<strong>final</strong>方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ModelAndView <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 交由子类实现，也就是RequestMappingHandlerAdapter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终处理的是invokeHandlerMethod，在这里会为equest创建一个<code>ServletInvocableHandlerMethod</code>，也就是说，对于向后端请求服务的request，实际处理的是用<code>ServletInvocableHandlerMethod</code>将request包裹之后的，在配置过一些属性后会将它作为入参，继续执行<em>invokeAndHandle</em>方法。</p>\n<h2 id=\"invokeAndHandle\"><a href=\"#invokeAndHandle\" class=\"headerlink\" title=\"invokeAndHandle\"></a>invokeAndHandle</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理请求与返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeAndHandle</span><span class=\"params\">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            Object... providedArgs)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 请求</span></span><br><span class=\"line\">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class=\"line\">    setResponseStatus(webRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (returnValue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class=\"keyword\">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class=\"line\">            disableContentCachingIfNecessary(webRequest);</span><br><span class=\"line\">            mavContainer.setRequestHandled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class=\"line\">        mavContainer.setRequestHandled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mavContainer.setRequestHandled(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    Assert.state(<span class=\"keyword\">this</span>.returnValueHandlers != <span class=\"keyword\">null</span>, <span class=\"string\">&quot;No return value handlers&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class=\"line\">            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>简而言之，请求（handlerMethod）由特定的adapter处理，比如<em>RequestMappingHandlerAdapter</em>，他会继续被封装成<em>ServletInvocableHandlerMethod</em>。</p>"},{"title":"springmvc-dispatch","date":"2021-04-06T08:35:27.000Z","_content":"\n​\t\t如何匹配controller，根据我们的使用以及对spring容器的理解，我可以猜测是通过反射获取注解，进而分类的，那springmvc是对他如何封装的呢？在springboot中又是如何融入springmvc，何时做的那些工作呢？\n\n<!-- more -->\n\n<!-- toc -->\n\n# AbstractHandlerMappingMethod\n\n​\t\t这个类继承了`AbstractHandlerMapping`并且实现了接口`InitializingBean`（任何bean在初始化时都会执行他的方法，接口中只有一个方法*afterPropertiesSet()*）。那这个类是做什么的呢？首先他是一个抽象类，一定会有更具体的类来实现它，其次，又是因为他是抽象类，所以内部一定定义了不用子类重复实现的公公流程，指明了大方向，结合web环境来说，**他定义了每个请求与`HandlerMethod`之间的映射关系**。\n\n下面我们从他实现的接口开始看，因为那时这个类刚刚实例化，我们看看他作为bean都做了哪些工作：\n\n```java\n@Override\npublic void afterPropertiesSet() {\n    initHandlerMethods();\n}\n\n/**\n * Scan beans in the ApplicationContext, detect and register handler methods.\n * @see #getCandidateBeanNames()\n * @see #processCandidateBean\n * @see #handlerMethodsInitialized\n */\nprotected void initHandlerMethods() {\n    for (String beanName : getCandidateBeanNames()) {\n        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n            processCandidateBean(beanName);\n        }\n    }\n    handlerMethodsInitialized(getHandlerMethods());\n}\n```\n\n从上面的注解可以看出，他会从上下文中扫描所有的bean并检测他是否是*handler method*。\n\n```java\nprotected void processCandidateBean(String beanName) {\n   Class<?> beanType = null;\n   try {\n      beanType = obtainApplicationContext().getType(beanName);\n   }\n   catch (Throwable ex) {\n      // An unresolvable bean type, probably from a lazy bean - let's ignore it.\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Could not resolve type for bean '\" + beanName + \"'\", ex);\n      }\n   }\n    // 判断是否是handler的bean\n   if (beanType != null && isHandler(beanType)) {\n       // 检测他的hadnler方法\n      detectHandlerMethods(beanName);\n   }\n}\n\n/**\n * Look for handler methods in the specified handler bean.\n * @param handler either a bean name or an actual handler instance\n * @see #getMappingForMethod\n */\nprotected void detectHandlerMethods(Object handler) {\n   Class<?> handlerType = (handler instanceof String ?\n         obtainApplicationContext().getType((String) handler) : handler.getClass());\n\n   if (handlerType != null) {\n      Class<?> userType = ClassUtils.getUserClass(handlerType);\n       // Method:ReqeustMappingInfo, 方法的第二个参数通过lambda传入\n      Map<Method, T> methods = MethodIntrospector.selectMethods(userType,\n            (MethodIntrospector.MetadataLookup<T>) method -> {\n               try {\n                   // 这里返回的类型是RequestMappingInfo，为方法创建mapping对象\n                  return getMappingForMethod(method, userType);\n               }\n               catch (Throwable ex) {\n                  throw new IllegalStateException(\"Invalid mapping on handler class [\" +\n                        userType.getName() + \"]: \" + method, ex);\n               }\n            });\n      if (logger.isTraceEnabled()) {\n         logger.trace(formatMappings(userType, methods));\n      }\n      methods.forEach((method, mapping) -> {\n         Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);\n          // 注册methods\n         registerHandlerMethod(handler, invocableMethod, mapping);\n      });\n   }\n}\n```\n\n```java\n@Override\nprotected boolean isHandler(Class<?> beanType) {\n    // 判断是否是handler的条件：是否有@Controller的注解或者@RequestMapping的注解\n   return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||\n         AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));\n}\n```\n\n> 这里也验证了一开始的猜测，通过注解来过滤我们需要的bean\n\n# HandlerMapping\n\n这是一个接口，为每个请求与处理做映射关系，里面有很多属性，有一个方法*getHandler(HttpServletRequest request)*，返回的是`HandlerExecutionChain`，所以说这也体现了拿servlet处理web的设计理念：如何做到通过reqeust找到我们要处理的方法，通过url中的参数来找我们写的controller，具体id细节就放在这个接口中来实现，返回的是一个处理链，然后怎么做呢，将这个处理链加到总的链中。\n\n```java\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    // 这是一个抽象方法，由子类实现，通过request返回handler\n    Object handler = getHandlerInternal(request);\n    if (handler == null) {\n        handler = getDefaultHandler();\n    }\n    if (handler == null) {\n        return null;\n    }\n    // Bean name or resolved handler?\n    if (handler instanceof String) {\n        String handlerName = (String) handler;\n        handler = obtainApplicationContext().getBean(handlerName);\n    }\n\n    // 再通过handler与request新建chain\n    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);\n\n    if (logger.isTraceEnabled()) {\n        logger.trace(\"Mapped to \" + handler);\n    }\n    else if (logger.isDebugEnabled() && !request.getDispatcherType().equals(DispatcherType.ASYNC)) {\n        logger.debug(\"Mapped to \" + executionChain.getHandler());\n    }\n\n    if (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) {\n        CorsConfiguration config = (this.corsConfigurationSource != null ? this.corsConfigurationSource.getCorsConfiguration(request) : null);\n        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);\n        config = (config != null ? config.combine(handlerConfig) : handlerConfig);\n        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);\n    }\n\n    return executionChain;\n}\n```\n\n```java\nprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n    HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?\n                                   (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));\n\n    String lookupPath = this.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);\n    for (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n        if (interceptor instanceof MappedInterceptor) {\n            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;\n            if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {\n                // 加拦截器\n                chain.addInterceptor(mappedInterceptor.getInterceptor());\n            }\n        }\n        else {\n            chain.addInterceptor(interceptor);\n        }\n    }\n    return chain;\n}\n```\n\n# 小结\n\n​\t\t这里再提一下springmvc的处理流程，首先到DispatcherServlet，他通过handlerMapping获得HandlerExecutionChain，然后获得HandlerAdapter，HandlerAdapter在内部对于每个请求都会实例化一个ServletInvocableHandlerMethod进行处理，ServletInvocableHandlerMethod在进行处理的时候会对请求和响应分别处理。下一篇我们分析他的参数处理，关于adapter和handlerMethod。","source":"_posts/springmvc-dispatch.md","raw":"---\ntitle: springmvc-dispatch\ndate: 2021-04-06 16:35:27\ncategories: springmvc\ntags: source\n---\n\n​\t\t如何匹配controller，根据我们的使用以及对spring容器的理解，我可以猜测是通过反射获取注解，进而分类的，那springmvc是对他如何封装的呢？在springboot中又是如何融入springmvc，何时做的那些工作呢？\n\n<!-- more -->\n\n<!-- toc -->\n\n# AbstractHandlerMappingMethod\n\n​\t\t这个类继承了`AbstractHandlerMapping`并且实现了接口`InitializingBean`（任何bean在初始化时都会执行他的方法，接口中只有一个方法*afterPropertiesSet()*）。那这个类是做什么的呢？首先他是一个抽象类，一定会有更具体的类来实现它，其次，又是因为他是抽象类，所以内部一定定义了不用子类重复实现的公公流程，指明了大方向，结合web环境来说，**他定义了每个请求与`HandlerMethod`之间的映射关系**。\n\n下面我们从他实现的接口开始看，因为那时这个类刚刚实例化，我们看看他作为bean都做了哪些工作：\n\n```java\n@Override\npublic void afterPropertiesSet() {\n    initHandlerMethods();\n}\n\n/**\n * Scan beans in the ApplicationContext, detect and register handler methods.\n * @see #getCandidateBeanNames()\n * @see #processCandidateBean\n * @see #handlerMethodsInitialized\n */\nprotected void initHandlerMethods() {\n    for (String beanName : getCandidateBeanNames()) {\n        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n            processCandidateBean(beanName);\n        }\n    }\n    handlerMethodsInitialized(getHandlerMethods());\n}\n```\n\n从上面的注解可以看出，他会从上下文中扫描所有的bean并检测他是否是*handler method*。\n\n```java\nprotected void processCandidateBean(String beanName) {\n   Class<?> beanType = null;\n   try {\n      beanType = obtainApplicationContext().getType(beanName);\n   }\n   catch (Throwable ex) {\n      // An unresolvable bean type, probably from a lazy bean - let's ignore it.\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Could not resolve type for bean '\" + beanName + \"'\", ex);\n      }\n   }\n    // 判断是否是handler的bean\n   if (beanType != null && isHandler(beanType)) {\n       // 检测他的hadnler方法\n      detectHandlerMethods(beanName);\n   }\n}\n\n/**\n * Look for handler methods in the specified handler bean.\n * @param handler either a bean name or an actual handler instance\n * @see #getMappingForMethod\n */\nprotected void detectHandlerMethods(Object handler) {\n   Class<?> handlerType = (handler instanceof String ?\n         obtainApplicationContext().getType((String) handler) : handler.getClass());\n\n   if (handlerType != null) {\n      Class<?> userType = ClassUtils.getUserClass(handlerType);\n       // Method:ReqeustMappingInfo, 方法的第二个参数通过lambda传入\n      Map<Method, T> methods = MethodIntrospector.selectMethods(userType,\n            (MethodIntrospector.MetadataLookup<T>) method -> {\n               try {\n                   // 这里返回的类型是RequestMappingInfo，为方法创建mapping对象\n                  return getMappingForMethod(method, userType);\n               }\n               catch (Throwable ex) {\n                  throw new IllegalStateException(\"Invalid mapping on handler class [\" +\n                        userType.getName() + \"]: \" + method, ex);\n               }\n            });\n      if (logger.isTraceEnabled()) {\n         logger.trace(formatMappings(userType, methods));\n      }\n      methods.forEach((method, mapping) -> {\n         Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);\n          // 注册methods\n         registerHandlerMethod(handler, invocableMethod, mapping);\n      });\n   }\n}\n```\n\n```java\n@Override\nprotected boolean isHandler(Class<?> beanType) {\n    // 判断是否是handler的条件：是否有@Controller的注解或者@RequestMapping的注解\n   return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||\n         AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));\n}\n```\n\n> 这里也验证了一开始的猜测，通过注解来过滤我们需要的bean\n\n# HandlerMapping\n\n这是一个接口，为每个请求与处理做映射关系，里面有很多属性，有一个方法*getHandler(HttpServletRequest request)*，返回的是`HandlerExecutionChain`，所以说这也体现了拿servlet处理web的设计理念：如何做到通过reqeust找到我们要处理的方法，通过url中的参数来找我们写的controller，具体id细节就放在这个接口中来实现，返回的是一个处理链，然后怎么做呢，将这个处理链加到总的链中。\n\n```java\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    // 这是一个抽象方法，由子类实现，通过request返回handler\n    Object handler = getHandlerInternal(request);\n    if (handler == null) {\n        handler = getDefaultHandler();\n    }\n    if (handler == null) {\n        return null;\n    }\n    // Bean name or resolved handler?\n    if (handler instanceof String) {\n        String handlerName = (String) handler;\n        handler = obtainApplicationContext().getBean(handlerName);\n    }\n\n    // 再通过handler与request新建chain\n    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);\n\n    if (logger.isTraceEnabled()) {\n        logger.trace(\"Mapped to \" + handler);\n    }\n    else if (logger.isDebugEnabled() && !request.getDispatcherType().equals(DispatcherType.ASYNC)) {\n        logger.debug(\"Mapped to \" + executionChain.getHandler());\n    }\n\n    if (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) {\n        CorsConfiguration config = (this.corsConfigurationSource != null ? this.corsConfigurationSource.getCorsConfiguration(request) : null);\n        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);\n        config = (config != null ? config.combine(handlerConfig) : handlerConfig);\n        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);\n    }\n\n    return executionChain;\n}\n```\n\n```java\nprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n    HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?\n                                   (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));\n\n    String lookupPath = this.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);\n    for (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n        if (interceptor instanceof MappedInterceptor) {\n            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;\n            if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {\n                // 加拦截器\n                chain.addInterceptor(mappedInterceptor.getInterceptor());\n            }\n        }\n        else {\n            chain.addInterceptor(interceptor);\n        }\n    }\n    return chain;\n}\n```\n\n# 小结\n\n​\t\t这里再提一下springmvc的处理流程，首先到DispatcherServlet，他通过handlerMapping获得HandlerExecutionChain，然后获得HandlerAdapter，HandlerAdapter在内部对于每个请求都会实例化一个ServletInvocableHandlerMethod进行处理，ServletInvocableHandlerMethod在进行处理的时候会对请求和响应分别处理。下一篇我们分析他的参数处理，关于adapter和handlerMethod。","slug":"springmvc-dispatch","published":1,"updated":"2021-04-07T04:19:14.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkj9y002pts9qbk7id7tk","content":"<p>​        如何匹配controller，根据我们的使用以及对spring容器的理解，我可以猜测是通过反射获取注解，进而分类的，那springmvc是对他如何封装的呢？在springboot中又是如何融入springmvc，何时做的那些工作呢？</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"AbstractHandlerMappingMethod\"><a href=\"#AbstractHandlerMappingMethod\" class=\"headerlink\" title=\"AbstractHandlerMappingMethod\"></a>AbstractHandlerMappingMethod</h1><p>​        这个类继承了<code>AbstractHandlerMapping</code>并且实现了接口<code>InitializingBean</code>（任何bean在初始化时都会执行他的方法，接口中只有一个方法<em>afterPropertiesSet()<em>）。那这个类是做什么的呢？首先他是一个抽象类，一定会有更具体的类来实现它，其次，又是因为他是抽象类，所以内部一定定义了不用子类重复实现的公公流程，指明了大方向，结合web环境来说，</em></em>他定义了每个请求与<code>HandlerMethod</code>之间的映射关系**。</p>\n<p>下面我们从他实现的接口开始看，因为那时这个类刚刚实例化，我们看看他作为bean都做了哪些工作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    initHandlerMethods();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getCandidateBeanNames()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #processCandidateBean</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #handlerMethodsInitialized</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initHandlerMethods</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class=\"line\">            processCandidateBean(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的注解可以看出，他会从上下文中扫描所有的bean并检测他是否是<em>handler method</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">processCandidateBean</span><span class=\"params\">(String beanName)</span> </span>&#123;</span><br><span class=\"line\">   Class&lt;?&gt; beanType = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      beanType = obtainApplicationContext().getType(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">         logger.trace(<span class=\"string\">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class=\"string\">&quot;&#x27;&quot;</span>, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否是handler的bean</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanType != <span class=\"keyword\">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 检测他的hadnler方法</span></span><br><span class=\"line\">      detectHandlerMethods(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Look for handler methods in the specified handler bean.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> handler either a bean name or an actual handler instance</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getMappingForMethod</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">detectHandlerMethods</span><span class=\"params\">(Object handler)</span> </span>&#123;</span><br><span class=\"line\">   Class&lt;?&gt; handlerType = (handler <span class=\"keyword\">instanceof</span> String ?</span><br><span class=\"line\">         obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (handlerType != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class=\"line\">       <span class=\"comment\">// Method:ReqeustMappingInfo, 方法的第二个参数通过lambda传入</span></span><br><span class=\"line\">      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class=\"line\">            (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">// 这里返回的类型是RequestMappingInfo，为方法创建mapping对象</span></span><br><span class=\"line\">                  <span class=\"keyword\">return</span> getMappingForMethod(method, userType);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class=\"line\">                        userType.getName() + <span class=\"string\">&quot;]: &quot;</span> + method, ex);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">         logger.trace(formatMappings(userType, methods));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      methods.forEach((method, mapping) -&gt; &#123;</span><br><span class=\"line\">         Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class=\"line\">          <span class=\"comment\">// 注册methods</span></span><br><span class=\"line\">         registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHandler</span><span class=\"params\">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否是handler的条件：是否有@Controller的注解或者@RequestMapping的注解</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class=\"line\">         AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里也验证了一开始的猜测，通过注解来过滤我们需要的bean</p>\n</blockquote>\n<h1 id=\"HandlerMapping\"><a href=\"#HandlerMapping\" class=\"headerlink\" title=\"HandlerMapping\"></a>HandlerMapping</h1><p>这是一个接口，为每个请求与处理做映射关系，里面有很多属性，有一个方法*getHandler(HttpServletRequest request)*，返回的是<code>HandlerExecutionChain</code>，所以说这也体现了拿servlet处理web的设计理念：如何做到通过reqeust找到我们要处理的方法，通过url中的参数来找我们写的controller，具体id细节就放在这个接口中来实现，返回的是一个处理链，然后怎么做呢，将这个处理链加到总的链中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> HandlerExecutionChain <span class=\"title\">getHandler</span><span class=\"params\">(HttpServletRequest request)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个抽象方法，由子类实现，通过request返回handler</span></span><br><span class=\"line\">    Object handler = getHandlerInternal(request);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handler = getDefaultHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Bean name or resolved handler?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String handlerName = (String) handler;</span><br><span class=\"line\">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 再通过handler与request新建chain</span></span><br><span class=\"line\">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">        logger.trace(<span class=\"string\">&quot;Mapped to &quot;</span> + handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class=\"line\">        CorsConfiguration config = (<span class=\"keyword\">this</span>.corsConfigurationSource != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class=\"line\">        config = (config != <span class=\"keyword\">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class=\"line\">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> executionChain;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> HandlerExecutionChain <span class=\"title\">getHandlerExecutionChain</span><span class=\"params\">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\">    HandlerExecutionChain chain = (handler <span class=\"keyword\">instanceof</span> HandlerExecutionChain ?</span><br><span class=\"line\">                                   (HandlerExecutionChain) handler : <span class=\"keyword\">new</span> HandlerExecutionChain(handler));</span><br><span class=\"line\"></span><br><span class=\"line\">    String lookupPath = <span class=\"keyword\">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HandlerInterceptor interceptor : <span class=\"keyword\">this</span>.adaptedInterceptors) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interceptor <span class=\"keyword\">instanceof</span> MappedInterceptor) &#123;</span><br><span class=\"line\">            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mappedInterceptor.matches(lookupPath, <span class=\"keyword\">this</span>.pathMatcher)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 加拦截器</span></span><br><span class=\"line\">                chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            chain.addInterceptor(interceptor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>​        这里再提一下springmvc的处理流程，首先到DispatcherServlet，他通过handlerMapping获得HandlerExecutionChain，然后获得HandlerAdapter，HandlerAdapter在内部对于每个请求都会实例化一个ServletInvocableHandlerMethod进行处理，ServletInvocableHandlerMethod在进行处理的时候会对请求和响应分别处理。下一篇我们分析他的参数处理，关于adapter和handlerMethod。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>​        如何匹配controller，根据我们的使用以及对spring容器的理解，我可以猜测是通过反射获取注解，进而分类的，那springmvc是对他如何封装的呢？在springboot中又是如何融入springmvc，何时做的那些工作呢？</p>","more":"<!-- toc -->\n\n<h1 id=\"AbstractHandlerMappingMethod\"><a href=\"#AbstractHandlerMappingMethod\" class=\"headerlink\" title=\"AbstractHandlerMappingMethod\"></a>AbstractHandlerMappingMethod</h1><p>​        这个类继承了<code>AbstractHandlerMapping</code>并且实现了接口<code>InitializingBean</code>（任何bean在初始化时都会执行他的方法，接口中只有一个方法<em>afterPropertiesSet()<em>）。那这个类是做什么的呢？首先他是一个抽象类，一定会有更具体的类来实现它，其次，又是因为他是抽象类，所以内部一定定义了不用子类重复实现的公公流程，指明了大方向，结合web环境来说，</em></em>他定义了每个请求与<code>HandlerMethod</code>之间的映射关系**。</p>\n<p>下面我们从他实现的接口开始看，因为那时这个类刚刚实例化，我们看看他作为bean都做了哪些工作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    initHandlerMethods();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getCandidateBeanNames()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #processCandidateBean</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #handlerMethodsInitialized</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initHandlerMethods</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class=\"line\">            processCandidateBean(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的注解可以看出，他会从上下文中扫描所有的bean并检测他是否是<em>handler method</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">processCandidateBean</span><span class=\"params\">(String beanName)</span> </span>&#123;</span><br><span class=\"line\">   Class&lt;?&gt; beanType = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      beanType = obtainApplicationContext().getType(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">         logger.trace(<span class=\"string\">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class=\"string\">&quot;&#x27;&quot;</span>, ex);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否是handler的bean</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (beanType != <span class=\"keyword\">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 检测他的hadnler方法</span></span><br><span class=\"line\">      detectHandlerMethods(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Look for handler methods in the specified handler bean.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> handler either a bean name or an actual handler instance</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #getMappingForMethod</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">detectHandlerMethods</span><span class=\"params\">(Object handler)</span> </span>&#123;</span><br><span class=\"line\">   Class&lt;?&gt; handlerType = (handler <span class=\"keyword\">instanceof</span> String ?</span><br><span class=\"line\">         obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (handlerType != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class=\"line\">       <span class=\"comment\">// Method:ReqeustMappingInfo, 方法的第二个参数通过lambda传入</span></span><br><span class=\"line\">      Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class=\"line\">            (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">// 这里返回的类型是RequestMappingInfo，为方法创建mapping对象</span></span><br><span class=\"line\">                  <span class=\"keyword\">return</span> getMappingForMethod(method, userType);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class=\"line\">                        userType.getName() + <span class=\"string\">&quot;]: &quot;</span> + method, ex);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">         logger.trace(formatMappings(userType, methods));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      methods.forEach((method, mapping) -&gt; &#123;</span><br><span class=\"line\">         Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class=\"line\">          <span class=\"comment\">// 注册methods</span></span><br><span class=\"line\">         registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHandler</span><span class=\"params\">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否是handler的条件：是否有@Controller的注解或者@RequestMapping的注解</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class=\"line\">         AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里也验证了一开始的猜测，通过注解来过滤我们需要的bean</p>\n</blockquote>\n<h1 id=\"HandlerMapping\"><a href=\"#HandlerMapping\" class=\"headerlink\" title=\"HandlerMapping\"></a>HandlerMapping</h1><p>这是一个接口，为每个请求与处理做映射关系，里面有很多属性，有一个方法*getHandler(HttpServletRequest request)*，返回的是<code>HandlerExecutionChain</code>，所以说这也体现了拿servlet处理web的设计理念：如何做到通过reqeust找到我们要处理的方法，通过url中的参数来找我们写的controller，具体id细节就放在这个接口中来实现，返回的是一个处理链，然后怎么做呢，将这个处理链加到总的链中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> HandlerExecutionChain <span class=\"title\">getHandler</span><span class=\"params\">(HttpServletRequest request)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个抽象方法，由子类实现，通过request返回handler</span></span><br><span class=\"line\">    Object handler = getHandlerInternal(request);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handler = getDefaultHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Bean name or resolved handler?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String handlerName = (String) handler;</span><br><span class=\"line\">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 再通过handler与request新建chain</span></span><br><span class=\"line\">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">        logger.trace(<span class=\"string\">&quot;Mapped to &quot;</span> + handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class=\"line\">        CorsConfiguration config = (<span class=\"keyword\">this</span>.corsConfigurationSource != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class=\"line\">        config = (config != <span class=\"keyword\">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class=\"line\">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> executionChain;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> HandlerExecutionChain <span class=\"title\">getHandlerExecutionChain</span><span class=\"params\">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\">    HandlerExecutionChain chain = (handler <span class=\"keyword\">instanceof</span> HandlerExecutionChain ?</span><br><span class=\"line\">                                   (HandlerExecutionChain) handler : <span class=\"keyword\">new</span> HandlerExecutionChain(handler));</span><br><span class=\"line\"></span><br><span class=\"line\">    String lookupPath = <span class=\"keyword\">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HandlerInterceptor interceptor : <span class=\"keyword\">this</span>.adaptedInterceptors) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (interceptor <span class=\"keyword\">instanceof</span> MappedInterceptor) &#123;</span><br><span class=\"line\">            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mappedInterceptor.matches(lookupPath, <span class=\"keyword\">this</span>.pathMatcher)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 加拦截器</span></span><br><span class=\"line\">                chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            chain.addInterceptor(interceptor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chain;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>​        这里再提一下springmvc的处理流程，首先到DispatcherServlet，他通过handlerMapping获得HandlerExecutionChain，然后获得HandlerAdapter，HandlerAdapter在内部对于每个请求都会实例化一个ServletInvocableHandlerMethod进行处理，ServletInvocableHandlerMethod在进行处理的时候会对请求和响应分别处理。下一篇我们分析他的参数处理，关于adapter和handlerMethod。</p>"},{"title":"springmvc-dispatcherservlet","date":"2021-04-06T05:59:49.000Z","_content":"\n这是剖析springmvc的第一篇，剖析前的他的原理已经猜的差不多了， 看源码是为了做一个验证，因为他也是依托于spring的，离不开ioc，所以一部分的原理已经清楚了， 剩下的是核心类`DispatcherServlet`以及为springboot适配而做的工作。\n\n<!-- more -->\n\n<!-- toc -->\n\n# HttpServletBean\n\n```properties\n-- HttpServlet\n    -- HttpServletBean\n    \t-- FrameworkServlet\n    \t\t-- DispatcherServlet\n```\n\n`HttpServlet`我们都知道，是javax提供的类，对所有的http请求做了封装，也是对每个servlet类的具体实现，在springmvc中为了将这个类融入到框架中，首先将他视作bean，添加了一些属性、实现了两个接口：`EnvironmentCapable`和`EnvironmentAware`，这两个接口的作用可通过名称或方法名来看（正符合spring的规范的设计）：\n\n```java\npublic interface EnvironmentCapable{\n    Environment getEnvironment();\n}\n\npublic interface EnvironmentAware extends Aware{\n    void setEnvironment(Environment environment);\n```\n\n除此之外，`HttpServletBean`重写了*init()*方法：\n\n```java\npublic final void init() throws ServletException {\n\n   // Set bean properties from init parameters.\n   PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n   if (!pvs.isEmpty()) {\n      try {\n          // 使用beanWrapper构造servletBean\n         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n         ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n         bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n         initBeanWrapper(bw);\n         bw.setPropertyValues(pvs, true);\n      }\n      catch (BeansException ex) {\n         if (logger.isErrorEnabled()) {\n            logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex);\n         }\n         throw ex;\n      }\n   }\n\n    // 子类方法重写，也就是初始化时可以做更多的事情\n   // Let subclasses do whatever initialization they like.\n   initServletBean();\n}\n```\n\n# FrameworkServlet\n\n这是一个抽象类，但他把控了大方向，正如他的名字一样，充分适配了spring上下文，具体体现在两个方面：\n\n- 每个servlet都管理着web上下文实例\n- 事件推送机制\n\n了解上面之前我们还是先顺着`HttpServletBean`中提到的扩展初始化的机制——留给子类复写的方法*initServletBean()*，看看在这里他是如何实现的：\n\n```java\nprotected final void initServletBean() throws ServletException {\n    // log...\n   try {\n       // 初始化WebApplicationContext，如果不存在的话会先创建\n      this.webApplicationContext = initWebApplicationContext();\n       // 留给子类重写\n      initFrameworkServlet();\n   }\n   catch (ServletException | RuntimeException ex) {\n      logger.error(\"Context initialization failed\", ex);\n      throw ex;\n   }\n   // log...\n}\n```\n\n```java\nprotected WebApplicationContext initWebApplicationContext() {\n   WebApplicationContext rootContext =\n         WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n   WebApplicationContext wac = null;\n\n   if (this.webApplicationContext != null) {\n      // A context instance was injected at construction time -> use it\n      wac = this.webApplicationContext;\n      if (wac instanceof ConfigurableWebApplicationContext) {\n         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n         if (!cwac.isActive()) {\n            // The context has not yet been refreshed -> provide services such as\n            // setting the parent context, setting the application context id, etc\n            if (cwac.getParent() == null) {\n               // The context instance was injected without an explicit parent -> set\n               // the root application context (if any; may be null) as the parent\n               cwac.setParent(rootContext);\n            }\n            configureAndRefreshWebApplicationContext(cwac);\n         }\n      }\n   }\n   if (wac == null) {\n      // No context instance was injected at construction time -> see if one\n      // has been registered in the servlet context. If one exists, it is assumed\n      // that the parent context (if any) has already been set and that the\n      // user has performed any initialization such as setting the context id\n      wac = findWebApplicationContext();\n   }\n   if (wac == null) {\n      // No context instance is defined for this servlet -> create a local one\n      wac = createWebApplicationContext(rootContext);\n   }\n\n   if (!this.refreshEventReceived) {\n      // Either the context is not a ConfigurableApplicationContext with refresh\n      // support or the context injected at construction time had already been\n      // refreshed -> trigger initial onRefresh manually here.\n      synchronized (this.onRefreshMonitor) {\n         // 留给子类实现\n         onRefresh(wac);\n      }\n   }\n\n   if (this.publishContext) {\n      // Publish the context as a servlet context attribute.\n      String attrName = getServletContextAttributeName();\n      getServletContext().setAttribute(attrName, wac);\n   }\n\n   return wac;\n}\n```\n\n初始化webApplicationContext时主要做两件事：\n\n- 关联servlet与容器，做法是设置父上下文\n- 推送事件\n\n# DispatcherServlet\n\n我们顺着上面留给子类重写的方法看起，这个类中并没有重写`initFrameworkdServlet()`，但是重写了`onRefresh()`方法：\n\n```java\n\t@Override\n\tprotected void onRefresh(ApplicationContext context) {\n\t\tinitStrategies(context);\n\t}\n\n\t/**\n\t * Initialize the strategy objects that this servlet uses.\n\t * <p>May be overridden in subclasses in order to initialize further strategy objects.\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\tinitHandlerMappings(context);\n\t\tinitHandlerAdapters(context);\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}\n```\n\n也就是说，在初始化阶段会做这么多事情，主要是集中在了这里，包括我们熟悉的*HandlerMapping*请求映射处理和异常处理*HandlerExceptionResolvers*等，做的是更具体的功能的实现。\n\n所以说，`HttpServletBean`也是继承了`HttpServlet`的，他做的是完成Bean所需要的工作，如配置环境属性；`FrameworkServlet`扩展了父类初始化时能做的事情，并且更加适配了spring上下文：有了上下文属性和事件推送；在这个类中，他做的事情更加具体了。\n\n\n\n## 分发请求\n\n上面提到`HttpSrevlet`对每个请求做了分装，细分了不同种类的请求，如POST、GET等，他的子类`HttpServletBean`是对bean的一种适配，业务规则没有做什么改变，而`FrameworkServlet`重写了*service()*方法：\n\n```java\nprotected void service(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n\n   HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    // 判断方法是否是PATHCH或null\n   if (httpMethod == HttpMethod.PATCH || httpMethod == null) {\n      processRequest(request, response);\n   }\n   else {\n      super.service(request, response);\n   }\n}\n```\n\n```java\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    long startTime = System.currentTimeMillis();\n    Throwable failureCause = null;\n\n    // 这部分是国际化的处理\n    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext = buildLocaleContext(request);\n\n    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n    initContextHolders(request, localeContext, requestAttributes);\n\n    try {\n        // 留给子类实现，即Dispatcherservlet\n        doService(request, response);\n    }\n    catch (ServletException | IOException ex) {\n        failureCause = ex;\n        throw ex;\n    }\n    catch (Throwable ex) {\n        failureCause = ex;\n        throw new NestedServletException(\"Request processing failed\", ex);\n    }\n\n    finally {\n        resetContextHolders(request, previousLocaleContext, previousAttributes);\n        if (requestAttributes != null) {\n            requestAttributes.requestCompleted();\n        }\n        logResult(request, response, failureCause, asyncManager);\n        publishRequestHandledEvent(request, response, startTime, failureCause);\n    }\n}\n```\n\n```java\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    logRequest(request);\n\n    // Keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    Map<String, Object> attributesSnapshot = null;\n    // 如果是include请求，特殊处理\n    if (WebUtils.isIncludeRequest(request)) {\n        attributesSnapshot = new HashMap<>();\n        Enumeration<?> attrNames = request.getAttributeNames();\n        while (attrNames.hasMoreElements()) {\n            String attrName = (String) attrNames.nextElement();\n            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n                attributesSnapshot.put(attrName, request.getAttribute(attrName));\n            }\n        }\n    }\n\n    // Make framework objects available to handlers and view objects.\n    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n    if (this.flashMapManager != null) {\n        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n        if (inputFlashMap != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n        }\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n    }\n\n    try {\n        // 其他请求在这里处理\n        doDispatch(request, response);\n    }\n    finally {\n        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n            // Restore the original attribute snapshot, in case of an include.\n            if (attributesSnapshot != null) {\n                restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n        }\n    }\n}\n```\n\n我们可以看到，在最初的`FrameworkServlet`中进入到`DispatcherServlet`中是有条件的，如果不是PATCH或null的方法就进入不了了吗？并不是，看到上面的流程，他会先去执行父类的方法，然后同样会回到`DispatcherServlet`中的*doDispatcherf()*中，更准确的说是*processRequest()*中，在process之后会紧接着发布事件，`FrameworkServlet`是针对父类有了较大的业务修改的，重写了很多方法，其中就包括各种*doPost()*、*doGet()*……这些，按照上面的流程，执行父类的请求，就会回到`FrameworkServlet`类中，而不是`HttpServlet`：\n\n```java\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    processRequest(request, response);\n}\n\n/**\n * Delegate POST requests to {@link #processRequest}.\n * @see #doService\n */\n@Override\nprotected final void doPost(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    processRequest(request, response);\n```\n\n\n\n# 小结\n\n以上是这篇的内容，主要介绍要了DispatcherServlet及其父类之间的关系，在融合进spring框架时各自的侧重点。关于请求时如何准确找到对应的controller（也就是没有展开将的*doDispatch(request, response)*方法）将在后面继续分析。","source":"_posts/springmvc-dispatcherservlet.md","raw":"---\ntitle: springmvc-dispatcherservlet\ndate: 2021-04-06 13:59:49\ncategories: springmvc\ntags: source\n---\n\n这是剖析springmvc的第一篇，剖析前的他的原理已经猜的差不多了， 看源码是为了做一个验证，因为他也是依托于spring的，离不开ioc，所以一部分的原理已经清楚了， 剩下的是核心类`DispatcherServlet`以及为springboot适配而做的工作。\n\n<!-- more -->\n\n<!-- toc -->\n\n# HttpServletBean\n\n```properties\n-- HttpServlet\n    -- HttpServletBean\n    \t-- FrameworkServlet\n    \t\t-- DispatcherServlet\n```\n\n`HttpServlet`我们都知道，是javax提供的类，对所有的http请求做了封装，也是对每个servlet类的具体实现，在springmvc中为了将这个类融入到框架中，首先将他视作bean，添加了一些属性、实现了两个接口：`EnvironmentCapable`和`EnvironmentAware`，这两个接口的作用可通过名称或方法名来看（正符合spring的规范的设计）：\n\n```java\npublic interface EnvironmentCapable{\n    Environment getEnvironment();\n}\n\npublic interface EnvironmentAware extends Aware{\n    void setEnvironment(Environment environment);\n```\n\n除此之外，`HttpServletBean`重写了*init()*方法：\n\n```java\npublic final void init() throws ServletException {\n\n   // Set bean properties from init parameters.\n   PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n   if (!pvs.isEmpty()) {\n      try {\n          // 使用beanWrapper构造servletBean\n         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n         ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n         bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n         initBeanWrapper(bw);\n         bw.setPropertyValues(pvs, true);\n      }\n      catch (BeansException ex) {\n         if (logger.isErrorEnabled()) {\n            logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex);\n         }\n         throw ex;\n      }\n   }\n\n    // 子类方法重写，也就是初始化时可以做更多的事情\n   // Let subclasses do whatever initialization they like.\n   initServletBean();\n}\n```\n\n# FrameworkServlet\n\n这是一个抽象类，但他把控了大方向，正如他的名字一样，充分适配了spring上下文，具体体现在两个方面：\n\n- 每个servlet都管理着web上下文实例\n- 事件推送机制\n\n了解上面之前我们还是先顺着`HttpServletBean`中提到的扩展初始化的机制——留给子类复写的方法*initServletBean()*，看看在这里他是如何实现的：\n\n```java\nprotected final void initServletBean() throws ServletException {\n    // log...\n   try {\n       // 初始化WebApplicationContext，如果不存在的话会先创建\n      this.webApplicationContext = initWebApplicationContext();\n       // 留给子类重写\n      initFrameworkServlet();\n   }\n   catch (ServletException | RuntimeException ex) {\n      logger.error(\"Context initialization failed\", ex);\n      throw ex;\n   }\n   // log...\n}\n```\n\n```java\nprotected WebApplicationContext initWebApplicationContext() {\n   WebApplicationContext rootContext =\n         WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n   WebApplicationContext wac = null;\n\n   if (this.webApplicationContext != null) {\n      // A context instance was injected at construction time -> use it\n      wac = this.webApplicationContext;\n      if (wac instanceof ConfigurableWebApplicationContext) {\n         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n         if (!cwac.isActive()) {\n            // The context has not yet been refreshed -> provide services such as\n            // setting the parent context, setting the application context id, etc\n            if (cwac.getParent() == null) {\n               // The context instance was injected without an explicit parent -> set\n               // the root application context (if any; may be null) as the parent\n               cwac.setParent(rootContext);\n            }\n            configureAndRefreshWebApplicationContext(cwac);\n         }\n      }\n   }\n   if (wac == null) {\n      // No context instance was injected at construction time -> see if one\n      // has been registered in the servlet context. If one exists, it is assumed\n      // that the parent context (if any) has already been set and that the\n      // user has performed any initialization such as setting the context id\n      wac = findWebApplicationContext();\n   }\n   if (wac == null) {\n      // No context instance is defined for this servlet -> create a local one\n      wac = createWebApplicationContext(rootContext);\n   }\n\n   if (!this.refreshEventReceived) {\n      // Either the context is not a ConfigurableApplicationContext with refresh\n      // support or the context injected at construction time had already been\n      // refreshed -> trigger initial onRefresh manually here.\n      synchronized (this.onRefreshMonitor) {\n         // 留给子类实现\n         onRefresh(wac);\n      }\n   }\n\n   if (this.publishContext) {\n      // Publish the context as a servlet context attribute.\n      String attrName = getServletContextAttributeName();\n      getServletContext().setAttribute(attrName, wac);\n   }\n\n   return wac;\n}\n```\n\n初始化webApplicationContext时主要做两件事：\n\n- 关联servlet与容器，做法是设置父上下文\n- 推送事件\n\n# DispatcherServlet\n\n我们顺着上面留给子类重写的方法看起，这个类中并没有重写`initFrameworkdServlet()`，但是重写了`onRefresh()`方法：\n\n```java\n\t@Override\n\tprotected void onRefresh(ApplicationContext context) {\n\t\tinitStrategies(context);\n\t}\n\n\t/**\n\t * Initialize the strategy objects that this servlet uses.\n\t * <p>May be overridden in subclasses in order to initialize further strategy objects.\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\tinitHandlerMappings(context);\n\t\tinitHandlerAdapters(context);\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}\n```\n\n也就是说，在初始化阶段会做这么多事情，主要是集中在了这里，包括我们熟悉的*HandlerMapping*请求映射处理和异常处理*HandlerExceptionResolvers*等，做的是更具体的功能的实现。\n\n所以说，`HttpServletBean`也是继承了`HttpServlet`的，他做的是完成Bean所需要的工作，如配置环境属性；`FrameworkServlet`扩展了父类初始化时能做的事情，并且更加适配了spring上下文：有了上下文属性和事件推送；在这个类中，他做的事情更加具体了。\n\n\n\n## 分发请求\n\n上面提到`HttpSrevlet`对每个请求做了分装，细分了不同种类的请求，如POST、GET等，他的子类`HttpServletBean`是对bean的一种适配，业务规则没有做什么改变，而`FrameworkServlet`重写了*service()*方法：\n\n```java\nprotected void service(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n\n   HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    // 判断方法是否是PATHCH或null\n   if (httpMethod == HttpMethod.PATCH || httpMethod == null) {\n      processRequest(request, response);\n   }\n   else {\n      super.service(request, response);\n   }\n}\n```\n\n```java\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    long startTime = System.currentTimeMillis();\n    Throwable failureCause = null;\n\n    // 这部分是国际化的处理\n    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n    LocaleContext localeContext = buildLocaleContext(request);\n\n    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n    initContextHolders(request, localeContext, requestAttributes);\n\n    try {\n        // 留给子类实现，即Dispatcherservlet\n        doService(request, response);\n    }\n    catch (ServletException | IOException ex) {\n        failureCause = ex;\n        throw ex;\n    }\n    catch (Throwable ex) {\n        failureCause = ex;\n        throw new NestedServletException(\"Request processing failed\", ex);\n    }\n\n    finally {\n        resetContextHolders(request, previousLocaleContext, previousAttributes);\n        if (requestAttributes != null) {\n            requestAttributes.requestCompleted();\n        }\n        logResult(request, response, failureCause, asyncManager);\n        publishRequestHandledEvent(request, response, startTime, failureCause);\n    }\n}\n```\n\n```java\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    logRequest(request);\n\n    // Keep a snapshot of the request attributes in case of an include,\n    // to be able to restore the original attributes after the include.\n    Map<String, Object> attributesSnapshot = null;\n    // 如果是include请求，特殊处理\n    if (WebUtils.isIncludeRequest(request)) {\n        attributesSnapshot = new HashMap<>();\n        Enumeration<?> attrNames = request.getAttributeNames();\n        while (attrNames.hasMoreElements()) {\n            String attrName = (String) attrNames.nextElement();\n            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {\n                attributesSnapshot.put(attrName, request.getAttribute(attrName));\n            }\n        }\n    }\n\n    // Make framework objects available to handlers and view objects.\n    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n    if (this.flashMapManager != null) {\n        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n        if (inputFlashMap != null) {\n            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n        }\n        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n    }\n\n    try {\n        // 其他请求在这里处理\n        doDispatch(request, response);\n    }\n    finally {\n        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n            // Restore the original attribute snapshot, in case of an include.\n            if (attributesSnapshot != null) {\n                restoreAttributesAfterInclude(request, attributesSnapshot);\n            }\n        }\n    }\n}\n```\n\n我们可以看到，在最初的`FrameworkServlet`中进入到`DispatcherServlet`中是有条件的，如果不是PATCH或null的方法就进入不了了吗？并不是，看到上面的流程，他会先去执行父类的方法，然后同样会回到`DispatcherServlet`中的*doDispatcherf()*中，更准确的说是*processRequest()*中，在process之后会紧接着发布事件，`FrameworkServlet`是针对父类有了较大的业务修改的，重写了很多方法，其中就包括各种*doPost()*、*doGet()*……这些，按照上面的流程，执行父类的请求，就会回到`FrameworkServlet`类中，而不是`HttpServlet`：\n\n```java\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    processRequest(request, response);\n}\n\n/**\n * Delegate POST requests to {@link #processRequest}.\n * @see #doService\n */\n@Override\nprotected final void doPost(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\n    processRequest(request, response);\n```\n\n\n\n# 小结\n\n以上是这篇的内容，主要介绍要了DispatcherServlet及其父类之间的关系，在融合进spring框架时各自的侧重点。关于请求时如何准确找到对应的controller（也就是没有展开将的*doDispatch(request, response)*方法）将在后面继续分析。","slug":"springmvc-dispatcherservlet","published":1,"updated":"2021-04-06T07:56:02.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkja2002tts9q55xgbdj3","content":"<p>这是剖析springmvc的第一篇，剖析前的他的原理已经猜的差不多了， 看源码是为了做一个验证，因为他也是依托于spring的，离不开ioc，所以一部分的原理已经清楚了， 剩下的是核心类<code>DispatcherServlet</code>以及为springboot适配而做的工作。</p>\n<span id=\"more\"></span>\n\n<!-- toc -->\n\n<h1 id=\"HttpServletBean\"><a href=\"#HttpServletBean\" class=\"headerlink\" title=\"HttpServletBean\"></a>HttpServletBean</h1><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">--</span> <span class=\"string\">HttpServlet</span></span><br><span class=\"line\">    <span class=\"meta\">--</span> <span class=\"string\">HttpServletBean</span></span><br><span class=\"line\">    \t<span class=\"meta\">--</span> <span class=\"string\">FrameworkServlet</span></span><br><span class=\"line\">    \t\t<span class=\"meta\">--</span> <span class=\"string\">DispatcherServlet</span></span><br></pre></td></tr></table></figure>\n\n<p><code>HttpServlet</code>我们都知道，是javax提供的类，对所有的http请求做了封装，也是对每个servlet类的具体实现，在springmvc中为了将这个类融入到框架中，首先将他视作bean，添加了一些属性、实现了两个接口：<code>EnvironmentCapable</code>和<code>EnvironmentAware</code>，这两个接口的作用可通过名称或方法名来看（正符合spring的规范的设计）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EnvironmentCapable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Environment <span class=\"title\">getEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EnvironmentAware</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aware</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setEnvironment</span><span class=\"params\">(Environment environment)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，<code>HttpServletBean</code>重写了*init()*方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Set bean properties from init parameters.</span></span><br><span class=\"line\">   PropertyValues pvs = <span class=\"keyword\">new</span> ServletConfigPropertyValues(getServletConfig(), <span class=\"keyword\">this</span>.requiredProperties);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!pvs.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 使用beanWrapper构造servletBean</span></span><br><span class=\"line\">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">         ResourceLoader resourceLoader = <span class=\"keyword\">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class=\"line\">         bw.registerCustomEditor(Resource.class, <span class=\"keyword\">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class=\"line\">         initBeanWrapper(bw);</span><br><span class=\"line\">         bw.setPropertyValues(pvs, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class=\"string\">&quot;&#x27;&quot;</span>, ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子类方法重写，也就是初始化时可以做更多的事情</span></span><br><span class=\"line\">   <span class=\"comment\">// Let subclasses do whatever initialization they like.</span></span><br><span class=\"line\">   initServletBean();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"FrameworkServlet\"><a href=\"#FrameworkServlet\" class=\"headerlink\" title=\"FrameworkServlet\"></a>FrameworkServlet</h1><p>这是一个抽象类，但他把控了大方向，正如他的名字一样，充分适配了spring上下文，具体体现在两个方面：</p>\n<ul>\n<li>每个servlet都管理着web上下文实例</li>\n<li>事件推送机制</li>\n</ul>\n<p>了解上面之前我们还是先顺着<code>HttpServletBean</code>中提到的扩展初始化的机制——留给子类复写的方法*initServletBean()*，看看在这里他是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">initServletBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// log...</span></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 初始化WebApplicationContext，如果不存在的话会先创建</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class=\"line\">       <span class=\"comment\">// 留给子类重写</span></span><br><span class=\"line\">      initFrameworkServlet();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class=\"line\">      logger.error(<span class=\"string\">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// log...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> WebApplicationContext <span class=\"title\">initWebApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   WebApplicationContext rootContext =</span><br><span class=\"line\">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class=\"line\">   WebApplicationContext wac = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.webApplicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// A context instance was injected at construction time -&gt; use it</span></span><br><span class=\"line\">      wac = <span class=\"keyword\">this</span>.webApplicationContext;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (wac <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class=\"line\">            <span class=\"comment\">// setting the parent context, setting the application context id, etc</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class=\"line\">               <span class=\"comment\">// the root application context (if any; may be null) as the parent</span></span><br><span class=\"line\">               cwac.setParent(rootContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            configureAndRefreshWebApplicationContext(cwac);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class=\"line\">      <span class=\"comment\">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class=\"line\">      <span class=\"comment\">// that the parent context (if any) has already been set and that the</span></span><br><span class=\"line\">      <span class=\"comment\">// user has performed any initialization such as setting the context id</span></span><br><span class=\"line\">      wac = findWebApplicationContext();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class=\"line\">      wac = createWebApplicationContext(rootContext);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.refreshEventReceived) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class=\"line\">      <span class=\"comment\">// support or the context injected at construction time had already been</span></span><br><span class=\"line\">      <span class=\"comment\">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.onRefreshMonitor) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 留给子类实现</span></span><br><span class=\"line\">         onRefresh(wac);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.publishContext) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Publish the context as a servlet context attribute.</span></span><br><span class=\"line\">      String attrName = getServletContextAttributeName();</span><br><span class=\"line\">      getServletContext().setAttribute(attrName, wac);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> wac;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化webApplicationContext时主要做两件事：</p>\n<ul>\n<li>关联servlet与容器，做法是设置父上下文</li>\n<li>推送事件</li>\n</ul>\n<h1 id=\"DispatcherServlet\"><a href=\"#DispatcherServlet\" class=\"headerlink\" title=\"DispatcherServlet\"></a>DispatcherServlet</h1><p>我们顺着上面留给子类重写的方法看起，这个类中并没有重写<code>initFrameworkdServlet()</code>，但是重写了<code>onRefresh()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitStrategies(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initStrategies</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitMultipartResolver(context);</span><br><span class=\"line\">\tinitLocaleResolver(context);</span><br><span class=\"line\">\tinitThemeResolver(context);</span><br><span class=\"line\">\tinitHandlerMappings(context);</span><br><span class=\"line\">\tinitHandlerAdapters(context);</span><br><span class=\"line\">\tinitHandlerExceptionResolvers(context);</span><br><span class=\"line\">\tinitRequestToViewNameTranslator(context);</span><br><span class=\"line\">\tinitViewResolvers(context);</span><br><span class=\"line\">\tinitFlashMapManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，在初始化阶段会做这么多事情，主要是集中在了这里，包括我们熟悉的<em>HandlerMapping</em>请求映射处理和异常处理<em>HandlerExceptionResolvers</em>等，做的是更具体的功能的实现。</p>\n<p>所以说，<code>HttpServletBean</code>也是继承了<code>HttpServlet</code>的，他做的是完成Bean所需要的工作，如配置环境属性；<code>FrameworkServlet</code>扩展了父类初始化时能做的事情，并且更加适配了spring上下文：有了上下文属性和事件推送；在这个类中，他做的事情更加具体了。</p>\n<h2 id=\"分发请求\"><a href=\"#分发请求\" class=\"headerlink\" title=\"分发请求\"></a>分发请求</h2><p>上面提到<code>HttpSrevlet</code>对每个请求做了分装，细分了不同种类的请求，如POST、GET等，他的子类<code>HttpServletBean</code>是对bean的一种适配，业务规则没有做什么改变，而<code>FrameworkServlet</code>重写了*service()*方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">      <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class=\"line\">    <span class=\"comment\">// 判断方法是否是PATHCH或null</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      processRequest(request, response);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.service(request, response);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">    Throwable failureCause = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这部分是国际化的处理</span></span><br><span class=\"line\">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class=\"line\">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class=\"keyword\">new</span> RequestBindingInterceptor());</span><br><span class=\"line\"></span><br><span class=\"line\">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 留给子类实现，即Dispatcherservlet</span></span><br><span class=\"line\">        doService(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (ServletException | IOException ex) &#123;</span><br><span class=\"line\">        failureCause = ex;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        failureCause = ex;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NestedServletException(<span class=\"string\">&quot;Request processing failed&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestAttributes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            requestAttributes.requestCompleted();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logResult(request, response, failureCause, asyncManager);</span><br><span class=\"line\">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doService</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    logRequest(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class=\"line\">    <span class=\"comment\">// to be able to restore the original attributes after the include.</span></span><br><span class=\"line\">    Map&lt;String, Object&gt; attributesSnapshot = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是include请求，特殊处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class=\"line\">        attributesSnapshot = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class=\"line\">            String attrName = (String) attrNames.nextElement();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class=\"line\">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make framework objects available to handlers and view objects.</span></span><br><span class=\"line\">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class=\"line\">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.localeResolver);</span><br><span class=\"line\">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.themeResolver);</span><br><span class=\"line\">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.flashMapManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        FlashMap inputFlashMap = <span class=\"keyword\">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputFlashMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class=\"keyword\">new</span> FlashMap());</span><br><span class=\"line\">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class=\"keyword\">this</span>.flashMapManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他请求在这里处理</span></span><br><span class=\"line\">        doDispatch(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (attributesSnapshot != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，在最初的<code>FrameworkServlet</code>中进入到<code>DispatcherServlet</code>中是有条件的，如果不是PATCH或null的方法就进入不了了吗？并不是，看到上面的流程，他会先去执行父类的方法，然后同样会回到<code>DispatcherServlet</code>中的*doDispatcherf()<em>中，更准确的说是</em>processRequest()<em>中，在process之后会紧接着发布事件，<code>FrameworkServlet</code>是针对父类有了较大的业务修改的，重写了很多方法，其中就包括各种</em>doPost()<em>、</em>doGet()*……这些，按照上面的流程，执行父类的请求，就会回到<code>FrameworkServlet</code>类中，而不是<code>HttpServlet</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    processRequest(request, response);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Delegate POST requests to &#123;<span class=\"doctag\">@link</span> #processRequest&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #doService</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    processRequest(request, response);</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上是这篇的内容，主要介绍要了DispatcherServlet及其父类之间的关系，在融合进spring框架时各自的侧重点。关于请求时如何准确找到对应的controller（也就是没有展开将的*doDispatch(request, response)*方法）将在后面继续分析。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这是剖析springmvc的第一篇，剖析前的他的原理已经猜的差不多了， 看源码是为了做一个验证，因为他也是依托于spring的，离不开ioc，所以一部分的原理已经清楚了， 剩下的是核心类<code>DispatcherServlet</code>以及为springboot适配而做的工作。</p>","more":"<!-- toc -->\n\n<h1 id=\"HttpServletBean\"><a href=\"#HttpServletBean\" class=\"headerlink\" title=\"HttpServletBean\"></a>HttpServletBean</h1><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">--</span> <span class=\"string\">HttpServlet</span></span><br><span class=\"line\">    <span class=\"meta\">--</span> <span class=\"string\">HttpServletBean</span></span><br><span class=\"line\">    \t<span class=\"meta\">--</span> <span class=\"string\">FrameworkServlet</span></span><br><span class=\"line\">    \t\t<span class=\"meta\">--</span> <span class=\"string\">DispatcherServlet</span></span><br></pre></td></tr></table></figure>\n\n<p><code>HttpServlet</code>我们都知道，是javax提供的类，对所有的http请求做了封装，也是对每个servlet类的具体实现，在springmvc中为了将这个类融入到框架中，首先将他视作bean，添加了一些属性、实现了两个接口：<code>EnvironmentCapable</code>和<code>EnvironmentAware</code>，这两个接口的作用可通过名称或方法名来看（正符合spring的规范的设计）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EnvironmentCapable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Environment <span class=\"title\">getEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EnvironmentAware</span> <span class=\"keyword\">extends</span> <span class=\"title\">Aware</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setEnvironment</span><span class=\"params\">(Environment environment)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，<code>HttpServletBean</code>重写了*init()*方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Set bean properties from init parameters.</span></span><br><span class=\"line\">   PropertyValues pvs = <span class=\"keyword\">new</span> ServletConfigPropertyValues(getServletConfig(), <span class=\"keyword\">this</span>.requiredProperties);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!pvs.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 使用beanWrapper构造servletBean</span></span><br><span class=\"line\">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">         ResourceLoader resourceLoader = <span class=\"keyword\">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class=\"line\">         bw.registerCustomEditor(Resource.class, <span class=\"keyword\">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class=\"line\">         initBeanWrapper(bw);</span><br><span class=\"line\">         bw.setPropertyValues(pvs, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class=\"string\">&quot;&#x27;&quot;</span>, ex);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 子类方法重写，也就是初始化时可以做更多的事情</span></span><br><span class=\"line\">   <span class=\"comment\">// Let subclasses do whatever initialization they like.</span></span><br><span class=\"line\">   initServletBean();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"FrameworkServlet\"><a href=\"#FrameworkServlet\" class=\"headerlink\" title=\"FrameworkServlet\"></a>FrameworkServlet</h1><p>这是一个抽象类，但他把控了大方向，正如他的名字一样，充分适配了spring上下文，具体体现在两个方面：</p>\n<ul>\n<li>每个servlet都管理着web上下文实例</li>\n<li>事件推送机制</li>\n</ul>\n<p>了解上面之前我们还是先顺着<code>HttpServletBean</code>中提到的扩展初始化的机制——留给子类复写的方法*initServletBean()*，看看在这里他是如何实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">initServletBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// log...</span></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 初始化WebApplicationContext，如果不存在的话会先创建</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class=\"line\">       <span class=\"comment\">// 留给子类重写</span></span><br><span class=\"line\">      initFrameworkServlet();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class=\"line\">      logger.error(<span class=\"string\">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// log...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> WebApplicationContext <span class=\"title\">initWebApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   WebApplicationContext rootContext =</span><br><span class=\"line\">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class=\"line\">   WebApplicationContext wac = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.webApplicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// A context instance was injected at construction time -&gt; use it</span></span><br><span class=\"line\">      wac = <span class=\"keyword\">this</span>.webApplicationContext;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (wac <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class=\"line\">            <span class=\"comment\">// setting the parent context, setting the application context id, etc</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class=\"line\">               <span class=\"comment\">// the root application context (if any; may be null) as the parent</span></span><br><span class=\"line\">               cwac.setParent(rootContext);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            configureAndRefreshWebApplicationContext(cwac);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class=\"line\">      <span class=\"comment\">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class=\"line\">      <span class=\"comment\">// that the parent context (if any) has already been set and that the</span></span><br><span class=\"line\">      <span class=\"comment\">// user has performed any initialization such as setting the context id</span></span><br><span class=\"line\">      wac = findWebApplicationContext();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class=\"line\">      wac = createWebApplicationContext(rootContext);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.refreshEventReceived) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class=\"line\">      <span class=\"comment\">// support or the context injected at construction time had already been</span></span><br><span class=\"line\">      <span class=\"comment\">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.onRefreshMonitor) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 留给子类实现</span></span><br><span class=\"line\">         onRefresh(wac);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.publishContext) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Publish the context as a servlet context attribute.</span></span><br><span class=\"line\">      String attrName = getServletContextAttributeName();</span><br><span class=\"line\">      getServletContext().setAttribute(attrName, wac);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> wac;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化webApplicationContext时主要做两件事：</p>\n<ul>\n<li>关联servlet与容器，做法是设置父上下文</li>\n<li>推送事件</li>\n</ul>\n<h1 id=\"DispatcherServlet\"><a href=\"#DispatcherServlet\" class=\"headerlink\" title=\"DispatcherServlet\"></a>DispatcherServlet</h1><p>我们顺着上面留给子类重写的方法看起，这个类中并没有重写<code>initFrameworkdServlet()</code>，但是重写了<code>onRefresh()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitStrategies(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initStrategies</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitMultipartResolver(context);</span><br><span class=\"line\">\tinitLocaleResolver(context);</span><br><span class=\"line\">\tinitThemeResolver(context);</span><br><span class=\"line\">\tinitHandlerMappings(context);</span><br><span class=\"line\">\tinitHandlerAdapters(context);</span><br><span class=\"line\">\tinitHandlerExceptionResolvers(context);</span><br><span class=\"line\">\tinitRequestToViewNameTranslator(context);</span><br><span class=\"line\">\tinitViewResolvers(context);</span><br><span class=\"line\">\tinitFlashMapManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，在初始化阶段会做这么多事情，主要是集中在了这里，包括我们熟悉的<em>HandlerMapping</em>请求映射处理和异常处理<em>HandlerExceptionResolvers</em>等，做的是更具体的功能的实现。</p>\n<p>所以说，<code>HttpServletBean</code>也是继承了<code>HttpServlet</code>的，他做的是完成Bean所需要的工作，如配置环境属性；<code>FrameworkServlet</code>扩展了父类初始化时能做的事情，并且更加适配了spring上下文：有了上下文属性和事件推送；在这个类中，他做的事情更加具体了。</p>\n<h2 id=\"分发请求\"><a href=\"#分发请求\" class=\"headerlink\" title=\"分发请求\"></a>分发请求</h2><p>上面提到<code>HttpSrevlet</code>对每个请求做了分装，细分了不同种类的请求，如POST、GET等，他的子类<code>HttpServletBean</code>是对bean的一种适配，业务规则没有做什么改变，而<code>FrameworkServlet</code>重写了*service()*方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">      <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class=\"line\">    <span class=\"comment\">// 判断方法是否是PATHCH或null</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      processRequest(request, response);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.service(request, response);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">    Throwable failureCause = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这部分是国际化的处理</span></span><br><span class=\"line\">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class=\"line\">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class=\"keyword\">new</span> RequestBindingInterceptor());</span><br><span class=\"line\"></span><br><span class=\"line\">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 留给子类实现，即Dispatcherservlet</span></span><br><span class=\"line\">        doService(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (ServletException | IOException ex) &#123;</span><br><span class=\"line\">        failureCause = ex;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        failureCause = ex;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NestedServletException(<span class=\"string\">&quot;Request processing failed&quot;</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestAttributes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            requestAttributes.requestCompleted();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logResult(request, response, failureCause, asyncManager);</span><br><span class=\"line\">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doService</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    logRequest(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class=\"line\">    <span class=\"comment\">// to be able to restore the original attributes after the include.</span></span><br><span class=\"line\">    Map&lt;String, Object&gt; attributesSnapshot = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是include请求，特殊处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class=\"line\">        attributesSnapshot = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class=\"line\">            String attrName = (String) attrNames.nextElement();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class=\"line\">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make framework objects available to handlers and view objects.</span></span><br><span class=\"line\">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class=\"line\">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.localeResolver);</span><br><span class=\"line\">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.themeResolver);</span><br><span class=\"line\">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.flashMapManager != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        FlashMap inputFlashMap = <span class=\"keyword\">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputFlashMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class=\"keyword\">new</span> FlashMap());</span><br><span class=\"line\">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class=\"keyword\">this</span>.flashMapManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 其他请求在这里处理</span></span><br><span class=\"line\">        doDispatch(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (attributesSnapshot != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，在最初的<code>FrameworkServlet</code>中进入到<code>DispatcherServlet</code>中是有条件的，如果不是PATCH或null的方法就进入不了了吗？并不是，看到上面的流程，他会先去执行父类的方法，然后同样会回到<code>DispatcherServlet</code>中的*doDispatcherf()<em>中，更准确的说是</em>processRequest()<em>中，在process之后会紧接着发布事件，<code>FrameworkServlet</code>是针对父类有了较大的业务修改的，重写了很多方法，其中就包括各种</em>doPost()<em>、</em>doGet()*……这些，按照上面的流程，执行父类的请求，就会回到<code>FrameworkServlet</code>类中，而不是<code>HttpServlet</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    processRequest(request, response);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Delegate POST requests to &#123;<span class=\"doctag\">@link</span> #processRequest&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span> #doService</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    processRequest(request, response);</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>以上是这篇的内容，主要介绍要了DispatcherServlet及其父类之间的关系，在融合进spring框架时各自的侧重点。关于请求时如何准确找到对应的controller（也就是没有展开将的*doDispatch(request, response)*方法）将在后面继续分析。</p>"},{"title":"subarray","date":"2021-02-27T05:45:38.000Z","_content":"\n这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的`map` + `preSum`，双指针的思路是很容易理解的，后者需要绕个弯。\n\n<!-- more -->\n\n<!--toc-->\n\n# [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\n\nGiven an array of integers `nums` and an integer `k`, return *the total number of continuous subarrays whose sum equals to `k`*.\n\n以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：\n\n```java\npublic int subarraySum(int[] nums, int k){\n    int res = 0;\n    for(int lo = 0, hi = 0, sum = 0; hi < nums.length; hi++){\n        sum += nums[i];\n        whlie(lo < nums.length && sum > k){\n            sum -= nums[lo++];\n        }\n        if(sum == k) res++;\n    }\n    \n    return res;\n}\n```\n\n如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的**Constraints**：\n\n- `1 <= nums.length <= 2 * 104`\n- `-1000 <= nums[i] <= 1000`\n- `-107 <= k <= 107`\n\n注意到了么，给的入参中数字是可以为负数的，在代码中`sum-= nums[lo++]`是无效的，如果入参都是正数，双指针就是OK的。\n\n## map + preSum\n\n​\t\t与双指针不同的是，这种解法用到了额外的数据结构`map`，在这里关于映射表的用法也有多种。另外一个`preSum`很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：\n\n有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么`P5 - P2`是12，正是子串\\[2, 3\\]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：`Px - Py = target (x > y)`，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：`Px - target = Py`，然后统计有多少个符合的子数组即可，这样我们的map可以定义为*Map\\<Integer, Integer\\>*，用来保存*当前的数组和*和*数组和的个数*。\n\n```java\npublic int subarraySum(int[] nums, int k){\n    if(nums.length == 0) return 0;\n    Map<Integer, Integer> map new HashMap<>();\n    int sum = 0, result = 0;\n    for(int cur : nums){\n        sum += cur; // preSum\n        if(sum == k) result++; //也可以提前在map中放入 map.put(0, 1)\n        result += map.getOrDefault(sum - k, 0);\n        map.put(sum, map.getOrDefault(sum, 0) + 1);\n    }\n    \n    return result;\n}\n```\n\n通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：`sum(i, j) = sum(0, j) - sum(0, i)`。\n\n# [Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero)\n\nYou are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn *the **minimum number** of operations to reduce* `x` *to **exactly*** `0` *if it's possible**, otherwise, return* `-1`.\n\n**Constraints:**\n\n- `1 <= nums.length <= 105`\n- `1 <= nums[i] <= 104`\n- `1 <= x <= 109`\n\n​\t\t以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。\n\n由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：\n\n```java\npublic int minOperations(int[] nums, int x){\n    int target = Arrays.stream(nums).sum() - x;\n    int size = -1, n = nums.length;\n    for(int lo = 0, hi = 0, sum = 0; hi < n; hi++){\n        sum += nums[hi];\n        while(lo < n && sum > target){\n            sum -= nums[lo++];\n        }\n        if(sum == target) size = Math.max(size, hi - lo + 1);\n    }\n    return size < 0 ? -1 : n - size;\n}\n```\n\n也能使用前缀和：\n\n```java\npublic int minOperations(int[] nums, int x) {\n    int target = Arrays.stream(nums).sum() - x;\n    if(target == 0) return nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);// 长度，下面是 i - map.value\n    int sum = 0, res = 0;\n    for(int i=0; i<nums.length; i++){\n        int num = nums[i];\n        sum += num;\n        if(map.containsKey(sum - target)){\n            res = Math.max(res, i - map.get(sum - target));\n        }\n        map.put(sum, i);\n    }\n\n    return res == 0 ? -1 : nums.length - res;\n}\n```\n\n","source":"_posts/subarray.md","raw":"---\ntitle: subarray\ndate: 2021-02-27 13:45:38\ncategories: Leetcode\ntags: \n- double poiters\n- map+preSum\n---\n\n这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的`map` + `preSum`，双指针的思路是很容易理解的，后者需要绕个弯。\n\n<!-- more -->\n\n<!--toc-->\n\n# [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\n\nGiven an array of integers `nums` and an integer `k`, return *the total number of continuous subarrays whose sum equals to `k`*.\n\n以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：\n\n```java\npublic int subarraySum(int[] nums, int k){\n    int res = 0;\n    for(int lo = 0, hi = 0, sum = 0; hi < nums.length; hi++){\n        sum += nums[i];\n        whlie(lo < nums.length && sum > k){\n            sum -= nums[lo++];\n        }\n        if(sum == k) res++;\n    }\n    \n    return res;\n}\n```\n\n如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的**Constraints**：\n\n- `1 <= nums.length <= 2 * 104`\n- `-1000 <= nums[i] <= 1000`\n- `-107 <= k <= 107`\n\n注意到了么，给的入参中数字是可以为负数的，在代码中`sum-= nums[lo++]`是无效的，如果入参都是正数，双指针就是OK的。\n\n## map + preSum\n\n​\t\t与双指针不同的是，这种解法用到了额外的数据结构`map`，在这里关于映射表的用法也有多种。另外一个`preSum`很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：\n\n有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么`P5 - P2`是12，正是子串\\[2, 3\\]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：`Px - Py = target (x > y)`，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：`Px - target = Py`，然后统计有多少个符合的子数组即可，这样我们的map可以定义为*Map\\<Integer, Integer\\>*，用来保存*当前的数组和*和*数组和的个数*。\n\n```java\npublic int subarraySum(int[] nums, int k){\n    if(nums.length == 0) return 0;\n    Map<Integer, Integer> map new HashMap<>();\n    int sum = 0, result = 0;\n    for(int cur : nums){\n        sum += cur; // preSum\n        if(sum == k) result++; //也可以提前在map中放入 map.put(0, 1)\n        result += map.getOrDefault(sum - k, 0);\n        map.put(sum, map.getOrDefault(sum, 0) + 1);\n    }\n    \n    return result;\n}\n```\n\n通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：`sum(i, j) = sum(0, j) - sum(0, i)`。\n\n# [Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero)\n\nYou are given an integer array `nums` and an integer `x`. In one operation, you can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from `x`. Note that this **modifies** the array for future operations.\n\nReturn *the **minimum number** of operations to reduce* `x` *to **exactly*** `0` *if it's possible**, otherwise, return* `-1`.\n\n**Constraints:**\n\n- `1 <= nums.length <= 105`\n- `1 <= nums[i] <= 104`\n- `1 <= x <= 109`\n\n​\t\t以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。\n\n由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：\n\n```java\npublic int minOperations(int[] nums, int x){\n    int target = Arrays.stream(nums).sum() - x;\n    int size = -1, n = nums.length;\n    for(int lo = 0, hi = 0, sum = 0; hi < n; hi++){\n        sum += nums[hi];\n        while(lo < n && sum > target){\n            sum -= nums[lo++];\n        }\n        if(sum == target) size = Math.max(size, hi - lo + 1);\n    }\n    return size < 0 ? -1 : n - size;\n}\n```\n\n也能使用前缀和：\n\n```java\npublic int minOperations(int[] nums, int x) {\n    int target = Arrays.stream(nums).sum() - x;\n    if(target == 0) return nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    map.put(0, -1);// 长度，下面是 i - map.value\n    int sum = 0, res = 0;\n    for(int i=0; i<nums.length; i++){\n        int num = nums[i];\n        sum += num;\n        if(map.containsKey(sum - target)){\n            res = Math.max(res, i - map.get(sum - target));\n        }\n        map.put(sum, i);\n    }\n\n    return res == 0 ? -1 : nums.length - res;\n}\n```\n\n","slug":"subarray","published":1,"updated":"2021-03-28T10:20:02.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkja5002xts9q2p9ja5y6","content":"<p>这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的<code>map</code> + <code>preSum</code>，双指针的思路是很容易理解的，后者需要绕个弯。</p>\n<span id=\"more\"></span>\n\n<!--toc-->\n\n<h1 id=\"Subarray-Sum-Equals-K\"><a href=\"#Subarray-Sum-Equals-K\" class=\"headerlink\" title=\"Subarray Sum Equals K\"></a><a href=\"https://leetcode.com/problems/subarray-sum-equals-k/\">Subarray Sum Equals K</a></h1><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.</p>\n<p>以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; nums.length; hi++)&#123;</span><br><span class=\"line\">        sum += nums[i];</span><br><span class=\"line\">        whlie(lo &lt; nums.length &amp;&amp; sum &gt; k)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) res++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的<strong>Constraints</strong>：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>\n<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n<li><code>-107 &lt;= k &lt;= 107</code></li>\n</ul>\n<p>注意到了么，给的入参中数字是可以为负数的，在代码中<code>sum-= nums[lo++]</code>是无效的，如果入参都是正数，双指针就是OK的。</p>\n<h2 id=\"map-preSum\"><a href=\"#map-preSum\" class=\"headerlink\" title=\"map + preSum\"></a>map + preSum</h2><p>​        与双指针不同的是，这种解法用到了额外的数据结构<code>map</code>，在这里关于映射表的用法也有多种。另外一个<code>preSum</code>很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：</p>\n<p>有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么<code>P5 - P2</code>是12，正是子串[2, 3]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：<code>Px - Py = target (x &gt; y)</code>，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：<code>Px - target = Py</code>，然后统计有多少个符合的子数组即可，这样我们的map可以定义为<em>Map&lt;Integer, Integer&gt;<em>，用来保存</em>当前的数组和</em>和<em>数组和的个数</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cur : nums)&#123;</span><br><span class=\"line\">        sum += cur; <span class=\"comment\">// preSum</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) result++; <span class=\"comment\">//也可以提前在map中放入 map.put(0, 1)</span></span><br><span class=\"line\">        result += map.getOrDefault(sum - k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        map.put(sum, map.getOrDefault(sum, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：<code>sum(i, j) = sum(0, j) - sum(0, i)</code>。</p>\n<h1 id=\"Minimum-Operations-to-Reduce-X-to-Zero\"><a href=\"#Minimum-Operations-to-Reduce-X-to-Zero\" class=\"headerlink\" title=\"Minimum Operations to Reduce X to Zero\"></a><a href=\"https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero\">Minimum Operations to Reduce X to Zero</a></h1><p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>\n<p>Return <em>the <strong>minimum number</strong> of operations to reduce</em> <code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it’s possible**, otherwise, return</em> <code>-1</code>.</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>1 &lt;= x &lt;= 109</code></li>\n</ul>\n<p>​        以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。</p>\n<p>由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = -<span class=\"number\">1</span>, n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; n; hi++)&#123;</span><br><span class=\"line\">        sum += nums[hi];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt; n &amp;&amp; sum &gt; target)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == target) size = Math.max(size, hi - lo + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size &lt; <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : n - size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也能使用前缀和：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, -<span class=\"number\">1</span>);<span class=\"comment\">// 长度，下面是 i - map.value</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = nums[i];</span><br><span class=\"line\">        sum += num;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.containsKey(sum - target))&#123;</span><br><span class=\"line\">            res = Math.max(res, i - map.get(sum - target));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.put(sum, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : nums.length - res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这篇聊聊双指针以及他的替代方法。title是subarray，这是因为相关的题使用双指针解起来是十分方便的，但是也有不适用的情况，所以更建议使用一步到位的<code>map</code> + <code>preSum</code>，双指针的思路是很容易理解的，后者需要绕个弯。</p>","more":"<!--toc-->\n\n<h1 id=\"Subarray-Sum-Equals-K\"><a href=\"#Subarray-Sum-Equals-K\" class=\"headerlink\" title=\"Subarray Sum Equals K\"></a><a href=\"https://leetcode.com/problems/subarray-sum-equals-k/\">Subarray Sum Equals K</a></h1><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.</p>\n<p>以上是题干，我们从这道题来入手这篇的主题。由于是求连续的子数组，所以我们首先想到的应该是双指针：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; nums.length; hi++)&#123;</span><br><span class=\"line\">        sum += nums[i];</span><br><span class=\"line\">        whlie(lo &lt; nums.length &amp;&amp; sum &gt; k)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) res++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果提交以上代码，肯定不会AC，为什么呢，我们再来看题目的<strong>Constraints</strong>：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>\n<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n<li><code>-107 &lt;= k &lt;= 107</code></li>\n</ul>\n<p>注意到了么，给的入参中数字是可以为负数的，在代码中<code>sum-= nums[lo++]</code>是无效的，如果入参都是正数，双指针就是OK的。</p>\n<h2 id=\"map-preSum\"><a href=\"#map-preSum\" class=\"headerlink\" title=\"map + preSum\"></a>map + preSum</h2><p>​        与双指针不同的是，这种解法用到了额外的数据结构<code>map</code>，在这里关于映射表的用法也有多种。另外一个<code>preSum</code>很好理解，就是前缀和。用这两个能做什么呢？我们从前缀和来试着理解下：</p>\n<p>有一串数字：1,2,3,4,5,6，6个数字，前5个的和记为P5，是15；前2个的和记为P2，是3，那么<code>P5 - P2</code>是12，正是子串[2, 3]。就是利用这个方式来找子串。那么子串找到了如何利用map呢？别忘了，入参不仅仅只有数组，在这道题中我们还要找到和为target的子串的数量，换句话说，要找到符合条件的子串。如果符合条件，那么应该满足：<code>Px - Py = target (x &gt; y)</code>，但是这样做我们岂不是要找出所有子串然后相减？显然违背了初衷（简单），我们换个思路，长的前缀和是已知的，目标值也是已知的，所以可以这样写：<code>Px - target = Py</code>，然后统计有多少个符合的子数组即可，这样我们的map可以定义为<em>Map&lt;Integer, Integer&gt;<em>，用来保存</em>当前的数组和</em>和<em>数组和的个数</em>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cur : nums)&#123;</span><br><span class=\"line\">        sum += cur; <span class=\"comment\">// preSum</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == k) result++; <span class=\"comment\">//也可以提前在map中放入 map.put(0, 1)</span></span><br><span class=\"line\">        result += map.getOrDefault(sum - k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        map.put(sum, map.getOrDefault(sum, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这道题可以衍生出很多种题目，尤其是这种解法，非常巧妙。特别是，改下题目，如果不是返回符合条件的个数，而是返回子数组呢？那么我们map记录的就不是子数组和的个数了，而应该是下标：<code>sum(i, j) = sum(0, j) - sum(0, i)</code>。</p>\n<h1 id=\"Minimum-Operations-to-Reduce-X-to-Zero\"><a href=\"#Minimum-Operations-to-Reduce-X-to-Zero\" class=\"headerlink\" title=\"Minimum Operations to Reduce X to Zero\"></a><a href=\"https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero\">Minimum Operations to Reduce X to Zero</a></h1><p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>\n<p>Return <em>the <strong>minimum number</strong> of operations to reduce</em> <code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it’s possible**, otherwise, return</em> <code>-1</code>.</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>1 &lt;= x &lt;= 109</code></li>\n</ul>\n<p>​        以上是题干，题目规定了取数的方式：只能从最左或最右侧取数。之所以把这道题放在这里，是因为换个角度看，其实也是求子数组！最小操作数意味着取最少的数字，那么子数组要在满足给定值的情况下保证最多。例如，有数组：1,2,3,4,5，目标值是6，我们需要从数组中找出满足（数组和为15，15-6=9）和为9的情况下个数最多的情况，这样一来，其余的值和为6且个数最少。</p>\n<p>由于题目给了限制条件：数组成员均大于或等于1，不存在负数，可以使用双指针遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = -<span class=\"number\">1</span>, n = nums.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>, hi = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>; hi &lt; n; hi++)&#123;</span><br><span class=\"line\">        sum += nums[hi];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt; n &amp;&amp; sum &gt; target)&#123;</span><br><span class=\"line\">            sum -= nums[lo++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum == target) size = Math.max(size, hi - lo + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size &lt; <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : n - size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也能使用前缀和：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> target = Arrays.stream(nums).sum() - x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    map.put(<span class=\"number\">0</span>, -<span class=\"number\">1</span>);<span class=\"comment\">// 长度，下面是 i - map.value</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = nums[i];</span><br><span class=\"line\">        sum += num;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(map.containsKey(sum - target))&#123;</span><br><span class=\"line\">            res = Math.max(res, i - map.get(sum - target));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.put(sum, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res == <span class=\"number\">0</span> ? -<span class=\"number\">1</span> : nums.length - res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"uml","date":"2020-01-12T15:14:16.000Z","_content":"\nThe **Unified Modeling Language(UML)** is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.\n\n<!-- more -->\n\n# 序\n\n主要说说UML中的关系(Class Relationships)\n\n[reference1](https://www.visual-paradigm.com/cn/guide/), [reference2](https://support.typora.io/Draw-Diagrams-With-Markdown/)\n\n## Class Relationships\n\nA class may be involved in one or more relationships with other classes.\n\n## Inheritance(or Generalization)\n\n- Represents an \"is-a\" relationship\n- An abstract class name is shown *in italics*\n- SubClass1 and SubClass2 are specializations of Super Class\n- **A solid line with a hollow arrowhead that point <u>from the child to the parent class</u>**\n\n```mermaid\nclassDiagram\nClass <|-- SubClass1\nClass <|-- SubClass2 \n```\n\n\n\n---\n\n## Simple Association\n\n- A structural link between two peer classes\n- There is an association between Class1 and Class2\n- **A solid line connecting two classes**\n\n```mermaid\nclassDiagram\nClass1 .. Class2\n```\n\n\n\n---\n\n## Aggregation\n\nA special type of association. It represents a \"part of\" relationship.\n\n- Class2 is part of Class1.\n- Many instances(denoted by the *) of Class2 can be associated with Class1\n- Objects of Class1 and Class2 have separate lifetimes\n- **A solid line with an unfilled diamond at the association end connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 o-- Class2\n```\n\n---\n\n## Composition\n\nA special type of aggregation **where parts are destroyed when the whole is destroyed.**\n\n- Objects of Class2 live and die with Class1\n- Class2 cannot stand by itself\n- **A solid line with a filled diamond at the association connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 *-- Class2\n```\n\n---\n\n## Dependency\n\n- Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)\n- Class1 depends on Class2\n- A dashed line with an open arrow\n\n```mermaid\nclassDiagram\nClass1 ..> Class2\n```\n\n\n\n","source":"_posts/uml.md","raw":"---\ntitle: uml\ndate: 2020-01-12 23:14:16\ncategories: Utils\ntags: utils\n---\n\nThe **Unified Modeling Language(UML)** is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.\n\n<!-- more -->\n\n# 序\n\n主要说说UML中的关系(Class Relationships)\n\n[reference1](https://www.visual-paradigm.com/cn/guide/), [reference2](https://support.typora.io/Draw-Diagrams-With-Markdown/)\n\n## Class Relationships\n\nA class may be involved in one or more relationships with other classes.\n\n## Inheritance(or Generalization)\n\n- Represents an \"is-a\" relationship\n- An abstract class name is shown *in italics*\n- SubClass1 and SubClass2 are specializations of Super Class\n- **A solid line with a hollow arrowhead that point <u>from the child to the parent class</u>**\n\n```mermaid\nclassDiagram\nClass <|-- SubClass1\nClass <|-- SubClass2 \n```\n\n\n\n---\n\n## Simple Association\n\n- A structural link between two peer classes\n- There is an association between Class1 and Class2\n- **A solid line connecting two classes**\n\n```mermaid\nclassDiagram\nClass1 .. Class2\n```\n\n\n\n---\n\n## Aggregation\n\nA special type of association. It represents a \"part of\" relationship.\n\n- Class2 is part of Class1.\n- Many instances(denoted by the *) of Class2 can be associated with Class1\n- Objects of Class1 and Class2 have separate lifetimes\n- **A solid line with an unfilled diamond at the association end connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 o-- Class2\n```\n\n---\n\n## Composition\n\nA special type of aggregation **where parts are destroyed when the whole is destroyed.**\n\n- Objects of Class2 live and die with Class1\n- Class2 cannot stand by itself\n- **A solid line with a filled diamond at the association connected to the class of composite**\n\n```mermaid\nclassDiagram\nClass1 *-- Class2\n```\n\n---\n\n## Dependency\n\n- Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)\n- Class1 depends on Class2\n- A dashed line with an open arrow\n\n```mermaid\nclassDiagram\nClass1 ..> Class2\n```\n\n\n\n","slug":"uml","published":1,"updated":"2021-03-28T10:20:02.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkja70030ts9q3vv96d9k","content":"<p>The <strong>Unified Modeling Language(UML)</strong> is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.</p>\n<span id=\"more\"></span>\n\n<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>主要说说UML中的关系(Class Relationships)</p>\n<p><a href=\"https://www.visual-paradigm.com/cn/guide/\">reference1</a>, <a href=\"https://support.typora.io/Draw-Diagrams-With-Markdown/\">reference2</a></p>\n<h2 id=\"Class-Relationships\"><a href=\"#Class-Relationships\" class=\"headerlink\" title=\"Class Relationships\"></a>Class Relationships</h2><p>A class may be involved in one or more relationships with other classes.</p>\n<h2 id=\"Inheritance-or-Generalization\"><a href=\"#Inheritance-or-Generalization\" class=\"headerlink\" title=\"Inheritance(or Generalization)\"></a>Inheritance(or Generalization)</h2><ul>\n<li>Represents an “is-a” relationship</li>\n<li>An abstract class name is shown <em>in italics</em></li>\n<li>SubClass1 and SubClass2 are specializations of Super Class</li>\n<li><strong>A solid line with a hollow arrowhead that point <u>from the child to the parent class</u></strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class &lt;|-- SubClass1</span><br><span class=\"line\">Class &lt;|-- SubClass2 </span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Simple-Association\"><a href=\"#Simple-Association\" class=\"headerlink\" title=\"Simple Association\"></a>Simple Association</h2><ul>\n<li>A structural link between two peer classes</li>\n<li>There is an association between Class1 and Class2</li>\n<li><strong>A solid line connecting two classes</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 .. Class2</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Aggregation\"><a href=\"#Aggregation\" class=\"headerlink\" title=\"Aggregation\"></a>Aggregation</h2><p>A special type of association. It represents a “part of” relationship.</p>\n<ul>\n<li>Class2 is part of Class1.</li>\n<li>Many instances(denoted by the *) of Class2 can be associated with Class1</li>\n<li>Objects of Class1 and Class2 have separate lifetimes</li>\n<li><strong>A solid line with an unfilled diamond at the association end connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 o-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Composition\"><a href=\"#Composition\" class=\"headerlink\" title=\"Composition\"></a>Composition</h2><p>A special type of aggregation <strong>where parts are destroyed when the whole is destroyed.</strong></p>\n<ul>\n<li>Objects of Class2 live and die with Class1</li>\n<li>Class2 cannot stand by itself</li>\n<li><strong>A solid line with a filled diamond at the association connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 *-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Dependency\"><a href=\"#Dependency\" class=\"headerlink\" title=\"Dependency\"></a>Dependency</h2><ul>\n<li>Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)</li>\n<li>Class1 depends on Class2</li>\n<li>A dashed line with an open arrow</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 ..&gt; Class2</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>The <strong>Unified Modeling Language(UML)</strong> is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.</p>","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>主要说说UML中的关系(Class Relationships)</p>\n<p><a href=\"https://www.visual-paradigm.com/cn/guide/\">reference1</a>, <a href=\"https://support.typora.io/Draw-Diagrams-With-Markdown/\">reference2</a></p>\n<h2 id=\"Class-Relationships\"><a href=\"#Class-Relationships\" class=\"headerlink\" title=\"Class Relationships\"></a>Class Relationships</h2><p>A class may be involved in one or more relationships with other classes.</p>\n<h2 id=\"Inheritance-or-Generalization\"><a href=\"#Inheritance-or-Generalization\" class=\"headerlink\" title=\"Inheritance(or Generalization)\"></a>Inheritance(or Generalization)</h2><ul>\n<li>Represents an “is-a” relationship</li>\n<li>An abstract class name is shown <em>in italics</em></li>\n<li>SubClass1 and SubClass2 are specializations of Super Class</li>\n<li><strong>A solid line with a hollow arrowhead that point <u>from the child to the parent class</u></strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class &lt;|-- SubClass1</span><br><span class=\"line\">Class &lt;|-- SubClass2 </span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Simple-Association\"><a href=\"#Simple-Association\" class=\"headerlink\" title=\"Simple Association\"></a>Simple Association</h2><ul>\n<li>A structural link between two peer classes</li>\n<li>There is an association between Class1 and Class2</li>\n<li><strong>A solid line connecting two classes</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 .. Class2</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"Aggregation\"><a href=\"#Aggregation\" class=\"headerlink\" title=\"Aggregation\"></a>Aggregation</h2><p>A special type of association. It represents a “part of” relationship.</p>\n<ul>\n<li>Class2 is part of Class1.</li>\n<li>Many instances(denoted by the *) of Class2 can be associated with Class1</li>\n<li>Objects of Class1 and Class2 have separate lifetimes</li>\n<li><strong>A solid line with an unfilled diamond at the association end connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 o-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Composition\"><a href=\"#Composition\" class=\"headerlink\" title=\"Composition\"></a>Composition</h2><p>A special type of aggregation <strong>where parts are destroyed when the whole is destroyed.</strong></p>\n<ul>\n<li>Objects of Class2 live and die with Class1</li>\n<li>Class2 cannot stand by itself</li>\n<li><strong>A solid line with a filled diamond at the association connected to the class of composite</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 *-- Class2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Dependency\"><a href=\"#Dependency\" class=\"headerlink\" title=\"Dependency\"></a>Dependency</h2><ul>\n<li>Exists between two classes if the changes to the definition of one may cause changes to the other (but not the other way around)</li>\n<li>Class1 depends on Class2</li>\n<li>A dashed line with an open arrow</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Class1 ..&gt; Class2</span><br></pre></td></tr></table></figure>"},{"title":"volatile","date":"2020-07-20T13:23:51.000Z","_content":"\n这个关键字用于将Java变量标记为`being stored in main memory`，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。\n\n<!--more-->\n\n# Visibility problems\n\n主要是多线程中的问题。线程在操作`非volatile`的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。\n\n那么问题来了，对于`非volatile`的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器\n\n```java\npublic class ShareObject{\n    public int counter = 0;\n}\n```\n\n假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。\n\n如果counter不声明为`volatile`，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，**一个线程的更新对其他线程是不可见的**。\n\n# Visibility Guarantee\n\n关键字`volatile`的设定就是解决上面提到的可见性问题。通过声明counter变量为`volatile`的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字`volatile`的例子：\n\n```java\npublic class ShareObject{\n    // 由于声明为volatile，因此更改变量对于其他线程的是可见的\n    public volatile int counter = 0 ;\n}\n```\n\n但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为`volatile`是不够的。\n\n## Full Visibility Guarantee\n\n实际上，关键字`volatile`的可见保证性超越了`volatile`变量本身。有点绕吧，可见保证性如下：\n\n- 如果线程A更改了`volatile`变量，并且线程B随后读取了它，则在写入`volatile`变量之前线程A可见的所有变量在线程B读取`volatile`变量后也将可见。\n\n- 如果线程A读取了一个`volatile`变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。\n\n看个代码例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    // 更改了三个变量，只有days是volatile的\n    public void update(int years, int months, int days){\n        this.years = year;\n        this.months = months;\n        this.days = days;    \n    }\n}\n```\n\n”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n\n    public int totalDays(){\n        int total = this.days;\n        total += months * 30;\n        total += years * 365;\n        return total;   \n    }\n\n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n着重观察*totalDays()*，他一开始会将`days`的值赋给变量`total` ,由于`days`的类型是`volatile`，所以，读取`days`的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了`volatile`他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为`volatile`，读取时必须**最后**读取带有`volatile`属性的值）。\n\n# Instruction Reordering\n\n指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：\n\n```java\nint a = 1;\nint b = 2;\na++;\nb++;\n```\n\n这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：\n\n```java\nint a  = 1;\na++;\nint b = 2;\nb++\n```\n\n然而，当变量属于`volatile`时，指令排序就需要小心了，看看下面的例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n如果JVM重排指令，像下面这样：\n\n```java\n    public void update(int years, int months, int days){\n        // 这里将days赋值动作放到了第一位\n        this.days = days;\n        this.years = years;\n        this.months = months;\n    }\n```\n\n当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。\n\n## Volatile Happens-Before Guarantee\n\n`volatile`关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。\n\n- 如果读/写其他变量出现在写`volatile变量`之前，那么就不能重排为出现在它之后。当然返回过是允许的。\n- 如果读/写其他变量出现在读`volatile变量`之后，那么就不能重排为出现在它之前。\n\n# Volatile is Not Always Enough\n\n很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证`原子性`的操作了，如**syncronized**或者比并发包下的`lock`了。\n","source":"_posts/volatile.md","raw":"---\ntitle: volatile\ndate: 2020-07-20 21:23:51\ncategories: Java\ntags: lock\n---\n\n这个关键字用于将Java变量标记为`being stored in main memory`，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。\n\n<!--more-->\n\n# Visibility problems\n\n主要是多线程中的问题。线程在操作`非volatile`的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。\n\n那么问题来了，对于`非volatile`的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器\n\n```java\npublic class ShareObject{\n    public int counter = 0;\n}\n```\n\n假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。\n\n如果counter不声明为`volatile`，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，**一个线程的更新对其他线程是不可见的**。\n\n# Visibility Guarantee\n\n关键字`volatile`的设定就是解决上面提到的可见性问题。通过声明counter变量为`volatile`的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字`volatile`的例子：\n\n```java\npublic class ShareObject{\n    // 由于声明为volatile，因此更改变量对于其他线程的是可见的\n    public volatile int counter = 0 ;\n}\n```\n\n但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为`volatile`是不够的。\n\n## Full Visibility Guarantee\n\n实际上，关键字`volatile`的可见保证性超越了`volatile`变量本身。有点绕吧，可见保证性如下：\n\n- 如果线程A更改了`volatile`变量，并且线程B随后读取了它，则在写入`volatile`变量之前线程A可见的所有变量在线程B读取`volatile`变量后也将可见。\n\n- 如果线程A读取了一个`volatile`变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。\n\n看个代码例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    // 更改了三个变量，只有days是volatile的\n    public void update(int years, int months, int days){\n        this.years = year;\n        this.months = months;\n        this.days = days;    \n    }\n}\n```\n\n”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n\n    public int totalDays(){\n        int total = this.days;\n        total += months * 30;\n        total += years * 365;\n        return total;   \n    }\n\n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n着重观察*totalDays()*，他一开始会将`days`的值赋给变量`total` ,由于`days`的类型是`volatile`，所以，读取`days`的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了`volatile`他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为`volatile`，读取时必须**最后**读取带有`volatile`属性的值）。\n\n# Instruction Reordering\n\n指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：\n\n```java\nint a = 1;\nint b = 2;\na++;\nb++;\n```\n\n这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：\n\n```java\nint a  = 1;\na++;\nint b = 2;\nb++\n```\n\n然而，当变量属于`volatile`时，指令排序就需要小心了，看看下面的例子：\n\n```java\npublic class MyClass{\n    private int years;\n    private int months;\n    private volatile int days;\n    \n    public void update(int years, int months, int days){\n        this.years = years;\n        this.months = months;\n        this.days = days;\n    }\n}\n```\n\n如果JVM重排指令，像下面这样：\n\n```java\n    public void update(int years, int months, int days){\n        // 这里将days赋值动作放到了第一位\n        this.days = days;\n        this.years = years;\n        this.months = months;\n    }\n```\n\n当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。\n\n## Volatile Happens-Before Guarantee\n\n`volatile`关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。\n\n- 如果读/写其他变量出现在写`volatile变量`之前，那么就不能重排为出现在它之后。当然返回过是允许的。\n- 如果读/写其他变量出现在读`volatile变量`之后，那么就不能重排为出现在它之前。\n\n# Volatile is Not Always Enough\n\n很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证`原子性`的操作了，如**syncronized**或者比并发包下的`lock`了。\n","slug":"volatile","published":1,"updated":"2021-03-28T10:20:02.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkjab0034ts9q33fl3w7e","content":"<p>这个关键字用于将Java变量标记为<code>being stored in main memory</code>，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Visibility-problems\"><a href=\"#Visibility-problems\" class=\"headerlink\" title=\"Visibility problems\"></a>Visibility problems</h1><p>主要是多线程中的问题。线程在操作<code>非volatile</code>的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。</p>\n<p>那么问题来了，对于<code>非volatile</code>的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。</p>\n<p>如果counter不声明为<code>volatile</code>，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，<strong>一个线程的更新对其他线程是不可见的</strong>。</p>\n<h1 id=\"Visibility-Guarantee\"><a href=\"#Visibility-Guarantee\" class=\"headerlink\" title=\"Visibility Guarantee\"></a>Visibility Guarantee</h1><p>关键字<code>volatile</code>的设定就是解决上面提到的可见性问题。通过声明counter变量为<code>volatile</code>的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字<code>volatile</code>的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由于声明为volatile，因此更改变量对于其他线程的是可见的</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为<code>volatile</code>是不够的。</p>\n<h2 id=\"Full-Visibility-Guarantee\"><a href=\"#Full-Visibility-Guarantee\" class=\"headerlink\" title=\"Full Visibility Guarantee\"></a>Full Visibility Guarantee</h2><p>实际上，关键字<code>volatile</code>的可见保证性超越了<code>volatile</code>变量本身。有点绕吧，可见保证性如下：</p>\n<ul>\n<li><p>如果线程A更改了<code>volatile</code>变量，并且线程B随后读取了它，则在写入<code>volatile</code>变量之前线程A可见的所有变量在线程B读取<code>volatile</code>变量后也将可见。</p>\n</li>\n<li><p>如果线程A读取了一个<code>volatile</code>变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。</p>\n</li>\n</ul>\n<p>看个代码例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 更改了三个变量，只有days是volatile的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = year;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">totalDays</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"keyword\">this</span>.days;</span><br><span class=\"line\">        total += months * <span class=\"number\">30</span>;</span><br><span class=\"line\">        total += years * <span class=\"number\">365</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>着重观察<em>totalDays()<em>，他一开始会将<code>days</code>的值赋给变量<code>total</code> ,由于<code>days</code>的类型是<code>volatile</code>，所以，读取<code>days</code>的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了<code>volatile</code>他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为<code>volatile</code>，读取时必须</em></em>最后**读取带有<code>volatile</code>属性的值）。</p>\n<h1 id=\"Instruction-Reordering\"><a href=\"#Instruction-Reordering\" class=\"headerlink\" title=\"Instruction Reordering\"></a>Instruction Reordering</h1><p>指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b++;</span><br></pre></td></tr></table></figure>\n\n<p>这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a  = <span class=\"number\">1</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">b++</span><br></pre></td></tr></table></figure>\n\n<p>然而，当变量属于<code>volatile</code>时，指令排序就需要小心了，看看下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果JVM重排指令，像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里将days赋值动作放到了第一位</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。</p>\n<h2 id=\"Volatile-Happens-Before-Guarantee\"><a href=\"#Volatile-Happens-Before-Guarantee\" class=\"headerlink\" title=\"Volatile Happens-Before Guarantee\"></a>Volatile Happens-Before Guarantee</h2><p><code>volatile</code>关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。</p>\n<ul>\n<li>如果读/写其他变量出现在写<code>volatile变量</code>之前，那么就不能重排为出现在它之后。当然返回过是允许的。</li>\n<li>如果读/写其他变量出现在读<code>volatile变量</code>之后，那么就不能重排为出现在它之前。</li>\n</ul>\n<h1 id=\"Volatile-is-Not-Always-Enough\"><a href=\"#Volatile-is-Not-Always-Enough\" class=\"headerlink\" title=\"Volatile is Not Always Enough\"></a>Volatile is Not Always Enough</h1><p>很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证<code>原子性</code>的操作了，如<strong>syncronized</strong>或者比并发包下的<code>lock</code>了。</p>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>这个关键字用于将Java变量标记为<code>being stored in main memory</code>，意味着每次对volatile变量的读取都将从计算机内存中读取，而不是从CPU缓存中读取，并且对volatile变量的写入都将被写入主存而不是CPU缓存。</p>","more":"<h1 id=\"Visibility-problems\"><a href=\"#Visibility-problems\" class=\"headerlink\" title=\"Visibility problems\"></a>Visibility problems</h1><p>主要是多线程中的问题。线程在操作<code>非volatile</code>的变量时，出于性能原因，都会将变量从主存复制到CPU缓存中，如果计算机上有多个CPU，那么每个线程可能在不同的CPU上运行，每个线程可以将变量复制到不同的CPU缓存中。</p>\n<p>那么问题来了，对于<code>非volatile</code>的变量，无法保证Java虚拟机何时将数据从主存储器读取到CPU缓存中，或者何时将数据从CPU缓存写入到主存储器中，设想一种情况：多个线程访问一个共享对象，该对象包含一个计数器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设只有线程1会将计数器递增，同时线程1和线程2都会不时地访问它。</p>\n<p>如果counter不声明为<code>volatile</code>，就无法保证计数器的值从CPU缓存重写回主存，这就意味着主存的counter与CPU缓存的值可能不同！（JVM内存模型有没有）。这种因为没有被另一个线程回写到主存导致无法同步值的问题就叫做“Visibility problem”，<strong>一个线程的更新对其他线程是不可见的</strong>。</p>\n<h1 id=\"Visibility-Guarantee\"><a href=\"#Visibility-Guarantee\" class=\"headerlink\" title=\"Visibility Guarantee\"></a>Visibility Guarantee</h1><p>关键字<code>volatile</code>的设定就是解决上面提到的可见性问题。通过声明counter变量为<code>volatile</code>的，所有对该变量更改都将立即回写到主存，同时所有对该变量的读操作也都会从主存中读取。下面是加了关键字<code>volatile</code>的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShareObject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 由于声明为volatile，因此更改变量对于其他线程的是可见的</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，目前仅是线程1更改，对线程2可见，要想线程1、2都更改，那么仅仅声明为<code>volatile</code>是不够的。</p>\n<h2 id=\"Full-Visibility-Guarantee\"><a href=\"#Full-Visibility-Guarantee\" class=\"headerlink\" title=\"Full Visibility Guarantee\"></a>Full Visibility Guarantee</h2><p>实际上，关键字<code>volatile</code>的可见保证性超越了<code>volatile</code>变量本身。有点绕吧，可见保证性如下：</p>\n<ul>\n<li><p>如果线程A更改了<code>volatile</code>变量，并且线程B随后读取了它，则在写入<code>volatile</code>变量之前线程A可见的所有变量在线程B读取<code>volatile</code>变量后也将可见。</p>\n</li>\n<li><p>如果线程A读取了一个<code>volatile</code>变量，则在读取那个变量时线程A可见的所有变量也将从主存中重新读取。</p>\n</li>\n</ul>\n<p>看个代码例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 更改了三个变量，只有days是volatile的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = year;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>”Full Visibility Guarantee“意味着，当一个值被写入days，那么线程所有的可见的变量都会被写入主存，对于上面的例子来说，months和years也会被写入主存。读取他们的值时，可以这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">totalDays</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"keyword\">this</span>.days;</span><br><span class=\"line\">        total += months * <span class=\"number\">30</span>;</span><br><span class=\"line\">        total += years * <span class=\"number\">365</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>着重观察<em>totalDays()<em>，他一开始会将<code>days</code>的值赋给变量<code>total</code> ,由于<code>days</code>的类型是<code>volatile</code>，所以，读取<code>days</code>的同时，其他变量（months、years）也都会从主存中读取，因此，这就是为什么可见保证性超过了<code>volatile</code>他本身，所以，对于本例甚至其他用到这个关键字的，都可以按照上面的顺序来保证读取到最新值（只给一个变量声明为<code>volatile</code>，读取时必须</em></em>最后**读取带有<code>volatile</code>属性的值）。</p>\n<h1 id=\"Instruction-Reordering\"><a href=\"#Instruction-Reordering\" class=\"headerlink\" title=\"Instruction Reordering\"></a>Instruction Reordering</h1><p>指令重排！！！出于性能原因，JVM和CPU是允许对程序中的指令进行重新排序，只要指令的语义含义保持不变即可。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\">b++;</span><br></pre></td></tr></table></figure>\n\n<p>这些指令可以重新排序为下列的顺序，且不会丢失原有程序的语义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a  = <span class=\"number\">1</span>;</span><br><span class=\"line\">a++;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">b++</span><br></pre></td></tr></table></figure>\n\n<p>然而，当变量属于<code>volatile</code>时，指令排序就需要小心了，看看下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> years;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> months;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> days;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果JVM重排指令，像下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> years, <span class=\"keyword\">int</span> months, <span class=\"keyword\">int</span> days)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里将days赋值动作放到了第一位</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.days = days;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.years = years;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.months = months;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当days的顺序变了，months和years的值就无法正确地展现给其他线程。接下来是如何解决这个问题。</p>\n<h2 id=\"Volatile-Happens-Before-Guarantee\"><a href=\"#Volatile-Happens-Before-Guarantee\" class=\"headerlink\" title=\"Volatile Happens-Before Guarantee\"></a>Volatile Happens-Before Guarantee</h2><p><code>volatile</code>关键字提供了一些“保证”，即不会去做的一些操作，以免出现意外。</p>\n<ul>\n<li>如果读/写其他变量出现在写<code>volatile变量</code>之前，那么就不能重排为出现在它之后。当然返回过是允许的。</li>\n<li>如果读/写其他变量出现在读<code>volatile变量</code>之后，那么就不能重排为出现在它之前。</li>\n</ul>\n<h1 id=\"Volatile-is-Not-Always-Enough\"><a href=\"#Volatile-is-Not-Always-Enough\" class=\"headerlink\" title=\"Volatile is Not Always Enough\"></a>Volatile is Not Always Enough</h1><p>很明显，在一开始counter的例子中存在这种情况，读取counter并赋值期间，存在多个线程的竞争状态，都赋值的话会覆盖彼此（往主存中），这时就得采用能保证<code>原子性</code>的操作了，如<strong>syncronized</strong>或者比并发包下的<code>lock</code>了。</p>"},{"title":"SpringBoot startup","date":"2021-02-15T05:18:14.000Z","_content":"\n出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。\n\n<!--more-->\n\n​\t\t使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。\n\n<!--toc-->\n\n# 启动\n\n```java\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n```\n\n这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：\n\n- @SpringBootApplication\n- 调用类SpringApplication的静态方法run，传入启动类的class以及main的args\n\n所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事\n\n- 实例化SpringApplication\n- 调用实例方法run\n\n接下来我们先从实例化看起。\n\n# 实例化\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    // 初始化资源加载器，这里是null\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    // 启动类的class\n    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n    // 判断应用程序的类型\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    // 设置初始化器\n    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    // 设置监听器\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    // 判断启动类\n    this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。\n\n## 应用程序类型\n\n虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。\n\n如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。\n\n```java\nprivate static final String WEBMVC_INDICATOR_CLASS = \"org.springframework.web.servlet.DispatcherServlet\";\n\n\tprivate static final String WEBFLUX_INDICATOR_CLASS = \"org.springframework.web.reactive.DispatcherHandler\";\n\n\tprivate static final String JERSEY_INDICATOR_CLASS = \"org.glassfish.jersey.servlet.ServletContainer\";\n\nstatic WebApplicationType deduceFromClasspath() {\n    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\n        && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\n        return WebApplicationType.REACTIVE;\n    }\n    for (String className : SERVLET_INDICATOR_CLASSES) {\n        if (!ClassUtils.isPresent(className, null)) {\n            return WebApplicationType.NONE;\n        }\n    }\n    return WebApplicationType.SERVLET;\n}\n```\n\n## SPI\n\n在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。\n\n```java\npublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n```\n\nSpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是`ApplicaitonListener`的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。\n\n## 监听器\n\n```properties\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\\norg.springframework.boot.context.logging.LoggingApplicationListener,\\\norg.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener\n```\n\n这里列出一部分的*spring.facories*中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如`ClearCachesApplicationListener`，清除缓存。\n\n这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。\n\n## 初始化器\n\n初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借`ApplicationContextInitializer`）找对应的全类名\n\n```properties\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\\norg.springframework.boot.context.ContextIdApplicationContextInitializer,\\\norg.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\\norg.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\\norg.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ\n```\n\n我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。\n\n# Run\n\n实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。\n\n```java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n    configureHeadlessProperty();\n    // 获取listeners，是listener的持有者\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        // 准备环境\n        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n        configureIgnoreBeanInfo(environment);\n        Banner printedBanner = printBanner(environment);\n        // 创建上下文\n        context = createApplicationContext();\n        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n                                                         new Class[] { ConfigurableApplicationContext.class }, context);\n        // 准备上下文，初始化\n        prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        // 刷新上下文\n        refreshContext(context);\n        afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        callRunners(context, applicationArguments);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, listeners);\n        throw new IllegalStateException(ex);\n    }\n\n    try {\n        listeners.running(context);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, null);\n        throw new IllegalStateException(ex);\n    }\n    return context;\n}\n```\n\n这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。\n\n## RunListeners\n\n通过名字可以看出，`SpringApplicaitonRunListeners`掌握着各种listener，但是不是那么的直接。\n\n```java\nprivate SpringApplicationRunListeners getRunListeners(String[] args) {\n    Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };\n    return new SpringApplicationRunListeners(logger,\n                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n}\n```\n\n可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，`EventPublishingRunListener`。也就是说`SpringApplicationRunListeners`持有类`EventPublishingRunListener`，run方法中的所有listeners的方法内部都是调用`EventPublishingRunListenr`的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？\n\n在`EventPublishingRunListener`的内部持有两个重要的对象，一个广播器`SimpleApplicationEventMulticaster`，例如：\n\n```java\n@Override\npublic void starting() {\n    this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));\n}\n```\n\n开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数`this.application`，这是持有的另一个重要的对象：`SpringApplication`。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将`SpringApplication`传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。\n\n## createApplicationContext\n\n```java\n\tpublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n\t\t\t+ \"annotation.AnnotationConfigApplicationContext\";\n\n\tpublic static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = \"org.springframework.boot.\"\n\t\t\t+ \"web.servlet.context.AnnotationConfigServletWebServerApplicationContext\";\n\n\tpublic static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = \"org.springframework.\"\n\t\t\t+ \"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\";\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n    Class<?> contextClass = this.applicationContextClass;\n    if (contextClass == null) {\n        try {\n            switch (this.webApplicationType) {\n                case SERVLET:\n                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);\n                    break;\n                case REACTIVE:\n                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n                    break;\n                default:\n                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);\n            }\n        }\n        catch (ClassNotFoundException ex) {\n            throw new IllegalStateException(\n                \"Unable create a default ApplicationContext, please specify an ApplicationContextClass\", ex);\n        }\n    }\n    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n```\n\n之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。\n\n## prepareContext\n\n创建完上下文，我们再来看刷新前的准备工作。\n\n```java\nprivate void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,\n                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n    context.setEnvironment(environment);\n    // 后置处理上下文\n    postProcessApplicationContext(context);\n    // 初始化上下文\n    applyInitializers(context);\n    listeners.contextPrepared(context);\n    if (this.logStartupInfo) {\n        logStartupInfo(context.getParent() == null);\n        logStartupProfileInfo(context);\n    }\n    // Add boot specific singleton beans\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n    if (printedBanner != null) {\n        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n    }\n    if (beanFactory instanceof DefaultListableBeanFactory) {\n        ((DefaultListableBeanFactory) beanFactory)\n        .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n    if (this.lazyInitialization) {\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    }\n    // Load the sources\n    Set<Object> sources = getAllSources();\n    Assert.notEmpty(sources, \"Sources must not be empty\");\n    // 创建BeanDefinitionLoader\n    load(context, sources.toArray(new Object[0]));\n    listeners.contextLoaded(context);\n}\n```\n\n准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了*contextPrepared*和*contextLoaded*。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。\n\n### contextPrepared\n\n这个阶段主要做两件事：后置处理，初始化。我们一件一件看。\n\n#### postProcess\n\n```java\nprotected void postProcessApplicationContext(ConfigurableApplicationContext context) {\n    if (this.beanNameGenerator != null) {\n        // 为bean命名\n        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,\n                                                   this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        if (context instanceof GenericApplicationContext) {\n            ((GenericApplicationContext) context).setResourceLoader(this.resourceLoader);\n        }\n        if (context instanceof DefaultResourceLoader) {\n            ((DefaultResourceLoader) context).setClassLoader(this.resourceLoader.getClassLoader());\n        }\n    }\n    if (this.addConversionService) {\n        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());\n    }\n}\n```\n\n这里主要为上下文装配工厂的`beanNameGenerator`、资源加载器和类加载器。\n\n#### applyInitializers\n\n```java\nprotected void applyInitializers(ConfigurableApplicationContext context) {\n    for (ApplicationContextInitializer initializer : getInitializers()) {\n        Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),\n                                                                        ApplicationContextInitializer.class);\n        Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n        initializer.initialize(context);\n    }\n}\n```\n\n之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。\n\n### contextLoaded\n\n这里主要是创建`BeanDefinitionLoader`，用来后续从xml、javaConfig中加载bean。\n\n```java\nprotected void load(ApplicationContext context, Object[] sources) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Loading source \" + StringUtils.arrayToCommaDelimitedString(sources));\n    }\n    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);\n    if (this.beanNameGenerator != null) {\n        loader.setBeanNameGenerator(this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        loader.setResourceLoader(this.resourceLoader);\n    }\n    if (this.environment != null) {\n        loader.setEnvironment(this.environment);\n    }\n    loader.load();\n}\n```\n\n\n\n# 总结\n\n我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：\n\n- 根据应用程序的类型创建对应的上下文\n- 初始化器配置上下文\n- 监听机制响应对应的事件","source":"_posts/SpringBoot-startup.md","raw":"---\ntitle: SpringBoot startup\ndate: 2021-02-15 13:18:14\ncategories: springboot\ntags: source\n---\n\n出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。\n\n<!--more-->\n\n​\t\t使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。\n\n<!--toc-->\n\n# 启动\n\n```java\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n```\n\n这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：\n\n- @SpringBootApplication\n- 调用类SpringApplication的静态方法run，传入启动类的class以及main的args\n\n所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事\n\n- 实例化SpringApplication\n- 调用实例方法run\n\n接下来我们先从实例化看起。\n\n# 实例化\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n    // 初始化资源加载器，这里是null\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    // 启动类的class\n    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n    // 判断应用程序的类型\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    // 设置初始化器\n    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n    // 设置监听器\n    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n    // 判断启动类\n    this.mainApplicationClass = deduceMainApplicationClass();\n}\n```\n\n以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。\n\n## 应用程序类型\n\n虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。\n\n如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。\n\n```java\nprivate static final String WEBMVC_INDICATOR_CLASS = \"org.springframework.web.servlet.DispatcherServlet\";\n\n\tprivate static final String WEBFLUX_INDICATOR_CLASS = \"org.springframework.web.reactive.DispatcherHandler\";\n\n\tprivate static final String JERSEY_INDICATOR_CLASS = \"org.glassfish.jersey.servlet.ServletContainer\";\n\nstatic WebApplicationType deduceFromClasspath() {\n    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\n        && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\n        return WebApplicationType.REACTIVE;\n    }\n    for (String className : SERVLET_INDICATOR_CLASSES) {\n        if (!ClassUtils.isPresent(className, null)) {\n            return WebApplicationType.NONE;\n        }\n    }\n    return WebApplicationType.SERVLET;\n}\n```\n\n## SPI\n\n在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。\n\n```java\npublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n```\n\nSpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是`ApplicaitonListener`的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。\n\n## 监听器\n\n```properties\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\\norg.springframework.boot.context.logging.LoggingApplicationListener,\\\norg.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener\n```\n\n这里列出一部分的*spring.facories*中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如`ClearCachesApplicationListener`，清除缓存。\n\n这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。\n\n## 初始化器\n\n初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借`ApplicationContextInitializer`）找对应的全类名\n\n```properties\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\\norg.springframework.boot.context.ContextIdApplicationContextInitializer,\\\norg.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\\norg.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\\norg.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ\n```\n\n我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。\n\n# Run\n\n实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。\n\n```java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n    configureHeadlessProperty();\n    // 获取listeners，是listener的持有者\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        // 准备环境\n        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n        configureIgnoreBeanInfo(environment);\n        Banner printedBanner = printBanner(environment);\n        // 创建上下文\n        context = createApplicationContext();\n        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n                                                         new Class[] { ConfigurableApplicationContext.class }, context);\n        // 准备上下文，初始化\n        prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        // 刷新上下文\n        refreshContext(context);\n        afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n        }\n        listeners.started(context);\n        callRunners(context, applicationArguments);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, listeners);\n        throw new IllegalStateException(ex);\n    }\n\n    try {\n        listeners.running(context);\n    }\n    catch (Throwable ex) {\n        handleRunFailure(context, ex, exceptionReporters, null);\n        throw new IllegalStateException(ex);\n    }\n    return context;\n}\n```\n\n这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。\n\n## RunListeners\n\n通过名字可以看出，`SpringApplicaitonRunListeners`掌握着各种listener，但是不是那么的直接。\n\n```java\nprivate SpringApplicationRunListeners getRunListeners(String[] args) {\n    Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };\n    return new SpringApplicationRunListeners(logger,\n                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));\n}\n```\n\n可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，`EventPublishingRunListener`。也就是说`SpringApplicationRunListeners`持有类`EventPublishingRunListener`，run方法中的所有listeners的方法内部都是调用`EventPublishingRunListenr`的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？\n\n在`EventPublishingRunListener`的内部持有两个重要的对象，一个广播器`SimpleApplicationEventMulticaster`，例如：\n\n```java\n@Override\npublic void starting() {\n    this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));\n}\n```\n\n开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数`this.application`，这是持有的另一个重要的对象：`SpringApplication`。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将`SpringApplication`传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。\n\n## createApplicationContext\n\n```java\n\tpublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n\t\t\t+ \"annotation.AnnotationConfigApplicationContext\";\n\n\tpublic static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = \"org.springframework.boot.\"\n\t\t\t+ \"web.servlet.context.AnnotationConfigServletWebServerApplicationContext\";\n\n\tpublic static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = \"org.springframework.\"\n\t\t\t+ \"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\";\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n    Class<?> contextClass = this.applicationContextClass;\n    if (contextClass == null) {\n        try {\n            switch (this.webApplicationType) {\n                case SERVLET:\n                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);\n                    break;\n                case REACTIVE:\n                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n                    break;\n                default:\n                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);\n            }\n        }\n        catch (ClassNotFoundException ex) {\n            throw new IllegalStateException(\n                \"Unable create a default ApplicationContext, please specify an ApplicationContextClass\", ex);\n        }\n    }\n    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n```\n\n之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。\n\n## prepareContext\n\n创建完上下文，我们再来看刷新前的准备工作。\n\n```java\nprivate void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,\n                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n    context.setEnvironment(environment);\n    // 后置处理上下文\n    postProcessApplicationContext(context);\n    // 初始化上下文\n    applyInitializers(context);\n    listeners.contextPrepared(context);\n    if (this.logStartupInfo) {\n        logStartupInfo(context.getParent() == null);\n        logStartupProfileInfo(context);\n    }\n    // Add boot specific singleton beans\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n    beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n    if (printedBanner != null) {\n        beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n    }\n    if (beanFactory instanceof DefaultListableBeanFactory) {\n        ((DefaultListableBeanFactory) beanFactory)\n        .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n    }\n    if (this.lazyInitialization) {\n        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n    }\n    // Load the sources\n    Set<Object> sources = getAllSources();\n    Assert.notEmpty(sources, \"Sources must not be empty\");\n    // 创建BeanDefinitionLoader\n    load(context, sources.toArray(new Object[0]));\n    listeners.contextLoaded(context);\n}\n```\n\n准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了*contextPrepared*和*contextLoaded*。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。\n\n### contextPrepared\n\n这个阶段主要做两件事：后置处理，初始化。我们一件一件看。\n\n#### postProcess\n\n```java\nprotected void postProcessApplicationContext(ConfigurableApplicationContext context) {\n    if (this.beanNameGenerator != null) {\n        // 为bean命名\n        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,\n                                                   this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        if (context instanceof GenericApplicationContext) {\n            ((GenericApplicationContext) context).setResourceLoader(this.resourceLoader);\n        }\n        if (context instanceof DefaultResourceLoader) {\n            ((DefaultResourceLoader) context).setClassLoader(this.resourceLoader.getClassLoader());\n        }\n    }\n    if (this.addConversionService) {\n        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());\n    }\n}\n```\n\n这里主要为上下文装配工厂的`beanNameGenerator`、资源加载器和类加载器。\n\n#### applyInitializers\n\n```java\nprotected void applyInitializers(ConfigurableApplicationContext context) {\n    for (ApplicationContextInitializer initializer : getInitializers()) {\n        Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),\n                                                                        ApplicationContextInitializer.class);\n        Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n        initializer.initialize(context);\n    }\n}\n```\n\n之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。\n\n### contextLoaded\n\n这里主要是创建`BeanDefinitionLoader`，用来后续从xml、javaConfig中加载bean。\n\n```java\nprotected void load(ApplicationContext context, Object[] sources) {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Loading source \" + StringUtils.arrayToCommaDelimitedString(sources));\n    }\n    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);\n    if (this.beanNameGenerator != null) {\n        loader.setBeanNameGenerator(this.beanNameGenerator);\n    }\n    if (this.resourceLoader != null) {\n        loader.setResourceLoader(this.resourceLoader);\n    }\n    if (this.environment != null) {\n        loader.setEnvironment(this.environment);\n    }\n    loader.load();\n}\n```\n\n\n\n# 总结\n\n我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：\n\n- 根据应用程序的类型创建对应的上下文\n- 初始化器配置上下文\n- 监听机制响应对应的事件","slug":"SpringBoot-startup","published":1,"updated":"2021-03-28T10:20:02.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkjdk004tts9q5wzxd6gu","content":"<p>出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。</p>\n<span id=\"more\"></span>\n\n<p>​        使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。</p>\n<!--toc-->\n\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MyApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：</p>\n<ul>\n<li>@SpringBootApplication</li>\n<li>调用类SpringApplication的静态方法run，传入启动类的class以及main的args</li>\n</ul>\n<p>所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事</p>\n<ul>\n<li>实例化SpringApplication</li>\n<li>调用实例方法run</li>\n</ul>\n<p>接下来我们先从实例化看起。</p>\n<h1 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringApplication</span><span class=\"params\">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化资源加载器，这里是null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resourceLoader = resourceLoader;</span><br><span class=\"line\">    Assert.notNull(primarySources, <span class=\"string\">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 启动类的class</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.primarySources = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class=\"line\">    <span class=\"comment\">// 判断应用程序的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化器</span></span><br><span class=\"line\">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class=\"line\">    <span class=\"comment\">// 设置监听器</span></span><br><span class=\"line\">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class=\"line\">    <span class=\"comment\">// 判断启动类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。</p>\n<h2 id=\"应用程序类型\"><a href=\"#应用程序类型\" class=\"headerlink\" title=\"应用程序类型\"></a>应用程序类型</h2><p>虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。</p>\n<p>如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBMVC_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBFLUX_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String JERSEY_INDICATOR_CLASS = <span class=\"string\">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> WebApplicationType <span class=\"title\">deduceFromClasspath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class=\"keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> WebApplicationType.REACTIVE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ClassUtils.isPresent(className, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> WebApplicationType.NONE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebApplicationType.SERVLET;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h2><p>在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String FACTORIES_RESOURCE_LOCATION = <span class=\"string\">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>SpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是<code>ApplicaitonListener</code>的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。</p>\n<h2 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationListener</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.ClearCachesApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.builder.ParentContextCloserApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.context.FileEncodingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.AnsiOutputApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.ConfigFileApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.LoggingApplicationListener,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span></span><br></pre></td></tr></table></figure>\n\n<p>这里列出一部分的<em>spring.facories</em>中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如<code>ClearCachesApplicationListener</code>，清除缓存。</p>\n<p>这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。</p>\n<h2 id=\"初始化器\"><a href=\"#初始化器\" class=\"headerlink\" title=\"初始化器\"></a>初始化器</h2><p>初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借<code>ApplicationContextInitializer</code>）找对应的全类名</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationContextInitializer</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.ContextIdApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。</p>\n<h1 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h1><p>实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">    StopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</span><br><span class=\"line\">    stopWatch.start();</span><br><span class=\"line\">    ConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    configureHeadlessProperty();</span><br><span class=\"line\">    <span class=\"comment\">// 获取listeners，是listener的持有者</span></span><br><span class=\"line\">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class=\"line\">    listeners.starting();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(args);</span><br><span class=\"line\">        <span class=\"comment\">// 准备环境</span></span><br><span class=\"line\">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">        configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">        Banner printedBanner = printBanner(environment);</span><br><span class=\"line\">        <span class=\"comment\">// 创建上下文</span></span><br><span class=\"line\">        context = createApplicationContext();</span><br><span class=\"line\">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">                                                         <span class=\"keyword\">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">        <span class=\"comment\">// 准备上下文，初始化</span></span><br><span class=\"line\">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">        <span class=\"comment\">// 刷新上下文</span></span><br><span class=\"line\">        refreshContext(context);</span><br><span class=\"line\">        afterRefresh(context, applicationArguments);</span><br><span class=\"line\">        stopWatch.stop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listeners.started(context);</span><br><span class=\"line\">        callRunners(context, applicationArguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        listeners.running(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。</p>\n<h2 id=\"RunListeners\"><a href=\"#RunListeners\" class=\"headerlink\" title=\"RunListeners\"></a>RunListeners</h2><p>通过名字可以看出，<code>SpringApplicaitonRunListeners</code>掌握着各种listener，但是不是那么的直接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SpringApplicationRunListeners <span class=\"title\">getRunListeners</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] types = <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplicationRunListeners(logger,</span><br><span class=\"line\">                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class=\"keyword\">this</span>, args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，<code>EventPublishingRunListener</code>。也就是说<code>SpringApplicationRunListeners</code>持有类<code>EventPublishingRunListener</code>，run方法中的所有listeners的方法内部都是调用<code>EventPublishingRunListenr</code>的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？</p>\n<p>在<code>EventPublishingRunListener</code>的内部持有两个重要的对象，一个广播器<code>SimpleApplicationEventMulticaster</code>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">starting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.initialMulticaster.multicastEvent(<span class=\"keyword\">new</span> ApplicationStartingEvent(<span class=\"keyword\">this</span>.application, <span class=\"keyword\">this</span>.args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数<code>this.application</code>，这是持有的另一个重要的对象：<code>SpringApplication</code>。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将<code>SpringApplication</code>传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。</p>\n<h2 id=\"createApplicationContext\"><a href=\"#createApplicationContext\" class=\"headerlink\" title=\"createApplicationContext\"></a>createApplicationContext</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.context.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;annotation.AnnotationConfigApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.boot.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableApplicationContext <span class=\"title\">createApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; contextClass = <span class=\"keyword\">this</span>.applicationContextClass;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.webApplicationType) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SERVLET:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> REACTIVE:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。</p>\n<h2 id=\"prepareContext\"><a href=\"#prepareContext\" class=\"headerlink\" title=\"prepareContext\"></a>prepareContext</h2><p>创建完上下文，我们再来看刷新前的准备工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareContext</span><span class=\"params\">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class=\"line\">    context.setEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 后置处理上下文</span></span><br><span class=\"line\">    postProcessApplicationContext(context);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化上下文</span></span><br><span class=\"line\">    applyInitializers(context);</span><br><span class=\"line\">    listeners.contextPrepared(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">        logStartupInfo(context.getParent() == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        logStartupProfileInfo(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Add boot specific singleton beans</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">    beanFactory.registerSingleton(<span class=\"string\">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (printedBanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory <span class=\"keyword\">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class=\"line\">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class=\"line\">        .setAllowBeanDefinitionOverriding(<span class=\"keyword\">this</span>.allowBeanDefinitionOverriding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lazyInitialization) &#123;</span><br><span class=\"line\">        context.addBeanFactoryPostProcessor(<span class=\"keyword\">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Load the sources</span></span><br><span class=\"line\">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class=\"line\">    Assert.notEmpty(sources, <span class=\"string\">&quot;Sources must not be empty&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建BeanDefinitionLoader</span></span><br><span class=\"line\">    load(context, sources.toArray(<span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    listeners.contextLoaded(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了<em>contextPrepared</em>和<em>contextLoaded</em>。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。</p>\n<h3 id=\"contextPrepared\"><a href=\"#contextPrepared\" class=\"headerlink\" title=\"contextPrepared\"></a>contextPrepared</h3><p>这个阶段主要做两件事：后置处理，初始化。我们一件一件看。</p>\n<h4 id=\"postProcess\"><a href=\"#postProcess\" class=\"headerlink\" title=\"postProcess\"></a>postProcess</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessApplicationContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为bean命名</span></span><br><span class=\"line\">        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</span><br><span class=\"line\">                                                   <span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> GenericApplicationContext) &#123;</span><br><span class=\"line\">            ((GenericApplicationContext) context).setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> DefaultResourceLoader) &#123;</span><br><span class=\"line\">            ((DefaultResourceLoader) context).setClassLoader(<span class=\"keyword\">this</span>.resourceLoader.getClassLoader());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addConversionService) &#123;</span><br><span class=\"line\">        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要为上下文装配工厂的<code>beanNameGenerator</code>、资源加载器和类加载器。</p>\n<h4 id=\"applyInitializers\"><a href=\"#applyInitializers\" class=\"headerlink\" title=\"applyInitializers\"></a>applyInitializers</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">applyInitializers</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class=\"line\">                                                                        ApplicationContextInitializer.class);</span><br><span class=\"line\">        Assert.isInstanceOf(requiredType, context, <span class=\"string\">&quot;Unable to call initializer.&quot;</span>);</span><br><span class=\"line\">        initializer.initialize(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。</p>\n<h3 id=\"contextLoaded\"><a href=\"#contextLoaded\" class=\"headerlink\" title=\"contextLoaded\"></a>contextLoaded</h3><p>这里主要是创建<code>BeanDefinitionLoader</code>，用来后续从xml、javaConfig中加载bean。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setBeanNameGenerator(<span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setEnvironment(<span class=\"keyword\">this</span>.environment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loader.load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：</p>\n<ul>\n<li>根据应用程序的类型创建对应的上下文</li>\n<li>初始化器配置上下文</li>\n<li>监听机制响应对应的事件</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>出个系列总结一下SpringBoot，会偏底层一些。这篇主要介绍SpringBoot的大致启动过程，细节会在稍后文章中讲解。</p>","more":"<p>​        使用SpringBoot会让人感到清爽，没有那么多的配置文件。笔者曾参与过Spring和Struts2的项目，虽然时间不长，但仍感受到了配置文件的复杂，难以维护。后来使用SpringBoot做web应用，只需一个程序入口main方法，启动后便能使用，无形中它帮助我们配置了一切，如果想修改，这一切也可以在properties/yml中修改。从软件工程学的角度来看，Spring是非常成功的产品，SpringBoot则更贴近用户，“约定大于配置。并不是很神奇的不用配置，而是在启动时帮助我们配置好了，除了自动配置，我们还会看看他的IOC、AOP的实现，包括常用的web服务器也内嵌在里面，所以接下来几篇我们会一探究竟。</p>\n<!--toc-->\n\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MyApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是SpringBoot的启动类入口，在resources目录下还会有配置文件，在启动类中我们要做的事情就两个：</p>\n<ul>\n<li>@SpringBootApplication</li>\n<li>调用类SpringApplication的静态方法run，传入启动类的class以及main的args</li>\n</ul>\n<p>所以，通过这个静态方法run，肯定会对启动类上的注解以及配置文件进行解析。跟进静态方法run，我们会发现他做了两件事</p>\n<ul>\n<li>实例化SpringApplication</li>\n<li>调用实例方法run</li>\n</ul>\n<p>接下来我们先从实例化看起。</p>\n<h1 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SpringApplication</span><span class=\"params\">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化资源加载器，这里是null</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resourceLoader = resourceLoader;</span><br><span class=\"line\">    Assert.notNull(primarySources, <span class=\"string\">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 启动类的class</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.primarySources = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class=\"line\">    <span class=\"comment\">// 判断应用程序的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化器</span></span><br><span class=\"line\">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class=\"line\">    <span class=\"comment\">// 设置监听器</span></span><br><span class=\"line\">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class=\"line\">    <span class=\"comment\">// 判断启动类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是实例化，实例化并不复杂，也只是做些简单的工作，着重说一下应用程序类型、初始化器和监听器，后面会再次用到。</p>\n<h2 id=\"应用程序类型\"><a href=\"#应用程序类型\" class=\"headerlink\" title=\"应用程序类型\"></a>应用程序类型</h2><p>虽然平时用SpringBoot最多的是作web程序开发，但是他支持的类型不止web，Spring中有上下文，后续会根据应用的类型去创建对应的上下文，所以会在这里做判断。</p>\n<p>如果是web类型的，SpringBoot会启动内嵌的web服务器，否则不会，而web服务器也分为响应的和非响应两种。如何判断呢？编译后会根据全类名判断是否有相应的class，如果要应用是web相关的，自然会引入相关的class。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBMVC_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String WEBFLUX_INDICATOR_CLASS = <span class=\"string\">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String JERSEY_INDICATOR_CLASS = <span class=\"string\">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> WebApplicationType <span class=\"title\">deduceFromClasspath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class=\"keyword\">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> WebApplicationType.REACTIVE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ClassUtils.isPresent(className, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> WebApplicationType.NONE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WebApplicationType.SERVLET;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h2><p>在说监听器和初始化器之前，我们先来说说SPI。跟进前两者的代码发现，他们的初始化逻辑是相同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String FACTORIES_RESOURCE_LOCATION = <span class=\"string\">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>SpringBoot会通过类加载器遍历上面的文件，文件属于配置文件，里面以key-value的形式放入了数据，例如监听器的入参是<code>ApplicaitonListener</code>的class，根据这个会找出对应的其他全类名，取出后再通过反射去初始化这些类。然后装入对应的容器。</p>\n<h2 id=\"监听器\"><a href=\"#监听器\" class=\"headerlink\" title=\"监听器\"></a>监听器</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationListener</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.ClearCachesApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.builder.ParentContextCloserApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\</span><br><span class=\"line\">org.springframework.boot.context.FileEncodingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.AnsiOutputApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.ConfigFileApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\</span><br><span class=\"line\">org.springframework.boot.context.logging.LoggingApplicationListener,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span></span><br></pre></td></tr></table></figure>\n\n<p>这里列出一部分的<em>spring.facories</em>中的listener，可以发现每个listener都有其对应的功能，与之相对应的是event，对于每个事件也有他对应的类。由于类数量多，且职责明确，他类中的内容是很少的，只是对传入的对象进行处理，比如<code>ClearCachesApplicationListener</code>，清除缓存。</p>\n<p>这些类只是监听，换句话说是需要被动触发，目前只是初始化阶段，等后续run的时候会初始化事件广播等其他对象，会与这些监听器一起配合使用。这些监听器被初始化完成后会存放在List容器中。</p>\n<h2 id=\"初始化器\"><a href=\"#初始化器\" class=\"headerlink\" title=\"初始化器\"></a>初始化器</h2><p>初始化器听起来是初始化用的，初始化什么呢？我们先看文件下对应的初始化器（与监听器同理，他是凭借<code>ApplicationContextInitializer</code>）找对应的全类名</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">org.springframework.context.ApplicationContextInitializer</span>=<span class=\"string\">\\</span></span><br><span class=\"line\">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.ContextIdApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\</span><br><span class=\"line\">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\</span><br><span class=\"line\"><span class=\"attr\">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializ</span></span><br></pre></td></tr></table></figure>\n\n<p>我们知道context是Spring的核心，不同类型的应用程序上下文都不一样，上下文 这个对象也会有中众多属性，这些初始化器就起到了初始化上下文的功能。例如地一个就是设置warnings的。只是目前是将这些类初始化，并将对象放入List容器。他们实现了相同的接口，后续也会向监听器一般被触发，然后遍历这些初始化器将传入的上下文初始化（对属性赋值）。</p>\n<h1 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h1><p>实例化完成后就是调用实例方法run了。总共就实例化和run两件事，实例化不复杂，那么是事情都落在了run上了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">    StopWatch stopWatch = <span class=\"keyword\">new</span> StopWatch();</span><br><span class=\"line\">    stopWatch.start();</span><br><span class=\"line\">    ConfigurableApplicationContext context = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    configureHeadlessProperty();</span><br><span class=\"line\">    <span class=\"comment\">// 获取listeners，是listener的持有者</span></span><br><span class=\"line\">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class=\"line\">    listeners.starting();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ApplicationArguments applicationArguments = <span class=\"keyword\">new</span> DefaultApplicationArguments(args);</span><br><span class=\"line\">        <span class=\"comment\">// 准备环境</span></span><br><span class=\"line\">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class=\"line\">        configureIgnoreBeanInfo(environment);</span><br><span class=\"line\">        Banner printedBanner = printBanner(environment);</span><br><span class=\"line\">        <span class=\"comment\">// 创建上下文</span></span><br><span class=\"line\">        context = createApplicationContext();</span><br><span class=\"line\">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class=\"line\">                                                         <span class=\"keyword\">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class=\"line\">        <span class=\"comment\">// 准备上下文，初始化</span></span><br><span class=\"line\">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">        <span class=\"comment\">// 刷新上下文</span></span><br><span class=\"line\">        refreshContext(context);</span><br><span class=\"line\">        afterRefresh(context, applicationArguments);</span><br><span class=\"line\">        stopWatch.stop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> StartupInfoLogger(<span class=\"keyword\">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        listeners.started(context);</span><br><span class=\"line\">        callRunners(context, applicationArguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        listeners.running(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">        handleRunFailure(context, ex, exceptionReporters, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这部分内容较多，我们先承接初始化将上下文的准备工作说一说，其余的在后面的文章说再提。</p>\n<h2 id=\"RunListeners\"><a href=\"#RunListeners\" class=\"headerlink\" title=\"RunListeners\"></a>RunListeners</h2><p>通过名字可以看出，<code>SpringApplicaitonRunListeners</code>掌握着各种listener，但是不是那么的直接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SpringApplicationRunListeners <span class=\"title\">getRunListeners</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] types = <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SpringApplicationRunListeners(logger,</span><br><span class=\"line\">                                             getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class=\"keyword\">this</span>, args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，与获取监听器、初始化器的方式如出一辙。这里获取到的类只有一个，<code>EventPublishingRunListener</code>。也就是说<code>SpringApplicationRunListeners</code>持有类<code>EventPublishingRunListener</code>，run方法中的所有listeners的方法内部都是调用<code>EventPublishingRunListenr</code>的，相当于他的代理类。后者的内部又是如何实现的，如何关联之前实例化的listeners呢？</p>\n<p>在<code>EventPublishingRunListener</code>的内部持有两个重要的对象，一个广播器<code>SimpleApplicationEventMulticaster</code>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">starting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.initialMulticaster.multicastEvent(<span class=\"keyword\">new</span> ApplicationStartingEvent(<span class=\"keyword\">this</span>.application, <span class=\"keyword\">this</span>.args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始监听，会创建一个相应的事件，并将其广播出去。注意到一个参数<code>this.application</code>，这是持有的另一个重要的对象：<code>SpringApplication</code>。前面提到，有对他进行实例化，实例化的时候会设置两个属性：初始化器和监听器。这里将<code>SpringApplication</code>传进去，后续自然会通过get方法去获取到listeners，再触发对应event的listener。</p>\n<h2 id=\"createApplicationContext\"><a href=\"#createApplicationContext\" class=\"headerlink\" title=\"createApplicationContext\"></a>createApplicationContext</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.context.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;annotation.AnnotationConfigApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.boot.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class=\"string\">&quot;org.springframework.&quot;</span></span><br><span class=\"line\">\t\t\t+ <span class=\"string\">&quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableApplicationContext <span class=\"title\">createApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; contextClass = <span class=\"keyword\">this</span>.applicationContextClass;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.webApplicationType) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> SERVLET:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> REACTIVE:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                <span class=\"string\">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前有提到，初始化的时候设置了应用程序类型，在这里会根据这个类型去创建对应的上下文，同样是通过反射进行的。</p>\n<h2 id=\"prepareContext\"><a href=\"#prepareContext\" class=\"headerlink\" title=\"prepareContext\"></a>prepareContext</h2><p>创建完上下文，我们再来看刷新前的准备工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareContext</span><span class=\"params\">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class=\"line\">    context.setEnvironment(environment);</span><br><span class=\"line\">    <span class=\"comment\">// 后置处理上下文</span></span><br><span class=\"line\">    postProcessApplicationContext(context);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化上下文</span></span><br><span class=\"line\">    applyInitializers(context);</span><br><span class=\"line\">    listeners.contextPrepared(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logStartupInfo) &#123;</span><br><span class=\"line\">        logStartupInfo(context.getParent() == <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        logStartupProfileInfo(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Add boot specific singleton beans</span></span><br><span class=\"line\">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class=\"line\">    beanFactory.registerSingleton(<span class=\"string\">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (printedBanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory <span class=\"keyword\">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class=\"line\">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class=\"line\">        .setAllowBeanDefinitionOverriding(<span class=\"keyword\">this</span>.allowBeanDefinitionOverriding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lazyInitialization) &#123;</span><br><span class=\"line\">        context.addBeanFactoryPostProcessor(<span class=\"keyword\">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Load the sources</span></span><br><span class=\"line\">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class=\"line\">    Assert.notEmpty(sources, <span class=\"string\">&quot;Sources must not be empty&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建BeanDefinitionLoader</span></span><br><span class=\"line\">    load(context, sources.toArray(<span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    listeners.contextLoaded(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>准备工作也不少，listeners的响应一个比较好的阶段划分标志。可以看到分为了<em>contextPrepared</em>和<em>contextLoaded</em>。前者主要是对上下文的处理，后者是对上下文中的工厂属性进行处理，后续得用工厂去生产bean。</p>\n<h3 id=\"contextPrepared\"><a href=\"#contextPrepared\" class=\"headerlink\" title=\"contextPrepared\"></a>contextPrepared</h3><p>这个阶段主要做两件事：后置处理，初始化。我们一件一件看。</p>\n<h4 id=\"postProcess\"><a href=\"#postProcess\" class=\"headerlink\" title=\"postProcess\"></a>postProcess</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessApplicationContext</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 为bean命名</span></span><br><span class=\"line\">        context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</span><br><span class=\"line\">                                                   <span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> GenericApplicationContext) &#123;</span><br><span class=\"line\">            ((GenericApplicationContext) context).setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> DefaultResourceLoader) &#123;</span><br><span class=\"line\">            ((DefaultResourceLoader) context).setClassLoader(<span class=\"keyword\">this</span>.resourceLoader.getClassLoader());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.addConversionService) &#123;</span><br><span class=\"line\">        context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要为上下文装配工厂的<code>beanNameGenerator</code>、资源加载器和类加载器。</p>\n<h4 id=\"applyInitializers\"><a href=\"#applyInitializers\" class=\"headerlink\" title=\"applyInitializers\"></a>applyInitializers</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">applyInitializers</span><span class=\"params\">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),</span><br><span class=\"line\">                                                                        ApplicationContextInitializer.class);</span><br><span class=\"line\">        Assert.isInstanceOf(requiredType, context, <span class=\"string\">&quot;Unable to call initializer.&quot;</span>);</span><br><span class=\"line\">        initializer.initialize(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前提到的初始化器，在这里会对刚生成的上下文进行初始化，配置相关属性。</p>\n<h3 id=\"contextLoaded\"><a href=\"#contextLoaded\" class=\"headerlink\" title=\"contextLoaded\"></a>contextLoaded</h3><p>这里主要是创建<code>BeanDefinitionLoader</code>，用来后续从xml、javaConfig中加载bean。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">(ApplicationContext context, Object[] sources)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(<span class=\"string\">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.beanNameGenerator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setBeanNameGenerator(<span class=\"keyword\">this</span>.beanNameGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.resourceLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setResourceLoader(<span class=\"keyword\">this</span>.resourceLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.environment != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        loader.setEnvironment(<span class=\"keyword\">this</span>.environment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loader.load();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们启动SpringBoot很简单，实际上内部做了非常多的事情，正是这些“约定”简化了我们的使用。核心是围绕着上下文来做的：</p>\n<ul>\n<li>根据应用程序的类型创建对应的上下文</li>\n<li>初始化器配置上下文</li>\n<li>监听机制响应对应的事件</li>\n</ul>"},{"title":"mq","date":"2020-07-20T13:04:40.000Z","_content":"\nmq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。\n\n<!--more-->\n\n# MQ的引入\n\n模拟几个场景：\n\n1. `学生模块`和`老师模块`。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。\n\n   解决方式：引入`班长模块`，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。\n\n2. `系统A`需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。\n\n   上线后又新增了一个需求，`D`也要接收`A`的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对`A`进行改造，开发、联调效率低，耦合严重，增加`A`的负担。\n\n## 好处\n\n- 解决耦合  当新的模块接进来时，可以做到代码改动最小\n\n- 异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力\n\n- 削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨\n\n# 订阅模式\n\n| 比较项目   | Topic模式队列                                                | Queue模式队列                                                |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 工作模式   | ”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。 | ”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。 |\n| 有无状态   | 无状态                                                       | Queue数据默认会在mq服务器上以文件形式保存                    |\n| 传递完整性 | 如果没有订阅者，消息会被丢弃。不完整。                       | 消息不会丢弃                                                 |\n| 处理效率   | 由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异 | 由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的 |\n\n# JMS\n\nJava消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。\n\n实现JMS接口和规范的消息中间件，即我们的MQ服务器。\n\n## MESSAGE\n\nJMS message的组成：消息头 + 消息体 + 消息属性\n\n### 消息头\n\n记录常用的\n\n- JMSDestination 消息发送的目的地，Queue或Topic\n\n- JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。\n\n- JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除\n\n- JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通\n\n- JMSMessgeID 唯一ID，判断是否重复消费，幂等性\n\n### 消息体\n\n封装具体消息数据，5种格式。（使用频率高）\n\n- TextMessage 普通字符串消息 （使用频率高）\n\n- MapMessage map类型消息，key为String类型，值为Java基本数据类型\n\n- BytesMessage 二进制数组消息\n\n- StreamMessage 流\n\n- ObjectMessage 可序列化的Java对象\n\n发送和接受的消息类型必须一致。\n\n### 消息属性\n\n如果需要除消息头字段以外的值，那么可以使用消息属性。\n\n```java\nTextMessage tm = session.createTextMessage(\"wa wa\");\ntm.setStringProperty(\"c01\",\"vip\"); // 增加属性\n\n\nTextMessage tms = (TextMessage) messge;\nSystem.out.println(tms.getStringProperty(\"c01\")); // 接收\n```\n\n# 可靠性\n\nMQ挂了，消息的持久话和丢失的情况如何？一般有**三个特征**来保障：持久化、事务、签收，其中**事务偏生产者，签收偏消费者**。此外对于对于宕机，还有**多节点集群**。\n\n## 持久化 PERSISTENT\n\n参考redis的持久化（有rdb和aof），消息也有类似的辅助。\n\n### QUEUE\n\n#### 参数设置\n\n1. 非持久 服务器宕机，消息不存在\n\n   > messaegeProducer.setDeliveryMode(DeliveryMode.*NON_PRESISTENT*);\n\n2. 持久化 服务器宕机后消息依然存在\n\n   > messageProducer.setDelieveryMode(DeliveryMode._PRESISTENT_);\n\n#### 模拟场景\n\n非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。\n\n持久化时，上述操作后，数据依然存在。\n\n在队列中，如果**不显示标注持久**，**默认持久化**，因为可靠性是优先考虑的因素。\n\n持久、事物、签收\n\n### TOPIC\n\n对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：\n\n1. 先运行一次消费者，等于向MQ注册\n\n2. 然后再运行生产者发送信息\n\n3. 消费者一定会收到订阅消息。不在线的话下次连接时会接收。\n\n## 事务 TRANSACTION\n\n数据库的事务、ACID、隔离级别\n\n```java\n// 创建session的第一个参数即 事务是否开启\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n### 生产者\n\n- false 关闭事务，只要执行`send`就进入到队列中\n\n- true 开启事物，先执行`send`再执行`commit`，消息才被真正提交到队列中。\n\n对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。\n\n```java\ntry{\n    // ok session.commit;\n}catch (Exception e){\n    // error\n    session.rollback();\n}finally{\n    if(null != session){\n        session.close();\n    }\n}\n```\n\n### 消费者\n\n创建session时将事务改为`true`，同样需要`commit`，否则事务会被重复消费。\n\n## 签收 ACKNOWLEDGE\n\n分为事务和非事务两种情况\n\n#### 非事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n- 自动签收（默认）   **AUTO_ACKNOWLEDGE**  （使用频率高）\n\n- 手动签收 **CLIENT_ACKNOWLEDGE** （使用频率高）\n\n- 允许重复消息 **DUPS_OK_ACKNOWLEDGE**\n\n手动签收时需要手动标记，否则会造成重复消费：\n\n```java\nTextMessage tm = (TextMessage)messageConsumer.receive(4000L);\nif(null != tm){\n    tm.acknowledge();\n}else{\n    break;\n}\n// ...\n```\n\n### 事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n```\n\n有事务就需要`commit`。\n\n## 点对点\n\n基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的**异步传输**成为可能。类比平时的即时通讯工具。\n\n- 如果在**Session**关闭时有部分消息已被收到但还没有签收（**acknowledge**)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）\n\n- 队列可以长久地保存消息直到消费者收到消息。**消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态**，充分体现了异步传输模式的优势。\n\n## 发布订阅\n\nJMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作**topic**，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。\n\n### 非持久\n\n对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。\n\n### 持久化\n\n客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。\n\n# BROKER\n\n集群、配置时会用到。\n\n相当于一个ActiveMQ服务器**实例**，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。\n\n之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.\n\n## 消息发送模式\n\nActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。\n\n`ActiveMQ默认使用异步发送的模式`，**同步发送有两种情况**：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。\n\n异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，`允许在失败的情况下有少量的数据丢失`。\n\n# ACTIVEMQ的传输协议\n\nQ: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？\n\n调优：使用NIO传输协议\n\n支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）\n\n| 协议   | 描述                                |\n| ------ | ----------------------------------- |\n| TCP    | 默认的协议，性能相对可以            |\n| NIO    | 基于TCP协议之上的，进行了扩展和优化 |\n| HTP(s) | 基于HTTP(s)                         |\n\n## NIO\n\n要换为NIO，需要修改`activemq.xml`配置文件。\n\n```xml\n<broker>\n    ...\n        <transportConnectors>\n            <transportConnector name=\"nio\" uri=\"nio://192.168.111.136\"/>\n        </transportConnectors>\n    ...\n</broker>\n```\n\n在消费者、生产者修改代码，指定传输协议：\n\n```java\npublic stati final String ACTIVEMQ_URL = \"nio://192.168.111.136\";\n\n\npublic static void main(String[] args){\n    ActiveMQConnectionFactory af = new ActiveMQConnectionFactory(ACTIVEMQ_URL);\n    ......\n}\n```\n\n### 增强\n\nQ: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持`openwire（TCP）`，如何让这个端口支持NIO，又支持多个协议呢？\n\n默认是`BIO+TCP`，目前是`NIO+TCP`，那么如何做到`NIO+TCP/Mqtt/stomp`。\n\nA: 开启多协议支持，用`auto`关键字，[reference](https://activemq.apache.org/auto)。\n\n```xml\n<transportConnector name=\"auto\" uri=\"auto://localhost:5761\"/>\n```\n\n**note:** 在activeMQ后台配置面板的`Network`可以查看开启的网络协议。\n\n# ACTIVEMQ的存储和可持久化\n\n对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会`采用持久化机制`（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。\n\n主要介绍两个DB：`KahaDB`, `LevelDB`, `JDBC`\n\nQ: AMQ持久化机制\n\n## KahaDB\n\n基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。\n\n在配置文件中，有：\n\n```xml\n<persistenceAdapter>\n    <kahaDB directory=\"${activemq.data}/kahadb\"/>\n</persistenceAdpter>\n```\n\n### 存储原理\n\nreference [here](https:/activemq.apache.org/kahadb)\n\n可用于任何场合，提高了性能和恢复能力。消息存储使用一个**事务日志**和一个**索引文件**（存储所有地址）。\n\nKahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）\n\n#### db\\<Number\\>.log\n\n存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。\n\n#### db.data\n\n包含了持久化的`BTree索引`，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向`db-\\<Number>.log`里面存储的消息。\n\n#### db.free\n\n当前`db.data`文件里哪些页面是空闲的，文件具体内容是所有空闲页的**ID**. 类比linux的bash命令`free`。\n\n#### db.redo\n\n用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。\n\n#### lock\n\n相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。\n\n## JDBC\n\n主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。\n\n## LevelDB\n\n## JDBC Message store with ActiveMQ Journal\n\n主要。\n\n# Q&A\n\n1. 引入消息队列后该如何保证其高可用性\n\n2. 异步投递Async Sends\n\n3. 延迟投递和定时投递\n\n4. 分发策略\n\n5. ActiveMQ消费重试机制\n\n6. 死信队列\n\n7. 如何保证消息不被重复消费呢？谈谈幂等性问题\n\n## 高可用\n\nzookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。\n\n## 异步投递\n\n如何确认发送成功？ \n\n在消息发送完后接收回调。\n\n```java\nActiveMQConnectionFacotry acf = new ActiveMQConnectionFactory(URL);\n// 设置为异步发送消息\nacf.setUseAsyncSend(true);\nActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);\n...\nTextMessage message = session.createTextMessage();\n// 未message设置属性\nmessage.setJMSMessageID(UUID.randomUUID().toString());\n\n// 使用带有回调的send方法来发送\namp.send(message, new AsyncCallback(){\n    @Override\n    public void onSucces(){\n\n        System.out.println(message.getJMSmessageID+\" succeed\")\n    }\n    @Override\n    public void onException(JMSException exception){\n        // 拿到属性来确认发送失败的消息\n        System.out.println(message.getJMSmessageID+\" fail\")\n    }\n})\n```\n\n## 延迟投递和定时投递\n\n参考[官网说明](http://activemq.apache.org/delay-and-schedule-message-delivery.html)\n\n| Property name          | type   | description        |\n| ---------------------- | ------ | ------------------ |\n| AMQ\\_SCHEDULED\\_DELAY  | long   | 延迟投递的时间     |\n| AMQ\\_SCHEDULED\\_PERIOD | long   | 重复投递的时间间隔 |\n| AMQ\\_SCHEDULED\\_REPEAT | int    | 重复投递次数       |\n| AMQ\\_SCHEDULED\\_CRON   | String | Cron表达式         |\n\n在`activemq.xml`中配置*schedulerSupport*属性为*true*且Java代码中封装的辅助消息类型为*ScheduledMessage*即可。\n\n```java\nlong delay = 3 * 1000; //延迟投递的时间，每3秒\nlong period = 4 * 1000;\nint repeat = 5;\n\nTextMessage message = session.createTextMessage();\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);\nmessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);\n\nmessageProducer.send(mesage);\n...\n```\n\n## ActiveMQ消费重试机制\n\n- 哪些情况会引起消息重发？\n\n- 消息重发时间间隔和重发次数\n\n- 有毒消息Posion ACK\n\nreference [here](activemq.apache.org/redelivery-policy)\n\n重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。\n\n## 如何保证消息不被重复消费（幂等性）\n\n**note**: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。\n\n- 如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突\n\n- 使用第三方服务来做消费记录。以redis为例，给消息分配一个**全局id**，只要消费过该消息，将\\<id, message\\>以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。","source":"_posts/mq.md","raw":"---\ntitle: mq\ndate: 2020-07-20 21:04:40\ncategories: MiddleWare\ntags: activemq\n---\n\nmq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。\n\n<!--more-->\n\n# MQ的引入\n\n模拟几个场景：\n\n1. `学生模块`和`老师模块`。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。\n\n   解决方式：引入`班长模块`，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。\n\n2. `系统A`需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。\n\n   上线后又新增了一个需求，`D`也要接收`A`的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对`A`进行改造，开发、联调效率低，耦合严重，增加`A`的负担。\n\n## 好处\n\n- 解决耦合  当新的模块接进来时，可以做到代码改动最小\n\n- 异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力\n\n- 削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨\n\n# 订阅模式\n\n| 比较项目   | Topic模式队列                                                | Queue模式队列                                                |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 工作模式   | ”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。 | ”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。 |\n| 有无状态   | 无状态                                                       | Queue数据默认会在mq服务器上以文件形式保存                    |\n| 传递完整性 | 如果没有订阅者，消息会被丢弃。不完整。                       | 消息不会丢弃                                                 |\n| 处理效率   | 由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异 | 由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的 |\n\n# JMS\n\nJava消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。\n\n实现JMS接口和规范的消息中间件，即我们的MQ服务器。\n\n## MESSAGE\n\nJMS message的组成：消息头 + 消息体 + 消息属性\n\n### 消息头\n\n记录常用的\n\n- JMSDestination 消息发送的目的地，Queue或Topic\n\n- JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。\n\n- JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除\n\n- JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通\n\n- JMSMessgeID 唯一ID，判断是否重复消费，幂等性\n\n### 消息体\n\n封装具体消息数据，5种格式。（使用频率高）\n\n- TextMessage 普通字符串消息 （使用频率高）\n\n- MapMessage map类型消息，key为String类型，值为Java基本数据类型\n\n- BytesMessage 二进制数组消息\n\n- StreamMessage 流\n\n- ObjectMessage 可序列化的Java对象\n\n发送和接受的消息类型必须一致。\n\n### 消息属性\n\n如果需要除消息头字段以外的值，那么可以使用消息属性。\n\n```java\nTextMessage tm = session.createTextMessage(\"wa wa\");\ntm.setStringProperty(\"c01\",\"vip\"); // 增加属性\n\n\nTextMessage tms = (TextMessage) messge;\nSystem.out.println(tms.getStringProperty(\"c01\")); // 接收\n```\n\n# 可靠性\n\nMQ挂了，消息的持久话和丢失的情况如何？一般有**三个特征**来保障：持久化、事务、签收，其中**事务偏生产者，签收偏消费者**。此外对于对于宕机，还有**多节点集群**。\n\n## 持久化 PERSISTENT\n\n参考redis的持久化（有rdb和aof），消息也有类似的辅助。\n\n### QUEUE\n\n#### 参数设置\n\n1. 非持久 服务器宕机，消息不存在\n\n   > messaegeProducer.setDeliveryMode(DeliveryMode.*NON_PRESISTENT*);\n\n2. 持久化 服务器宕机后消息依然存在\n\n   > messageProducer.setDelieveryMode(DeliveryMode._PRESISTENT_);\n\n#### 模拟场景\n\n非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。\n\n持久化时，上述操作后，数据依然存在。\n\n在队列中，如果**不显示标注持久**，**默认持久化**，因为可靠性是优先考虑的因素。\n\n持久、事物、签收\n\n### TOPIC\n\n对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：\n\n1. 先运行一次消费者，等于向MQ注册\n\n2. 然后再运行生产者发送信息\n\n3. 消费者一定会收到订阅消息。不在线的话下次连接时会接收。\n\n## 事务 TRANSACTION\n\n数据库的事务、ACID、隔离级别\n\n```java\n// 创建session的第一个参数即 事务是否开启\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n### 生产者\n\n- false 关闭事务，只要执行`send`就进入到队列中\n\n- true 开启事物，先执行`send`再执行`commit`，消息才被真正提交到队列中。\n\n对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。\n\n```java\ntry{\n    // ok session.commit;\n}catch (Exception e){\n    // error\n    session.rollback();\n}finally{\n    if(null != session){\n        session.close();\n    }\n}\n```\n\n### 消费者\n\n创建session时将事务改为`true`，同样需要`commit`，否则事务会被重复消费。\n\n## 签收 ACKNOWLEDGE\n\n分为事务和非事务两种情况\n\n#### 非事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n```\n\n- 自动签收（默认）   **AUTO_ACKNOWLEDGE**  （使用频率高）\n\n- 手动签收 **CLIENT_ACKNOWLEDGE** （使用频率高）\n\n- 允许重复消息 **DUPS_OK_ACKNOWLEDGE**\n\n手动签收时需要手动标记，否则会造成重复消费：\n\n```java\nTextMessage tm = (TextMessage)messageConsumer.receive(4000L);\nif(null != tm){\n    tm.acknowledge();\n}else{\n    break;\n}\n// ...\n```\n\n### 事务\n\n```java\n// 创建session的第个参数即 签收类型\nSession session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n```\n\n有事务就需要`commit`。\n\n## 点对点\n\n基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的**异步传输**成为可能。类比平时的即时通讯工具。\n\n- 如果在**Session**关闭时有部分消息已被收到但还没有签收（**acknowledge**)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）\n\n- 队列可以长久地保存消息直到消费者收到消息。**消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态**，充分体现了异步传输模式的优势。\n\n## 发布订阅\n\nJMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作**topic**，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。\n\n### 非持久\n\n对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。\n\n### 持久化\n\n客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。\n\n# BROKER\n\n集群、配置时会用到。\n\n相当于一个ActiveMQ服务器**实例**，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。\n\n之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.\n\n## 消息发送模式\n\nActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。\n\n`ActiveMQ默认使用异步发送的模式`，**同步发送有两种情况**：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。\n\n异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，`允许在失败的情况下有少量的数据丢失`。\n\n# ACTIVEMQ的传输协议\n\nQ: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？\n\n调优：使用NIO传输协议\n\n支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）\n\n| 协议   | 描述                                |\n| ------ | ----------------------------------- |\n| TCP    | 默认的协议，性能相对可以            |\n| NIO    | 基于TCP协议之上的，进行了扩展和优化 |\n| HTP(s) | 基于HTTP(s)                         |\n\n## NIO\n\n要换为NIO，需要修改`activemq.xml`配置文件。\n\n```xml\n<broker>\n    ...\n        <transportConnectors>\n            <transportConnector name=\"nio\" uri=\"nio://192.168.111.136\"/>\n        </transportConnectors>\n    ...\n</broker>\n```\n\n在消费者、生产者修改代码，指定传输协议：\n\n```java\npublic stati final String ACTIVEMQ_URL = \"nio://192.168.111.136\";\n\n\npublic static void main(String[] args){\n    ActiveMQConnectionFactory af = new ActiveMQConnectionFactory(ACTIVEMQ_URL);\n    ......\n}\n```\n\n### 增强\n\nQ: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持`openwire（TCP）`，如何让这个端口支持NIO，又支持多个协议呢？\n\n默认是`BIO+TCP`，目前是`NIO+TCP`，那么如何做到`NIO+TCP/Mqtt/stomp`。\n\nA: 开启多协议支持，用`auto`关键字，[reference](https://activemq.apache.org/auto)。\n\n```xml\n<transportConnector name=\"auto\" uri=\"auto://localhost:5761\"/>\n```\n\n**note:** 在activeMQ后台配置面板的`Network`可以查看开启的网络协议。\n\n# ACTIVEMQ的存储和可持久化\n\n对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会`采用持久化机制`（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。\n\n主要介绍两个DB：`KahaDB`, `LevelDB`, `JDBC`\n\nQ: AMQ持久化机制\n\n## KahaDB\n\n基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。\n\n在配置文件中，有：\n\n```xml\n<persistenceAdapter>\n    <kahaDB directory=\"${activemq.data}/kahadb\"/>\n</persistenceAdpter>\n```\n\n### 存储原理\n\nreference [here](https:/activemq.apache.org/kahadb)\n\n可用于任何场合，提高了性能和恢复能力。消息存储使用一个**事务日志**和一个**索引文件**（存储所有地址）。\n\nKahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）\n\n#### db\\<Number\\>.log\n\n存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。\n\n#### db.data\n\n包含了持久化的`BTree索引`，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向`db-\\<Number>.log`里面存储的消息。\n\n#### db.free\n\n当前`db.data`文件里哪些页面是空闲的，文件具体内容是所有空闲页的**ID**. 类比linux的bash命令`free`。\n\n#### db.redo\n\n用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。\n\n#### lock\n\n相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。\n\n## JDBC\n\n主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。\n\n## LevelDB\n\n## JDBC Message store with ActiveMQ Journal\n\n主要。\n\n# Q&A\n\n1. 引入消息队列后该如何保证其高可用性\n\n2. 异步投递Async Sends\n\n3. 延迟投递和定时投递\n\n4. 分发策略\n\n5. ActiveMQ消费重试机制\n\n6. 死信队列\n\n7. 如何保证消息不被重复消费呢？谈谈幂等性问题\n\n## 高可用\n\nzookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。\n\n## 异步投递\n\n如何确认发送成功？ \n\n在消息发送完后接收回调。\n\n```java\nActiveMQConnectionFacotry acf = new ActiveMQConnectionFactory(URL);\n// 设置为异步发送消息\nacf.setUseAsyncSend(true);\nActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);\n...\nTextMessage message = session.createTextMessage();\n// 未message设置属性\nmessage.setJMSMessageID(UUID.randomUUID().toString());\n\n// 使用带有回调的send方法来发送\namp.send(message, new AsyncCallback(){\n    @Override\n    public void onSucces(){\n\n        System.out.println(message.getJMSmessageID+\" succeed\")\n    }\n    @Override\n    public void onException(JMSException exception){\n        // 拿到属性来确认发送失败的消息\n        System.out.println(message.getJMSmessageID+\" fail\")\n    }\n})\n```\n\n## 延迟投递和定时投递\n\n参考[官网说明](http://activemq.apache.org/delay-and-schedule-message-delivery.html)\n\n| Property name          | type   | description        |\n| ---------------------- | ------ | ------------------ |\n| AMQ\\_SCHEDULED\\_DELAY  | long   | 延迟投递的时间     |\n| AMQ\\_SCHEDULED\\_PERIOD | long   | 重复投递的时间间隔 |\n| AMQ\\_SCHEDULED\\_REPEAT | int    | 重复投递次数       |\n| AMQ\\_SCHEDULED\\_CRON   | String | Cron表达式         |\n\n在`activemq.xml`中配置*schedulerSupport*属性为*true*且Java代码中封装的辅助消息类型为*ScheduledMessage*即可。\n\n```java\nlong delay = 3 * 1000; //延迟投递的时间，每3秒\nlong period = 4 * 1000;\nint repeat = 5;\n\nTextMessage message = session.createTextMessage();\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);\nmessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);\nmessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);\n\nmessageProducer.send(mesage);\n...\n```\n\n## ActiveMQ消费重试机制\n\n- 哪些情况会引起消息重发？\n\n- 消息重发时间间隔和重发次数\n\n- 有毒消息Posion ACK\n\nreference [here](activemq.apache.org/redelivery-policy)\n\n重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。\n\n## 如何保证消息不被重复消费（幂等性）\n\n**note**: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。\n\n- 如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突\n\n- 使用第三方服务来做消费记录。以redis为例，给消息分配一个**全局id**，只要消费过该消息，将\\<id, message\\>以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。","slug":"mq","published":1,"updated":"2021-03-28T10:20:02.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckplbkjdm004uts9q8sho2q45","content":"<p>mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"MQ的引入\"><a href=\"#MQ的引入\" class=\"headerlink\" title=\"MQ的引入\"></a>MQ的引入</h1><p>模拟几个场景：</p>\n<ol>\n<li><p><code>学生模块</code>和<code>老师模块</code>。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。</p>\n<p>解决方式：引入<code>班长模块</code>，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。</p>\n</li>\n<li><p><code>系统A</code>需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。</p>\n<p>上线后又新增了一个需求，<code>D</code>也要接收<code>A</code>的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对<code>A</code>进行改造，开发、联调效率低，耦合严重，增加<code>A</code>的负担。</p>\n</li>\n</ol>\n<h2 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h2><ul>\n<li><p>解决耦合  当新的模块接进来时，可以做到代码改动最小</p>\n</li>\n<li><p>异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力</p>\n</li>\n<li><p>削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨</p>\n</li>\n</ul>\n<h1 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h1><table>\n<thead>\n<tr>\n<th>比较项目</th>\n<th>Topic模式队列</th>\n<th>Queue模式队列</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工作模式</td>\n<td>”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。</td>\n<td>”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。</td>\n</tr>\n<tr>\n<td>有无状态</td>\n<td>无状态</td>\n<td>Queue数据默认会在mq服务器上以文件形式保存</td>\n</tr>\n<tr>\n<td>传递完整性</td>\n<td>如果没有订阅者，消息会被丢弃。不完整。</td>\n<td>消息不会丢弃</td>\n</tr>\n<tr>\n<td>处理效率</td>\n<td>由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异</td>\n<td>由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的</td>\n</tr>\n</tbody></table>\n<h1 id=\"JMS\"><a href=\"#JMS\" class=\"headerlink\" title=\"JMS\"></a>JMS</h1><p>Java消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。</p>\n<p>实现JMS接口和规范的消息中间件，即我们的MQ服务器。</p>\n<h2 id=\"MESSAGE\"><a href=\"#MESSAGE\" class=\"headerlink\" title=\"MESSAGE\"></a>MESSAGE</h2><p>JMS message的组成：消息头 + 消息体 + 消息属性</p>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><p>记录常用的</p>\n<ul>\n<li><p>JMSDestination 消息发送的目的地，Queue或Topic</p>\n</li>\n<li><p>JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。</p>\n</li>\n<li><p>JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除</p>\n</li>\n<li><p>JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通</p>\n</li>\n<li><p>JMSMessgeID 唯一ID，判断是否重复消费，幂等性</p>\n</li>\n</ul>\n<h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><p>封装具体消息数据，5种格式。（使用频率高）</p>\n<ul>\n<li><p>TextMessage 普通字符串消息 （使用频率高）</p>\n</li>\n<li><p>MapMessage map类型消息，key为String类型，值为Java基本数据类型</p>\n</li>\n<li><p>BytesMessage 二进制数组消息</p>\n</li>\n<li><p>StreamMessage 流</p>\n</li>\n<li><p>ObjectMessage 可序列化的Java对象</p>\n</li>\n</ul>\n<p>发送和接受的消息类型必须一致。</p>\n<h3 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h3><p>如果需要除消息头字段以外的值，那么可以使用消息属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = session.createTextMessage(<span class=\"string\">&quot;wa wa&quot;</span>);</span><br><span class=\"line\">tm.setStringProperty(<span class=\"string\">&quot;c01&quot;</span>,<span class=\"string\">&quot;vip&quot;</span>); <span class=\"comment\">// 增加属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage tms = (TextMessage) messge;</span><br><span class=\"line\">System.out.println(tms.getStringProperty(<span class=\"string\">&quot;c01&quot;</span>)); <span class=\"comment\">// 接收</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>MQ挂了，消息的持久话和丢失的情况如何？一般有<strong>三个特征</strong>来保障：持久化、事务、签收，其中<strong>事务偏生产者，签收偏消费者</strong>。此外对于对于宕机，还有<strong>多节点集群</strong>。</p>\n<h2 id=\"持久化-PERSISTENT\"><a href=\"#持久化-PERSISTENT\" class=\"headerlink\" title=\"持久化 PERSISTENT\"></a>持久化 PERSISTENT</h2><p>参考redis的持久化（有rdb和aof），消息也有类似的辅助。</p>\n<h3 id=\"QUEUE\"><a href=\"#QUEUE\" class=\"headerlink\" title=\"QUEUE\"></a>QUEUE</h3><h4 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h4><ol>\n<li><p>非持久 服务器宕机，消息不存在</p>\n<blockquote>\n<p>messaegeProducer.setDeliveryMode(DeliveryMode.<em>NON_PRESISTENT</em>);</p>\n</blockquote>\n</li>\n<li><p>持久化 服务器宕机后消息依然存在</p>\n<blockquote>\n<p>messageProducer.setDelieveryMode(DeliveryMode.<em>PRESISTENT</em>);</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"模拟场景\"><a href=\"#模拟场景\" class=\"headerlink\" title=\"模拟场景\"></a>模拟场景</h4><p>非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。</p>\n<p>持久化时，上述操作后，数据依然存在。</p>\n<p>在队列中，如果<strong>不显示标注持久</strong>，<strong>默认持久化</strong>，因为可靠性是优先考虑的因素。</p>\n<p>持久、事物、签收</p>\n<h3 id=\"TOPIC\"><a href=\"#TOPIC\" class=\"headerlink\" title=\"TOPIC\"></a>TOPIC</h3><p>对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：</p>\n<ol>\n<li><p>先运行一次消费者，等于向MQ注册</p>\n</li>\n<li><p>然后再运行生产者发送信息</p>\n</li>\n<li><p>消费者一定会收到订阅消息。不在线的话下次连接时会接收。</p>\n</li>\n</ol>\n<h2 id=\"事务-TRANSACTION\"><a href=\"#事务-TRANSACTION\" class=\"headerlink\" title=\"事务 TRANSACTION\"></a>事务 TRANSACTION</h2><p>数据库的事务、ACID、隔离级别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第一个参数即 事务是否开启</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><ul>\n<li><p>false 关闭事务，只要执行<code>send</code>就进入到队列中</p>\n</li>\n<li><p>true 开启事物，先执行<code>send</code>再执行<code>commit</code>，消息才被真正提交到队列中。</p>\n</li>\n</ul>\n<p>对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ok session.commit;</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">    session.rollback();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != session)&#123;</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>创建session时将事务改为<code>true</code>，同样需要<code>commit</code>，否则事务会被重复消费。</p>\n<h2 id=\"签收-ACKNOWLEDGE\"><a href=\"#签收-ACKNOWLEDGE\" class=\"headerlink\" title=\"签收 ACKNOWLEDGE\"></a>签收 ACKNOWLEDGE</h2><p>分为事务和非事务两种情况</p>\n<h4 id=\"非事务\"><a href=\"#非事务\" class=\"headerlink\" title=\"非事务\"></a>非事务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>自动签收（默认）   <strong>AUTO_ACKNOWLEDGE</strong>  （使用频率高）</p>\n</li>\n<li><p>手动签收 <strong>CLIENT_ACKNOWLEDGE</strong> （使用频率高）</p>\n</li>\n<li><p>允许重复消息 <strong>DUPS_OK_ACKNOWLEDGE</strong></p>\n</li>\n</ul>\n<p>手动签收时需要手动标记，否则会造成重复消费：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = (TextMessage)messageConsumer.receive(<span class=\"number\">4000L</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != tm)&#123;</span><br><span class=\"line\">    tm.acknowledge();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<p>有事务就需要<code>commit</code>。</p>\n<h2 id=\"点对点\"><a href=\"#点对点\" class=\"headerlink\" title=\"点对点\"></a>点对点</h2><p>基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。类比平时的即时通讯工具。</p>\n<ul>\n<li><p>如果在<strong>Session</strong>关闭时有部分消息已被收到但还没有签收（<strong>acknowledge</strong>)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）</p>\n</li>\n<li><p>队列可以长久地保存消息直到消费者收到消息。<strong>消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态</strong>，充分体现了异步传输模式的优势。</p>\n</li>\n</ul>\n<h2 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h2><p>JMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作<strong>topic</strong>，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。</p>\n<h3 id=\"非持久\"><a href=\"#非持久\" class=\"headerlink\" title=\"非持久\"></a>非持久</h3><p>对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。</p>\n<h3 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h3><p>客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。</p>\n<h1 id=\"BROKER\"><a href=\"#BROKER\" class=\"headerlink\" title=\"BROKER\"></a>BROKER</h1><p>集群、配置时会用到。</p>\n<p>相当于一个ActiveMQ服务器<strong>实例</strong>，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。</p>\n<p>之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.</p>\n<h2 id=\"消息发送模式\"><a href=\"#消息发送模式\" class=\"headerlink\" title=\"消息发送模式\"></a>消息发送模式</h2><p>ActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。</p>\n<p><code>ActiveMQ默认使用异步发送的模式</code>，<strong>同步发送有两种情况</strong>：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。</p>\n<p>异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，<code>允许在失败的情况下有少量的数据丢失</code>。</p>\n<h1 id=\"ACTIVEMQ的传输协议\"><a href=\"#ACTIVEMQ的传输协议\" class=\"headerlink\" title=\"ACTIVEMQ的传输协议\"></a>ACTIVEMQ的传输协议</h1><p>Q: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？</p>\n<p>调优：使用NIO传输协议</p>\n<p>支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP</td>\n<td>默认的协议，性能相对可以</td>\n</tr>\n<tr>\n<td>NIO</td>\n<td>基于TCP协议之上的，进行了扩展和优化</td>\n</tr>\n<tr>\n<td>HTP(s)</td>\n<td>基于HTTP(s)</td>\n</tr>\n</tbody></table>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>要换为NIO，需要修改<code>activemq.xml</code>配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">broker</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nio&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;nio://192.168.111.136&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">broker</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在消费者、生产者修改代码，指定传输协议：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> stati <span class=\"keyword\">final</span> String ACTIVEMQ_URL = <span class=\"string\">&quot;nio://192.168.111.136&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    ActiveMQConnectionFactory af = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增强\"><a href=\"#增强\" class=\"headerlink\" title=\"增强\"></a>增强</h3><p>Q: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持<code>openwire（TCP）</code>，如何让这个端口支持NIO，又支持多个协议呢？</p>\n<p>默认是<code>BIO+TCP</code>，目前是<code>NIO+TCP</code>，那么如何做到<code>NIO+TCP/Mqtt/stomp</code>。</p>\n<p>A: 开启多协议支持，用<code>auto</code>关键字，<a href=\"https://activemq.apache.org/auto\">reference</a>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;auto://localhost:5761&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 在activeMQ后台配置面板的<code>Network</code>可以查看开启的网络协议。</p>\n<h1 id=\"ACTIVEMQ的存储和可持久化\"><a href=\"#ACTIVEMQ的存储和可持久化\" class=\"headerlink\" title=\"ACTIVEMQ的存储和可持久化\"></a>ACTIVEMQ的存储和可持久化</h1><p>对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会<code>采用持久化机制</code>（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p>\n<p>主要介绍两个DB：<code>KahaDB</code>, <code>LevelDB</code>, <code>JDBC</code></p>\n<p>Q: AMQ持久化机制</p>\n<h2 id=\"KahaDB\"><a href=\"#KahaDB\" class=\"headerlink\" title=\"KahaDB\"></a>KahaDB</h2><p>基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。</p>\n<p>在配置文件中，有：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">persistenceAdapter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">kahaDB</span> <span class=\"attr\">directory</span>=<span class=\"string\">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">persistenceAdpter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储原理\"><a href=\"#存储原理\" class=\"headerlink\" title=\"存储原理\"></a>存储原理</h3><p>reference <a href=\"https://activemq.apache.org/kahadb\">here</a></p>\n<p>可用于任何场合，提高了性能和恢复能力。消息存储使用一个<strong>事务日志</strong>和一个<strong>索引文件</strong>（存储所有地址）。</p>\n<p>Kahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）</p>\n<h4 id=\"db-lt-Number-gt-log\"><a href=\"#db-lt-Number-gt-log\" class=\"headerlink\" title=\"db&lt;Number&gt;.log\"></a>db&lt;Number&gt;.log</h4><p>存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。</p>\n<h4 id=\"db-data\"><a href=\"#db-data\" class=\"headerlink\" title=\"db.data\"></a>db.data</h4><p>包含了持久化的<code>BTree索引</code>，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向<code>db-\\&lt;Number&gt;.log</code>里面存储的消息。</p>\n<h4 id=\"db-free\"><a href=\"#db-free\" class=\"headerlink\" title=\"db.free\"></a>db.free</h4><p>当前<code>db.data</code>文件里哪些页面是空闲的，文件具体内容是所有空闲页的<strong>ID</strong>. 类比linux的bash命令<code>free</code>。</p>\n<h4 id=\"db-redo\"><a href=\"#db-redo\" class=\"headerlink\" title=\"db.redo\"></a>db.redo</h4><p>用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。</p>\n<h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h4><p>相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。</p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。</p>\n<h2 id=\"LevelDB\"><a href=\"#LevelDB\" class=\"headerlink\" title=\"LevelDB\"></a>LevelDB</h2><h2 id=\"JDBC-Message-store-with-ActiveMQ-Journal\"><a href=\"#JDBC-Message-store-with-ActiveMQ-Journal\" class=\"headerlink\" title=\"JDBC Message store with ActiveMQ Journal\"></a>JDBC Message store with ActiveMQ Journal</h2><p>主要。</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><ol>\n<li><p>引入消息队列后该如何保证其高可用性</p>\n</li>\n<li><p>异步投递Async Sends</p>\n</li>\n<li><p>延迟投递和定时投递</p>\n</li>\n<li><p>分发策略</p>\n</li>\n<li><p>ActiveMQ消费重试机制</p>\n</li>\n<li><p>死信队列</p>\n</li>\n<li><p>如何保证消息不被重复消费呢？谈谈幂等性问题</p>\n</li>\n</ol>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><p>zookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。</p>\n<h2 id=\"异步投递\"><a href=\"#异步投递\" class=\"headerlink\" title=\"异步投递\"></a>异步投递</h2><p>如何确认发送成功？ </p>\n<p>在消息发送完后接收回调。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveMQConnectionFacotry acf = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(URL);</span><br><span class=\"line\"><span class=\"comment\">// 设置为异步发送消息</span></span><br><span class=\"line\">acf.setUseAsyncSend(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">ActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class=\"line\">...</span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\"><span class=\"comment\">// 未message设置属性</span></span><br><span class=\"line\">message.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用带有回调的send方法来发送</span></span><br><span class=\"line\">amp.send(message, <span class=\"keyword\">new</span> AsyncCallback()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSucces</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; succeed&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(JMSException exception)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到属性来确认发送失败的消息</span></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; fail&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"延迟投递和定时投递\"><a href=\"#延迟投递和定时投递\" class=\"headerlink\" title=\"延迟投递和定时投递\"></a>延迟投递和定时投递</h2><p>参考<a href=\"http://activemq.apache.org/delay-and-schedule-message-delivery.html\">官网说明</a></p>\n<table>\n<thead>\n<tr>\n<th>Property name</th>\n<th>type</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AMQ_SCHEDULED_DELAY</td>\n<td>long</td>\n<td>延迟投递的时间</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_PERIOD</td>\n<td>long</td>\n<td>重复投递的时间间隔</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_REPEAT</td>\n<td>int</td>\n<td>重复投递次数</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_CRON</td>\n<td>String</td>\n<td>Cron表达式</td>\n</tr>\n</tbody></table>\n<p>在<code>activemq.xml</code>中配置<em>schedulerSupport</em>属性为<em>true</em>且Java代码中封装的辅助消息类型为<em>ScheduledMessage</em>即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> delay = <span class=\"number\">3</span> * <span class=\"number\">1000</span>; <span class=\"comment\">//延迟投递的时间，每3秒</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> period = <span class=\"number\">4</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> repeat = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);</span><br><span class=\"line\">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);</span><br><span class=\"line\"></span><br><span class=\"line\">messageProducer.send(mesage);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ActiveMQ消费重试机制\"><a href=\"#ActiveMQ消费重试机制\" class=\"headerlink\" title=\"ActiveMQ消费重试机制\"></a>ActiveMQ消费重试机制</h2><ul>\n<li><p>哪些情况会引起消息重发？</p>\n</li>\n<li><p>消息重发时间间隔和重发次数</p>\n</li>\n<li><p>有毒消息Posion ACK</p>\n</li>\n</ul>\n<p>reference <a href=\"activemq.apache.org/redelivery-policy\">here</a></p>\n<p>重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。</p>\n<h2 id=\"如何保证消息不被重复消费（幂等性）\"><a href=\"#如何保证消息不被重复消费（幂等性）\" class=\"headerlink\" title=\"如何保证消息不被重复消费（幂等性）\"></a>如何保证消息不被重复消费（幂等性）</h2><p><strong>note</strong>: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。</p>\n<ul>\n<li><p>如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突</p>\n</li>\n<li><p>使用第三方服务来做消费记录。以redis为例，给消息分配一个<strong>全局id</strong>，只要消费过该消息，将&lt;id, message&gt;以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。</p>\n</li>\n</ul>\n","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"<p>mq的出现是大势所趋，也一定是为了解决某方面的问题，从这里入手，可以综合的了解所有mq的异同。</p>","more":"<h1 id=\"MQ的引入\"><a href=\"#MQ的引入\" class=\"headerlink\" title=\"MQ的引入\"></a>MQ的引入</h1><p>模拟几个场景：</p>\n<ol>\n<li><p><code>学生模块</code>和<code>老师模块</code>。功能：学生向老师抛出问题，老师反馈给学生答案。老师一次只能给一个学生解答问题，这样一来学生数量很多的话就会给后续等待的学生到成堵塞、浪费资源。同时，众多的学生与老师之间形成了耦合。</p>\n<p>解决方式：引入<code>班长模块</code>，学生将问题都抛给班长（需要定义格式），班长不做解答，只做问题的记录，这样学生将问题抛出后不用等待。班长收集问题后，将问题给老师模块，老师依次解答。这样解决了学生与老师之间的耦合，也避免了众多学生的等待浪费。</p>\n</li>\n<li><p><code>系统A</code>需要发送数据给其他系统，已经完成了给B、C发送的功能，发送给每个系统的数据可能有差异，因此发送前会对数据进行组装。</p>\n<p>上线后又新增了一个需求，<code>D</code>也要接收<code>A</code>的数据，__此时就需要修改A系统，让他感知到D的存在__，这时就暴露出一个问题：每接入一个下游系统，都需要对<code>A</code>进行改造，开发、联调效率低，耦合严重，增加<code>A</code>的负担。</p>\n</li>\n</ol>\n<h2 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h2><ul>\n<li><p>解决耦合  当新的模块接进来时，可以做到代码改动最小</p>\n</li>\n<li><p>异步模型  “早上下单，下午收货“，提升整体系统的吞吐能力</p>\n</li>\n<li><p>削峰  相当于流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲跨</p>\n</li>\n</ul>\n<h1 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h1><table>\n<thead>\n<tr>\n<th>比较项目</th>\n<th>Topic模式队列</th>\n<th>Queue模式队列</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工作模式</td>\n<td>”订阅-发布“模式，如果当前没有订阅者，消息将会被丢弃，如果有多个订阅者，都会被分发。</td>\n<td>”负载均衡“模式。如果当前没有消费者，消息也不会被丢弃。如果有多个消费者，那么消息也只会发送给其中一个消费者（轮寻着发）。一对一（端对端）。</td>\n</tr>\n<tr>\n<td>有无状态</td>\n<td>无状态</td>\n<td>Queue数据默认会在mq服务器上以文件形式保存</td>\n</tr>\n<tr>\n<td>传递完整性</td>\n<td>如果没有订阅者，消息会被丢弃。不完整。</td>\n<td>消息不会丢弃</td>\n</tr>\n<tr>\n<td>处理效率</td>\n<td>由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议、自身的性能差异</td>\n<td>由于一条信息只发送给一个消费者，所以性能与消费者数量无关。但是不同消息协议的具体性能也是有差异的</td>\n</tr>\n</tbody></table>\n<h1 id=\"JMS\"><a href=\"#JMS\" class=\"headerlink\" title=\"JMS\"></a>JMS</h1><p>Java消息服务，Java Message Service，JavaEE中的一套规范，指的是两个应用程序之间进行异步通信的API，它为标准消息协议i和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。</p>\n<p>实现JMS接口和规范的消息中间件，即我们的MQ服务器。</p>\n<h2 id=\"MESSAGE\"><a href=\"#MESSAGE\" class=\"headerlink\" title=\"MESSAGE\"></a>MESSAGE</h2><p>JMS message的组成：消息头 + 消息体 + 消息属性</p>\n<h3 id=\"消息头\"><a href=\"#消息头\" class=\"headerlink\" title=\"消息头\"></a>消息头</h3><p>记录常用的</p>\n<ul>\n<li><p>JMSDestination 消息发送的目的地，Queue或Topic</p>\n</li>\n<li><p>JMSDeliveryMode 持久或非持久（消息的持久化）。持久话能让数据更可靠，即JMS出现故障的话数据也不会丢失，会在服务器恢复之后再次传递。</p>\n</li>\n<li><p>JMSExpiration 过期时间，过期时间之后消息还没被发出去，就清除</p>\n</li>\n<li><p>JMSPriority 优先级，0-4普通，5-9加急，不严格按照顺序，但加急一定高于普通</p>\n</li>\n<li><p>JMSMessgeID 唯一ID，判断是否重复消费，幂等性</p>\n</li>\n</ul>\n<h3 id=\"消息体\"><a href=\"#消息体\" class=\"headerlink\" title=\"消息体\"></a>消息体</h3><p>封装具体消息数据，5种格式。（使用频率高）</p>\n<ul>\n<li><p>TextMessage 普通字符串消息 （使用频率高）</p>\n</li>\n<li><p>MapMessage map类型消息，key为String类型，值为Java基本数据类型</p>\n</li>\n<li><p>BytesMessage 二进制数组消息</p>\n</li>\n<li><p>StreamMessage 流</p>\n</li>\n<li><p>ObjectMessage 可序列化的Java对象</p>\n</li>\n</ul>\n<p>发送和接受的消息类型必须一致。</p>\n<h3 id=\"消息属性\"><a href=\"#消息属性\" class=\"headerlink\" title=\"消息属性\"></a>消息属性</h3><p>如果需要除消息头字段以外的值，那么可以使用消息属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = session.createTextMessage(<span class=\"string\">&quot;wa wa&quot;</span>);</span><br><span class=\"line\">tm.setStringProperty(<span class=\"string\">&quot;c01&quot;</span>,<span class=\"string\">&quot;vip&quot;</span>); <span class=\"comment\">// 增加属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage tms = (TextMessage) messge;</span><br><span class=\"line\">System.out.println(tms.getStringProperty(<span class=\"string\">&quot;c01&quot;</span>)); <span class=\"comment\">// 接收</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>MQ挂了，消息的持久话和丢失的情况如何？一般有<strong>三个特征</strong>来保障：持久化、事务、签收，其中<strong>事务偏生产者，签收偏消费者</strong>。此外对于对于宕机，还有<strong>多节点集群</strong>。</p>\n<h2 id=\"持久化-PERSISTENT\"><a href=\"#持久化-PERSISTENT\" class=\"headerlink\" title=\"持久化 PERSISTENT\"></a>持久化 PERSISTENT</h2><p>参考redis的持久化（有rdb和aof），消息也有类似的辅助。</p>\n<h3 id=\"QUEUE\"><a href=\"#QUEUE\" class=\"headerlink\" title=\"QUEUE\"></a>QUEUE</h3><h4 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h4><ol>\n<li><p>非持久 服务器宕机，消息不存在</p>\n<blockquote>\n<p>messaegeProducer.setDeliveryMode(DeliveryMode.<em>NON_PRESISTENT</em>);</p>\n</blockquote>\n</li>\n<li><p>持久化 服务器宕机后消息依然存在</p>\n<blockquote>\n<p>messageProducer.setDelieveryMode(DeliveryMode.<em>PRESISTENT</em>);</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"模拟场景\"><a href=\"#模拟场景\" class=\"headerlink\" title=\"模拟场景\"></a>模拟场景</h4><p>非持久化时，当发布者在队列发布了消息，之后将activeMQ服务器重启，MQ服务器中的消息会丢失。</p>\n<p>持久化时，上述操作后，数据依然存在。</p>\n<p>在队列中，如果<strong>不显示标注持久</strong>，<strong>默认持久化</strong>，因为可靠性是优先考虑的因素。</p>\n<p>持久、事物、签收</p>\n<h3 id=\"TOPIC\"><a href=\"#TOPIC\" class=\"headerlink\" title=\"TOPIC\"></a>TOPIC</h3><p>对于topic，先启动订阅再启动生产，否则没有意义（没人订阅，发送的消息都是废消息）。持久化topic类似于订阅号：</p>\n<ol>\n<li><p>先运行一次消费者，等于向MQ注册</p>\n</li>\n<li><p>然后再运行生产者发送信息</p>\n</li>\n<li><p>消费者一定会收到订阅消息。不在线的话下次连接时会接收。</p>\n</li>\n</ol>\n<h2 id=\"事务-TRANSACTION\"><a href=\"#事务-TRANSACTION\" class=\"headerlink\" title=\"事务 TRANSACTION\"></a>事务 TRANSACTION</h2><p>数据库的事务、ACID、隔离级别</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第一个参数即 事务是否开启</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><ul>\n<li><p>false 关闭事务，只要执行<code>send</code>就进入到队列中</p>\n</li>\n<li><p>true 开启事物，先执行<code>send</code>再执行<code>commit</code>，消息才被真正提交到队列中。</p>\n</li>\n</ul>\n<p>对于事物的true，为何多此一举？保证事务的高可用、容错性，可以回滚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ok session.commit;</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">    session.rollback();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != session)&#123;</span><br><span class=\"line\">        session.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>创建session时将事务改为<code>true</code>，同样需要<code>commit</code>，否则事务会被重复消费。</p>\n<h2 id=\"签收-ACKNOWLEDGE\"><a href=\"#签收-ACKNOWLEDGE\" class=\"headerlink\" title=\"签收 ACKNOWLEDGE\"></a>签收 ACKNOWLEDGE</h2><p>分为事务和非事务两种情况</p>\n<h4 id=\"非事务\"><a href=\"#非事务\" class=\"headerlink\" title=\"非事务\"></a>非事务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>自动签收（默认）   <strong>AUTO_ACKNOWLEDGE</strong>  （使用频率高）</p>\n</li>\n<li><p>手动签收 <strong>CLIENT_ACKNOWLEDGE</strong> （使用频率高）</p>\n</li>\n<li><p>允许重复消息 <strong>DUPS_OK_ACKNOWLEDGE</strong></p>\n</li>\n</ul>\n<p>手动签收时需要手动标记，否则会造成重复消费：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextMessage tm = (TextMessage)messageConsumer.receive(<span class=\"number\">4000L</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">null</span> != tm)&#123;</span><br><span class=\"line\">    tm.acknowledge();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建session的第个参数即 签收类型</span></span><br><span class=\"line\">Session session = connection.createSession(<span class=\"keyword\">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>\n\n<p>有事务就需要<code>commit</code>。</p>\n<h2 id=\"点对点\"><a href=\"#点对点\" class=\"headerlink\" title=\"点对点\"></a>点对点</h2><p>基于队列，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。类比平时的即时通讯工具。</p>\n<ul>\n<li><p>如果在<strong>Session</strong>关闭时有部分消息已被收到但还没有签收（<strong>acknowledge</strong>)，那当消费者下次连接到同样的队列时，消息会被再次接收。（不会丢失）</p>\n</li>\n<li><p>队列可以长久地保存消息直到消费者收到消息。<strong>消费者不需要因为再次担心消息丢失而时刻和队列保持激活的连接状态</strong>，充分体现了异步传输模式的优势。</p>\n</li>\n</ul>\n<h2 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h2><p>JMS Pub/Sub模型。定义了如何向一个内容节点发布和订阅消息，这些节点被称作<strong>topic</strong>，主题可以被认为是消息的传输中介，publisher发布消息到主题，subscribe从主题订阅消息。主题使得publisher和subscribe保持互相独立，不需要接触即可保证消息的传送。</p>\n<h3 id=\"非持久\"><a href=\"#非持久\" class=\"headerlink\" title=\"非持久\"></a>非持久</h3><p>对于非持久订阅，只有当客户端处于激活状态，也就是和MQ保持连接状态才能收到发送到某个主题的消息。如果消费者处于离线状态，生产者发生发送的主题消息将会丢失作废，消费者永远不会收到。所以消费者要先注册才能接受到发布。</p>\n<h3 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h3><p>客户端先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ时，MQ会根据消费者的ID得到所有当自己处于离线时发送到主题的消息（即 可以恢复、派送未签收的消息）。</p>\n<h1 id=\"BROKER\"><a href=\"#BROKER\" class=\"headerlink\" title=\"BROKER\"></a>BROKER</h1><p>集群、配置时会用到。</p>\n<p>相当于一个ActiveMQ服务器<strong>实例</strong>，实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动（用的时候再启动，这样节省资源、保证可靠性）。</p>\n<p>之前会在linux服务器上启动，而在这里，是将MQ装在了代码里，MQ是一个实例。  类比springboot内嵌tomcat.</p>\n<h2 id=\"消息发送模式\"><a href=\"#消息发送模式\" class=\"headerlink\" title=\"消息发送模式\"></a>消息发送模式</h2><p>ActiveMQ支持同步、异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大影响，使用异步发送可以显著的提高发送的性能。</p>\n<p><code>ActiveMQ默认使用异步发送的模式</code>，<strong>同步发送有两种情况</strong>：1. 是明确指定使用同步发送。2. 在未使用事务的情况下发送持久化的消息。第二种情况是特别要注意的，每次发送都会阻塞producer直到broker返回一个确认，表示消息已经被安全地持久化到磁盘，确认机制提供了消息安全的保障，同时阻塞客户端带来了很大的延时。</p>\n<p>异步发送可以最大化producer端的发送效率，适合发送消息比较密集的情况下使用，提升producer性能的情况下，也有一定的弊端，就是消耗较多client端内存同时，也会导致broker端性能消耗增加（不停地发消息，能不累么）；此外，它也不能保证消息100%地发送成功，需要容忍消息丢失的可能。很多高性能的应用，<code>允许在失败的情况下有少量的数据丢失</code>。</p>\n<h1 id=\"ACTIVEMQ的传输协议\"><a href=\"#ACTIVEMQ的传输协议\" class=\"headerlink\" title=\"ACTIVEMQ的传输协议\"></a>ACTIVEMQ的传输协议</h1><p>Q: 默认的61616端口如何更改？生产上的链接协议如何配置的，使用tcp么？</p>\n<p>调优：使用NIO传输协议</p>\n<p>支持的通讯协议：TCP, NIO, UDP, SSL, VM……（对于java，主要使用前两个）</p>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP</td>\n<td>默认的协议，性能相对可以</td>\n</tr>\n<tr>\n<td>NIO</td>\n<td>基于TCP协议之上的，进行了扩展和优化</td>\n</tr>\n<tr>\n<td>HTP(s)</td>\n<td>基于HTTP(s)</td>\n</tr>\n</tbody></table>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>要换为NIO，需要修改<code>activemq.xml</code>配置文件。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">broker</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nio&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;nio://192.168.111.136&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">transportConnectors</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">broker</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在消费者、生产者修改代码，指定传输协议：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> stati <span class=\"keyword\">final</span> String ACTIVEMQ_URL = <span class=\"string\">&quot;nio://192.168.111.136&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    ActiveMQConnectionFactory af = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增强\"><a href=\"#增强\" class=\"headerlink\" title=\"增强\"></a>增强</h3><p>Q: uri以”nio“开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型，但是这样的设置方式，只能使这个端口支持<code>openwire（TCP）</code>，如何让这个端口支持NIO，又支持多个协议呢？</p>\n<p>默认是<code>BIO+TCP</code>，目前是<code>NIO+TCP</code>，那么如何做到<code>NIO+TCP/Mqtt/stomp</code>。</p>\n<p>A: 开启多协议支持，用<code>auto</code>关键字，<a href=\"https://activemq.apache.org/auto\">reference</a>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transportConnector</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">uri</span>=<span class=\"string\">&quot;auto://localhost:5761&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>note:</strong> 在activeMQ后台配置面板的<code>Network</code>可以查看开启的网络协议。</p>\n<h1 id=\"ACTIVEMQ的存储和可持久化\"><a href=\"#ACTIVEMQ的存储和可持久化\" class=\"headerlink\" title=\"ACTIVEMQ的存储和可持久化\"></a>ACTIVEMQ的存储和可持久化</h1><p>对于上面的提到的节点（事务、持久、签收），他们都是MQ自带的，不能保证自身故障时的持久，这里提到的可持久化的目的是将数据保存在另外一台机器做备份，达到物理隔离，完成高可用。所以为了避免意外宕机后丢失信息，需要做到重启后可以恢复消息队列，消息系统一般都会<code>采用持久化机制</code>（所有MQ都会这样）：在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等，再试图将消息发送给接收者，成功则将消息从存储中删除，失败i则继续尝试发送；如果是重启，消息中心启动后首先检查指定的存储位置，如果有未发送成功的消息，则需要把消息发送出去。</p>\n<p>主要介绍两个DB：<code>KahaDB</code>, <code>LevelDB</code>, <code>JDBC</code></p>\n<p>Q: AMQ持久化机制</p>\n<h2 id=\"KahaDB\"><a href=\"#KahaDB\" class=\"headerlink\" title=\"KahaDB\"></a>KahaDB</h2><p>基于日志文件，从ActiveMQ5.4开始作为默认的持久化插件（相当于Redis的aof），记录做了哪些操作。</p>\n<p>在配置文件中，有：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">persistenceAdapter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">kahaDB</span> <span class=\"attr\">directory</span>=<span class=\"string\">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">persistenceAdpter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储原理\"><a href=\"#存储原理\" class=\"headerlink\" title=\"存储原理\"></a>存储原理</h3><p>reference <a href=\"https://activemq.apache.org/kahadb\">here</a></p>\n<p>可用于任何场合，提高了性能和恢复能力。消息存储使用一个<strong>事务日志</strong>和一个<strong>索引文件</strong>（存储所有地址）。</p>\n<p>Kahadb在消息保存目录中只有4类文件和一个lock：db-1.log, db.data, db.free, db.redo, lock. （4个文件1把锁）</p>\n<h4 id=\"db-lt-Number-gt-log\"><a href=\"#db-lt-Number-gt-log\" class=\"headerlink\" title=\"db&lt;Number&gt;.log\"></a>db&lt;Number&gt;.log</h4><p>存储消息到预定义大小的数据记录文件中，Number初始为1，。当数据文件已满时，一个新的文件会随之创建。当不再有引用到数据文件中的任何消息时，文件会被删除或归档（自我空间清理）。</p>\n<h4 id=\"db-data\"><a href=\"#db-data\" class=\"headerlink\" title=\"db.data\"></a>db.data</h4><p>包含了持久化的<code>BTree索引</code>，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree，使用B-Tree作为索引指向<code>db-\\&lt;Number&gt;.log</code>里面存储的消息。</p>\n<h4 id=\"db-free\"><a href=\"#db-free\" class=\"headerlink\" title=\"db.free\"></a>db.free</h4><p>当前<code>db.data</code>文件里哪些页面是空闲的，文件具体内容是所有空闲页的<strong>ID</strong>. 类比linux的bash命令<code>free</code>。</p>\n<h4 id=\"db-redo\"><a href=\"#db-redo\" class=\"headerlink\" title=\"db.redo\"></a>db.redo</h4><p>用来进行消息恢复，如果KahaDB消息存储在强制退出后启动，用于恢复BTree索引。</p>\n<h4 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h4><p>相当于mysql中的悲观锁。表示当前获得kahadb读写权限的broker。</p>\n<h2 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h2><p>主要。将数据放入mysql/oracle中，这是对于长时间持久化存储，推荐用jdbc，特别是带了Journal的。缺点是有点慢。kahaDB是将服务器做本地数据库，JDBC是将他放入另外一个磁盘（类似云盘），相对来说更安全。</p>\n<h2 id=\"LevelDB\"><a href=\"#LevelDB\" class=\"headerlink\" title=\"LevelDB\"></a>LevelDB</h2><h2 id=\"JDBC-Message-store-with-ActiveMQ-Journal\"><a href=\"#JDBC-Message-store-with-ActiveMQ-Journal\" class=\"headerlink\" title=\"JDBC Message store with ActiveMQ Journal\"></a>JDBC Message store with ActiveMQ Journal</h2><p>主要。</p>\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><ol>\n<li><p>引入消息队列后该如何保证其高可用性</p>\n</li>\n<li><p>异步投递Async Sends</p>\n</li>\n<li><p>延迟投递和定时投递</p>\n</li>\n<li><p>分发策略</p>\n</li>\n<li><p>ActiveMQ消费重试机制</p>\n</li>\n<li><p>死信队列</p>\n</li>\n<li><p>如何保证消息不被重复消费呢？谈谈幂等性问题</p>\n</li>\n</ol>\n<h2 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h2><p>zookeeper + (replicated-leveldb-store)的主从集群，起码非单机版，是集群的。</p>\n<h2 id=\"异步投递\"><a href=\"#异步投递\" class=\"headerlink\" title=\"异步投递\"></a>异步投递</h2><p>如何确认发送成功？ </p>\n<p>在消息发送完后接收回调。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveMQConnectionFacotry acf = <span class=\"keyword\">new</span> ActiveMQConnectionFactory(URL);</span><br><span class=\"line\"><span class=\"comment\">// 设置为异步发送消息</span></span><br><span class=\"line\">acf.setUseAsyncSend(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">ActiveMQMessageProducer amp = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class=\"line\">...</span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\"><span class=\"comment\">// 未message设置属性</span></span><br><span class=\"line\">message.setJMSMessageID(UUID.randomUUID().toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用带有回调的send方法来发送</span></span><br><span class=\"line\">amp.send(message, <span class=\"keyword\">new</span> AsyncCallback()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSucces</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; succeed&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(JMSException exception)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到属性来确认发送失败的消息</span></span><br><span class=\"line\">        System.out.println(message.getJMSmessageID+<span class=\"string\">&quot; fail&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"延迟投递和定时投递\"><a href=\"#延迟投递和定时投递\" class=\"headerlink\" title=\"延迟投递和定时投递\"></a>延迟投递和定时投递</h2><p>参考<a href=\"http://activemq.apache.org/delay-and-schedule-message-delivery.html\">官网说明</a></p>\n<table>\n<thead>\n<tr>\n<th>Property name</th>\n<th>type</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AMQ_SCHEDULED_DELAY</td>\n<td>long</td>\n<td>延迟投递的时间</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_PERIOD</td>\n<td>long</td>\n<td>重复投递的时间间隔</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_REPEAT</td>\n<td>int</td>\n<td>重复投递次数</td>\n</tr>\n<tr>\n<td>AMQ_SCHEDULED_CRON</td>\n<td>String</td>\n<td>Cron表达式</td>\n</tr>\n</tbody></table>\n<p>在<code>activemq.xml</code>中配置<em>schedulerSupport</em>属性为<em>true</em>且Java代码中封装的辅助消息类型为<em>ScheduledMessage</em>即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> delay = <span class=\"number\">3</span> * <span class=\"number\">1000</span>; <span class=\"comment\">//延迟投递的时间，每3秒</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> period = <span class=\"number\">4</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> repeat = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">TextMessage message = session.createTextMessage();</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class=\"line\">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, delay);</span><br><span class=\"line\">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, delay);</span><br><span class=\"line\"></span><br><span class=\"line\">messageProducer.send(mesage);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ActiveMQ消费重试机制\"><a href=\"#ActiveMQ消费重试机制\" class=\"headerlink\" title=\"ActiveMQ消费重试机制\"></a>ActiveMQ消费重试机制</h2><ul>\n<li><p>哪些情况会引起消息重发？</p>\n</li>\n<li><p>消息重发时间间隔和重发次数</p>\n</li>\n<li><p>有毒消息Posion ACK</p>\n</li>\n</ul>\n<p>reference <a href=\"activemq.apache.org/redelivery-policy\">here</a></p>\n<p>重发：在设置事务后没有进行提交（commit），消息就会被重复消费，这时会触发重发机制，默认被重复消费6次后MQ会把这个消息放入DLQ（Dead Letter Queue）死信队列供开发查看，不会再被消费。</p>\n<h2 id=\"如何保证消息不被重复消费（幂等性）\"><a href=\"#如何保证消息不被重复消费（幂等性）\" class=\"headerlink\" title=\"如何保证消息不被重复消费（幂等性）\"></a>如何保证消息不被重复消费（幂等性）</h2><p><strong>note</strong>: 何时会重复消费？网络延迟造成MQ重试，进而重复消费。</p>\n<ul>\n<li><p>如果是做数据库的插入操作，可以给消息做一个唯一主键，重复消费时会导致主键冲突</p>\n</li>\n<li><p>使用第三方服务来做消费记录。以redis为例，给消息分配一个<strong>全局id</strong>，只要消费过该消息，将&lt;id, message&gt;以K-V形式写入redis，消费者消费前先去redis中查询有没有消费记录即可。</p>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckplbkj5u0001ts9qfdfnd0ea","category_id":"ckplbkj6d0004ts9qfbu9btqs","_id":"ckplbkj7q000kts9q0cjhgmre"},{"post_id":"ckplbkj6a0003ts9q6d53ai5v","category_id":"ckplbkj6d0004ts9qfbu9btqs","_id":"ckplbkj7y000qts9qbsxu7moj"},{"post_id":"ckplbkj6k0007ts9qgtkoa4mh","category_id":"ckplbkj7q000jts9q7op70z98","_id":"ckplbkj87000wts9q94834xbg"},{"post_id":"ckplbkj6o0009ts9qex9egao6","category_id":"ckplbkj7z000rts9qa868gmhl","_id":"ckplbkj8d0013ts9q1r3z6s93"},{"post_id":"ckplbkj6r000bts9qdqk86rdb","category_id":"ckplbkj7z000rts9qa868gmhl","_id":"ckplbkj8l0018ts9q6azthioa"},{"post_id":"ckplbkj7j000gts9q0g46dpx6","category_id":"ckplbkj8d0012ts9q1la7e6nm","_id":"ckplbkj8p001ets9qedem36fh"},{"post_id":"ckplbkj7o000its9q5ovlcoal","category_id":"ckplbkj8l0019ts9qgyv22jyr","_id":"ckplbkj8y001mts9qcu0s44ke"},{"post_id":"ckplbkj7s000nts9q195ogwm9","category_id":"ckplbkj8d0012ts9q1la7e6nm","_id":"ckplbkj96001tts9q2pzhckct"},{"post_id":"ckplbkj90001pts9q34ee7at1","category_id":"ckplbkj8l0019ts9qgyv22jyr","_id":"ckplbkj9b001yts9q81rmfkxn"},{"post_id":"ckplbkj7w000pts9qdvy7a0mb","category_id":"ckplbkj8l0019ts9qgyv22jyr","_id":"ckplbkj9f0022ts9q42lla7tm"},{"post_id":"ckplbkj95001rts9qhezye8bf","category_id":"ckplbkj7q000jts9q7op70z98","_id":"ckplbkj9h0025ts9qbgbz68bj"},{"post_id":"ckplbkj97001vts9qh31bfh8b","category_id":"ckplbkj7q000jts9q7op70z98","_id":"ckplbkj9k0028ts9qbqthe4eb"},{"post_id":"ckplbkj82000tts9q7cnb0nrh","category_id":"ckplbkj96001sts9q2td30ce8","_id":"ckplbkj9n002cts9qe71r9g4u"},{"post_id":"ckplbkj9a001xts9q5znub0t3","category_id":"ckplbkj7q000jts9q7op70z98","_id":"ckplbkj9q002gts9q3tx6bobu"},{"post_id":"ckplbkj85000vts9qdjrihczl","category_id":"ckplbkj8l0019ts9qgyv22jyr","_id":"ckplbkj9u002jts9q80yo0iw8"},{"post_id":"ckplbkj9g0024ts9qcbvka96y","category_id":"ckplbkj96001sts9q2td30ce8","_id":"ckplbkj9x002mts9q65ljh9py"},{"post_id":"ckplbkj9j0027ts9q3oae30l7","category_id":"ckplbkj8d0012ts9q1la7e6nm","_id":"ckplbkja0002qts9q7t750nh0"},{"post_id":"ckplbkj89000zts9q6ywr9roq","category_id":"ckplbkj8l0019ts9qgyv22jyr","_id":"ckplbkja3002uts9qepf9eal0"},{"post_id":"ckplbkj8b0011ts9q1j86cyxa","category_id":"ckplbkj9o002dts9qa6490lu3","_id":"ckplbkja6002yts9q48oq7h1n"},{"post_id":"ckplbkj9s002its9q04kw2hw0","category_id":"ckplbkj7z000rts9qa868gmhl","_id":"ckplbkja90031ts9qgo4u4xam"},{"post_id":"ckplbkj8h0015ts9qeqp8105h","category_id":"ckplbkj9u002kts9q78qjfxmx","_id":"ckplbkjab0035ts9q1m6d7akg"},{"post_id":"ckplbkja5002xts9q2p9ja5y6","category_id":"ckplbkj8d0012ts9q1la7e6nm","_id":"ckplbkjad0038ts9q9oiq3i0w"},{"post_id":"ckplbkj8k0017ts9qc1j5gi2p","category_id":"ckplbkja1002sts9q80597743","_id":"ckplbkjae003bts9q4lq05i1n"},{"post_id":"ckplbkjab0034ts9q33fl3w7e","category_id":"ckplbkj8l0019ts9qgyv22jyr","_id":"ckplbkjae003ets9qgxqz7g1c"},{"post_id":"ckplbkj8m001bts9qaw8i6twl","category_id":"ckplbkja90032ts9qfwkb2y9z","_id":"ckplbkjaf003hts9q1t089ix2"},{"post_id":"ckplbkj8q001fts9q7yj03cl7","category_id":"ckplbkja90032ts9qfwkb2y9z","_id":"ckplbkjah003kts9q3or10wn4"},{"post_id":"ckplbkj8t001jts9q4grb3y0u","category_id":"ckplbkja90032ts9qfwkb2y9z","_id":"ckplbkjaj003nts9q8y21f4h6"},{"post_id":"ckplbkj8w001kts9q7b5gcd3i","category_id":"ckplbkjag003jts9qbywh5f5z","_id":"ckplbkjal003sts9qcj25022t"},{"post_id":"ckplbkj9e0021ts9qfm70frf4","category_id":"ckplbkj9o002dts9qa6490lu3","_id":"ckplbkjam003vts9q0kvp6gga"},{"post_id":"ckplbkj9m002bts9qbz0cgr1z","category_id":"ckplbkjak003rts9qe5cofz84","_id":"ckplbkjaq0040ts9qcv4mcsmn"},{"post_id":"ckplbkj9p002fts9q7r2kfvec","category_id":"ckplbkja1002sts9q80597743","_id":"ckplbkjas0043ts9qhdk04fnd"},{"post_id":"ckplbkj9v002lts9qfwpdcq4f","category_id":"ckplbkjap003zts9q9eww8ywd","_id":"ckplbkjaw0048ts9q8bl6489e"},{"post_id":"ckplbkj9y002pts9qbk7id7tk","category_id":"ckplbkjap003zts9q9eww8ywd","_id":"ckplbkjaz004cts9q8imjajef"},{"post_id":"ckplbkja2002tts9q55xgbdj3","category_id":"ckplbkjap003zts9q9eww8ywd","_id":"ckplbkjb0004ets9q45yw96oh"},{"post_id":"ckplbkja70030ts9q3vv96d9k","category_id":"ckplbkjay004bts9qe2dp0ld4","_id":"ckplbkjb1004gts9qav8ld7ax"},{"post_id":"ckplbkjdk004tts9q5wzxd6gu","category_id":"ckplbkj7z000rts9qa868gmhl","_id":"ckplbkjdq004yts9q4adx7xwx"},{"post_id":"ckplbkjdm004uts9q8sho2q45","category_id":"ckplbkjdp004wts9qh7u55pmw","_id":"ckplbkjdr0050ts9q1mik5ysd"}],"PostTag":[{"post_id":"ckplbkj5u0001ts9qfdfnd0ea","tag_id":"ckplbkj6g0005ts9q04du8g8k","_id":"ckplbkj7i000ets9qc40h1kfr"},{"post_id":"ckplbkj6a0003ts9q6d53ai5v","tag_id":"ckplbkj6g0005ts9q04du8g8k","_id":"ckplbkj7s000mts9q1fekhf2f"},{"post_id":"ckplbkj7o000its9q5ovlcoal","tag_id":"ckplbkj6g0005ts9q04du8g8k","_id":"ckplbkj7v000ots9q6mp39wjo"},{"post_id":"ckplbkj6k0007ts9qgtkoa4mh","tag_id":"ckplbkj7q000lts9qbiabgkxy","_id":"ckplbkj84000uts9q9sv8b2hl"},{"post_id":"ckplbkj6o0009ts9qex9egao6","tag_id":"ckplbkj7z000sts9q64gu6zi5","_id":"ckplbkj8b0010ts9q8c9sdjam"},{"post_id":"ckplbkj6r000bts9qdqk86rdb","tag_id":"ckplbkj7z000sts9q64gu6zi5","_id":"ckplbkj8j0016ts9q8077bp8f"},{"post_id":"ckplbkj7j000gts9q0g46dpx6","tag_id":"ckplbkj8d0014ts9qach9cy7h","_id":"ckplbkj8o001cts9qhc3r58ki"},{"post_id":"ckplbkj7s000nts9q195ogwm9","tag_id":"ckplbkj8m001ats9q0290a3x3","_id":"ckplbkj8s001its9qedxtdund"},{"post_id":"ckplbkj8t001jts9q4grb3y0u","tag_id":"ckplbkj6g0005ts9q04du8g8k","_id":"ckplbkj90001ots9qccdx04vq"},{"post_id":"ckplbkj7w000pts9qdvy7a0mb","tag_id":"ckplbkj8r001hts9qd5hhbysy","_id":"ckplbkj94001qts9qbo6i8e00"},{"post_id":"ckplbkj82000tts9q7cnb0nrh","tag_id":"ckplbkj8z001nts9q92kw1p5c","_id":"ckplbkj99001wts9q7rl352ui"},{"post_id":"ckplbkj85000vts9qdjrihczl","tag_id":"ckplbkj97001uts9q7vdi1msx","_id":"ckplbkj9g0023ts9q8ib743lr"},{"post_id":"ckplbkj9g0024ts9qcbvka96y","tag_id":"ckplbkj8z001nts9q92kw1p5c","_id":"ckplbkj9m002ats9qarqd9np7"},{"post_id":"ckplbkj89000zts9q6ywr9roq","tag_id":"ckplbkj9d0020ts9q45f73u6x","_id":"ckplbkj9p002ets9qfi7f6txc"},{"post_id":"ckplbkj9s002its9q04kw2hw0","tag_id":"ckplbkj7z000sts9q64gu6zi5","_id":"ckplbkj9y002ots9qdrlb5edx"},{"post_id":"ckplbkj8b0011ts9q1j86cyxa","tag_id":"ckplbkj9k0029ts9q59wm8j4d","_id":"ckplbkja1002rts9q9sfehu38"},{"post_id":"ckplbkj8b0011ts9q1j86cyxa","tag_id":"ckplbkj9r002hts9q9tn28wpt","_id":"ckplbkja4002vts9q7jql4pd1"},{"post_id":"ckplbkj9v002lts9qfwpdcq4f","tag_id":"ckplbkj7z000sts9q64gu6zi5","_id":"ckplbkja7002zts9q5isxck58"},{"post_id":"ckplbkj9y002pts9qbk7id7tk","tag_id":"ckplbkj7z000sts9q64gu6zi5","_id":"ckplbkjaa0033ts9q6me5b1ki"},{"post_id":"ckplbkj8h0015ts9qeqp8105h","tag_id":"ckplbkj9x002nts9q9l07c7sn","_id":"ckplbkjac0037ts9q30uo3we6"},{"post_id":"ckplbkja2002tts9q55xgbdj3","tag_id":"ckplbkj7z000sts9q64gu6zi5","_id":"ckplbkjad003ats9qgd5a1mnw"},{"post_id":"ckplbkj8k0017ts9qc1j5gi2p","tag_id":"ckplbkja4002wts9qh8sydgxs","_id":"ckplbkjae003dts9qefq49si5"},{"post_id":"ckplbkj8m001bts9qaw8i6twl","tag_id":"ckplbkjac0036ts9q25uh7s0z","_id":"ckplbkjaf003gts9q3prx4ja6"},{"post_id":"ckplbkj8q001fts9q7yj03cl7","tag_id":"ckplbkjae003cts9q7dvt7sv5","_id":"ckplbkjah003lts9q5cdn829p"},{"post_id":"ckplbkj8w001kts9q7b5gcd3i","tag_id":"ckplbkjag003its9q3fbs5q04","_id":"ckplbkjaj003pts9qe2sqfvci"},{"post_id":"ckplbkj90001pts9q34ee7at1","tag_id":"ckplbkjai003mts9qeuwle6u3","_id":"ckplbkjal003tts9qcidkh4dt"},{"post_id":"ckplbkj95001rts9qhezye8bf","tag_id":"ckplbkjak003qts9qher39i6y","_id":"ckplbkjao003xts9qdlrdawka"},{"post_id":"ckplbkj97001vts9qh31bfh8b","tag_id":"ckplbkjak003qts9qher39i6y","_id":"ckplbkjaq0041ts9qgjh0binl"},{"post_id":"ckplbkj9a001xts9q5znub0t3","tag_id":"ckplbkjak003qts9qher39i6y","_id":"ckplbkjat0045ts9qdu1w90zx"},{"post_id":"ckplbkj9e0021ts9qfm70frf4","tag_id":"ckplbkjar0042ts9q70awd5fi","_id":"ckplbkjaw0049ts9qao15asbx"},{"post_id":"ckplbkj9j0027ts9q3oae30l7","tag_id":"ckplbkjau0046ts9q1oc167c0","_id":"ckplbkjaz004dts9q1chx2ph8"},{"post_id":"ckplbkj9m002bts9qbz0cgr1z","tag_id":"ckplbkjax004ats9q5hhs94hs","_id":"ckplbkjb2004its9qg6uh7nfs"},{"post_id":"ckplbkj9m002bts9qbz0cgr1z","tag_id":"ckplbkjb0004fts9q1yri8pmf","_id":"ckplbkjb2004jts9q45sa8qic"},{"post_id":"ckplbkj9p002fts9q7r2kfvec","tag_id":"ckplbkjb1004hts9qgkyj3com","_id":"ckplbkjb3004lts9q4dhm85ux"},{"post_id":"ckplbkja5002xts9q2p9ja5y6","tag_id":"ckplbkjb2004kts9qhn0r88mp","_id":"ckplbkjb6004ots9qcyf9f1bj"},{"post_id":"ckplbkja5002xts9q2p9ja5y6","tag_id":"ckplbkjb4004mts9q88opauj9","_id":"ckplbkjb6004pts9q3iwy014d"},{"post_id":"ckplbkja70030ts9q3vv96d9k","tag_id":"ckplbkjag003its9q3fbs5q04","_id":"ckplbkjb7004rts9q4t2x105s"},{"post_id":"ckplbkjab0034ts9q33fl3w7e","tag_id":"ckplbkjai003mts9qeuwle6u3","_id":"ckplbkjb7004sts9q3xnh54fq"},{"post_id":"ckplbkjdk004tts9q5wzxd6gu","tag_id":"ckplbkj7z000sts9q64gu6zi5","_id":"ckplbkjdo004vts9q6xpf3n2j"},{"post_id":"ckplbkjdm004uts9q8sho2q45","tag_id":"ckplbkjdp004xts9qgrt94e1w","_id":"ckplbkjdq004zts9q6cjca4k0"}],"Tag":[{"name":"summary","_id":"ckplbkj6g0005ts9q04du8g8k"},{"name":"spring security","_id":"ckplbkj7q000lts9qbiabgkxy"},{"name":"source","_id":"ckplbkj7z000sts9q64gu6zi5"},{"name":"standard","_id":"ckplbkj8d0014ts9qach9cy7h"},{"name":"bst","_id":"ckplbkj8m001ats9q0290a3x3"},{"name":"bitwise","_id":"ckplbkj8r001hts9qd5hhbysy"},{"name":"design_patterns","_id":"ckplbkj8z001nts9q92kw1p5c"},{"name":"hashmap, data structure","_id":"ckplbkj97001uts9q7vdi1msx"},{"name":"datastructure","_id":"ckplbkj9d0020ts9q45f73u6x"},{"name":"http","_id":"ckplbkj9k0029ts9q59wm8j4d"},{"name":"https","_id":"ckplbkj9r002hts9q9tn28wpt"},{"name":"framework","_id":"ckplbkj9x002nts9q9l07c7sn"},{"name":"greedy dp stratey","_id":"ckplbkja4002wts9qh8sydgxs"},{"name":"classloader","_id":"ckplbkjac0036ts9q25uh7s0z"},{"name":"memory","_id":"ckplbkjae003cts9q7dvt7sv5"},{"name":"utils","_id":"ckplbkjag003its9q3fbs5q04"},{"name":"lock","_id":"ckplbkjai003mts9qeuwle6u3"},{"name":"mybatis","_id":"ckplbkjak003qts9qher39i6y"},{"name":"network","_id":"ckplbkjar0042ts9q70awd5fi"},{"name":"dp","_id":"ckplbkjau0046ts9q1oc167c0"},{"name":"redis","_id":"ckplbkjax004ats9q5hhs94hs"},{"name":"nosql","_id":"ckplbkjb0004fts9q1yri8pmf"},{"name":"treeMap trie","_id":"ckplbkjb1004hts9qgkyj3com"},{"name":"double poiters","_id":"ckplbkjb2004kts9qhn0r88mp"},{"name":"map+preSum","_id":"ckplbkjb4004mts9q88opauj9"},{"name":"activemq","_id":"ckplbkjdp004xts9qgrt94e1w"}]}}